#import win <random>
#import win <sys/timeb.h>
#import <Geode/utils/cocos.hpp>

[[link(android)]]
class AccountHelpLayer : GJDropDownLayer, GJAccountDelegate, FLAlertLayerProtocol {
    AccountHelpLayer() {
        m_unk290 = false;
    }
    ~AccountHelpLayer() = win inline, m1 0xb54dc {
        auto gjam = GJAccountManager::sharedState();
        if (gjam->m_accountDelegate == this) gjam->m_accountDelegate = nullptr;
    }

    static AccountHelpLayer* create() = win inline, m1 0xb538c {
        auto ret = new AccountHelpLayer();
        if (ret->init("Account Help")) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void customSetup() = win 0x7f630, m1 0xb57f8, imac 0xce3e0;
    virtual void layerHidden() = win 0x80390, m1 0xb6458, imac 0xcf080;
    virtual void accountStatusChanged() = win 0x7fd30, imac 0xcef40, m1 0xb630c;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x80010, m1 0xb6318, imac 0xcef70;

    void doUnlink() = win inline, imac 0xcef00, m1 0xb62d8, ios inline {
        GJAccountManager::sharedState()->unlinkFromAccount();
        this->exitLayer();
    }
    void exitLayer() = win inline, m1 0xb6304, ios inline {
        GJDropDownLayer::exitLayer(nullptr);
    }
    void onAccountManagement(cocos2d::CCObject* sender) = imac 0xce820;
    void onReLogin(cocos2d::CCObject* sender) = win 0x7fa40, m1 0xb5ba4;
    void onUnlink(cocos2d::CCObject* sender) = win 0x7fb90, m1 0xb5cec;
    void updatePage() = win 0x7fd40, imac 0xceaa0, m1 0xb5ea0;
    void verifyUnlink() = win inline, imac 0xcedf0 {
        auto alert = FLAlertLayer::create(
            this,
            "Warning",
            "This will <cr>delete</c> ALL <cl>save data</c>.\nDo you want to continue?\n<cy>(You cannot undo this action)</c>",
            "Cancel",
            "DELETE",
            300.f,
            false,
            0.f,
            1.f
        );
        alert->setTag(4);
        alert->m_button2->updateBGImage("GJ_button_06.png");
        alert->show();
    }

    cocos2d::CCLabelBMFont* m_loginStatusLabel;
    TextArea* m_textArea;
    CCMenuItemSpriteExtra* m_refreshLoginButton;
    CCMenuItemSpriteExtra* m_unlinkAccountButton;
    bool m_unk290;
}

[[link(android)]]
class AccountLayer : GJDropDownLayer, GJAccountDelegate, GJAccountBackupDelegate, GJAccountSyncDelegate, FLAlertLayerProtocol {
    // virtual ~AccountLayer();
    // AccountLayer();

    static AccountLayer* create() = win 0x7d5d0, m1 0xb3130;

    virtual void customSetup() = win 0x7d730, m1 0xb33c0, imac 0xcbd70;
    virtual void layerHidden() = win 0x7f4c0, imac 0xcdda0, m1 0xb5320;
    virtual void backupAccountFinished() = win 0x7eba0, imac 0xcd2e0, m1 0xb48dc;
    virtual void backupAccountFailed(BackupAccountError errorType, int response) = win 0x7ed50, m1 0xb4aa0, imac 0xcd4a0;
    virtual void syncAccountFinished() = win 0x7f060, imac 0xcd860, m1 0xb4e0c;
    virtual void syncAccountFailed(BackupAccountError errorType, int response) = win 0x7f220, m1 0xb4f78, imac 0xcd9e0;
    virtual void accountStatusChanged() = win 0x7e7c0, imac 0xcd2b0, m1 0xb48c8;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x7f3b0, m1 0xb51f0, imac 0xcdc80;

    void createToggleButton(gd::string text, cocos2d::SEL_MenuHandler selector, bool toggled, cocos2d::CCMenu* menu, cocos2d::CCPoint position) = win inline, imac 0xccf40, m1 0xb44e8, ios inline {
        auto onSprite = cocos2d::CCSprite::createWithSpriteFrameName("GJ_checkOn_001.png");
        auto offSprite = cocos2d::CCSprite::createWithSpriteFrameName("GJ_checkOff_001.png");
        onSprite->setScale(.8f);
        offSprite->setScale(.8f);
        auto toggler = CCMenuItemToggler::create(offSprite, onSprite, this, selector);
        toggler->toggle(toggled);
        menu->addChild(toggler);
        toggler->setPosition(menu->convertToNodeSpace(position));
        toggler->setSizeMult(1.5f);
        auto label = cocos2d::CCLabelBMFont::create(text.c_str(), "bigFont.fnt");
        m_mainLayer->addChild(label);
        label->setAnchorPoint({ .0f, .5f });
        label->setPosition(position + cocos2d::CCPoint { onSprite->getContentSize().width * .5f + 6.4f, 0.f });
        auto width = label->getContentSize().width;
        if (width > 120.f) label->setScale(120.f / width);
        label->setScale(std::min(label->getScale(), .35f));
    }
    void doBackup() = win inline, imac 0xcd150, m1 0xb475c {
        this->updatePage(false);
        if (!GJAccountManager::sharedState()->getAccountBackupURL()) this->backupAccountFailed(BackupAccountError::GenericError, 0);
        else this->showLoadingUI();
    }
    void doSync() = win inline, imac 0xcd220, m1 0xb4838 {
        this->updatePage(false);
        if (!GJAccountManager::sharedState()->getAccountSyncURL()) this->syncAccountFailed(BackupAccountError::GenericError, 0);
        else this->showLoadingUI();
    }
    void exitLayer() = win inline, m1 0xb48c0, ios inline {
        GJDropDownLayer::exitLayer(nullptr);
    }
    void hideLoadingUI() = win inline, imac 0xcd430, m1 0xb4a44, ios inline {
        this->toggleUI(true);
        m_loadingCircle->setVisible(false);
    }
    void onBackup(cocos2d::CCObject* sender) = m1 0xb3ac8;
    void onHelp(cocos2d::CCObject* sender) = imac 0xcc9e0;
    void onLogin(cocos2d::CCObject* sender) = m1 0xb3a10;
    void onMore(cocos2d::CCObject* sender);
    void onRegister(cocos2d::CCObject* sender) = win 0x7dec0, m1 0xb3aac;
    void onSync(cocos2d::CCObject* sender) = m1 0xb3dc0;
    void showLoadingUI() = win inline, imac 0xcd1d0, m1 0xb47e4, ios inline {
        this->toggleUI(false);
        m_loadingCircle->setVisible(true);
    }
    void toggleUI(bool enable) = win inline, imac 0xcdc40, m1 0xb51b0, ios inline {
        m_buttonMenu->setEnabled(enable);
        this->setKeypadEnabled(enable);
    }
    void updatePage(bool changed) = win 0x7e7d0;

    cocos2d::CCLabelBMFont* m_linkedAccountTitle;
    TextArea* m_textArea;
    CCMenuItemSpriteExtra* m_loginButton;
    CCMenuItemSpriteExtra* m_registerButton;
    CCMenuItemSpriteExtra* m_backupButton;
    CCMenuItemSpriteExtra* m_syncButton;
    CCMenuItemSpriteExtra* m_helpButton;
    CCMenuItemSpriteExtra* m_moreButton;
    LoadingCircle* m_loadingCircle;
    int m_accountHelpRelated;
    bool m_isLoggedIn;
}

[[link(android)]]
class AccountLoginLayer : FLAlertLayer, TextInputDelegate, GJAccountLoginDelegate, FLAlertLayerProtocol {
    // virtual ~AccountLoginLayer();

    static AccountLoginLayer* create(gd::string username) = win 0x7b790, imac 0x4986b0, m1 0x3fcb14;

    virtual void registerWithTouchDispatcher() = win 0x42660, m1 0x3fe9c0, imac 0x49a5d0;
    virtual void keyBackClicked() = win 0x7d010, imac 0x49a490, m1 0x3fe870;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x7cbc0, imac 0x49a2d0, m1 0x3fe65c;
    virtual void textInputOpened(CCTextInputNode* node) = win inline, m1 0x3feb8c, imac 0x49a770 {}
    virtual void textInputClosed(CCTextInputNode* node) = win 0x7d0e0, m1 0x3fe9f8, imac 0x49a610;
    virtual void textChanged(CCTextInputNode* node) = win inline, m1 0x3feb94, imac 0x49a790 {}
    virtual void loginAccountFinished(int accountID, int userID) = win 0x7c7b0, imac 0x499c40, m1 0x3fdf98;
    virtual void loginAccountFailed(AccountError errorType) = win 0x7ca00, m1 0x3fe308, imac 0x499fc0;

    cocos2d::extension::CCScale9Sprite* createTextBackground(cocos2d::CCPoint position, char const* text, cocos2d::CCSize size) = win 0x7c520, imac 0x499980, m1 0x3fdcb8;
    CCTextInputNode* createTextInput(cocos2d::CCPoint position, cocos2d::CCSize size, char const* text, int tag) = win 0x7c6c0, imac 0x499b20, m1 0x3fde64;
    cocos2d::CCLabelBMFont* createTextLabel(cocos2d::CCPoint position, char const* text, cocos2d::CCSize size) = win 0x7c5e0, imac 0x499a40, m1 0x3fdd7c;
    void disableNodes() = win inline, imac 0x49a3b0, m1 0x3fe778, ios inline {
        m_usernameInput->onClickTrackNode(false);
        m_passwordInput->onClickTrackNode(false);
    }
    void hideLoadingUI() = win inline, imac 0x499f10, m1 0x3fe270, ios inline {
        this->toggleUI(true);
        m_loadingCircle->setVisible(false);
    }
    bool init(gd::string username) = win 0x7b930;
    void onClose(cocos2d::CCObject* sender) = win 0x7cfc0, imac 0x499530, m1 0x3fd844;
    void onForgotPassword(cocos2d::CCObject* sender) = m1 0x3fdf74;
    void onForgotUser(cocos2d::CCObject* sender) = m1 0x3fdf50;
    void onSubmit(cocos2d::CCObject* sender) = win 0x7cc30, imac 0x499590, m1 0x1aae70;
    void resetLabel(int tag) = win 0x7cb40, m1 0x21372c;
    void resetLabels() = win inline, imac 0x49a200, m1 0x3fe568 {
        this->resetLabel(1);
        this->resetLabel(2);
    }
    void showLoadingUI() = win inline, imac 0x49a3f0, m1 0x3fe7b8 {
        this->disableNodes();
        this->toggleUI(false);
        m_loadingCircle->setVisible(true);
    }
    void toggleUI(bool enable) = win 0x7d070, imac 0x49a560, m1 0x3fe944;
    void updateLabel(AccountError type) = win 0x7ca40;

    CCTextInputNode* m_usernameInput;
    CCTextInputNode* m_passwordInput;
    cocos2d::CCLabelBMFont* m_usernameLabel;
    cocos2d::CCLabelBMFont* m_passwordLabel;
    LoadingCircle* m_loadingCircle;
    gd::string m_username;
    gd::string m_password;
}

[[link(android)]]
class AccountRegisterLayer : FLAlertLayer, TextInputDelegate, GJAccountRegisterDelegate, FLAlertLayerProtocol {
    AccountRegisterLayer() {
        m_usernameField = nullptr;
        m_passwordField = nullptr;
        m_confirmPasswordField = nullptr;
        m_emailField = nullptr;
        m_usernameLabel = nullptr;
        m_passwordLabel = nullptr;
        m_confirmPasswordLabel = nullptr;
        m_emailLabel = nullptr;
        m_loadingCircle = nullptr;
        m_lockInput = false;
    }
    ~AccountRegisterLayer() = win inline, m1 0x3f9564 {
        auto gjam = GJAccountManager::sharedState();
        if (gjam->m_accountRegisterDelegate == this) gjam->m_accountRegisterDelegate = nullptr;
        CC_SAFE_RELEASE(m_loadingCircle);
    }

    static AccountRegisterLayer* create() = win inline, imac 0x494e70, m1 0x3f9820 {
        auto ret = new AccountRegisterLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x78ac0, m1 0x3f9940, imac 0x494ff0;
    virtual void registerWithTouchDispatcher() = win 0x42660, m1 0x3fc080, imac 0x497a60;
    virtual void keyBackClicked() = win 0x7ac50, imac 0x497890, m1 0x3fbe7c;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x7a260, imac 0x4973c0, m1 0x3fba34;
    virtual void textInputOpened(CCTextInputNode* node) = win inline, imac 0x498330, m1 0x3fc840 {}
    virtual void textInputClosed(CCTextInputNode* node) = win 0x7adb0, imac 0x497aa0, m1 0x3fc0b8;
    virtual void textChanged(CCTextInputNode* node) = win inline, imac 0x498350, m1 0x3fc848 {}
    virtual void textInputShouldOffset(CCTextInputNode* node, float yOffset) = win 0x7b620, m1 0x3fc850, imac 0x498370;
    virtual void textInputReturn(CCTextInputNode* node) = win 0x7b680, m1 0x3fc920, imac 0x498430;
    virtual bool allowTextInput(CCTextInputNode* node) = win 0x7b6d0, m1 0x3fc9d8, imac 0x4984e0;
    virtual void registerAccountFinished() = win 0x79cf0, m1 0x3fb298, imac 0x496c80;
    virtual void registerAccountFailed(AccountError errorType) = win 0x79f10, m1 0x3fb430, imac 0x496e30;

    cocos2d::extension::CCScale9Sprite* createTextBackground(cocos2d::CCPoint position, cocos2d::CCSize size) = win 0x799f0, imac 0x4969e0, m1 0x3fafe0;
    CCTextInputNode* createTextInput(cocos2d::CCPoint position, cocos2d::CCSize size, gd::string text, int tag) = win 0x79bc0, imac 0x496b90, m1 0x3fb198;
    cocos2d::CCLabelBMFont* createTextLabel(cocos2d::CCPoint position, gd::string text, cocos2d::CCSize size) = win 0x79ab0, imac 0x496aa0, m1 0x3fb0a4;
    void disableNodes() = win 0x7ac90, imac 0x497520, m1 0x3fbbc8;
    void hideLoadingUI() = win inline, imac 0x4970e0, m1 0x3fb744, ios inline {
        this->toggleUI(true);
        m_loadingCircle->setVisible(false);
    }
    void onClose(cocos2d::CCObject* sender) = win 0x7ac20, imac 0x4960b0, m1 0x3fa7e4;
    void onSubmit(cocos2d::CCObject* sender) = win 0x7a2b0, imac 0x496140, m1 0x3fa888;
    void resetLabel(int tag) = win 0x7a150;
    void resetLabels() = win inline, imac 0x4971d0, m1 0x3fb818 {
        this->resetLabel(1);
        this->resetLabel(2);
        this->resetLabel(3);
        this->resetLabel(4);
        this->resetLabel(5);
    }
    void showLoadingUI() = win inline, imac 0x497780, m1 0x3fbd4c {
        this->disableNodes();
        this->toggleUI(false);
        m_loadingCircle->setVisible(true);
    }
    void toggleUI(bool enable) = win 0x7ad00, imac 0x4979c0, m1 0x3fbfc8;
    void updateLabel(AccountError type) = win 0x79f50, m1 0x251e90;
    bool validEmail(gd::string email) = win 0x7b6e0, ios inline {
        if (!email.c_str()) return false;
        auto first = email[0];
        if (first < 'A' || (first > 'Z' && first < 'a') || first > 'z') return false;
        auto len = strlen(email.c_str());
        auto atPos = -1;
        auto dotPos = -1;
        for (int i = 0; i < len; i++) {
            if (email[i] == '@') atPos = i;
            else if (email[i] == '.') dotPos = i;
        }
        return atPos != -1 && dotPos != -1 && atPos <= dotPos && dotPos < len - 1;
    }
    bool validPassword(gd::string password) = win inline, imac 0x4975c0, ios inline {
        return password.size() > 5;
    }
    bool validUser(gd::string username) = win inline, imac 0x497590, ios inline {
        return username.size() > 2;
    }

    CCTextInputNode* m_usernameField;
    CCTextInputNode* m_passwordField;
    CCTextInputNode* m_confirmPasswordField;
    CCTextInputNode* m_emailField;
    CCTextInputNode* m_verifyEmailField;
    cocos2d::CCLabelBMFont* m_usernameLabel;
    cocos2d::CCLabelBMFont* m_passwordLabel;
    cocos2d::CCLabelBMFont* m_confirmPasswordLabel;
    cocos2d::CCLabelBMFont* m_emailLabel;
    cocos2d::CCLabelBMFont* m_verifyEmailLabel;
    LoadingCircle* m_loadingCircle;
    bool m_lockInput;
}

[[link(android)]]
class AchievementBar : cocos2d::CCNodeRGBA {
    // virtual ~AchievementBar();
    AchievementBar() {
        m_layerColor = nullptr;
        m_unkUnused = 0;
        m_nextScene = nullptr;
    }

    static AchievementBar* create(char const* title, char const* desc, char const* icon, bool quest) = win inline, imac 0x618630, m1 0x53c9e0 {
        auto ret = new AchievementBar();
        if (ret->init(title, desc, icon, quest)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void setOpacity(unsigned char opacity) = win 0x81f10, imac 0x619f90, m1 0x53e2a8;

    bool init(char const* title, char const* desc, char const* icon, bool quest) = win 0x806e0;
    void show() = win 0x81c90, m1 0x53e068;

    cocos2d::CCLayerColor* m_layerColor;
    int m_unkUnused;
    cocos2d::CCScene* m_nextScene;
    cocos2d::extension::CCScale9Sprite* m_bg;
    cocos2d::extension::CCScale9Sprite* m_bg2;
    cocos2d::CCSprite* m_achievementGlowSprite;
    cocos2d::CCSprite* m_achievementSprite;
    cocos2d::CCLabelBMFont* m_titleLabel;
    TextArea* m_achievementDescription;
}

[[link(android)]]
class AchievementCell : TableViewCell {
    // virtual ~AchievementCell();
    AchievementCell(char const* identifier, float width, float height) = win inline, m1 0x1f4d78, ios inline : TableViewCell(identifier, width, height) {
        this->init();
    }

    virtual bool init() = win inline, imac 0x24e4b0, m1 0x1f4db8 { return true; }
    virtual void draw() = win 0xade40, m1 0x1f4dc0, imac 0x24e4c0;

    void loadFromDict(cocos2d::CCDictionary* dict) = win 0xac880, imac 0x242540;
    void updateBGColor(int index) = win inline, imac 0x243990, m1 0x1ea6ac {
        m_backgroundLayer->setColor(index % 2 == 0 ? cocos2d::ccColor3B { 161, 88, 44 } : cocos2d::ccColor3B { 194, 114, 62 });
    }
}

[[link(android)]]
class AchievementManager : cocos2d::CCNode {
    // virtual ~AchievementManager();

    static AchievementManager* sharedState() = win 0x7da0, imac 0x72b390, m1 0x4eb06c;

    virtual bool init() = win 0x7e60, m1 0x63d408, imac 0x72b4a0;

    gd::string achievementForUnlock(int id, UnlockType type) = win 0x3a1c0, imac 0x784d30, m1 0x68bc74;
    void addAchievement(gd::string identifier, gd::string title, gd::string achievedDescription, gd::string unachievedDescription, gd::string icon, int limits) = win 0x7ef0, imac 0x784520, m1 0x68b3b4;
    void addManualAchievements() = win 0x8410, imac 0x72b530;
    bool areAchievementsEarned(cocos2d::CCArray* achievements) = win inline, imac 0x784970, m1 0x68b834, ios inline {
        for (int i = 0; i < achievements->count(); i++) {
            if (!this->isAchievementEarned(static_cast<cocos2d::CCString*>(achievements->objectAtIndex(i))->getCString())) {
                return false;
            }
        }
        return true;
    }
    void checkAchFromUnlock(char const* id) = win inline, imac 0x52b570, m1 0x47fa84, ios inline {}
    void dataLoaded(DS_Dictionary* dict) = win inline, imac 0x784800, m1 0x68b71c {
        auto reportedAchievements = dict->getDictForKey("reportedAchievements", false);
        if (m_reportedAchievements) {
            GameToolbox::mergeDictsSaveLargestInt(m_reportedAchievements, reportedAchievements);
        }
        else if (reportedAchievements) {
            CC_SAFE_RETAIN(reportedAchievements);
            CC_SAFE_RELEASE(m_reportedAchievements);
            m_reportedAchievements = reportedAchievements;
        }
    }
    void encodeDataTo(DS_Dictionary* dict) = win inline, imac 0x784870, m1 0x68b788 {
        dict->setDictForKey("reportedAchievements", m_reportedAchievements);
    }
    void firstSetup() = win inline, m1 0x68b6d0 {
        auto reportedAchievements = cocos2d::CCDictionary::create();
        if (m_reportedAchievements != reportedAchievements) {
            CC_SAFE_RETAIN(reportedAchievements);
            CC_SAFE_RELEASE(m_reportedAchievements);
            m_reportedAchievements = reportedAchievements;
        }
    }
    cocos2d::CCDictionary* getAchievementRewardDict() = m1 0x68c584;
    cocos2d::CCDictionary* getAchievementsWithID(char const* id) = win 0x39d70;
    cocos2d::CCArray* getAllAchievements() = win inline, imac 0x784b20, m1 0x68ba0c {
        return m_allAchievements;
    }
    cocos2d::CCArray* getAllAchievementsSorted(bool available) = win 0x39b50, imac 0x783ed0;
    bool isAchievementAvailable(gd::string id) = win inline, imac 0x2a9b10, ios inline {
        if (auto achievements = getAchievementsWithID(id.c_str())) {
            return achievements->objectForKey("un") == nullptr;
        }
        return false;
    }
    bool isAchievementEarned(char const* ach) = win 0x39a70, imac 0x7849e0;
    int limitForAchievement(gd::string id) = win inline, imac 0x54f860, m1 0x68bb18 {
        if (auto achievements = getAchievementsWithID(id.c_str())) {
            if (auto limits = static_cast<cocos2d::CCString*>(achievements->objectForKey("limits"))) return limits->intValue();
        }
        return 0;
    }
    void notifyAchievement(char const* title, char const* description, char const* icon) = win inline {
        if (!m_dontNotify) AchievementNotifier::sharedState()->notifyAchievement(title, description, icon, true);
    }
    void notifyAchievementWithID(char const* id) = win 0x3a470;
    int percentageForCount(int count, int total) = win inline, imac 0x784af0, m1 0x68b9e4, ios inline {
        return std::min<int>(100, ((float)count / (float)total) * 100.f);
    }
    int percentForAchievement(char const* id) = win 0x39a90;
    void reportAchievementWithID(char const* id, int percent, bool dontNotify) = imac 0x7855e0, m1 0x148b28;
    void reportPlatformAchievementWithID(char const* id, int percent) = imac 0x785760, m1 0x68c570;
    void resetAchievement(char const* id) = win inline {
        m_reportedAchievements->removeObjectForKey(id);
    }
    void resetAchievements() = win inline, m1 0x68c57c, ios inline {
        m_reportedAchievements->removeAllObjects();
    }
    void setup() = win inline, imac 0x784890, m1 0x68b7a0, ios inline {}
    void storeAchievementUnlocks() = win 0x39e20, m1 0x68afa8;

    cocos2d::CCArray* m_allAchievements;
    cocos2d::CCDictionary* m_platformAchievements;
    cocos2d::CCDictionary* m_achievementUnlocks;
    void* m_unkPtrUnused;
    cocos2d::CCDictionary* m_reportedAchievements;
    bool m_dontNotify;
    cocos2d::CCArray* m_allAchievementsSorted;
    int m_order;
    cocos2d::CCDictionary* m_unAchieved;
}

[[link(android)]]
class AchievementNotifier : cocos2d::CCNode {
    // virtual ~AchievementNotifier();

    static AchievementNotifier* sharedState() = win 0x3ab20, m1 0x6c7b4c, imac 0x7c2580;

    virtual bool init() = win 0x3abd0, m1 0x6c7bc8, imac 0x7c2610;

    void achievementDisplayFinished() = win 0x3ae40, imac 0x7c27a0, m1 0x6c7d60;
    void notifyAchievement(char const* title, char const* desc, char const* icon, bool quest) = win 0x3ac00, imac 0x7c2640, m1 0x6c7bf4;
    void showNextAchievement() = win 0x3ace0, m1 0x6c7c48;
    void willSwitchToScene(cocos2d::CCScene* scene) = win inline, imac 0x7c27f0, m1 0x6c7da4 {
        this->m_nextScene = scene;

        if (this->m_activeAchievementBar && this->m_activeAchievementBar->getParent() != this->m_nextScene)
        {
            this->m_activeAchievementBar->retain();
            this->m_activeAchievementBar->removeFromParentAndCleanup(false);
            this->m_nextScene->addChild(this->m_activeAchievementBar, 105);
            this->m_activeAchievementBar->release();
            this->m_activeAchievementBar->resumeSchedulerAndActions();
        }
    }

    cocos2d::CCScene* m_nextScene;
    cocos2d::CCArray* m_achievementBarArray;
    AchievementBar* m_activeAchievementBar;
}

[[link(android)]]
class AchievementsLayer : GJDropDownLayer {
    // virtual ~AchievementsLayer();
    AchievementsLayer() = m1 0x2fcee8 {
        m_currentPage = 0;
        m_nextPageButton = nullptr;
        m_prevPageButton = nullptr;
        m_pageLabel = nullptr;
    }

    static AchievementsLayer* create() = win inline, m1 0x2fc748 {
        auto ret = new AchievementsLayer();
        if (ret->init("Achievements")) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyDown(cocos2d::enumKeyCodes key, double timestamp) = win 0x822d0, m1 0x2fcc60, imac 0x3731c0;
    virtual void customSetup() = win 0x82020, m1 0x2fc804, imac 0x372d00;

    void loadPage(int page) = win 0x82370, imac 0x372fe0, m1 0x2fca90;
    void onNextPage(cocos2d::CCObject* sender) = win 0x82550, imac 0x372fc0, m1 0x2fca84;
    void onPrevPage(cocos2d::CCObject* sender) = win 0x82560, imac 0x372fa0, m1 0x2fca78;
    void setupLevelBrowser(cocos2d::CCArray* arr) = win inline, imac 0x3732f0, m1 0x2fcdc4 {
        m_listLayer->removeChildByTag(9, true);
        auto* listView = CustomListView::create(arr, BoomListType::Default, 220.f, 356.f);
        listView->setTag(9);
        m_listLayer->addChild(listView, 6);
    }
    void setupPageInfo(int itemCount, int pageStartIdx, int pageEndIdx) = win inline, m1 0x2fce4c {
        m_prevPageButton->setVisible(pageStartIdx != 0);
        auto nextIndex = pageStartIdx + pageEndIdx;
        m_nextPageButton->setVisible(itemCount > nextIndex);
        nextIndex = std::min(nextIndex, itemCount);
        m_pageLabel->setString(cocos2d::CCString::createWithFormat("%i to %i of %i", pageStartIdx + 1, nextIndex, itemCount)->getCString());
    }

    int m_currentPage;
    CCMenuItemSpriteExtra* m_nextPageButton;
    CCMenuItemSpriteExtra* m_prevPageButton;
    cocos2d::CCLabelBMFont* m_pageLabel;
    cocos2d::CCPoint m_unkPoint;
}

[[link(android)]]
class AdToolbox {
    static void cacheInterstitial() = imac 0xcb8e0, m1 0xb30a4;
    static void cacheRewardedVideo() = imac 0xcb910, m1 0xb30b4;
    static void disableBanner() = imac 0xcb8c0, m1 0xb309c;
    static void enableBanner() = imac 0xcb8b0, m1 0xb3098;
    static void enableBannerNoRefresh() = imac 0xcb8a0, m1 0xb3094;
    static bool hasCachedInterstitial() = imac 0xcb8f0, m1 0xb30a8;
    static bool hasCachedRewardedVideo() = imac 0xcb920, m1 0xb30b8;
    static bool isShowingAd() = imac 0xcb940, m1 0xb30c4;
    static void queueRefreshBanner() = imac 0xcb890, m1 0xb3090;
    static void setupAds() = win inline, imac 0xcb880, m1 0xb308c {}
    static void showDebug() = imac 0xcb930, m1 0xb30c0;
    static void showInterstitial() = imac 0xcb8d0, m1 0xb30a0;
    static void showRewardedVideo() = imac 0xcb900, m1 0xb30b0;
}

[[link(android)]]
class AdvancedFollowEditObject : AdvancedFollowTriggerObject {
    // virtual ~AdvancedFollowEditObject();
    AdvancedFollowEditObject() {
        m_modX = 1.f;
        m_modXVariance = 0.f;
        m_modY = 1.f;
        m_modYVariance = 0.f;
        m_redirectDirection = false;
    }

    static AdvancedFollowEditObject* create(char const* frame) = win inline, imac 0x1ad0a0, m1 0x1683ac {
        auto ret = new AdvancedFollowEditObject();
        if (ret->init(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x49e7e0, imac 0x1ae260, m1 0x169184;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x49e3f0, m1 0x168514, imac 0x1ad250;

    bool init(char const* frame) = win inline, ios inline {
        return AdvancedFollowTriggerObject::init(frame);
    }

    // property 566
    float m_modX;
    // property 567
    float m_modXVariance;
    // property 568
    float m_modY;
    // property 569
    float m_modYVariance;
    // property 570
    bool m_redirectDirection;
}

[[link(android)]]
class AdvancedFollowTriggerObject : EffectGameObject {
    // virtual ~AdvancedFollowTriggerObject();
    AdvancedFollowTriggerObject() = win 0x495880 {
        m_delay = 0.f;
        m_delayVariance = 0.f;
        m_startSpeed = 0.f;
        m_startSpeedVariance = 0.f;
        m_startSpeedReference = 0;
        m_startDirection = 0.f;
        m_startDirectionVariance = 0.f;
        m_startDirectionReference = 0;
        m_maxSpeed = 0.f;
        m_maxSpeedVariance = 0.f;
        m_xOnly = false;
        m_yOnly = false;
        m_maxRange = 0.f;
        m_maxRangeVariance = 0.f;
        m_property310 = 0.f;
        m_property311 = 0.f;
        m_acceleration = 0.f;
        m_accelerationVariance = 0.f;
        m_property312 = 0.f;
        m_property313 = 0.f;
        m_property314 = 0.f;
        m_property315 = 0.f;
        m_steerForce = 0.f;
        m_steerForceVariance = 0.f;
        m_steerForceLowEnabled = false;
        m_steerForceLow = 0.f;
        m_steerForceLowVariance = 0.f;
        m_steerForceHighEnabled = false;
        m_steerForceHigh = 0.f;
        m_steerFroceHighVariance = 0.f;
        m_speedRangeLow = 0.f;
        m_speedRangeLowVariance = 0.f;
        m_speedRangeHigh = 0.f;
        m_speedRangeHighVariance = 0.f;
        m_breakForce = 0.f;
        m_breakForceVariance = 0.f;
        m_breakAngle = 0.f;
        m_breakAngleVariance = 0.f;
        m_breakSteerForce = 0.f;
        m_breakSteerForceVariance = 0.f;
        m_breakSteerSpeedLimit = 0.f;
        m_breakSteerSpeedLimitVariance = 0.f;
        m_targetDirection = false;
        m_ignoreDisabled = false;
        m_rotateDirection = false;
        m_rotationOffset = 0.f;
        m_nearAcceleration = 0.f;
        m_nearAccelerationVariance = 0.f;
        m_nearDistance = 0.f;
        m_nearDistanceVariance = 0.f;
        m_nearFriction = 0.f;
        m_nearFrictionVariance = 0.f;
        m_friction = 0.f;
        m_frictionVariance = 0.f;
        m_easing = 0.f;
        m_easingVariance = 0.f;
        m_rotateEasing = 0.f;
        m_rotateDeadZ = 0.f;
        m_priority = 0;
        m_unk7fc = 0;
        m_maxRangeReference = 0;
        m_followMode = 0;
        m_exclusive = false;
        m_startMode = 0;
    }

    static AdvancedFollowTriggerObject* create(char const* frame) = win inline, imac 0x1a28c0, m1 0x16056c {
        auto ret = new AdvancedFollowTriggerObject();
        if (ret->init(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x49d4c0, imac 0x1abfc0, m1 0x167518;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x49b2c0, m1 0x1606fc, imac 0x1a2aa0;

    int getAdvancedFollowID() = win inline, imac 0x1a2a60 {
        if (m_targetPlayer1) return -1;
        if (m_targetPlayer2) return -2;
        if (m_followCPP) return -3;
        else return m_centerGroupID;
    }
    bool init(char const* frame) = win inline, ios inline {
        return EffectGameObject::init(frame);
    }

    // property 292
    float m_delay;
    // property 293
    float m_delayVariance;
    // property 300
    float m_startSpeed;
    // property 301
    float m_startSpeedVariance;
    // property 560
    int m_startSpeedReference;
    // property 563
    float m_startDirection;
    // property 564
    float m_startDirectionVariance;
    // property 565
    int m_startDirectionReference;
    // property 298
    float m_maxSpeed;
    // property 299
    float m_maxSpeedVariance;
    // property 306
    bool m_xOnly;
    // property 307
    bool m_yOnly;
    // property 308
    float m_maxRange;
    // property 309
    float m_maxRangeVariance;
    // property 310
    float m_property310;
    // property 311
    float m_property311;
    // property 334
    float m_acceleration;
    // property 335
    float m_accelerationVariance;
    // property 312
    float m_property312;
    // property 313
    float m_property313;
    // property 314
    float m_property314;
    // property 315
    float m_property315;
    // property 316
    float m_steerForce;
    // property 317
    float m_steerForceVariance;
    // property 337
    bool m_steerForceLowEnabled;
    // property 318
    float m_steerForceLow;
    // property 319
    float m_steerForceLowVariance;
    // property 338
    bool m_steerForceHighEnabled;
    // property 320
    float m_steerForceHigh;
    // property 321
    float m_steerFroceHighVariance;
    // property 322
    float m_speedRangeLow;
    // property 323
    float m_speedRangeLowVariance;
    // property 324
    float m_speedRangeHigh;
    // property 325
    float m_speedRangeHighVariance;
    // property 326
    float m_breakForce;
    // property 327
    float m_breakForceVariance;
    // property 328
    float m_breakAngle;
    // property 329
    float m_breakAngleVariance;
    // property 330
    float m_breakSteerForce;
    // property 331
    float m_breakSteerForceVariance;
    // property 332
    float m_breakSteerSpeedLimit;
    // property 333
    float m_breakSteerSpeedLimitVariance;
    // property 305
    bool m_targetDirection;
    // property 336
    bool m_ignoreDisabled;
    // property 339
    bool m_rotateDirection;
    // property 340
    float m_rotationOffset;
    // property 357
    float m_nearAcceleration;
    // property 358
    float m_nearAccelerationVariance;
    // property 359
    float m_nearDistance;
    // property 360
    float m_nearDistanceVariance;
    // property 561
    float m_nearFriction;
    // property 562
    float m_nearFrictionVariance;
    // property 558
    float m_friction;
    // property 559
    float m_frictionVariance;
    // property 361
    float m_easing;
    // property 362
    float m_easingVariance;
    // property 363
    float m_rotateEasing;
    // property 364
    float m_rotateDeadZ;
    // property 365
    int m_priority;
    int m_unk7fc;
    // property 366
    int m_maxRangeReference;
    // property 367
    int m_followMode;
    // property 571
    bool m_exclusive;
    // property 572
    int m_startMode;
}

[[link(android)]]
class AdvFollowSetup {
    // ~AdvFollowSetup();

    gd::unordered_set<int> m_centerIDs;
    gd::unordered_set<int> m_groupIDs;
    gd::unordered_set<int> m_controlIDs;
    int m_delay;
}

[[link(android)]]
class AnimatedGameObject : EnhancedGameObject, AnimatedSpriteDelegate, SpritePartDelegate {
    AnimatedGameObject() {
        m_animatedSprite = nullptr;
        m_childSprite = nullptr;
        m_eyeSpritePart = nullptr;
        m_finishedAnimating = false;
        m_playingAnimation = false;
        m_notGrounded = false;
        m_animationID = 0;
    }
    ~AnimatedGameObject() = win inline, m1 0x16f934 {
        CC_SAFE_RELEASE(m_eyeSpritePart);
    }

    static gd::string animationForID(int type, int id) = win 0x4a5010, imac 0x1b8850;
    static AnimatedGameObject* create(int id) = win inline, imac 0x1b5ed0, m1 0x16fab0 {
        auto ret = new AnimatedGameObject();
        if (ret->init(id)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static float getTweenTime(int type, int id) = win inline, ios inline { return .05f; }

    virtual void setOpacity(unsigned char opacity) = win 0x4a3950, m1 0x170aec, imac 0x1b6f70;
    virtual void setChildColor(cocos2d::ccColor3B const& color) = win 0x4a54c0, m1 0x1724a4, imac 0x1b8b70;
    virtual void resetObject() = win 0x4a4fc0, m1 0x172440, imac 0x1b8b00;
    virtual void activateObject() = win 0x4a37a0, m1 0x170a00, imac 0x1b6e60;
    virtual void deactivateObject(bool deactivate) = win 0x4a3870, imac 0x1b6ea0, m1 0x170a44;
    virtual void setObjectColor(cocos2d::ccColor3B const& color) = win 0x4a3a20, m1 0x170bb8, imac 0x1b7050;
    virtual void animationFinished(char const* key) = win 0x4a3a60, m1 0x170bec, imac 0x1b7080;
    virtual void displayFrameChanged(cocos2d::CCObject* sprite, gd::string frameName) = win 0x4a4d40, m1 0x171c28, imac 0x1b83b0;

    bool init(int id) = win 0x4a26d0, imac 0x1b6020, m1 0x16fbd4;
    void playAnimation(int type) = win 0x4a4e90, m1 0x171f48;
    void setupAnimatedSize(int id) = win inline, imac 0x1b61c0, m1 0x16fd70 {
        auto width = 10.f;
        auto height = 10.f;
        switch (id) {
            case 918:
                m_hasContentSize = true;
                m_objectRadius = 24.f;
                m_lastSize.width = 80.f;
                m_lastSize.height = 80.f;
                width = 48.f;
                height = 48.f;
                break;
            case 919:
                width = 25.f;
                height = 6.f;
                break;
            case 1327:
                m_hasContentSize = true;
                m_lastSize.width = 35.f;
                m_lastSize.height = 30.f;
                width = 8.f;
                height = 8.f;
                break;
            case 1328:
                m_hasContentSize = true;
                m_lastSize.width = 35.f;
                m_lastSize.height = 40.f;
                width = 8.f;
                height = 15.f;
                break;
            case 1584:
                m_hasContentSize = true;
                m_lastSize.width = 60.f;
                m_lastSize.height = 80.f;
                width = 8.f;
                height = 8.f;
                break;
            case 2012:
                m_hasContentSize = true;
                m_objectRadius = 15.f;
                m_lastSize.width = 45.f;
                m_lastSize.height = 45.f;
                width = 8.f;
                height = 8.f;
                break;
        }
        m_width = width * m_scaleX;
        m_height = height * m_scaleY;
        this->setContentSize({ width, height });
    }
    void setupChildSprites() = win 0x4a2c60, imac 0x1b6380, m1 0x16ff00;
    void updateChildSpriteColor(cocos2d::ccColor3B color) = win inline, imac 0x1b6c20, m1 0x1707e8 {
        if (!m_childSprite) return;
        auto spriteChildren = m_childSprite->getChildren();
        for (int i = 0; i < spriteChildren->count(); i++) {
            static_cast<cocos2d::CCSprite*>(spriteChildren->objectAtIndex(i))->setColor(color);
        }
    }
    void updateObjectAnimation() = win 0x4a3530, imac 0x1b6ca0, m1 0x170868;

    CCAnimatedSprite* m_animatedSprite;
    cocos2d::CCSprite* m_childSprite;
    CCSpritePart* m_eyeSpritePart;
    bool m_finishedAnimating;
    bool m_playingAnimation;
    gd::string m_currentAnimation;
    bool m_notGrounded;
    int m_animationID;
}

[[link(android)]]
class AnimatedShopKeeper : CCAnimatedSprite {
    // virtual ~AnimatedShopKeeper();
    AnimatedShopKeeper() {
        m_type = ShopType::Normal;
        m_idleInt1 = 0;
        m_idleInt2 = 0;
        m_looking = false;
        m_reacting = false;
        m_reactCount = 0;
        m_gruntIndex = 0;
    }

    static AnimatedShopKeeper* create(ShopType type) = win inline, imac 0x3242d0 {
        auto ret = new AnimatedShopKeeper();
        if (ret->init(type)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void animationFinished(char const* key) = win 0x2afd60, m1 0x2b5510, imac 0x3282d0;

    bool init(ShopType type) = win inline, imac 0x328220 {
        m_type = type;
        auto shopkeeper = "GJShopKeeper";
        switch (type) {
            case ShopType::Secret: shopkeeper = "GJShopKeeper2"; break;
            case ShopType::Community: shopkeeper = "GJShopKeeper3"; break;
            case ShopType::Mechanic: shopkeeper = "GJShopKeeper4"; break;
            case ShopType::Diamond: shopkeeper = "GJShopKeeper5"; break;
            default: shopkeeper = "GJShopKeeper"; break;
        }
        if (!CCAnimatedSprite::initWithType(shopkeeper, nullptr, false)) return false;
        m_idleInt2 = (rand() / 32767.f) * 5.f + 10.f;
        m_idleInt1 = (rand() / 32767.f) * 2.f + 1.f;
        m_animationManager->stopAnimations();
        return true;
    }
    void playReactAnimation() = win 0x2afa40;
    void startAnimating() = win 0x2afcd0, imac 0x324440, m1 0x2b1d34;

    ShopType m_type;
    int m_idleInt1;
    int m_idleInt2;
    bool m_looking;
    bool m_reacting;
    int m_reactCount;
    int m_gruntIndex;
}

[[link(android)]]
class AnimatedSpriteDelegate {
    virtual void animationFinished(char const* key) {}
}

[[link(android)]]
class AppDelegate : cocos2d::CCApplication, cocos2d::CCSceneDelegate {
    // virtual ~AppDelegate() = ios 0x1b7c90;

    static AppDelegate* get() = win inline, m1 0x57bb48 {
        return static_cast<AppDelegate*>(cocos2d::CCApplication::sharedApplication());
    }

    virtual bool applicationDidFinishLaunching() = win 0x82a60, imac 0x65bb20, m1 0x57b9c4;
    virtual void applicationDidEnterBackground() = win 0x82e10, m1 0x57bc3c, imac 0x65bdc0;
    virtual void applicationWillEnterForeground() = win 0x82e90, m1 0x57bd88, imac 0x65bf20;
    virtual void applicationWillBecomeActive() = win 0x82db0, m1 0x57bb58, imac 0x65bcc0;
    virtual void applicationWillResignActive() = win 0x82e00, m1 0x57bb6c, imac 0x65bce0;
    virtual void trySaveGame(bool force) = win 0x83520, imac 0x65c1b0, m1 0x57c00c;
    virtual void willSwitchToScene(cocos2d::CCScene* scene) = win 0x83600, m1 0x57c0e8, imac 0x65c290;

    float bgScale() = win inline, m1 0x57bb34 {
        return cocos2d::CCDirector::sharedDirector()->getScreenScaleFactorMax();
    }
    void checkSound() = win inline {
        if (this->musicTest()) FMODAudioEngine::sharedEngine()->pauseAllMusic(true);
    }
    void hideLoadingCircle() = win inline, m1 0x57c134 {}
    void loadingIsFinished() = win inline, m1 0x57bb4c {
        m_loadingFinished = true;
        PlatformToolbox::reportLoadingFinished();
    }
    bool musicTest() = win 0x833e0;
    void pauseGame() = win 0x83060;
    void pauseSound() = win 0x83140;
    void platformShutdown() = ios inline {}
    void resumeSound() = win 0x832e0;
    void setIdleTimerDisabled(bool disabled) = win inline, ios inline {}
    void setupGLView() = win 0x825f0;
    void showLoadingCircle(bool unk1, bool unk2, bool unk3) = win inline, m1 0x57c130 {}

    bool m_glViewSetup;
    bool m_gamePaused;
    cocos2d::CCScene* m_runningScene;
    bool m_loadingFinished;
    bool m_unk0e9;
    bool m_ios;
    bool m_unk0eb;
    bool m_unk0ec;
    bool m_unk0ed;
    float m_saveTime;
}

[[link(android)]]
class ArtistCell : TableViewCell {
    // virtual ~ArtistCell();
    ArtistCell(char const* identifier, float width, float height) = win inline, m1 0x1fa304, ios inline : TableViewCell(identifier, width, height) {
        this->init();
    }

    virtual bool init() = win 0x3c850, imac 0x254320, m1 0x1fa348;
    virtual void draw() = win 0xade40, m1 0x1fa50c, imac 0x2544e0;

    void loadFromObject(SongInfoObject* object) = win 0xb5630, imac 0x246db0, m1 0x1edd04;
    void onNewgrounds(cocos2d::CCObject* sender) = win 0xb5960, m1 0x1fa354;
    void onYouTube(cocos2d::CCObject* sender) = win 0xb5a00, m1 0x1fa430;
    void updateBGColor(int index) = win inline, imac 0x247100, m1 0x1ee050 {
        m_backgroundLayer->setColor(index % 2 == 0 ? cocos2d::ccColor3B { 161, 88, 44 } : cocos2d::ccColor3B { 194, 114, 62 });
        m_backgroundLayer->setOpacity(255);
    }

    SongInfoObject* m_songInfo;
}

[[link(android)]]
class ArtTriggerGameObject : EffectGameObject {
    // virtual ~ArtTriggerGameObject();
    ArtTriggerGameObject() {
        m_artIndex = 0;
    }

    static ArtTriggerGameObject* create(char const* frame) = win inline, m1 0x19c0bc {
        auto ret = new ArtTriggerGameObject();
        if (ret->init(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void triggerObject(GJBaseGameLayer* layer, int uniqueID, gd::vector<int> const* remapKeys) = win 0x4c2080, imac 0x1ed1b0, m1 0x19c6a8;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4c2000, m1 0x19c630, imac 0x1ed150;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x4c1e90, m1 0x19c1c8, imac 0x1ecc20;

    bool init(char const* frame) = win inline, ios inline {
        return EffectGameObject::init(frame);
    }

    // property 533
    int m_artIndex;
}

[[link(android)]]
class AudioAssetsBrowser : FLAlertLayer, TableViewCellDelegate, MusicDownloadDelegate {
    AudioAssetsBrowser() {
        m_songInfoObjects = nullptr;
        m_songList = nullptr;
        m_pageIndicatorLabel = nullptr;
        m_loadingCircle = nullptr;
    }
    ~AudioAssetsBrowser() = win inline, m1 0x6b98a0 {
        MusicDownloadManager::sharedState()->removeMusicDownloadDelegate(this);
        CC_SAFE_RELEASE(m_songInfoObjects);
    }

    static AudioAssetsBrowser* create(gd::vector<int>& songIds, gd::vector<int>& sfxIds) = win inline, imac 0x7b3780, m1 0x6b9980 {
        auto ret = new AudioAssetsBrowser();
        if (ret->init(songIds, sfxIds)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void registerWithTouchDispatcher() = win 0x42660, m1 0x6ba968, imac 0x7b4970;
    virtual void keyBackClicked() = win 0x846c0, m1 0x6ba8ec, imac 0x7b4900;
    virtual void musicActionFinished(GJMusicAction action) = win 0x83d40, imac 0x7b4820, m1 0x6ba898 {}
    virtual void musicActionFailed(GJMusicAction action) = win 0x83dc0, m1 0x6ba8a4, imac 0x7b4850;
    virtual bool cellPerformedAction(TableViewCell* cell, int listType, CellAction action, cocos2d::CCNode* parent) = win inline, imac 0x7b4890, m1 0x6ba8b8 { return false; }
    virtual int getSelectedCellIdx() = win inline, imac 0x7b48b0, m1 0x6ba8c8 { return 0; }
    virtual int getCellDelegateType() = win inline, imac 0x7b48d0, m1 0x6ba8d8 { return 1; }

    bool init(gd::vector<int>& songIds, gd::vector<int>& sfxIds) = win 0x837d0;
    void onClose(cocos2d::CCObject* sender) = win 0x84690, imac 0x7b3e70, m1 0x6b9fe8;
    void onInfo(cocos2d::CCObject* sender) = win 0x83fe0, imac 0x7b3ea0, m1 0x6ba024;
    void onPage(cocos2d::CCObject* sender) = win inline, imac 0x7b4880, m1 0x6ba8b4, ios inline {}
    void setupList() = win 0x83e00, imac 0x7b45c0, m1 0x6ba664;
    void trySetupAudioBrowser() = win inline, m1 0x6ba7f8 {
        auto mdm = MusicDownloadManager::sharedState();
        if (mdm->m_sfxObjects) {
            if (mdm->m_customContentURL.empty()) mdm->getCustomContentURL();
            this->setupList();
        }
        else {
            if (mdm->m_customContentURL.empty()) mdm->getCustomContentURL();
            else mdm->downloadSFXLibrary();
        }
    }
    void updatePageLabel() = win inline, ios inline {}

    cocos2d::CCArray* m_songInfoObjects;
    GJCommentListLayer* m_songList;
    cocos2d::CCLabelBMFont* m_pageIndicatorLabel;
    gd::vector<int> m_songsIds;
    gd::vector<int> m_sfxIds;
    LoadingCircleSprite* m_loadingCircle;
}

[[link(android)]]
class AudioEffectsLayer : cocos2d::CCLayerColor {
    AudioEffectsLayer() {
        m_batchNode = nullptr;
        m_unk1bc = nullptr;
        m_unk1c0 = nullptr;
        m_timeElapsed = 0;
        m_audioPulseMod = 0;
        m_goingDown = false;
        m_audioScale = 0;
        m_unk1d4 = false;
    }
    ~AudioEffectsLayer() = win inline {
        CC_SAFE_RELEASE(m_unk1bc);
        CC_SAFE_RELEASE(m_unk1c0);
    }

    static AudioEffectsLayer* create(gd::string audioString) = win inline, imac 0x4aecf0, m1 0x410dac {
        auto ret = new AudioEffectsLayer();
        if (ret->init(audioString)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void draw() = win inline, m1 0x411818, imac 0x4af710 {}
    virtual void updateTweenAction(float value, char const* key) = win 0x85020, imac 0x4af5f0, m1 0x4116f0;

    void audioStep(float dt) = win 0x84df0, imac 0x4af3f0, m1 0x4114c4;
    cocos2d::CCSprite* getBGSquare() = m1 0x41181c;
    void goingDown() = win 0x85190, imac 0x4af5e0, m1 0x4116e4;
    bool init(gd::string audioString) = win 0x84c00, imac 0x5407f0;
    void resetAudioVars() = win 0x84d90, imac 0x4af390, m1 0x41147c;
    void triggerEffect(float pulse) = win inline {
        float scale;
        if (pulse == 1.f) scale = .8f;
        else if (pulse == .9f) scale = .6f;
        else if (pulse == .8f) scale = .4f;
        else scale = pulse * .2f;
        auto pulseMod = std::min(scale + m_audioScale, 1.1f);
        if (!m_goingDown && m_audioPulseMod > pulseMod) return;
        m_audioPulseMod = pulseMod;
        m_goingDown = false;
        this->stopActionByTag(0);
        auto action = cocos2d::CCSequence::create(
            cocos2d::CCActionTween::create(.05f, "audioScale", m_audioScale, pulseMod),
            cocos2d::CCCallFunc::create(this, callfunc_selector(AudioEffectsLayer::goingDown)),
            cocos2d::CCActionTween::create(.2f, "audioScale", pulseMod, .1f),
            nullptr
        );
        action->setTag(0);
        this->runAction(action);
    }

    cocos2d::CCSpriteBatchNode* m_batchNode;
    cocos2d::CCArray* m_unk1bc;
    cocos2d::CCArray* m_unk1c0;
    float m_timeElapsed;
    float m_audioPulseMod;
    bool m_goingDown;
    float m_audioScale;
    bool m_unk1d4;
}

[[link(android)]]
class AudioLineGuideGameObject : EffectGameObject {
    // virtual ~AudioLineGuideGameObject();
    AudioLineGuideGameObject() {
        m_beatsPerMinute = 100;
        m_beatsPerBar = 1;
        m_speed = Speed::Normal;
        m_disabled = false;
    }

    static AudioLineGuideGameObject* create() = win inline, imac 0x1ea5c0, m1 0x19a23c {
        auto ret = new AudioLineGuideGameObject();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x4c10e0, m1 0x19a314, imac 0x1ea6a0;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4c14a0, m1 0x19adc8, imac 0x1eb450;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x4c1150, m1 0x19a364, imac 0x1ea6f0;

    // property 498
    int m_beatsPerMinute;
    // property 501
    int m_beatsPerBar;
    // property 499
    Speed m_speed;
    // property 500
    bool m_disabled;
}

[[link(android)]]
class BitmapFontCache : cocos2d::CCObject {
    BitmapFontCache() {
        m_cache = nullptr;
    }
    ~BitmapFontCache() = win inline, m1 0x1ca814 {
        CC_SAFE_RELEASE(m_cache);
    }

    static void purgeSharedFontCache() = win inline, m1 0x1ca7e8 {
        auto** instancePtr = reinterpret_cast<BitmapFontCache**>(geode::base::get() + 0x6a4e08);
        if (*instancePtr) {
            (*instancePtr)->release();
            *instancePtr = nullptr;
        }
    }
    static BitmapFontCache* sharedFontCache() = win inline, m1 0x1ca744 {
        auto** instancePtr = reinterpret_cast<BitmapFontCache**>(geode::base::get() + 0x6a4e08);
        if (!*instancePtr) {
            *instancePtr = new BitmapFontCache();
            (*instancePtr)->init();
        }
        return *instancePtr;
    }

    FontObject* fontWithConfigFile(char const* font, float scale) = win 0x3b3e0, imac 0x21fbd0, m1 0x1ca8cc;
    bool init() = win inline, m1 0x1ca7bc, ios inline {
        m_cache = cocos2d::CCDictionary::create();
        m_cache->retain();
        return true;
    }

    cocos2d::CCDictionary* m_cache;
}

[[link(android)]]
class BonusDropdown : cocos2d::CCNode {
    // virtual ~BonusDropdown();

    static BonusDropdown* create(gd::string text, int price) = imac 0x492e70, m1 0x3f7c8c;

    bool init(gd::string text, int price) = imac 0x492f50, m1 0x3f7d64;
    void show() = m1 0x4cb54;

    cocos2d::CCLayerColor* m_layerColor;
    float m_yPosition;
    cocos2d::CCScene* m_scene;
}

[[link(android)]]
class BoomListLayer : cocos2d::CCLayerColor {
    // virtual ~BoomListLayer();

    static BoomListLayer* create(BoomListView* listView, char const* title) = imac 0x46d990, m1 0x3d56a0;

    bool init(BoomListView* listView, char const* title) = imac 0x46da80;
}

[[link(android)]]
class BoomListView : cocos2d::CCLayer, TableViewDelegate, TableViewDataSource {
    BoomListView() {
        m_tableView = nullptr;
        m_entries = nullptr;
        m_type = BoomListType::Default;
        m_height = 0.f;
        m_width = 0.f;
        m_itemSeparation = 0.f;
        m_currentPage = 0;
        m_locked = false;
    }
    ~BoomListView() = win 0x3bfa0, m1 0x29b7b0, imac 0x30be50;

    static BoomListView* create(cocos2d::CCArray* entries, TableViewCellDelegate* delegate, float height, float width, int page, BoomListType type, float y) = win inline, imac 0x30c170, m1 0x29b9c0, ios inline {
        auto ret = new BoomListView();
        if (ret->init(entries, delegate, height, width, page, type, y)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void draw() = win inline, imac 0x30ce10, m1 0x29c47c {}
    virtual void setupList(float yOffset) = win 0x3c3b0, imac 0x30c4d0, m1 0x29bcc0;
    virtual void TableViewWillDisplayCellForRowAtIndexPath(CCIndexPath& indexPath, TableViewCell* cell, TableView* tableView) = win inline, imac 0x30c570, m1 0x29bd40 {}
    virtual float cellHeightForRowAtIndexPath(CCIndexPath& indexPath, TableView* tableView) = win 0x3c440, imac 0x30c5b0, m1 0x29bd50;
    virtual void didSelectRowAtIndexPath(CCIndexPath& indexPath, TableView* tableView) = win inline, m1 0x29bd60, imac 0x30c5d0 {}
    virtual int numberOfRowsInSection(unsigned int section, TableView* tableView) = win 0x3c450, m1 0x29bd68, imac 0x30c5f0;
    virtual unsigned int numberOfSectionsInTableView(TableView* tableView) = win inline, imac 0x30c620, m1 0x29bd78 { return 1; }
    virtual TableViewCell* cellForRowAtIndexPath(CCIndexPath& indexPath, TableView* tableView) = win 0x3c470, imac 0x30c640, m1 0x29bd88;
    virtual void TableViewCommitCellEditingStyleForRowAtIndexPath(TableView* tableView, TableViewCellEditingStyle style, CCIndexPath& indexPath) = win inline, imac 0x30cdf0, m1 0x29c474 {}
    virtual void TableViewWillReloadCellForRowAtIndexPath(CCIndexPath& indexPath, TableViewCell* cell, TableView* tableView) = win inline, imac 0x30c590, m1 0x29bd48 {}
    virtual TableViewCell* getListCell(char const* identifier) = win 0x3c500, imac 0x30c760, m1 0x29bea4;
    virtual void loadCell(TableViewCell* cell, int index) = win 0x3c670, imac 0x30c9a0, m1 0x29c048;

    void addObjectToList(cocos2d::CCNode* node) = win inline, m1 0x29bcb0, ios inline {
        if (m_entries) m_entries->addObject(node);
    }
    bool init(cocos2d::CCArray* entries, BoomListType type, float width, float height) {
        return this->init(entries, nullptr, height, width, 0, type, 0.0f);
    }
    bool init(cocos2d::CCArray* entries, TableViewCellDelegate* delegate, float height, float width, int page, BoomListType type, float y) = win 0x3c040, m1 0x29bacc, imac 0x30c2a0;
    void lockList(bool locked) = win inline, imac 0x30c450 {
        m_locked = locked;
        this->setTouchEnabled(!locked);
        this->setMouseEnabled(!locked);
        this->setKeyboardEnabled(!locked);
    }

    TableView* m_tableView;
    cocos2d::CCArray* m_entries;
    BoomListType m_type;
    float m_height;
    float m_width;
    float m_itemSeparation;
    int m_currentPage;
    bool m_locked;
}

[[link(android)]]
class BoomScrollLayer : cocos2d::CCLayer {
    BoomScrollLayer() = m1 0x32b848 {
        m_dots = nullptr;
        m_slowPage = 0;
        m_touchX = 0.f;
        m_touchQuotient = 0.f;
        m_looped = false;
        m_dynamicDelegate = nullptr;
        m_dynamicObjects = nullptr;
        m_dynamic = false;
        m_touchType = 0;
        m_ignoreTouchCancel = false;
        m_touch = nullptr;
        m_pages = nullptr;
        m_touchTime = 0.0;
        m_extendedLayer = nullptr;
        m_unkFloat1 = 0.f;
        m_maxSpeed = 0.f;
        m_minSpeed = 0.f;
        m_unkFloat2 = 0.f;
        m_delegate = nullptr;
        m_pageMoving = false;
        m_pagesInvisible = false;
        m_minimumTouchLengthToSlide = 0.f;
        m_minimumTouchLengthToChangePage = 0.f;
        m_width = 0.f;
        m_cancelAndStealTouch = false;
        m_dotsVisible = false;
        m_page = 0;
        m_pageOffset = 0.f;
        m_unkPtr = nullptr;
        m_doVisit = false;
    }
    ~BoomScrollLayer() = win inline, m1 0x32a340 {
        CC_SAFE_RELEASE(m_dynamicObjects);
        CC_SAFE_RELEASE(m_pages);
        CC_SAFE_RELEASE(m_dots);
    }

    static BoomScrollLayer* create(cocos2d::CCArray* pages, int offset, bool looped) = win inline, imac 0x3a4ac0, m1 0x32944c {
        return BoomScrollLayer::create(pages, offset, looped, nullptr, nullptr);
    }
    static BoomScrollLayer* create(cocos2d::CCArray* pages, int offset, bool looped, cocos2d::CCArray* dynamicObjects, DynamicScrollDelegate* delegate) = win 0x3d0c0, imac 0x3a46e0, m1 0x329080;

    virtual void visit() = win 0x3dc40, m1 0x32a6dc, imac 0x3a5ea0;
    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x3e780, m1 0x32b1e4, imac 0x3a69d0;
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x3e840, m1 0x32b2c0, imac 0x3a6ad0;
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x3eb80, m1 0x32b58c, imac 0x3a6df0;
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x3e6a0, m1 0x32b028, imac 0x3a6800;
    virtual void registerWithTouchDispatcher() = win 0x3e610, m1 0x32aeb0, imac 0x3a6670;

    void addPage(cocos2d::CCLayer* page) = win inline, m1 0x32ac7c, ios inline {
        this->addPage(page, m_pages->count());
    }
    void addPage(cocos2d::CCLayer* page, int index) = win inline, imac 0x3a64b0, m1 0x32acec, ios inline {
        index = std::clamp<int>(index, 0, m_pages->count());
        m_pages->insertObject(page, index);
        this->updatePages();
        this->moveToPage(m_page);
    }
    void cancelAndStoleTouch(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline {
        auto touches = new cocos2d::CCSet();
        touches->addObject(touch);
        touches->autorelease();
        m_ignoreTouchCancel = true;
        cocos2d::CCDirector::sharedDirector()->getTouchDispatcher()->touchesCancelled(touches, event);
        m_ignoreTouchCancel = false;
        this->claimTouch(touch);
    }
    void claimTouch(cocos2d::CCTouch* touch) = win inline {
        auto handler = static_cast<cocos2d::CCTargetedTouchHandler*>(cocos2d::CCDirector::sharedDirector()->getTouchDispatcher()->findHandler(this));
        if (!handler->getClaimedTouches()->containsObject(touch)) {
            handler->getClaimedTouches()->addObject(touch);
        }
    }
    cocos2d::CCLayer* getPage(int page) = win inline {
        if (m_dynamic) {
            auto pages = m_pages->count();
            if (page > 0) page = page % pages;
            else {
                while (page < 0) page += pages;
            }
        }
        return static_cast<cocos2d::CCLayer*>(m_pages->objectAtIndex(page));
    }
    int getRelativePageForNum(int page) = win inline {
        auto pages = this->getTotalPages();
        if (page > 0) return page % pages;
        while (page < 0) page += pages;
        return page;
    }
    cocos2d::CCPoint getRelativePosForPage(int page) = win inline, imac 0x3a5940, m1 0x32a288, ios inline {
        return { this->getContentSize().width - m_pageOffset * page, 0.f };
    }
    int getTotalPages() = win inline {
        return m_dynamic ? m_dynamicObjects->count() : m_pages->count();
    }
    bool init(cocos2d::CCArray* pages, int offset, bool looped, cocos2d::CCArray* dynamicObjects, DynamicScrollDelegate* delegate) = win 0x3d2a0;
    void instantMoveToPage(int page) = win 0x3de30;
    void moveToPage(int page) = win 0x3df10, imac 0x3a6170;
    void moveToPageEnded() = win 0x3dca0, imac 0x3a5f00, m1 0x32a760;
    int pageNumberForPosition(cocos2d::CCPoint position) = win 0x3dd30, imac 0x3a5d00, m1 0x32a530;
    cocos2d::CCPoint positionForPageWithNumber(int page) = win inline, imac 0x3a6040, m1 0x32a89c, ios inline {
        return { this->getContentSize().width + m_pageOffset * page, 0.f };
    }
    void quickUpdate() = win inline {
        if (m_pageMoving) {
            m_pageMoving = false;
            m_extendedLayer->stopActionByTag(2);
            m_extendedLayer->setPosition(m_position);
            this->moveToPageEnded();
        }
    }
    void removePage(cocos2d::CCLayer* page) = win inline, imac 0x3a6520, m1 0x32ad54, ios inline {
        m_pages->removeObject(page);
        this->removeChild(page, true);
        m_slowPage = m_page;
        m_page = std::min<int>(m_page, m_pages->count() - 1);
        this->moveToPage(m_page);
    }
    void removePageWithNumber(int page) = win inline, imac 0x3a65b0, m1 0x32ade8, ios inline {
        if (page > -1 && page < m_pages->count()) {
            this->removePage(static_cast<cocos2d::CCLayer*>(m_pages->objectAtIndex(page)));
        }
    }
    void repositionPagesLooped() = win 0x3e0d0;
    void selectPage(int page) = win inline {
        if (page > -1 && page < this->getTotalPages()) {
            m_extendedLayer->setPosition(this->positionForPageWithNumber(page));
            m_slowPage = m_page;
            m_page = page;
        }
    }
    void setDotScale(float scale) = win inline, m1 0x32a220 {
        for (int i = 0; i < m_dots->count(); i++) {
            static_cast<cocos2d::CCSprite*>(m_dots->objectAtIndex(i))->setScale(scale);
        }
    }
    void setPagesIndicatorPosition(cocos2d::CCPoint pos) = win inline, imac 0x3a4c00, m1 0x329598 {
        m_dotPosition = pos;
        this->updateDots(0.f);
    }
    void setupDynamicScrolling(cocos2d::CCArray* dynamicObjects, DynamicScrollDelegate* delegate) = win 0x3d610, imac 0x3a53c0, m1 0x329d30;
    void togglePageIndicators(bool visible) = win 0x3dbd0, imac 0x3a5e30, m1 0x32a670;
    void updateDots(float dt) = win 0x3d9d0;
    void updatePages() = win 0x3d8b0, m1 0x380c4;

    cocos2d::CCArray* m_dots;
    int m_slowPage;
    float m_touchX;
    float m_touchQuotient;
    bool m_looped;
    DynamicScrollDelegate* m_dynamicDelegate;
    cocos2d::CCArray* m_dynamicObjects;
    bool m_dynamic;
    int m_touchType;
    bool m_ignoreTouchCancel;
    cocos2d::CCTouch* m_touch;
    cocos2d::CCArray* m_pages;
    double m_touchTime;
    cocos2d::CCPoint m_position;
    ExtendedLayer* m_extendedLayer;
    cocos2d::CCRect m_rect;
    // these 4 floats are likely wrong, they're min, touchSpeedFast, touchSpeedMid in 2.0 but it only has 3 of them
    float m_unkFloat1;
    float m_maxSpeed;
    float m_minSpeed;
    float m_unkFloat2;
    BoomScrollLayerDelegate* m_delegate;
    bool m_pageMoving;
    bool m_pagesInvisible;
    float m_minimumTouchLengthToSlide;
    float m_minimumTouchLengthToChangePage;
    float m_width; //marginOffset in Rob terms
    bool m_cancelAndStealTouch;
    bool m_dotsVisible;
    cocos2d::CCPoint m_dotPosition;
    cocos2d::ccColor4B m_selectedPageColor;
    cocos2d::ccColor4B m_normalPageColor;
    int m_page;
    float m_pageOffset;
    void* m_unkPtr;
    bool m_doVisit;
    cocos2d::CCRect m_clippingRect;
}

[[link(android)]]
class BoomScrollLayerDelegate {
    virtual void scrollLayerScrollingStarted(BoomScrollLayer* layer) {}
    virtual void scrollLayerScrolledToPage(BoomScrollLayer* layer, int page) {}
    virtual void scrollLayerMoved(cocos2d::CCPoint position) {}
    virtual void scrollLayerWillScrollToPage(BoomScrollLayer* layer, int page) {}
}

[[link(android)]]
class BrowseSmartKeyLayer : BrowseSmartTemplateLayer {
    // virtual ~BrowseSmartKeyLayer();
    BrowseSmartKeyLayer() {
        m_templatePage = 0;
    }

    static BrowseSmartKeyLayer* create(GJSmartTemplate* smartTemplate, gd::string prefabKey) = win inline, imac 0x4ea200, m1 0x444944 {
        auto ret = new BrowseSmartKeyLayer();
        if (ret->init(smartTemplate, prefabKey)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void onBack(cocos2d::CCObject* sender) = win 0x45c1e0, m1 0x445f44, imac 0x4eb9b0;

    void addChanceToSelected(int chance, bool zero) = win inline, imac 0x4eb520, m1 0x445abc {
        auto blocks = this->getAllSelectedBlocks();
        for (int i = 0; i < blocks->count(); i++) {
            if (auto prefab = m_template->getPrefabWithID(m_prefabKey, blocks->objectAtIndex(i)->getTag())) {
                if (zero) prefab->m_prefabChance = 0;
                else prefab->m_prefabChance += chance;
            }
        }
        this->updateChanceValues();
    }
    void createTemplateObjects() = win inline, m1 0x445708 {
        auto blocks = this->getAllSelectedBlocks();
        if (blocks->count() == 0) return;
        for (int i = 0; i < blocks->count(); i++) {
            this->createPrefab(m_prefabKey, blocks->objectAtIndex(i)->getTag());
        }
        this->addChild(TextAlertPopup::create("Added to editor", .5f, .6f, 150, ""), 100);
    }
    void deletedSelectedItems() = win inline, m1 0x445938 {
        for (int i = 0; i < m_pages->count(); i++) {
            auto page = static_cast<cocos2d::CCArray*>(m_pages->objectAtIndex(i));
            for (int j = 0; j < page->count();) {
                auto button = static_cast<CCMenuItemSpriteExtra*>(page->objectAtIndex(j));
                auto block = static_cast<GJSmartBlockPreview*>(button->getNormalImage());
                if (block->m_selected) {
                    m_template->removePrefab(m_prefabKey, block->getTag());
                    page->removeObjectAtIndex(j);
                }
                else j++;
            }
        }
        this->updateChanceValues();
    }
    cocos2d::CCArray* getAllSelectedBlocks() = win 0x45bf00, m1 0x445ca0;
    bool init(GJSmartTemplate* smartTemplate, gd::string prefabKey) = win 0x45b100;
    void onButton(cocos2d::CCObject* sender) = win 0x45bae0, imac 0x4eb160;
    void onPrefabObject(cocos2d::CCObject* sender) = win 0x45c100, m1 0x445638;
    void updateChanceValues() = win 0x45bfd0, imac 0x4eb7d0;

    gd::string m_prefabKey;
    int m_templatePage;
}

[[link(android), depends(SmartPrefabResult)]]
class BrowseSmartTemplateLayer : FLAlertLayer {
    BrowseSmartTemplateLayer() {
        m_template = nullptr;
        m_pages = nullptr;
        m_page = 0;
        m_nextPageBtn = nullptr;
        m_prevPageBtn = nullptr;
        m_dotsArray = nullptr;
    }
    ~BrowseSmartTemplateLayer() = win 0x4599b0, m1 0x442f40;

    static BrowseSmartTemplateLayer* create(GJSmartTemplate* smartTemplate, SmartBrowseFilter browseFilter) = win inline, imac 0x4e7fe0, m1 0x4429b0 {
        auto ret = new BrowseSmartTemplateLayer();
        if (ret->init(smartTemplate, browseFilter)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyBackClicked() = win 0x45b070, imac 0x4ea3c0, m1 0x444ae0;
    virtual void onBack(cocos2d::CCObject* sender) = win 0x45b090, imac 0x4ea400, m1 0x444b04;

    void addObjectToPage(cocos2d::CCObject* object, int page) = win 0x45a4e0, imac 0x4e9dd0, m1 0x4444e8;
    void addPrefabMenuItem(SmartPrefabResult result, int index) = win 0x45a0e0, imac 0x4e9420;
    void baseSetup() = win 0x45a570;
    void createDots() = win inline, imac 0x4e9ea0 {
        auto batchNode = cocos2d::CCSpriteBatchNode::create("smallDot.png");
        m_mainLayer->addChild(batchNode, 5);
        m_dotsArray = cocos2d::CCArray::create();
        m_dotsArray->retain();
        for (int i = 0; i < m_pages->count(); i++) {
            auto dot = cocos2d::CCSprite::create("smallDot.png");
            dot->setScale(.8f);
            batchNode->addChild(dot);
            m_dotsArray->addObject(dot);
        }
    }
    void createPrefab(gd::string key, int id) = win 0x45ac90, imac 0x4ea100, m1 0x44482c;
    void goToPage(int page) = win 0x45ab20, m1 0x443fec;
    bool init(GJSmartTemplate* smartTemplate, SmartBrowseFilter browseFilter) = win 0x459a70, imac 0x4e88a0;
    void onClick(cocos2d::CCObject* sender) = win 0x45b020, imac 0x4e9e50, m1 0x444564;
    void onClose(cocos2d::CCObject* sender) = win inline, m1 0x4448ec {
        cocos2d::CCDirector::sharedDirector()->getTouchDispatcher()->unregisterForcePrio(this);
        this->setKeypadEnabled(false);
        this->removeFromParentAndCleanup(true);
    }
    void onTemplateObject(cocos2d::CCObject* sender) = win 0x45ad60, imac 0x4e9b30, m1 0x4441c0;
    void updateDots() = win inline, imac 0x4e9f70, m1 0x4446b8 {
        if (!m_dotsArray) this->createDots();
        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        auto count = m_pages->count();
        for (int i = 0; i < count; i++) {
            if (i < m_dotsArray->count()) {
                auto dot = static_cast<cocos2d::CCSprite*>(m_dotsArray->objectAtIndex(i));
                dot->setPosition(winSize * .5f + cocos2d::CCPoint { (i - (count - 1) * .5f) * 16.f, -125.f });
                dot->setColor(i == m_page ? cocos2d::ccColor3B { 255, 255, 255 } : cocos2d::ccColor3B { 125, 125, 125 });
            }
        }
    }

    GJSmartTemplate* m_template;
    cocos2d::CCArray* m_pages;
    int m_page;
    cocos2d::CCNode* m_nextPageBtn;
    cocos2d::CCNode* m_prevPageBtn;
    cocos2d::CCArray* m_dotsArray;
}

[[link(android)]]
class ButtonPage : cocos2d::CCLayer {
    // virtual ~ButtonPage();
    ButtonPage() {}

    static ButtonPage* create(cocos2d::CCArray* objects, cocos2d::CCPoint position, int rows, float spacing) = win inline, imac 0x5e1e10, m1 0x50ca68 {
        auto ret = new ButtonPage();
        if (ret->init(objects, position, rows, spacing)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init(cocos2d::CCArray* objects, cocos2d::CCPoint position, int rows, float spacing) = win inline, imac 0x5e2000, m1 0x50cc14 {
        if (!cocos2d::CCLayer::init()) return false;

        auto menu = cocos2d::CCMenu::create();
        this->addChild(menu);

        auto x = position.x;
        auto y = position.y;
        for (int i = 0; i < objects->count(); i++) {
            auto row = rows != 0 ? (int)(i / rows) : 0;
            auto node = static_cast<cocos2d::CCNode*>(objects->objectAtIndex(i));
            menu->addChild(node);
            node->setPosition(menu->convertToNodeSpace({
                (i % rows) + (spacing + 4.f) * (spacing * .5f + x - rows * spacing * .5f - (rows - 1) * 2.f),
                (y - spacing * .5f) - row * (spacing + 4.f)
            }));
        }

        return true;
    }
}

[[link(android)]]
class ButtonSprite : cocos2d::CCSprite {
    // virtual ~ButtonSprite();
    ButtonSprite() = win 0x3edb0 {
        m_mode = 0;
        m_width = 0.f;
        m_minWidth = 0.f;
        m_scale = 0.f;
        m_height = 0.f;
        m_absolute = false;
        m_label = nullptr;
        m_subSprite = nullptr;
        m_subBGSprite = nullptr;
        m_BGSprite = nullptr;
    }

    static ButtonSprite* create(char const* caption) {
        return ButtonSprite::create(caption, 0, false, "goldFont.fnt", "GJ_button_01.png", .0f, 1.f);
    }
    static ButtonSprite* create(cocos2d::CCSprite* topSprite) {
        return ButtonSprite::create(topSprite, 0, 0, .0f, 1.f, false, "GJ_button_01.png", false);
    }
    static ButtonSprite* create(char const* caption, float scale) {
        return ButtonSprite::create(caption, 0, false, "goldFont.fnt", "GJ_button_01.png", .0f, scale);
    }
    static ButtonSprite* create(char const* caption, const char* font, const char* texture) {
        return ButtonSprite::create(caption, 0, false, font, texture, .0f, 1.f);
    }
    static ButtonSprite* create(char const* caption, const char* font, const char* texture, float scale) {
        return ButtonSprite::create(caption, 0, false, font, texture, .0f, scale);
    }
    static ButtonSprite* create(char const* caption, int width, int minWidth, float scale, bool absolute) {
        return ButtonSprite::create(caption, width, minWidth, scale, absolute, "goldFont.fnt", "GJ_button_01.png", .0f);
    }

    /// Create a ButtonSprite with a top sprite and a texture.
    /// @param topSprite The top sprite to add on top of the sprite
    /// @param width Sprite width; ignored if `absolute` is false
    /// @param absolute Whether to use absolute width or not
    /// @param texture The name of the background sprite file (can't be in a spritesheet)
    /// @param height The height of the button, leave 0 for automatic
    /// @param scale Scale of top sprite
    static ButtonSprite* create(cocos2d::CCSprite* topSprite, int width, bool absolute, float height, const char* texture, float scale) {
        return create(topSprite, width, 0, height, scale, absolute, texture, true);
    }
    static ButtonSprite* create(cocos2d::CCSprite* topSprite, int width, int minWidth, float height, float scale, bool absolute) {
        return ButtonSprite::create(topSprite, width, minWidth, height, scale, absolute, "GJ_button_01.png", false);
    }
    static ButtonSprite* create(char const* caption, int width, int minWidth, float scale, bool absolute, char const* font, char const* bg) {
        return ButtonSprite::create(caption, width, minWidth, scale, absolute, font, bg, .0f);
    }

    /// Create a ButtonSprite with text, a font and a texture.
    /// @param caption The text of the ButtonSprite
    /// @param width Sprite width; ignored if `absolute` is false
    /// @param absolute Whether to use absolute width or not
    /// @param font The name of the BM font file to use
    /// @param texture The name of the background sprite file (can't be in a spritesheet)
    /// @param height The height of the button, leave 0 for automatic
    /// @param scale Scale of text
    /// @returns Pointer to the created ButtonSprite, or nullptr on error
    static ButtonSprite* create(const char* caption, int width, bool absolute, const char* font, const char* texture, float height, float scale) {
        return create(caption, width, 0, scale, absolute, font, texture, height);
    }
    static ButtonSprite* create(char const* caption, int width, int minWidth, float scale, bool absolute, char const* font, char const* bg, float height) = win 0x3f1e0, imac 0x92ac0, m1 0x83b48;
    static ButtonSprite* create(cocos2d::CCSprite* topSprite, int width, int minWidth, float height, float scale, bool absolute, char const* bgSprite, bool noScaleSpriteForBG) = win 0x3eed0, imac 0x92230, m1 0x83388;

    bool init(char const* caption, int width, int minWidth, float scale, bool absolute, char const* font, char const* bg, float height) = win 0x3f2b0;
    bool init(cocos2d::CCSprite* topSprite, int width, int minWidth, float height, float scale, bool absolute, char const* bgSprite, bool noScaleSpriteForBG) = win 0x3ef80;
    void setColor(cocos2d::ccColor3B color) = win inline, imac 0x933d0, m1 0x843d4 {
        // i love inlined funcs
        if (m_label) m_label->setColor(color);
        if (m_subSprite) m_subSprite->setColor(color);
        if (m_subBGSprite) m_subBGSprite->setColor(color);
        if (m_BGSprite) m_BGSprite->setColor(color);
    }
    void setString(char const* text) = win 0x3fb70, m1 0x83eec, imac 0x92eb0;
    void updateBGImage(char const* filename) = win 0x3f5b0, imac 0x93290;
    void updateSpriteBGSize() = win 0x3f6f0;
    void updateSpriteOffset(cocos2d::CCPoint offset) = win inline, imac 0x933a0, m1 0x843ac {
        m_spritePosition = offset;
        this->updateSpriteBGSize();
    }

    int m_mode;
    float m_width;
    float m_minWidth;
    float m_scale;
    float m_height;
    bool m_absolute;
    cocos2d::CCLabelBMFont* m_label;
    cocos2d::CCSprite* m_subSprite;
    cocos2d::CCSprite* m_subBGSprite;
    cocos2d::extension::CCScale9Sprite* m_BGSprite;
    cocos2d::CCPoint m_textOffset;
    cocos2d::CCPoint m_spritePosition;
    gd::string m_caption;
}

[[link(android)]]
class CameraTriggerGameObject : EffectGameObject {
    // virtual ~CameraTriggerGameObject();
    CameraTriggerGameObject() {
        m_exitStatic = false;
        m_followObject = false;
        m_followEasing = 1.f;
        m_edgeDirection = 0;
        m_smoothVelocity = false;
        m_velocityModifier = 0.f;
        m_exitInstant = false;
        m_previewOpacity = 1.f;
    }

    static CameraTriggerGameObject* create(char const* frame) = win inline {
        auto ret = new CameraTriggerGameObject();
        if (ret->init(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void triggerObject(GJBaseGameLayer* layer, int uniqueID, gd::vector<int> const* remapKeys) = win 0x4bd4b0, m1 0x19071c, imac 0x1ddaf0;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4be750, m1 0x193a70, imac 0x1e2030;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x4bd810, m1 0x1908bc, imac 0x1ddd50;

    bool init(char const* frame) = win inline, ios inline {
        return EffectGameObject::init(frame);
    }

    // property 110
    bool m_exitStatic;
    // property 212
    bool m_followObject;
    // property 213
    float m_followEasing;
    // property 164
    int m_edgeDirection;
    // property 453
    bool m_smoothVelocity;
    // property 454
    float m_velocityModifier;
    // property 465
    bool m_exitInstant;
    // property 506
    float m_previewOpacity;
}

[[link(android)]]
class CCAlertCircle : cocos2d::CCNode {
    // virtual ~CCAlertCircle();

    static CCAlertCircle* create() = m1 0x13ec78;

    virtual bool init() = imac 0x178bf0, m1 0x13ed5c;
    virtual void draw() = imac 0x178c80, m1 0x13ee08;

    CCCircleAlert* m_circleAlert;
}

[[link(android)]]
class CCAnimatedSprite : cocos2d::CCSprite {
    CCAnimatedSprite() = win 0x3ff40 {
        m_animationManager = nullptr;
        m_sprite = nullptr;
        m_fbfSprite = nullptr;
        m_paSprite = nullptr;
        m_spriteMode = (spriteMode)0;
        m_delegate = nullptr;
    }
    ~CCAnimatedSprite() = win 0x411d0, m1 0x2dd978;

    static CCAnimatedSprite* createWithType(char const* definition, cocos2d::CCTexture2D* texture, bool useTexture) = win inline, imac 0x34f970, m1 0x2dc6f8 {
        auto ret = new CCAnimatedSprite();
        if (ret->initWithType(definition, texture, useTexture)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void setOpacity(unsigned char opacity) = win 0x41100, imac 0x350b20, m1 0x2dd818;
    virtual void setColor(cocos2d::ccColor3B const& color) = win 0x41160, m1 0x2dd8c8, imac 0x350bd0;
    virtual void animationFinished(char const* key) = win 0x410e0, imac 0x350b00, m1 0x2dd800;
    virtual void animationFinishedO(cocos2d::CCObject* str) = win 0x410a0, m1 0x2dd7cc, imac 0x350ad0;

    void cleanupSprite() = win inline, imac 0x350390, m1 0x2dd0b4 {
        if (m_paSprite) m_paSprite->cleanup();
        if (m_fbfSprite) m_fbfSprite->cleanup();
        if (m_animationManager) m_animationManager->doCleanup();
        if (m_fbfSprite) m_fbfSprite->removeFromParentAndCleanup(true);
        if (m_paSprite) m_paSprite->removeFromParentAndCleanup(true);
        m_animationManager = nullptr;
        m_sprite = nullptr;
        m_fbfSprite = nullptr;
        m_paSprite = nullptr;
        m_spriteMode = (spriteMode)0;
    }
    bool initWithType(char const* definition, cocos2d::CCTexture2D* texture, bool useTexture) = win 0x40050, m1 0x2dc7cc;
    void loadType(char const* definition, cocos2d::CCTexture2D* texture, bool useTexture) = win 0x40270, m1 0x2dc9bc;
    void runAnimation(gd::string animation) = win 0x40d10, imac 0x350550, m1 0x2dd250;
    void runAnimationForced(gd::string animation) = win inline, m1 0x2dd2e8 {
        m_animationManager->overridePrio();
        m_animationManager->runAnimation(animation);
    }
    void stopTween() = win inline, m1 0x2dd790 {
        m_paSprite->stopAllActions();
        this->stopActionByTag(1);
        m_activeTween = "";
    }
    void switchToMode(spriteMode mode) = win 0x40ba0, m1 0x5e584;
    void tweenToAnimation(gd::string animation, float duration) = win 0x40d80, imac 0x350690, m1 0x2dd3bc;
    void tweenToAnimationFinished() = win 0x41050, imac 0x350980, m1 0x2dd674;
    void willPlayAnimation() = win inline {
        this->stopActionByTag(1);
        m_activeTween = "";
    }

    gd::string m_unkString1;
    gd::string m_activeTween;
    SpriteAnimationManager* m_animationManager;
    cocos2d::CCSprite* m_sprite;
    cocos2d::CCSprite* m_fbfSprite;
    CCPartAnimSprite* m_paSprite;
    spriteMode m_spriteMode;
    gd::string m_currentAnim;
    AnimatedSpriteDelegate* m_delegate;
}

[[link(android)]]
class CCAnimateFrameCache : cocos2d::CCObject {
    // virtual ~CCAnimateFrameCache();

    static CCAnimateFrameCache* get() {
        return CCAnimateFrameCache::sharedSpriteFrameCache();
    }
    static CCAnimateFrameCache* sharedSpriteFrameCache() = win 0x414e0, imac 0x56a820, m1 0x4b8bd8;

    void addCustomSpriteFramesWithFile(char const* filename) = imac 0x56aa60, m1 0x4b8ddc;
    cocos2d::CCDictionary* addDict(DS_Dictionary* dict, char const* filename) = win 0x41700, m1 0x4ba028;
    cocos2d::CCDictionary* addDict(cocos2d::CCDictionary* dict, char const* filename) = win inline, imac 0x17b720 {
        m_animateDescriptions->setObject(dict, filename);
        auto container = static_cast<cocos2d::CCDictionary*>(dict->objectForKey("animationContainer"));
        auto keys = container->allKeys();
        for (int i = 0; i < keys->count(); i++) {
            auto key = static_cast<cocos2d::CCString*>(keys->objectAtIndex(i))->getCString();
            auto animation = static_cast<cocos2d::CCDictionary*>(container->objectForKey(key));
            auto frames = cocos2d::CCArray::create();
            m_animateFrames->setObject(frames, key);
            for (int i = 0; i < animation->count(); i++) {
                auto frame = animation->objectForKey(cocos2d::CCString::createWithFormat("sprite_%i", i)->getCString());
                frames->addObject(SpriteDescription::createDescription(static_cast<cocos2d::CCDictionary*>(frame)));
            }
        }
        return dict;
    }
    cocos2d::CCDictionary* addSpriteFramesWithFile(char const* filename) = win 0x41570;
    bool init() = win inline, m1 0x4db24 {
        m_animateFrames = cocos2d::CCDictionary::create();
        m_animateFrames->retain();
        m_unk040 = cocos2d::CCDictionary::create();
        m_unk040->retain();
        m_animateDescriptions = cocos2d::CCDictionary::create();
        m_animateDescriptions->retain();
        return true;
    }
    void purgeSharedSpriteFrameCache() = win inline, m1 0x4b8cb0, ios inline {
        auto** instancePtr = reinterpret_cast<CCAnimateFrameCache**>(geode::base::get() + GEODE_WINDOWS(0x6a4e10) GEODE_IOS(0x85f2d0));
        if (*instancePtr) {
            (*instancePtr)->release();
            *instancePtr = nullptr;
        }
    }
    void removeSpriteFrames() = win inline, m1 0x4ba77c {
        m_animateFrames->removeAllObjects();
        m_unk040->removeAllObjects();
        m_animateDescriptions->removeAllObjects();
    }
    cocos2d::CCArray* spriteFrameByName(char const* name);

    cocos2d::CCDictionary* m_animateFrames;
    cocos2d::CCDictionary* m_unk040;
    cocos2d::CCDictionary* m_animateDescriptions;
}

[[link(android)]]
class CCBlockLayer : cocos2d::CCLayerColor {
    CCBlockLayer() = win 0x423f0 {
        m_closeOnHide = false;
        m_forcePrioRegistered = false;
    }
    ~CCBlockLayer() = win 0x424c0, imac 0x517410, m1 0x46dd6c;

    static CCBlockLayer* create() = win inline, imac 0x517790, m1 0x46e008, ios inline {
        auto ret = new CCBlockLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x42570, imac 0x517860, m1 0x46e0c0;
    virtual void draw() = win 0x42780, m1 0x46e340, imac 0x517b10;
    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline, m1 0x46e37c, imac 0x517b40 { return true; }
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline, m1 0x46e39c, imac 0x517ba0 {}
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline, m1 0x46e38c, imac 0x517b60 {}
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline, m1 0x46e394, imac 0x517b80 {}
    virtual void registerWithTouchDispatcher() = win 0x42660, m1 0x46e220, imac 0x5179d0;
    virtual void keyBackClicked() = win 0x426b0, imac 0x517a10, m1 0x46e258;
    virtual void customSetup() = win inline, imac 0x517970, m1 0x46e1dc {}
    virtual void enterLayer() = win 0x42630, m1 0x46e1e8, imac 0x5179a0;
    virtual void exitLayer() = win 0x426d0, imac 0x517a40, m1 0x46e274;
    virtual void showLayer(bool instant) = win 0x42710, imac 0x517a80, m1 0x46e2c0;
    virtual void hideLayer(bool instant) = win 0x42720, imac 0x517a90, m1 0x46e2cc;
    virtual void layerVisible() = win 0x42730, m1 0x46e2dc, imac 0x517ab0;
    virtual void layerHidden() = win 0x42740, m1 0x46e2ec, imac 0x517ad0;
    virtual void enterAnimFinished() = win inline, m1 0x46e2d8, imac 0x517aa0 {}
    virtual void disableUI() = win inline, imac 0x517980, m1 0x46e1e0 {}
    virtual void enableUI() = win inline, imac 0x517990, m1 0x46e1e4 {}

    void decrementForcePrio() = win inline {
        if (m_forcePrioRegistered) {
            m_forcePrioRegistered = false;
            cocos2d::CCDirector::sharedDirector()->getTouchDispatcher()->unregisterForcePrio(this);
        }
    }
    void incrementForcePrio() = win inline {
        if (!m_forcePrioRegistered) {
            m_forcePrioRegistered = true;
            cocos2d::CCDirector::sharedDirector()->getTouchDispatcher()->registerForcePrio(this, 2);
        }
    }

    bool m_closeOnHide;
    bool m_forcePrioRegistered;
}

[[link(android)]]
class CCCircleAlert : CCCircleWave {
    // virtual ~CCCircleAlert();

    static CCCircleAlert* create(float duration, float startRadius, float endRadius) = imac 0x178870, m1 0x13e9c4;

    bool init(float duration, float startRadius, float endRadius) = imac 0x178a20, m1 0x13eb80;
}

[[link(android)]]
class CCCircleWave : cocos2d::CCNode {
    // virtual ~CCCircleWave();
    // CCCircleWave() = win 0x418b0;

    static CCCircleWave* create(float startRadius, float endRadius, float duration, bool fadeIn) = win inline, imac 0x178030, m1 0x13e20c {
        return CCCircleWave::create(startRadius, endRadius, duration, fadeIn, true);
    }
    static CCCircleWave* create(float startRadius, float endRadius, float duration, bool fadeIn, bool easeOut) = win 0x42890, imac 0x178040, m1 0x13e214;

    virtual void setPosition(cocos2d::CCPoint const& position) = win 0x42b80, m1 0x13e4e8, imac 0x178390;
    virtual void removeMeAndCleanup() = win 0x42f90, imac 0x178840, m1 0x13e98c;
    virtual void draw() = win 0x42e60, m1 0x13e848, imac 0x178700;
    virtual void updateTweenAction(float value, char const* key) = win 0x42c00, imac 0x178490, m1 0x13e5f8;

    void baseSetup(float radius) = win inline, imac 0x178330, m1 0x13e4ac, ios inline {
        m_target = nullptr;
        m_radius = radius;
        m_opacity = 1.f;
        m_color.r = 255;
        m_color.g = 255;
        m_color.b = 255;
        m_circleMode = CircleMode::Filled;
        m_lineWidth = 2;
        m_opacityMod = 1.f;
        m_blendAdditive = true;
    }
    void followObject(cocos2d::CCNode* newTarget, bool staticPosition) = win inline, imac 0x178400, m1 0x13e568 {
        if (m_target) m_target->release();

        m_target = newTarget;
        newTarget->retain();

        this->unschedule(schedule_selector(CCCircleWave::updatePosition));
        if (!staticPosition) this->schedule(schedule_selector(CCCircleWave::updatePosition));

        this->setPosition(newTarget->getPosition());
    }
    bool init(float startRadius, float endRadius, float duration, bool fadeIn, bool easeOut) = win 0x42940, imac 0x178130, m1 0x13e2e8;
    void updatePosition(float dt) = win 0x42bc0, imac 0x1783c0, m1 0x13e51c;

    cocos2d::CCNode* m_target;
    float m_width;
    float m_radius;
    float m_opacity;
    cocos2d::ccColor3B m_color;
    cocos2d::CCPoint m_position;
    CircleMode m_circleMode;
    int m_lineWidth;
    float m_opacityMod;
    bool m_blendAdditive;
    CCCircleWaveDelegate* m_delegate;
}

[[link(android)]]
class CCCircleWaveDelegate {
    virtual void circleWaveWillBeRemoved(CCCircleWave* circleWave) {}
}

[[link(android)]]
class CCContentLayer : cocos2d::CCLayerColor {
    CCContentLayer() {}

    static CCContentLayer* create(cocos2d::ccColor4B const& color, float width, float height) = win inline, m1 0x6c799c {
        auto ret = new CCContentLayer();
        if (ret->initWithColor(color, width, height)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void setPosition(cocos2d::CCPoint const& position) = win 0x43000, m1 0x6c7a80, imac 0x7c24b0;
}

[[link(android)]]
class CCCountdown : cocos2d::CCSprite {
    // virtual ~CCCountdown();

    static CCCountdown* create() = m1 0x6caf84;

    virtual bool init() = imac 0x7c5f80, m1 0x6cb028;
    virtual void setOpacity(unsigned char opacity) = m1 0x6cb3dc, imac 0x7c6340;

    void lapFinished() = imac 0x7c6230, m1 0x6cb2b4;
    void startTimerWithSeconds(float seconds, cocos2d::SEL_CallFunc selector, cocos2d::CCNode* target) = imac 0x7c61b0, m1 0x6cb248;

    cocos2d::CCProgressTimer* m_progressTimer;
    float m_unk260;
    int m_seconds;
    cocos2d::CCLabelBMFont* m_countdownLabel;
    cocos2d::SEL_CallFunc m_callbackSelector;
    cocos2d::CCNode* m_targetNode;
}

[[link(android)]]
class CCCounterLabel : cocos2d::CCLabelBMFont {
    // virtual ~CCCounterLabel();
    CCCounterLabel() {
        m_stepSize = 0;
        m_targetCount = 0;
        m_currentCount = 0;
        m_counterEnabled = false;
        m_stepCount = 10;
        m_dontSchedule = false;
        m_formatterType = FormatterType::Integer;
    }

    static CCCounterLabel* create(int count, char const* font, FormatterType type) = win inline, imac 0x511030, m1 0x467c18 {
        auto ret = new CCCounterLabel();
        if (ret->init(count, font, type)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    void calculateStepSize(int steps) = win inline, imac 0x511360, m1 0x467f10, ios inline {
        auto diff = m_targetCount - m_currentCount;
        m_stepSize = diff / std::min<float>(std::abs(diff), steps);
    }
    void disableCounter() = win inline, ios inline {
        if (m_counterEnabled) {
            m_counterEnabled = false;
            if (!m_dontSchedule) {
                this->unscheduleAllSelectors();
            }
        }
    }
    void enableCounter() = win inline, imac 0x5111f0, ios inline {
        if (!m_counterEnabled) {
            m_counterEnabled = true;
            if (!m_dontSchedule) {
                this->schedule(schedule_selector(CCCounterLabel::updateCounter), 1.f / 30.f);
            }
        }
    }
    void fastUpdateCounter() = win inline, imac 0x5111d0, ios inline {
        m_currentCount = m_targetCount;
        this->updateString();
    }
    int getTargetCount() = win inline, imac 0x5113b0, m1 0x467f4c, ios inline {
        return m_targetCount;
    }
    bool init(int count, char const* font, FormatterType type) = win inline, imac 0x511150, m1 0x467d2c {
        if (!cocos2d::CCLabelBMFont::initWithString(" ", font)) return false;
        m_formatterType = type;
        m_targetCount = count;
        this->fastUpdateCounter();
        return true;
    }
    void setTargetCount(int count) = win 0x431c0, imac 0x5112e0;
    void updateCounter(float dt) = win 0x43250;
    void updateString() = win 0x432d0, imac 0x5113c0, m1 0x467f54;

    int m_stepSize;
    int m_targetCount;
    int m_currentCount;
    bool m_counterEnabled;
    int m_stepCount;
    bool m_dontSchedule;
    FormatterType m_formatterType;
}

[[link(android)]]
class CCExtenderNode : cocos2d::CCNode {
    void setOpacity(unsigned int opacity) = win inline, imac 0x50f490, ios inline {
        auto children = this->getChildren();
        for (int i = 0; i < children->count(); i++) {
            static_cast<cocos2d::CCNodeRGBA*>(children->objectAtIndex(i))->setOpacity(opacity);
        }
    }
}

[[link(android)]]
class CCIndexPath : cocos2d::CCObject {
    CCIndexPath() {
        m_row = 0;
        m_section = 0;
    }

    // virtual ~CCIndexPath();
    static CCIndexPath* CCIndexPathWithSectionRow(int section, int row) {
        auto ret = new CCIndexPath();
        ret->m_row = row;
        ret->m_section = section;
        ret->autorelease();
        return ret;
    }

    int m_row;
    int m_section;
}

[[link(android)]]
class CCLightFlash : cocos2d::CCNode {
    CCLightFlash() {
        m_lightStripArray = nullptr;
        m_layerColor = nullptr;
        m_dontFadeOut = false;
        m_mainLayer = nullptr;
        m_layerColorZOrder = 0;
    }
    ~CCLightFlash() = win inline, m1 0x45b950 {
        CC_SAFE_RELEASE(m_lightStripArray);
    }

    static CCLightFlash* create() = win inline, imac 0x503570, m1 0x45b188 {
        auto ret = new CCLightFlash();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        CC_SAFE_DELETE(ret);
        return nullptr;
    }

    virtual bool init() = win inline, imac 0x5035e0, m1 0x45b1ec {
        return true;
    }

    void cleanupFlash() = win 0x43d10, imac 0x503e50, m1 0x45b910;
    void fadeAndRemove() = win inline {
        for (int i = 0; i < m_lightStripArray->count(); i++) {
            auto strip = static_cast<CCLightStrip*>(m_lightStripArray->objectAtIndex(i));
            strip->runAction(cocos2d::CCSequence::create(
                cocos2d::CCDelayTime::create(((float)rand() / RAND_MAX) * .2f),
                cocos2d::CCActionTween::create((((float)rand() / RAND_MAX) * .2f - .1f) * .1f + .5f, "opacity", strip->m_opacity, 0.f),
                cocos2d::CCCallFunc::create(this, callfunc_selector(CCNode::removeMeAndCleanup)),
                nullptr
            ));
        }
    }
    // param names from https://github.com/gd-hyperdash/Cocos2Dx/blob/master/cocos2dx/extensions/RobTop/CCLightFlash.h and confirmed to be correct
    void playEffect(cocos2d::CCPoint pos, cocos2d::ccColor3B col, float startWidth, float startWidthVariation, float endWidth, float endWidthVariation, float endHeight, float stripDuration, float stripDurationVariance, float stripInterval, float stripStartDelay, float stripStartDelayVariation, float stripRotation, float stripRotationVariation, float stripOpacity, float stripOpacityVariation, int stripCount, bool circleRotation, bool fadeIn, float delay) = win 0x43430, imac 0x5035f0, m1 0x45b1f4;
    void removeLights() = win 0x43cb0, m1 0x45b8b4;
    void showFlash() = win 0x43970;

    cocos2d::CCArray* m_lightStripArray;
    cocos2d::CCLayerColor* m_layerColor;
    bool m_dontFadeOut;
    cocos2d::CCNode* m_mainLayer;
    int m_layerColorZOrder;
}

[[link(android)]]
class CCLightStrip : cocos2d::CCNode {
    CCLightStrip() {
        m_objectWidth = .0f;
        m_toWidth = .0f;
        m_toHeight = .0f;
        m_duration = .0f;
        m_opacity = .0f;
        m_width = .0f;
        m_height = .0f;
    }

    // virtual ~CCLightStrip();
    static CCLightStrip* create(float width, float toWidth, float toHeight, float duration, float delay) = win inline, imac 0x503a90, m1 0x45b584 {
        auto ret = new CCLightStrip();
        if (ret->init(width, toWidth, toHeight, duration, delay)) {
            ret->autorelease();
            return ret;
        }
        CC_SAFE_DELETE(ret);
        return nullptr;
    }

    virtual void draw() = win 0x43d40, imac 0x5040a0, m1 0x45bb20;
    virtual void updateTweenAction(float value, char const* keyword) = win 0x43f00, imac 0x504230, m1 0x45bc78;

    bool init(float width, float toWidth, float toHeight, float duration, float delay) = win inline, imac 0x503f60, m1 0x45ba08 {
        this->m_toWidth = toWidth;
        this->m_toHeight = toHeight;
        this->m_objectWidth = width;
        this->m_duration = duration;
        this->m_width = width;
        this->m_opacity = 255.f;
        this->m_height = 1.f;

        this->setVisible(false);

        auto* delayAction = cocos2d::CCDelayTime::create(delay);
        auto* heightActionTween = cocos2d::CCActionTween::create(this->m_duration, "height", this->m_height, this->m_toHeight);
        auto* widthActionTween = cocos2d::CCActionTween::create(this->m_duration, "width", this->m_width, this->m_toWidth);
        auto* heightEaseOutAction = cocos2d::CCEaseOut::create(heightActionTween, 2.f);
        auto* widthEaseOutAction = cocos2d::CCEaseOut::create(widthActionTween, 2.f);
        auto* spawnEaseOutActions = cocos2d::CCSpawn::create(heightEaseOutAction, widthEaseOutAction, nullptr);
        auto* lightStripSequence = cocos2d::CCSequence::create(delayAction, cocos2d::CCShow::create(), spawnEaseOutActions, nullptr);

        cocos2d::CCDirector::sharedDirector()->getActionManager()->addAction(lightStripSequence, this, false);

        return true;
    }

    float m_objectWidth;
    float m_toWidth;
    float m_toHeight;
    float m_duration;
    cocos2d::ccColor4B m_color;
    float m_opacity;
    float m_width;
    float m_height;
}

[[link(android)]]
class CCMenuItemSpriteExtra : cocos2d::CCMenuItemSprite {
    CCMenuItemSpriteExtra() = win 0x44a80 {
        m_animationEnabled = false; //this is changed to true in init
        m_colorEnabled = false;
        m_colorDip = 0.78431374f;
        m_scaleMultiplier = 1.f; //this is changed to 1.26f in init
        m_volume = 1.f;
        m_duration = 0.3f;
        m_unselectedDuration = 0.4f;
        m_animationType = MenuAnimationType::Scale;
        m_iconType = IconType::Cube;
        m_baseScale = 0.f; //this is changed to 1.f in init
    }

    static CCMenuItemSpriteExtra* create(cocos2d::CCNode* sprite, cocos2d::CCObject* target, cocos2d::SEL_MenuHandler callback) {
        return CCMenuItemSpriteExtra::create(sprite, nullptr, target, callback);
    }
    static CCMenuItemSpriteExtra* create(cocos2d::CCNode* sprite, cocos2d::CCNode* selectedSprite, cocos2d::CCObject* target, cocos2d::SEL_MenuHandler callback) = win 0x44bd0, imac 0x276720, m1 0x218bc4;

    virtual void activate() = win 0x44dd0, m1 0x218e08, imac 0x276930;
    virtual void selected() = win 0x44ee0, m1 0x218f5c, imac 0x276ab0;
    virtual void unselected() = win 0x45100, m1 0x2191a8, imac 0x276d30;

    bool init(cocos2d::CCNode* sprite, cocos2d::CCNode* selectedSprite, cocos2d::CCObject* target, cocos2d::SEL_MenuHandler callback) = win 0x44c70, imac 0x2767b0, m1 0x218c7c;
    void setSizeMult(float mult) = win inline, imac 0x276920, m1 0x218e00 {
        //inlined on windows, member is in CCMenuItemSprite
        m_fSizeMult = mult;
    }

    /// Set a new image for this button
    /// Prefer using this over `setNormalImage` as the latter does not actually
    /// handle any of the special sizing operations `CCMenuItemSpriteExtra` has
    /// @param sprite The sprite to replace this button's sprite with
    /// @note Geode addition
    void setSprite(cocos2d::CCSprite* sprite) {
        this->setNormalImage(sprite);
        this->updateSprite();
    }

    /// Update the sizing of this button's image
    /// If you for example have a `ButtonSprite` on this button and change the
    /// text, you need to call `updateSprite` afterwards to fix the button's
    /// content size
    /// @note Geode addition
    void updateSprite() {
        auto sprite = this->getNormalImage();
        auto size = sprite->getScaledContentSize();
        sprite->setPosition(size / 2);
        sprite->setAnchorPoint({ .5f, .5f });
        this->setContentSize(size);
    }
    void useAnimationType(MenuAnimationType type) = win inline, imac 0x2768e0, m1 0x218db8 {
        m_startPosition = this->getNormalImage()->getPosition();
        m_animationType = type;
    }

    float m_scaleMultiplier;
    float m_baseScale;
    bool m_animationEnabled;
    bool m_colorEnabled;
    float m_volume;
    gd::string m_activateSound;
    gd::string m_selectSound;
    float m_colorDip;
    cocos2d::CCPoint m_offset;
    float m_duration;
    float m_unselectedDuration;
    MenuAnimationType m_animationType;
    cocos2d::CCPoint m_startPosition;
    IconType m_iconType;
}

[[link(android)]]
class CCMenuItemToggler : cocos2d::CCMenuItem {
    CCMenuItemToggler() {
        m_offButton = nullptr;
        m_onButton = nullptr;
        m_toggled = false;
        m_notClickable = false;
    }

    // virtual ~CCMenuItemToggler();
    static CCMenuItemToggler* create(cocos2d::CCNode* off, cocos2d::CCNode* on, cocos2d::CCObject* target, cocos2d::SEL_MenuHandler callback) = win 0x45270, imac 0x597b0, m1 0x4cec0;
    static CCMenuItemToggler* createWithSize(const char* spr1, const char* spr2, cocos2d::CCObject* target, cocos2d::SEL_MenuHandler callback, float scale) {
        auto sprOff = cocos2d::CCSprite::createWithSpriteFrameName(spr1);
        auto sprOn = cocos2d::CCSprite::createWithSpriteFrameName(spr2);

        sprOff->setScale(scale);
        sprOn->setScale(scale);

        return create(sprOff, sprOn, target, callback);
    }
    static CCMenuItemToggler* createWithStandardSprites(cocos2d::CCObject* target, cocos2d::SEL_MenuHandler callback, float scale) {
        auto sprOff = cocos2d::CCSprite::createWithSpriteFrameName("GJ_checkOff_001.png");
        auto sprOn = cocos2d::CCSprite::createWithSpriteFrameName("GJ_checkOn_001.png");

        float maxWidth = std::max(sprOff->getContentSize().width, sprOn->getContentSize().width);
        float maxHeight = std::max(sprOff->getContentSize().height, sprOn->getContentSize().height);

        sprOff->setScale(scale);
        sprOn->setScale(scale);

        auto ret = create(sprOff, sprOn, target, callback);

        ret->setContentSize({maxWidth, maxHeight});

        ret->m_offButton->setContentSize({maxWidth, maxHeight});
        ret->m_onButton->setContentSize({maxWidth, maxHeight});

        ret->m_offButton->setPosition({maxWidth/2, maxHeight/2});
        ret->m_onButton->setPosition({maxWidth/2, maxHeight/2});

        sprOff->setPosition({maxWidth/2, maxHeight/2});
        sprOn->setPosition({maxWidth/2, maxHeight/2});

        return ret;
    }

    virtual void activate() = win 0x45520, m1 0x4d5e8, imac 0x59e90;
    virtual void selected() = win 0x454d0, m1 0x4d5a8, imac 0x59e60;
    virtual void unselected() = win 0x45570, m1 0x4d628, imac 0x59ec0;
    virtual void setEnabled(bool enabled) = win 0x455c0, m1 0x4d668, imac 0x59ef0;

    CCMenuItemSpriteExtra* activeItem() = win inline, imac 0x59e40 {
        return m_toggled ? m_onButton : m_offButton;
    }
    bool init(cocos2d::CCNode* off, cocos2d::CCNode* on, cocos2d::CCObject* target, cocos2d::SEL_MenuHandler callback) = win inline, m1 0x4cfa4, imac 0x59880 {
        if (!CCMenuItem::initWithTarget(target, callback)) return false;

        m_offButton = CCMenuItemSpriteExtra::create(off, nullptr, this, menu_selector(CCMenuItemToggler::normalTouch));
        m_onButton = CCMenuItemSpriteExtra::create(on, nullptr, this, menu_selector(CCMenuItemToggler::selectedTouch));

        this->addChild(m_offButton);
        this->addChild(m_onButton);

        m_offButton->getNormalImage()->setAnchorPoint({0.5f, 0.5f});
        m_onButton->getNormalImage()->setAnchorPoint({0.5f, 0.5f});

        auto imgoff = m_offButton->getNormalImage();
        auto imgon = m_onButton->getNormalImage();

        imgoff->setPosition(m_offButton->convertToNodeSpace({0.f, 0.f}));
        imgon->setPosition(m_onButton->convertToNodeSpace({0.f, 0.f}));
        m_notClickable = false;
        this->toggle(false);

        return true;
    }
    bool isOn() {
        return m_toggled;
    }
    bool isToggled() {
        return m_toggled;
    }
    void normalTouch(cocos2d::CCObject* sender) = win 0x45610;
    void selectedTouch(cocos2d::CCObject* sender) = win 0x45630;
    void setClickable(bool on) {
        m_notClickable = !on;
    }
    void setSizeMult(float mult) = win 0x454a0, m1 0x4d498;
    void toggle(bool on) = win 0x45650, imac 0x59c80, m1 0x4d3c0;
    void toggleWithCallback(bool on) {
        this->activate();
        this->toggle(on);
    }

    /// Update the sizing of this toggle's image
    /// If you for example have a `ButtonSprite` on this toggle and change the
    /// text, you need to call `updateSprite` afterwards to fix the toggle's
    /// content size
    /// @note Geode addition
    void updateSprite() {
        m_offButton->updateSprite();
        m_onButton->updateSprite();
        auto size = m_offButton->getScaledContentSize();
        m_offButton->setPosition(size / 2);
        m_offButton->setAnchorPoint({ .5f, .5f });
        m_onButton->setPosition(size / 2);
        m_onButton->setAnchorPoint({ .5f, .5f });
        this->setContentSize(size);
    }

    CCMenuItemSpriteExtra* m_offButton;
    CCMenuItemSpriteExtra* m_onButton;
    bool m_toggled;
    bool m_notClickable;
}

[[link(android)]]
class CCMoveCNode : cocos2d::CCObject {
    // virtual ~CCMoveCNode();
    CCMoveCNode() {
        m_unk038 = 0.0;
        m_unk040 = 0.0;
        m_unk048 = 0.0;
        m_unk058 = 0.0;
        m_unk060 = 0.0;
        m_unk068 = 0.0;
        m_unk070 = false;
        m_unk071 = false;
        m_unk074 = 0;
        m_unk078 = false;
        m_unk07c = 0;
        m_unk080 = 1.0;
        m_unk088 = 1.0;
        m_unk090 = 0.0;
        m_unk098 = 0.0;
        m_unk0a0 = 0.0;
        m_unk0a8 = 0.0;
        m_unk0b0 = 0.0;
        m_unk0b8 = 0;
        m_unk0c0 = 0.0;
        m_groupObject = nullptr;
        m_unk0d0 = false;
        m_unk0d1 = false;
    }

    static CCMoveCNode* create() = win inline, imac 0x2e4330, m1 0x27cf50 {
        auto ret = new CCMoveCNode();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init() = win inline, imac 0x2ef5e0, m1 0x285b30, ios inline { return true; }
    void reset() = win inline, imac 0x2ef5f0, m1 0x285b38, ios inline {
        m_unk038 = 0.0;
        m_unk040 = 0.0;
        m_unk048 = 0.0;
        m_unk058 = 0.0;
        m_unk060 = 0.0;
        m_unk068 = 0.0;
        m_unk070 = false;
        m_unk071 = false;
        m_unk074 = 0;
        m_unk078 = false;
        m_unk07c = 0;
        m_unk080 = 1.0;
        m_unk088 = 1.0;
        m_unk090 = 0.0;
        m_unk098 = 0.0;
        m_unk0a0 = 0.0;
        m_unk0a8 = 0.0;
        m_unk0b0 = 0.0;
        m_unk0b8 = 0;
        m_unk0c0 = 0.0;
        m_unk0d0 = false;
        m_groupObjects.clear();
        this->setTag(0);
        this->setObjType((cocos2d::CCObjectType)0);
    }

    double m_unk038;
    double m_unk040;
    double m_unk048;
    void* m_unk050;
    double m_unk058;
    double m_unk060;
    double m_unk068;
    bool m_unk070;
    bool m_unk071;
    int m_unk074;
    bool m_unk078;
    int m_unk07c;
    double m_unk080;
    double m_unk088;
    double m_unk090;
    double m_unk098;
    double m_unk0a0;
    double m_unk0a8;
    double m_unk0b0;
    int m_unk0b8;
    double m_unk0c0;
    GroupCommandObject2* m_groupObject;
    bool m_unk0d0;
    bool m_unk0d1;
    gd::vector<GroupCommandObject2*> m_groupObjects;
}

[[link(android)]]
class CCNodeContainer : cocos2d::CCNode {
    // virtual ~CCNodeContainer();

    static CCNodeContainer* create() = win 0x248ab0, m1 0xeea24;

    virtual bool init() = win 0x77e00, m1 0x132590, imac 0x164d20;
    virtual void visit() = win 0x248b80, imac 0x164d30, m1 0x132594;
}

[[link(android)]]
class CCPartAnimSprite : cocos2d::CCSprite {
    CCPartAnimSprite() {
        m_spritePartIDs = nullptr;
        m_spriteFrame = nullptr;
        m_hasChanged = false;
        m_spriteParts = nullptr;
    }
    ~CCPartAnimSprite() = win inline {
        CC_SAFE_RELEASE(m_spritePartIDs);
        CC_SAFE_RELEASE(m_spriteFrame);
        CC_SAFE_RELEASE(m_spriteParts);
    }

    static CCPartAnimSprite* createWithAnimDesc(char const* definition, cocos2d::CCTexture2D* texture, bool useTexture) = win inline, imac 0x3735d0, m1 0x2fd054 {
        auto ret = new CCPartAnimSprite();
        if (ret->initWithAnimDesc(definition, texture, useTexture)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void setScaleX(float scaleX) = win 0x46740, m1 0x2fe6c4, imac 0x374de0;
    virtual void setScaleY(float scaleY) = win 0x46760, m1 0x2fe6ec, imac 0x374e00;
    virtual void setScale(float scale) = win 0x46720, m1 0x2fe69c, imac 0x374dc0;
    virtual void setOpacity(unsigned char opacity) = win 0x46930, m1 0x2fe9b0, imac 0x375070;
    virtual void setBlendFunc(cocos2d::ccBlendFunc blendFunc) = win 0x46780, imac 0x374e20, m1 0x2fe714;
    virtual void setDisplayFrame(cocos2d::CCSpriteFrame* frame) = win 0x46150, imac 0x374990, m1 0x2fe274;
    virtual bool isFrameDisplayed(cocos2d::CCSpriteFrame* frame) = win 0x463c0, imac 0x374b00, m1 0x2fe3cc;
    virtual cocos2d::CCSpriteFrame* displayFrame() = win 0x463e0, imac 0x374b20, m1 0x2fe3e4;

    void changeTextureOfID(char const* key, char const* frame) = win inline, m1 0x2fdee0, ios inline {
        if (auto spritePart = static_cast<CCSpritePart*>(m_spritePartIDs->objectForKey(key))) {
            if (frame) spritePart->updateDisplayFrame(frame);
            else spritePart->resetTextureRect();
        }
    }
    int countParts() = win inline, imac 0x375200, m1 0x2feb64, ios inline {
        return this->getChildren()->count();
    }
    void dirtify() = win inline, imac 0x375220, m1 0x2feb80, ios inline {
        for (auto obj : geode::cocos::CCArrayExt<cocos2d::CCObject*, false>(this->getChildren())) {
            static_cast<cocos2d::CCSprite*>(obj)->setDirty(true);
        }
    }
    CCSpritePart* getSpriteForKey(char const* key) = win inline {
        return static_cast<CCSpritePart*>(m_spritePartIDs->objectForKey(key));
    }
    bool initWithAnimDesc(char const* definition, cocos2d::CCTexture2D* texture, bool useTexture) = win 0x459a0, m1 0x2fd140;
    void setColor(cocos2d::ccColor3B color) = win 0x46850, imac 0x374fa0, m1 0x2fe8c4;
    void setFlipX(bool flipX) = win inline, m1 0x2fe5f4 {
        auto currentFlipX = this->isFlipX();
        if (currentFlipX != flipX) this->setScaleX(currentFlipX ? 0.f : 1.f);
        CCSprite::setFlipX(flipX);
        m_hasChanged = true;
    }
    void setFlipY(bool flipY) = win inline, m1 0x2fe64c, ios inline {
        this->setScaleY(this->isFlipY() ? 0.f : 1.f);
        CCSprite::setFlipY(flipY);
        m_hasChanged = true;
    }
    void transformSprite(SpriteDescription* description) = win inline, imac 0x3741d0, m1 0x2fda9c {
        auto spritePart = static_cast<CCSpritePart*>(m_spriteParts->objectAtIndex(description->m_tag));
        spritePart->stopAllActions();
        spritePart->setPosition(description->m_position);
        auto scaleX = description->m_scale.x;
        if (description->m_flipped.x) scaleX = -scaleX;
        auto scaleY = description->m_scale.y;
        if (description->m_flipped.y) scaleY = -scaleY;
        spritePart->setScaleX(scaleX);
        spritePart->setScaleY(scaleY);
        spritePart->setRotation(description->m_rotation);
        if (description->m_usesCustomTag) {
            spritePart->setDisplayFrame(description->m_texture);
            spritePart->frameChanged(description->m_texture->getFrameName());
        }
    }
    void tweenSpriteTo(SpriteDescription* description, float duration) = win inline, imac 0x374480, m1 0x2fdd38 {
        auto spritePart = static_cast<CCSpritePart*>(m_spriteParts->objectAtIndex(description->m_tag));
        spritePart->stopAllActions();
        auto scaleX = description->m_scale.x;
        if (description->m_flipped.x) scaleX = -scaleX;
        auto scaleY = description->m_scale.y;
        if (description->m_flipped.y) scaleY = -scaleY;
        spritePart->runAction(cocos2d::CCMoveTo::create(duration, description->m_position));
        spritePart->runAction(cocos2d::CCScaleTo::create(duration, scaleX, scaleY));
        spritePart->runAction(cocos2d::CCRotateTo::create(duration, description->m_rotation));
        if (description->m_usesCustomTag) {
            spritePart->setDisplayFrame(description->m_texture);
            spritePart->frameChanged(description->m_texture->getFrameName());
        }
        auto zValue = description->m_zValue;
        if (spritePart->getZOrder() != zValue) {
            this->reorderChild(spritePart, zValue);
        }
    }
    void tweenToFrame(cocos2d::CCSpriteFrame* frame, float duration) = win 0x463f0, imac 0x24d3a0, m1 0x2fe3ec;

    cocos2d::CCDictionary* m_spritePartIDs;
    cocos2d::CCSpriteFrame* m_spriteFrame;
    bool m_hasChanged;
    cocos2d::CCSize m_unkSize;
    cocos2d::CCArray* m_spriteParts;
}

[[link(android), depends(CCContentLayer)]]
class CCScrollLayerExt : cocos2d::CCLayer {
    CCScrollLayerExt(cocos2d::CCRect rect) = win 0x46ae0, m1 0x3a0300, imac 0x42d900;
    ~CCScrollLayerExt() = win 0x47120, m1 0x3a0ad0, imac 0x42e0b0;

    virtual void visit() = win 0x47b60, m1 0x3a1558, imac 0x42ec90;
    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x47610, m1 0x3a0f5c, imac 0x42e630;
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x479e0, imac 0x42ea50, m1 0x3a1318;
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x47730, imac 0x42e750, m1 0x3a1074;
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x479b0, imac 0x42e9f0, m1 0x3a12b4;
    virtual void registerWithTouchDispatcher() = win 0x475c0, m1 0x3a0f24, imac 0x42e5f0;
    virtual void preVisitWithClippingRect(cocos2d::CCRect rect) = win 0x47c90, imac 0x42ed90, m1 0x3a1680;
    virtual void postVisit() = win 0x47d30, m1 0x3a1714, imac 0x42ee10;

    void constraintContent() = win 0x47190, imac 0x42e340, m1 0x3a0c98;
    void doConstraintContent(bool instant) = win 0x471a0, imac 0x42e350, m1 0x3a0ca0;
    float getMaxY() = win inline, imac 0x42df20, m1 0x3a0934 {
        return m_scrollLimitBottom;
    }
    float getMinY() = win inline, imac 0x42df30, m1 0x3a093c, ios inline {
        return this->getContentSize().height - m_contentLayer->getContentSize().height - m_scrollLimitTop;
    }
    void moveToTop() = win 0x47090, imac 0x42e020, m1 0x3a0a38;
    void moveToTopWithOffset(float offset) = win 0x46ff0, imac 0x42df80, m1 0x3a0990;
    void scrollingEnd() = win 0x47350, m1 0x3a0e30;
    void scrollLayer(float offset) = win inline, imac 0x4e570, m1 0x3a1490 {
        float y = m_contentLayer->getPositionY() + offset;
        float minY = getMinY();
        float maxY = getMaxY();
        m_contentLayer->setPositionY(y < minY ? minY : y > maxY ? maxY : y);
    }
    void setContentLayerSize(cocos2d::CCSize size) = win inline, imac 0x42e540, m1 0x3a0e78, ios inline {
        m_contentLayer->setContentSize(size);
    }
    void setContentOffset(cocos2d::CCPoint offset, bool animate) = win inline, imac 0x42e560, m1 0x3a0e88 {
        if (animate) {
            m_contentLayer->runAction(cocos2d::CCSequence::create(
                cocos2d::CCEaseOut::create(cocos2d::CCMoveTo::create(.3f, offset), 3.f),
                cocos2d::CCCallFunc::create(this, callfunc_selector(CCScrollLayerExt::constraintContent)),
                nullptr
            ));
        }
        else {
            m_contentLayer->setPosition(offset);
            this->constraintContent();
        }
    }
    void updateIndicators(float dt) = win 0x47390, imac 0x42dcc0, m1 0x3a06e8;

    cocos2d::CCTouch* m_touch;
    cocos2d::CCPoint m_touchPosition;
    cocos2d::CCPoint m_touchStartPosition;
    cocos2d::cc_timeval m_timeValue;
    bool m_touchDown;
    bool m_notAtEndOfScroll;
    cocos2d::CCLayerColor* m_verticalScrollbar;
    cocos2d::CCLayerColor* m_horizontalScrollbar;
    CCScrollLayerExtDelegate* m_delegate;
    CCContentLayer* m_contentLayer;
    bool m_cutContent;
    bool m_vScrollbarVisible;
    bool m_hScrollbarVisible;
    bool m_disableHorizontal;
    bool m_disableVertical;
    bool m_disableMovement;
    float m_scrollLimitTop;
    float m_scrollLimitBottom;
    float m_peekLimitTop;
    float m_peekLimitBottom;
}

[[link(android)]]
class CCScrollLayerExtDelegate {
    virtual void scrllViewWillBeginDecelerating(CCScrollLayerExt* layer) {}
    virtual void scrollViewDidEndDecelerating(CCScrollLayerExt* layer) {}
    virtual void scrollViewTouchMoving(CCScrollLayerExt* layer) {}
    virtual void scrollViewDidEndMoving(CCScrollLayerExt* layer) {}
    virtual void scrollViewTouchBegin(CCScrollLayerExt* layer) {}
    virtual void scrollViewTouchEnd(CCScrollLayerExt* layer) {}
}

[[link(android)]]
class CCSpriteCOpacity : cocos2d::CCSprite {
    // virtual ~CCSpriteCOpacity();
    CCSpriteCOpacity() {}

    static CCSpriteCOpacity* createWithSpriteFrame(cocos2d::CCSpriteFrame* frame) = win inline, m1 0x3e7d8c, ios inline {
        auto ret = new CCSpriteCOpacity();
        if (ret->initWithSpriteFrame(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static CCSpriteCOpacity* createWithSpriteFrameName(char const* frameName) = win inline, m1 0x3e7e2c, ios inline {
        return CCSpriteCOpacity::createWithSpriteFrame(cocos2d::CCSpriteFrameCache::sharedSpriteFrameCache()->spriteFrameByName(frameName));
    }

    virtual void setOpacity(unsigned char opacity) = win 0x48450, m1 0x3e7edc, imac 0x481e10;
}

[[link(android)]]
class CCSpriteGrayscale : CCSpriteWithHue {
    // virtual ~CCSpriteGrayscale();
    CCSpriteGrayscale() {}

    static CCSpriteGrayscale* create(gd::string const& file) = win inline, ios inline {
        auto ret = new CCSpriteGrayscale();
        if (ret->initWithFile(file.c_str())) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static CCSpriteGrayscale* create(gd::string const& file, cocos2d::CCRect const& rect) = win inline, ios inline {
        auto ret = new CCSpriteGrayscale();
        if (ret->initWithFile(file.c_str(), rect)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static CCSpriteGrayscale* createWithSpriteFrame(cocos2d::CCSpriteFrame* frame) = win inline {
        auto ret = new CCSpriteGrayscale();
        if (ret->initWithSpriteFrame(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static CCSpriteGrayscale* createWithSpriteFrameName(gd::string const& frameName) = m1 0x51a680, win 0x490b0;
    static CCSpriteGrayscale* createWithTexture(cocos2d::CCTexture2D* texture) = win inline, ios inline {
        auto ret = new CCSpriteGrayscale();
        if (ret->initWithTexture(texture)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static CCSpriteGrayscale* createWithTexture(cocos2d::CCTexture2D* texture, cocos2d::CCRect const& rect, bool rotated) = win inline, ios inline {
        auto ret = new CCSpriteGrayscale();
        if (ret->initWithTexture(texture, rect, rotated)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual gd::string getShaderName() = win 0x49050, imac 0x5f0720, m1 0x51a1a8;
    virtual const char* shaderBody() = win 0x48e90, imac 0x5f04f0, m1 0x51a068;
}

[[link(android)]]
class CCSpritePart : CCSpritePlus {
    // virtual ~CCSpritePart();
    CCSpritePart() = win 0x458b0 {
        m_isBeingUsed = false;
        m_delegate = nullptr;
    }

    static CCSpritePart* create(cocos2d::CCTexture2D* texture) = win inline, m1 0x2fd9e8 {
        auto ret = new CCSpritePart();
        if (ret->initWithTexture(texture)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static CCSpritePart* createWithSpriteFrameName(char const* frame) = win inline, m1 0x2fd888 {
        auto ret = new CCSpritePart();
        if (ret->initWithSpriteFrameName(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void setVisible(bool visible) = win 0x46ac0, m1 0x2fed84, imac 0x375460;

    void frameChanged(gd::string frame) = win 0x46a10, imac 0x374350, m1 0x2fdc20;
    bool getBeingUsed() = win inline, ios inline {
        return m_isBeingUsed;
    }
    void hideInactive() = win inline, imac 0x374ae0, ios inline {
        if (!m_isBeingUsed) this->setVisible(false);
    }
    void markAsNotBeingUsed() = win inline, imac 0x374ad0, ios inline {
        m_isBeingUsed = false;
    }
    void resetTextureRect() = win inline, imac 0x3747e0, m1 0x2fe098, ios inline {
        this->setTextureRect({ 0.f, 0.f, 0.f, 0.f });
    }
    void setBeingUsed(bool beingUsed) = win inline, imac 0x374470, m1 0x2fdd30, ios inline {
        m_isBeingUsed = beingUsed;
    }
    void updateDisplayFrame(gd::string frame) = win inline, imac 0x374800, m1 0x2fe0ac, ios inline {
        this->frameChanged(frame);
        this->setDisplayFrame(cocos2d::CCSpriteFrameCache::sharedSpriteFrameCache()->spriteFrameByName(frame.c_str()));
    }

    bool m_isBeingUsed;
    gd::string m_spriteFrameName;
    SpritePartDelegate* m_delegate;
}

[[link(android)]]
class CCSpritePlus : cocos2d::CCSprite {
    // virtual ~CCSpritePlus();
    CCSpritePlus() = win 0x45730 {
        m_followers = nullptr;
        m_followingSprite = nullptr;
        m_hasFollower = false;
        m_propagateScaleChanges = false;
        m_propagateFlipChanges = false;
    }
    ~CCSpritePlus() = win 0x47d50, m1 0x3e74d8;

    /// Creates a sprite by a given sprite frame
    /// @param frame the frame to give to the specific sprite
    /// @return CCSpritePlus object and returns null if initialization fails
    static CCSpritePlus* createWithSpriteFrame(cocos2d::CCSpriteFrame* frame) = win inline, m1 0x3e75c0 {
        auto ret = new CCSpritePlus();
        if (ret->initWithSpriteFrame(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    /// Creates a sprite by a given sprite's frame name
    /// @param frame the frame or filename to give to the specific sprite
    /// @return CCSpritePlus object and returns null if initialization fails
    static CCSpritePlus* createWithSpriteFrameName(char const* frame) = win 0x47da0, m1 0x3e7670;

    /// Sets X's scale on itself and it's followers
    /// @param scaleX the scale of X to set
    virtual void setScaleX(float scaleX) = win 0x48260, m1 0x3e7aa0, imac 0x481a00;

    /// Sets Y's scale on itself and it's followers
    /// @param scaleY the scale of Y to set
    virtual void setScaleY(float scaleY) = win 0x482e0, m1 0x3e7b24, imac 0x481a80;

    /// Sets the Scale of itself and it's followers
    /// @param scale the scale value to set
    virtual void setScale(float scale) = win 0x48370, m1 0x3e7ba8, imac 0x481b00;

    /// Sets the position where the sprite will be at and it's followers
    /// @param position the position to place to the sprite and it's followers
    virtual void setPosition(cocos2d::CCPoint const& position) = win 0x47e60, m1 0x3e7750, imac 0x481660;

    /// Sets the sprite's given rotation and it's followers
    /// @param rotation the rotation value to set
    virtual void setRotation(float rotation) = win 0x47ef0, m1 0x3e77c8, imac 0x4816e0;

    /// Sets the sprite's given rotation of X and it's followers
    /// @param rotationX the rotation of X to set.
    virtual void setRotationX(float rotationX) = win 0x47f80, m1 0x3e7840, imac 0x481760;

    /// Sets the sprite's given rotation of Y and it's followers
    /// @param rotationY the rotation of Y to set
    virtual void setRotationY(float rotationY) = win 0x48010, m1 0x3e78b8, imac 0x4817e0;

    /// Initalizes the sprite using a texture
    /// @param texture the texture to initalize the sprite with
    /// @return true if initalization succeeded.
    virtual bool initWithTexture(cocos2d::CCTexture2D* texture) = win 0x47e40, imac 0x481640, m1 0x3e773c;

    /// Initalizes the sprite with a frame name
    /// @param frameName the frame to initalize the sprite with
    /// @return true if initalization succeeded
    virtual bool initWithSpriteFrameName(char const* frameName) = win 0x47e30, imac 0x481620, m1 0x3e7730;

    /// Sets flipX to itself and it's followers
    /// @param flipX the direction that the sprite should be flipped to
    virtual void setFlipX(bool flipX) = win 0x480a0, m1 0x3e7930, imac 0x481860;

    /// Sets flipY to itself and it's followers
    /// @param flipY the direction that the sprite should be flipped to
    virtual void setFlipY(bool flipY) = win 0x48180, m1 0x3e79e8, imac 0x481930;

    /// Adds a follower to the sprite
    /// @param follower Something that will follow this sprite
    void addFollower(cocos2d::CCNode* follower) = win inline {
        m_hasFollower = true;
        if (!m_followers) {
            m_followers = cocos2d::CCArray::create();
            m_followers->retain();
        }
        m_followers->addObject(follower);
    }

    /// Attaches a sprite to the sprite. and other way around
    /// you can think of this as attaching 2 lego blocks together and letting
    /// it drag along.
    /// @param sprite the sprite to attach to the main sprite and vice versa
    void followSprite(CCSpritePlus* sprite) = win inline, imac 0x481c20, m1 0x3e7cc4 {
        m_followingSprite = sprite;
        sprite->addFollower(this);
    }

    /// Obtains the first following sprite if it has a follower on hand
    /// @return nullptr if there is no follower avalible
    CCSpritePlus* getFollower() = win inline {
        return m_hasFollower ? static_cast<CCSpritePlus*>(m_followers->objectAtIndex(0)) : nullptr;
    }

    /// Removes a specific following sprite from this sprite.
    /// @param sprite follower sprite that will be removed.
    void removeFollower(cocos2d::CCNode* sprite) = win 0x48400, imac 0x481bd0, m1 0x3e7c7c;

    /// Stops this child sprite from following it's given parent
    void stopFollow() = win inline, imac 0x481c70, m1 0x3e7d1c {
        if (m_followingSprite) m_followingSprite->removeFollower(this);
    }

    cocos2d::CCArray* m_followers;
    CCSpritePlus* m_followingSprite;
    bool m_hasFollower;
    bool m_propagateScaleChanges;
    bool m_propagateFlipChanges;
}

[[link(android)]]
class CCSpriteWithHue : cocos2d::CCSprite {
    // virtual ~CCSpriteWithHue();
    CCSpriteWithHue() {}

    static CCSpriteWithHue* create(gd::string const& file) = win inline, ios inline {
        auto ret = new CCSpriteWithHue();
        if (ret->initWithFile(file.c_str())) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static CCSpriteWithHue* create(gd::string const& file, cocos2d::CCRect const& rect) = win inline, ios inline {
        auto ret = new CCSpriteWithHue();
        if (ret->initWithFile(file.c_str(), rect)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static CCSpriteWithHue* createWithSpriteFrame(cocos2d::CCSpriteFrame* frame) = win inline {
        auto ret = new CCSpriteWithHue();
        if (ret->initWithSpriteFrame(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static CCSpriteWithHue* createWithSpriteFrameName(gd::string const& frameName) = win inline, m1 0x5195f4 {
        return CCSpriteWithHue::createWithSpriteFrame(cocos2d::CCSpriteFrameCache::sharedSpriteFrameCache()->spriteFrameByName(frameName.c_str()));
    }
    static CCSpriteWithHue* createWithTexture(cocos2d::CCTexture2D* texture) = win inline, ios inline {
        auto ret = new CCSpriteWithHue();
        if (ret->initWithTexture(texture)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static CCSpriteWithHue* createWithTexture(cocos2d::CCTexture2D* texture, cocos2d::CCRect const& rect, bool rotated) = win inline, ios inline {
        auto ret = new CCSpriteWithHue();
        if (ret->initWithTexture(texture, rect, rotated)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void draw() = win 0x48cb0, m1 0x519ee8, imac 0x5f0340;
    virtual bool initWithTexture(cocos2d::CCTexture2D* texture) = win 0x48680, m1 0x51989c, imac 0x5efc00;
    virtual bool initWithTexture(cocos2d::CCTexture2D* texture, cocos2d::CCRect const& rect) = win 0x486e0, imac 0x5efc70, m1 0x519918;
    virtual bool initWithTexture(cocos2d::CCTexture2D* texture, cocos2d::CCRect const& rect, bool rotated) = win 0x48620, m1 0x519628, imac 0x5ef9c0;
    virtual bool initWithSpriteFrame(cocos2d::CCSpriteFrame* frame) = win 0x486f0, m1 0x519928, imac 0x5efc90;
    virtual gd::string getShaderName() = win 0x48490, imac 0x5ef510, m1 0x519114;
    virtual const char* shaderBody() = win 0x48990, imac 0x5efdd0, m1 0x519a6c;
    virtual void updateColor() = win 0x489a0, m1 0x519a84, imac 0x5efdf0;

    float getAlpha() = win inline, imac 0x5f0270, m1 0x519e48, ios inline {
        return _displayedOpacity / 255.f;
    }
    float getHue() = win inline, m1 0x519e60, ios inline {
        return m_hue;
    }
    void getUniformLocations() = win inline, imac 0x5efd60, m1 0x5199e8 {
        m_uHueLoc = glGetUniformLocation(m_pShaderProgram->getProgram(), "u_hue");
        m_uAlphaLoc = glGetUniformLocation(m_pShaderProgram->getProgram(), "u_alpha");
        m_uLumLoc = glGetUniformLocation(m_pShaderProgram->getProgram(), "u_lum");
    }
    void initShader() = win 0x48760, m1 0x519680;
    void setCustomLuminance(float r, float g, float b) = win inline, imac 0x5f0320, ios inline {
        m_luminance[0] = r;
        m_luminance[1] = g;
        m_luminance[2] = b;
    }
    void setEvenLuminance(float luminance) = win inline, imac 0x5f02f0, m1 0x519eb8 {
        m_luminance[0] = luminance * 0.33f;
        m_luminance[1] = luminance * 0.33f;
        m_luminance[2] = luminance * 0.33f;
    }
    void setHue(float hue) = win inline, imac 0x5efd10, m1 0x5199b8, ios inline {
        m_hue = hue;
        this->updateColorMatrix();
    }
    void setHueDegrees(float degrees) = win inline, m1 0x519e68 {
        auto deg = degrees;
        while (deg < 0.f) deg += 360.f;
        this->setHue(deg / 360.f * 6.28318548f);
    }
    void setLuminance(float luminance) = win inline, imac 0x5efd30, m1 0x5199c0 {
        m_luminance[0] = luminance * 0.21f;
        m_luminance[1] = luminance * 0.72f;
        m_luminance[2] = luminance * 0.07f;
    }
    void setupDefaultSettings() = win inline, imac 0x5efa00, m1 0x51966c, ios inline {
        m_hue = 0.f;
        this->setLuminance(1.f);
    }
    void updateColorMatrix() = win 0x489c0, m1 0x519aa8;
    void updateHue(float unused) = win inline, imac 0x5efce0, m1 0x51998c, ios inline {
        this->setHue(m_hue + 0.05235988f);
    }

    float m_hue;
    std::array<float, 3> m_luminance;
    std::array<std::array<float, 3>, 3> m_colorMatrix;
    int m_uHueLoc;
    int m_uAlphaLoc;
    int m_uLumLoc;
}

[[link(android)]]
class CCTextInputNode : cocos2d::CCLayer, cocos2d::CCIMEDelegate, cocos2d::CCTextFieldDelegate {
    CCTextInputNode() {
        m_numberInput = false;
        m_unknown1 = 0;
        m_selected = false;
        m_unknown2 = false;
        m_fontValue1 = -0.5f;
        m_fontValue2 = 8.0f;
        m_isChatFont = false;
        m_maxLabelWidth = 0.0f;
        m_maxLabelScale = 0.0f;
        m_placeholderScale = 0.0f;
        m_cursor = nullptr;
        m_textField = nullptr;
        m_delegate = nullptr;
        m_maxLabelLength = 0;
        m_textLabel = nullptr;
        m_filterSwearWords = false;
        m_usePasswordChar = false;
        m_forceOffset = false;
        m_textArea = nullptr;
        m_valueType = (InputValueType)0;
        m_kerningAmount = 0;
    }
    ~CCTextInputNode() = win inline, m1 0x8e6d0, imac 0x9ddd0 {
        if (m_selected) CCTextInputNode::onClickTrackNode(false);
    }

    static CCTextInputNode* create(float width, float height, char const* placeholder, char const* fontPath) {
        return CCTextInputNode::create(width, height, placeholder, 0x18, fontPath);
    }
    static CCTextInputNode* create(float width, float height, char const* placeholder, int fontSize, char const* fontPath) {
        return CCTextInputNode::create(width, height, placeholder, "Thonburi", fontSize, fontPath);
    }
    static CCTextInputNode* create(float width, float height, char const* placeholder, char const* textFont, int fontSize, char const* labelFont) = win 0x4f180, imac 0x9df80, m1 0x8e7e8;

    virtual void visit() = win 0x4f7c0, m1 0x8f1b0, imac 0x9ea00;
    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x51350, m1 0x91188, imac 0xa0de0;
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline, m1 0x91368, imac 0xa1000 {}
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline, imac 0xa0fc0, m1 0x91358 {}
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline, imac 0xa0fe0, m1 0x91360 {}
    virtual void registerWithTouchDispatcher() = win 0x51560, m1 0x91370, imac 0xa1020;
    virtual void textChanged() = win 0x504a0, imac 0x9f580, m1 0x8fc40;
    virtual void onClickTrackNode(bool selected) = win 0x50480, imac 0x9f560, m1 0x8fc20;
    virtual void keyboardWillShow(cocos2d::CCIMEKeyboardNotificationInfo& info) = win 0x502a0, m1 0x8f9d4, imac 0x9f300;
    virtual void keyboardWillHide(cocos2d::CCIMEKeyboardNotificationInfo& info) = win 0x50400, m1 0x8faf8, imac 0x9f450;
    virtual bool onTextFieldInsertText(cocos2d::CCTextFieldTTF* pSender, char const* text, int nLen, cocos2d::enumKeyCodes keyCodes) = win 0x50530, m1 0x8fd4c, imac 0x9f6a0;
    virtual bool onTextFieldAttachWithIME(cocos2d::CCTextFieldTTF* tField) = win 0x50910, imac 0x9fce0, m1 0x902a4;
    virtual bool onTextFieldDetachWithIME(cocos2d::CCTextFieldTTF* tField) = win 0x50c40, m1 0x905ac, imac 0xa0010;

    void addTextArea(TextArea* textArea) = win 0x4f5d0, imac 0x9e4b0, m1 0x8ec90;
    void forceOffset() = win inline, imac 0xa07a0, m1 0x90c5c {}
    gd::string getString() = win inline, imac 0x9eb20, m1 0x8f2dc {
        return m_textField->getString();
    }
    cocos2d::CCLabelBMFont* getTextLabel() {
        return m_textLabel;
    }
    bool init(float width, float height, char const* placeholder, char const* textFont, int fontSize, char const* labelFont) = win 0x4f390, m1 0x8e948, imac 0x9e140;
    void refreshLabel() = win 0x4fbd0, imac 0x9ebd0, m1 0x8f38c;
    void setAllowedChars(gd::string filter) = win inline, imac 0x9e9e0, m1 0x8f1a8 {
        m_allowedChars = filter;
    }
    void setDelegate(TextInputDelegate* delegate) {
        m_delegate = delegate;
    }
    void setLabelNormalColor(cocos2d::ccColor3B color) = win inline, m1 0x8f5cc, imac 0x9ee90, ios inline {
        m_textColor = color;
        this->refreshLabel();
    }
    void setLabelPlaceholderColor(cocos2d::ccColor3B color) = win inline, m1 0x8f5bc, imac 0x9ee70 {
        m_placeholderColor = color;
        this->refreshLabel();
    }
    void setLabelPlaceholderScale(float v) = win inline, m1 0x8f5b4, imac 0x9ee50 {
        m_placeholderScale = v;
        this->refreshLabel();
    }
    void setMaxLabelLength(int v) {
        m_maxLabelLength = v;
        this->refreshLabel();
    }
    void setMaxLabelScale(float v) = win inline, m1 0x8f5a4, imac 0x9ee10 {
        m_maxLabelScale = v;
        this->refreshLabel();
    }
    void setMaxLabelWidth(float v) = win inline, m1 0x8f5ac, imac 0x9ee30 {
        m_maxLabelWidth = v;
        this->refreshLabel();
    }
    void setString(gd::string text) = win 0x4f830, imac 0x9ea60, m1 0x8f20c;
    void updateBlinkLabel() = win inline, imac 0x9edf0, m1 0x8f598, ios inline {
        this->updateBlinkLabelToChar(this->m_textField->m_uCursorPos);
    }
    void updateBlinkLabelToChar(int index) = win 0x4feb0, imac 0x9eeb0, m1 0x8f5e0;
    void updateCursorPosition(cocos2d::CCPoint position, cocos2d::CCRect rect) = win 0x50df0, m1 0x90c60, imac 0xa07b0;
    void updateDefaultFontValues(gd::string font) = win 0x4f6c0, imac 0x9e410, m1 0x8ebe8;
    void updateLabel(gd::string text) = win 0x4f8d0, imac 0x9e6c0, m1 0x8eeb8;

    bool m_numberInput;
    gd::string m_caption;
    int m_unknown1;
    bool m_selected;
    bool m_unknown2;
    float m_fontValue1;
    float m_fontValue2;
    bool m_isChatFont;
    gd::string m_allowedChars;
    float m_maxLabelWidth;
    float m_maxLabelScale;
    float m_placeholderScale;
    cocos2d::ccColor3B m_placeholderColor;
    cocos2d::ccColor3B m_textColor;
    cocos2d::CCLabelBMFont* m_cursor;
    cocos2d::CCTextFieldTTF* m_textField;
    TextInputDelegate* m_delegate;
    int m_maxLabelLength;
    cocos2d::CCLabelBMFont* m_textLabel;
    bool m_filterSwearWords;
    bool m_usePasswordChar;
    bool m_forceOffset;
    TextArea* m_textArea;
    InputValueType m_valueType;
    int m_decimalPlaces;
    int m_kerningAmount;
}

[[link(android)]]
class CCURLObject : cocos2d::CCObject {
    // virtual ~CCURLObject();

    static CCURLObject* create(gd::string name, gd::string url) = win 0x17b300, imac 0x376440, m1 0x2ffad8;

    bool init(gd::string name, gd::string url) = win inline, imac 0x3765b0, m1 0x2ffc54, ios inline {
        m_name = name;
        m_url = url;
        return true;
    }

    gd::string m_name;
    gd::string m_url;
}

[[link(android), depends(ChallengesPage), depends(GJChallengeItem)]]
class ChallengeNode : cocos2d::CCNode {
    ChallengeNode() {
        m_challengeItem = nullptr;
        m_countdownLabel = nullptr;
        m_unloaded = false;
    }
    ~ChallengeNode() = win inline {
        CC_SAFE_RELEASE(m_challengeItem);
    }

    static ChallengeNode* create(GJChallengeItem* challengeItem, ChallengesPage* challengesPage, bool isNew) = win inline, imac 0x39df90, m1 0x3232bc {
        auto ret = new ChallengeNode();
        if (ret->init(challengeItem, challengesPage, isNew)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init(GJChallengeItem* challengeItem, ChallengesPage* challengesPage, bool isNew) = win 0x86d50;
    void onClaimReward(cocos2d::CCObject* sender) = win 0x87da0, m1 0x324500;
    void updateTimeLabel(gd::string text) = win inline, imac 0x39e060, m1 0x323390, ios inline {
        if (m_countdownLabel) m_countdownLabel->setString(text.c_str());
    }

    ChallengesPage* m_challengesPage;
    GJChallengeItem* m_challengeItem;
    cocos2d::CCPoint m_unkPoint;
    cocos2d::CCLabelBMFont* m_countdownLabel;
    bool m_unloaded;
}

[[link(android)]]
class ChallengesPage : FLAlertLayer, FLAlertLayerProtocol, GJChallengeDelegate, CurrencyRewardDelegate {
    ChallengesPage() {
        m_dots = nullptr;
        m_countdownLabel = nullptr;
        m_circle = nullptr;
        m_triedToLoad = false;
        m_unkBool = false;
        m_currencyRewardLayer = nullptr;
        m_challengeNodes = nullptr;
    }
    ~ChallengesPage() = win inline, m1 0x321d84 {
        auto glm = GameLevelManager::sharedState();
        if (glm->m_GJChallengeDelegate == this) glm->m_GJChallengeDelegate = nullptr;
        if (m_currencyRewardLayer) m_currencyRewardLayer->m_delegate = nullptr;
        CC_SAFE_RELEASE(m_challengeNodes);
        CC_SAFE_RELEASE(m_dots);
    }

    static ChallengesPage* create() = win inline, m1 0x321e74 {
        auto ret = new ChallengesPage();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x85370, m1 0x321f90, imac 0x39cc30;
    virtual void registerWithTouchDispatcher() = win 0x42660, m1 0x3235ec, imac 0x39e2d0;
    virtual void keyBackClicked() = win 0x869f0, m1 0x323550, imac 0x39e240;
    virtual void show() = win 0x86810, m1 0x3233c0, imac 0x39e0a0;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win inline, m1 0x323548, imac 0x39e220 {}
    virtual void challengeStatusFinished() = win 0x85e20, m1 0x322e74, imac 0x39dba0;
    virtual void challengeStatusFailed() = win 0x85fb0, m1 0x323138, imac 0x39dea0;
    virtual void currencyWillExit(CurrencyRewardLayer* layer) = win 0x86d30, m1 0x323754, imac 0x39e430;

    void claimItem(ChallengeNode* node, GJChallengeItem* item, cocos2d::CCPoint position) = win 0x86a40, imac 0x39e310, m1 0x323624;
    ChallengeNode* createChallengeNode(int number, bool skipAnimation, float animLength, bool isNew) = win 0x86100, imac 0x39d8e0, m1 0x322bf0;
    void exitNodeAtSlot(int position, float delay) = win 0x86430, imac 0x39dda0, m1 0x323050;
    void onClose(cocos2d::CCObject* sender) = win 0x869b0, m1 0x322964;
    void tryGetChallenges() = win 0x86080;
    void updateDots() = win 0x85d80, m1 0x322dcc;
    callback void updateTimers(float dt) = win 0x86520, m1 0x3229b0;

    cocos2d::CCArray* m_dots;
    cocos2d::CCLabelBMFont* m_countdownLabel;
    LoadingCircle* m_circle;
    bool m_triedToLoad;
    bool m_unkBool;
    CurrencyRewardLayer* m_currencyRewardLayer;
    cocos2d::CCDictionary* m_challengeNodes;
}

[[link(android), depends(ChanceObject)]]
class ChanceTriggerGameObject : EffectGameObject {
    // virtual ~ChanceTriggerGameObject();
    ChanceTriggerGameObject() {}

    void editChanceObject(int oldID, int newID) = win inline {
        for (auto& obj : m_chanceObjects) {
            if (obj.m_groupID == oldID) obj.m_groupID = newID;
        }
    }
    bool init(char const* frame) = win inline, m1 0x17a378, ios inline {
        return EffectGameObject::init(frame);
    }
    void remapChanceObjects(gd::unordered_map<int, int> const* remap) = win 0x4b3d60, m1 0x17a3c0;
    void revertChanceRemap() = win inline, m1 0x17a4c0 {
        for (auto& obj : m_chanceObjects) {
            obj.m_groupID = obj.m_oldGroupID;
        }
    }

    // property 435
    gd::vector<ChanceObject> m_chanceObjects;
}

[[link(android)]]
class CharacterColorDelegate {
    virtual void playerColorChanged() {}
    virtual void showUnlockPopup(int id, UnlockType type) {}
}

[[link(android)]]
class CharacterColorPage : FLAlertLayer {
    CharacterColorPage() {
        m_colorMode = 0;
        m_playerObjects = nullptr;
        m_modeButtons = nullptr;
        m_colorButtons = nullptr;
        m_cursors = nullptr;
        m_delegate = nullptr;
        m_glowToggler = nullptr;
        m_glowLabel = nullptr;
    }
    ~CharacterColorPage() = win inline, m1 0x57c19c {
        CC_SAFE_RELEASE(m_playerObjects);
        CC_SAFE_RELEASE(m_modeButtons);
        CC_SAFE_RELEASE(m_colorButtons);
        CC_SAFE_RELEASE(m_cursors);
    }

    static CharacterColorPage* create() = win inline, m1 0x57c264 {
        auto ret = new CharacterColorPage();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x87fa0, m1 0x57c36c, imac 0x65c600;
    virtual void registerWithTouchDispatcher() = win 0x42660, m1 0x57e220, imac 0x65e4d0;
    virtual void keyBackClicked() = win 0x8a810, imac 0x65e430, m1 0x57e174;
    virtual void show() = win 0x86810, m1 0x57dfe8, imac 0x65e2a0;

    int activeColorForMode(int mode) = win 0x894b0, imac 0x559870, m1 0x57df10;
    bool checkColor(int id, UnlockType type) = win inline {
        auto result = GameManager::sharedState()->isColorUnlocked(id, type);
        if (!result && m_delegate) {
            m_delegate->showUnlockPopup(id, type);
        }
        return result;
    }
    int colorForIndex(int index) = win 0x8a0c0, m1 0x57dc60;
    void createColorMenu() = win 0x88ec0, m1 0xf5750;
    void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win inline, imac 0x65e420, m1 0x57e170, ios inline {}
    cocos2d::CCPoint offsetForIndex(int index) = win inline, imac 0x65e180, m1 0x57debc {
        float x;
        float y;
        if (index > 53 && index < 136) y = -.8f;
        else if (index > 135) y = .4f;
        else y = 0.f;
        switch (index) {
            case 4: case 5: case 6: case 7: case 13: case 14: case 15: case 16: case 22: case 23:
            case 24: case 25: case 31: case 32: case 33: case 34: case 40: case 41: case 42: case 43:
            case 49: case 50: case 51: case 52: case 58: case 59: case 60: case 61: case 67: case 68:
            case 69: case 70: case 76: case 77: case 78: case 79: case 85: case 86: case 87: case 88:
            case 94: case 95: case 96: case 97: case 103: case 104: case 105: case 106: case 112: case 113:
            case 114: case 115: case 136: case 137: case 138: case 139: case 140: case 141: case 142:
                x = 1.f;
                break;
            default:
                x = 0.f;
                break;
        }
        return { x, y };
    }
    void onClose(cocos2d::CCObject* sender) = win 0x8a7d0, imac 0x65d1c0, m1 0x57cf28;
    void onMode(cocos2d::CCObject* sender) = win 0x895c0, imac 0x65d2c0, m1 0x2966c;
    void onPlayerColor(cocos2d::CCObject* sender) = win 0x89dd0, imac 0x65df30, m1 0x57dc80;
    void toggleGlow(cocos2d::CCObject* sender) = m1 0x57d748, win 0x88e10;
    void toggleGlowItems(bool visible) = win inline, imac 0x65dec0, m1 0x57dc0c, ios inline {
        m_glowToggler->setEnabled(visible);
        m_glowToggler->setVisible(visible);
        m_glowLabel->setVisible(visible);
    }
    void toggleShip(cocos2d::CCObject* sender) = win 0x88cf0, imac 0x65d210, m1 0x57cf7c;
    void updateColorMode(int mode) = win 0x89860, imac 0x65da00, m1 0x57d780;
    void updateIconColors() = win 0x8a5b0, m1 0x57d230;

    int m_colorMode;
    float m_height;
    float m_width;
    cocos2d::CCArray* m_playerObjects;
    cocos2d::CCArray* m_modeButtons;
    cocos2d::CCDictionary* m_colorButtons;
    cocos2d::CCArray* m_cursors;
    CharacterColorDelegate* m_delegate;
    CCMenuItemToggler* m_glowToggler;
    cocos2d::CCLabelBMFont* m_glowLabel;
}

[[link(android)]]
class CheckpointGameObject : EffectGameObject {
    // virtual ~CheckpointGameObject();
    CheckpointGameObject() {
        m_checkpointActivated = false;
        m_respawnID = 0;
    }

    static CheckpointGameObject* create() = win inline {
        auto ret = new CheckpointGameObject();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x4b9a20, m1 0x189388, imac 0x1d4b20;
    virtual void setupCustomSprites(gd::string frameName) = win 0x4b9e60, m1 0x1897c0, imac 0x1d4f40;
    virtual void resetObject() = win 0x4bac50, m1 0x18ab08, imac 0x1d6580;
    virtual void triggerObject(GJBaseGameLayer* layer, int uniqueID, gd::vector<int> const* remapKeys) = win 0x4b9aa0, imac 0x1d4b80, m1 0x1893e4;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4bab20, m1 0x18a9d0, imac 0x1d6440;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x4ba850, m1 0x18a0bc, imac 0x1d58f0;
    virtual void triggerActivated(float xPosition) = win 0x4b9ac0, imac 0x1d4ba0, m1 0x1893fc;
    virtual void restoreObject() = win 0x4bae60, imac 0x1d65f0, m1 0x18ab60;
    virtual void updateSyncedAnimation(float totalTime, int frameIndex) = win 0x4ba500, imac 0x1d5500, m1 0x189d34;

    void resetCheckpoint() = win 0x4bacd0, ios inline {
        m_checkpointActivated = false;
        this->updateCheckpointSpriteVisibility();
    }
    void updateCheckpointSpriteVisibility() = win inline, imac 0x1d4dc0, m1 0x18962c {
        this->getChildByTag(1125)->setVisible(!m_checkpointActivated);
        this->getChildByTag(1126)->setVisible(!m_checkpointActivated);
        this->getChildByTag(1127)->setVisible(!m_checkpointActivated);
        this->getChildByTag(1128)->setVisible(m_checkpointActivated);
        m_colorSprite->getChildByTag(1125)->setVisible(!m_checkpointActivated);
        m_colorSprite->getChildByTag(1126)->setVisible(!m_checkpointActivated);
        m_colorSprite->getChildByTag(1127)->setVisible(!m_checkpointActivated);
        m_colorSprite->getChildByTag(1128)->setVisible(m_checkpointActivated);
        if (m_checkpointActivated) this->setObjectColor({ 255, 255, 255 });
        m_isColorSpriteBlack = m_checkpointActivated;
    }

    bool m_checkpointActivated;
    // property 448
    int m_respawnID;
}

[[link(android), depends(GJGameState), depends(GJShaderState), depends(FMODAudioState), depends(EffectManagerState), depends(SavedObjectStateRef), depends(SavedActiveObjectState), depends(SavedSpecialObjectState), depends(SequenceTriggerState)]]
class CheckpointObject : cocos2d::CCNode {
    CheckpointObject() = win 0x3a4e70;
    ~CheckpointObject() = win inline, imac 0xbf7c0 {
        CC_SAFE_RELEASE(m_physicalCheckpointObject);
        CC_SAFE_RELEASE(m_player1Checkpoint);
        CC_SAFE_RELEASE(m_player2Checkpoint);
        CC_SAFE_RELEASE(m_gradientTriggerObjectArray);
    }

    static CheckpointObject* create() = win inline, m1 0xa8c34 {
        auto ret = new CheckpointObject();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x77e00, m1 0xac4bc, imac 0xbfae0;

    GameObject* getObject() = win inline {
        return m_physicalCheckpointObject;
    }
    void setObject(GameObject* object) = win inline, m1 0xa9898 {
        if (m_physicalCheckpointObject != object) {
            CC_SAFE_RETAIN(object);
            CC_SAFE_RELEASE(m_physicalCheckpointObject);
            m_physicalCheckpointObject = object;
        }
    }

    GJGameState m_gameState;
    GJShaderState m_shaderState;
    FMODAudioState m_audioState;
    GameObject* m_physicalCheckpointObject;
    PlayerCheckpoint* m_player1Checkpoint;
    PlayerCheckpoint* m_player2Checkpoint;
    int m_unke78;
    int m_unke7c;
    float m_unke80;
    bool m_ground2Invisible;
    bool m_streakBlend;
    int m_uniqueID;
    int m_respawnID;
    gd::vector<SavedObjectStateRef> m_vectorSavedObjectStateRef;
    gd::vector<SavedActiveObjectState> m_vectorActiveSaveObjectState;
    gd::vector<SavedSpecialObjectState> m_vectorSpecialSaveObjectState;
    EffectManagerState m_effectManagerState;
    cocos2d::CCArray* m_gradientTriggerObjectArray;
    bool m_unk11e8;
    gd::unordered_map<int,SequenceTriggerState> m_sequenceTriggerStateUnorderedMap;
    int m_commandIndex;
}

[[link(android)]]
class CollisionBlockPopup : FLAlertLayer, TextInputDelegate {
    // virtual ~CollisionBlockPopup();

    static CollisionBlockPopup* create(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x8a940, imac 0x285790, m1 0x227008;

    virtual void keyBackClicked() = win 0x8bc00, m1 0x228550, imac 0x286e50;
    virtual void show() = win 0x8bb10, m1 0x228504, imac 0x286df0;
    virtual void textInputClosed(CCTextInputNode* node) = win 0x8b870, m1 0x2283a8, imac 0x286c40;
    virtual void textChanged(CCTextInputNode* node) = win 0x8b880, m1 0x2283c4, imac 0x286c80;
    virtual void textInputShouldOffset(CCTextInputNode* node, float yOffset) = win 0x7b620, m1 0x22855c, imac 0x286e80;
    virtual void textInputReturn(CCTextInputNode* node) = win 0x7b680, m1 0x22862c, imac 0x286f40;

    CCMenuItemToggler* createToggleButton(gd::string label, cocos2d::SEL_MenuHandler selector, bool toggled, cocos2d::CCMenu* menu, cocos2d::CCPoint position) = win inline, m1 0x2280b4, ios inline {
        auto onSprite = cocos2d::CCSprite::createWithSpriteFrameName("GJ_checkOn_001.png");
        auto offSprite = cocos2d::CCSprite::createWithSpriteFrameName("GJ_checkOff_001.png");
        onSprite->setScale(.8f);
        offSprite->setScale(.8f);
        auto toggler = CCMenuItemToggler::create(offSprite, onSprite, this, selector);
        toggler->toggle(toggled);
        menu->addChild(toggler);
        toggler->setPosition(menu->convertToNodeSpace(position));
        toggler->setSizeMult(1.5f);
        auto labelNode = cocos2d::CCLabelBMFont::create(label.c_str(), "bigFont.fnt");
        this->addChild(labelNode);
        labelNode->setAnchorPoint({ .0f, .5f });
        labelNode->setPosition(position + cocos2d::CCPoint { onSprite->getContentSize().width * .5f + 4.8f, 0.f });
        labelNode->limitLabelWidth(110.f, .35f, .0f);
        return toggler;
    }
    void determineStartValues() = win inline, imac 0x2862d0, m1 0x227ac0 {
        if (m_gameObject) {
            m_blockID = m_gameObject->m_itemID;
            m_dynamicBlock = m_gameObject->m_isDynamicBlock;
        }
        else if (m_gameObjects && m_gameObjects->count() != 0) {
            m_blockID = -1;
            m_dynamicBlock = true;
            for (int i = 0; i < m_gameObjects->count(); i++) {
                auto obj = static_cast<EffectGameObject*>(m_gameObjects->objectAtIndex(i));
                if (!obj->m_isDynamicBlock) m_dynamicBlock = false;
                if (m_blockID == -1) m_blockID = obj->m_itemID;
                else if (m_blockID != obj->m_itemID) m_blockID = 0;
            }
        }
    }
    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x8aa60, m1 0x227130, imac 0x2858f0;
    void onClose(cocos2d::CCObject* sender) = win 0x8bb60, imac 0x2863a0, m1 0x227b78;
    void onDynamicBlock(cocos2d::CCObject* sender) = imac 0x286860;
    void onItemIDArrow(cocos2d::CCObject* sender) = win 0x8b670, imac 0x286620, m1 0x227db0;
    void onNextItemID(cocos2d::CCObject* sender);
    void updateEditorLabel() = m1 0x2282b0;
    void updateItemID() = m1 0x228328;
    void updateTextInputLabel() = m1 0x227ec8, imac 0x286750;

    EffectGameObject* m_gameObject;
    cocos2d::CCArray* m_gameObjects;
    CCTextInputNode* m_blockIDInput;
    int m_blockID;
    bool m_dynamicBlock;
    bool m_disableDelegate;
}

[[link(android)]]
class CollisionTriggerAction {
    bool m_disabled;
    int m_blockAID;
    int m_blockBID;
    int m_targetGroupID;
    int m_triggerOnExit;
    bool m_activateGroup;
    int m_triggerUniqueID;
    int m_controlID;
    gd::vector<int> m_remapKeys;
}

[[link(android)]]
class ColorAction : cocos2d::CCObject {
    // virtual ~ColorAction();
    ColorAction() {
        m_stepFinished = false;
        m_paused = false;
        m_currentOpacity = 1.f;
        m_deltaTime = 0.f;
        m_duration = 0.f;
        m_blending = false;
        m_playerColor = 0;
        m_colorID = 0;
        m_fromOpacity = 1.f;
        m_toOpacity = 1.f;
        m_copyHSV = { 0.f, 1.f, 1.f, false, false };
        m_copyID = 0;
        m_copyColorCalculated = false;
        m_copyOpacity = false;
        m_copyColorLoop = false;
        m_uniqueID = 0;
        m_controlID = 0;
        m_legacyHSV = false;
        m_colorSprite = nullptr;
        m_inheritanceNode = nullptr;
        m_actionDelay = 0.f;
        m_stepInterval = 0.f;
    }

    static ColorAction* create() = win 0x258cb0, imac 0x2d9060, m1 0x273684;
    static ColorAction* create(cocos2d::ccColor3B color, bool blending, int playerColor) = win inline, imac 0x2d9260, m1 0x273834, ios inline {
        return ColorAction::create(color, color, 0.f, 0.0, blending, playerColor, 1.f, 1.f);
    }
    static ColorAction* create(cocos2d::ccColor3B fromColor, cocos2d::ccColor3B toColor, float duration, double unused, bool blending) = win inline, imac 0x2d9350, m1 0x2738fc, ios inline {
        return ColorAction::create(fromColor, toColor, duration, unused, blending, -1, 1.f, 1.f);
    }
    static ColorAction* create(cocos2d::ccColor3B fromColor, cocos2d::ccColor3B toColor, float duration, double unused, bool blending, int playerColor, float fromOpacity, float toOpacity) = win inline, imac 0x2d9140, m1 0x273744 {
        auto ret = new ColorAction();
        if (ret->init(fromColor, toColor, duration, unused, blending, playerColor, fromOpacity, toOpacity)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    ColorAction* getCopy() = win inline, imac 0x2dbc90, m1 0x276414, ios inline {
        return ColorAction::create(m_fromColor, m_toColor, m_duration, 0.0, m_blending, m_playerColor, m_fromOpacity, m_toOpacity);
    }
    bool init(cocos2d::ccColor3B fromColor, cocos2d::ccColor3B toColor, float duration, double unused, bool blending, int playerColor, float fromOpacity, float toOpacity) = win inline, imac 0x2d9450, m1 0x2739dc, ios inline {
        m_fromColor = fromColor;
        m_toColor = toColor;
        m_duration = duration;
        m_blending = blending;
        m_playerColor = playerColor;
        m_colorID = 0;
        m_fromOpacity = fromOpacity;
        m_toOpacity = toOpacity;
        return true;
    }
    bool isInUse() = win inline, m1 0x273b18 {
        return m_fromColor.r != 255 || m_fromColor.g != 255 || m_fromColor.b != 255 || m_fromOpacity != 1.f || m_copyID != 0 || m_blending || m_playerColor > 0;
    }
    void loadFromState(CAState& state) = win inline, imac 0x2d96d0, m1 0x273c3c {
        m_fromColor = state.m_fromColor;
        m_toColor = state.m_toColor;
        m_color = state.m_color;
        m_paused = state.m_paused;
        m_blending = state.m_blending;
        m_copyOpacity = state.m_copyOpacity;
        m_legacyHSV = state.m_legacyHSV;
        m_playerColor = state.m_playerColor;
        m_colorID = state.m_colorID;
        m_copyID = state.m_copyID;
        m_uniqueID = state.m_uniqueID;
        m_duration = state.m_duration;
        m_fromOpacity = state.m_fromOpacity;
        m_toOpacity = state.m_toOpacity;
        m_deltaTime = state.m_deltaTime;
        m_currentOpacity = state.m_currentOpacity;
        m_copyHSV = state.m_copyHSV;
    }
    void resetAction() = win inline, imac 0x2d95a0, m1 0x273b0c {
        m_stepFinished = false;
        m_paused = false;
        m_deltaTime = 0.f;
    }
    void saveToState(CAState& state) = win inline, imac 0x2d9630, m1 0x273bb0 {
        state.m_fromColor = m_fromColor;
        state.m_toColor = m_toColor;
        state.m_color = m_color;
        state.m_paused = m_paused;
        state.m_blending = m_blending;
        state.m_copyOpacity = m_copyOpacity;
        state.m_legacyHSV = m_legacyHSV;
        state.m_playerColor = m_playerColor;
        state.m_colorID = m_colorID;
        state.m_copyID = m_copyID;
        state.m_uniqueID = m_uniqueID;
        state.m_duration = m_duration;
        state.m_fromOpacity = m_fromOpacity;
        state.m_toOpacity = m_toOpacity;
        state.m_deltaTime = m_deltaTime;
        state.m_currentOpacity = m_currentOpacity;
        state.m_copyHSV = m_copyHSV;
    }
    void setupFromMap(gd::map<gd::string, gd::string>& setup) = win 0x259970, imac 0x2db5a0, m1 0x275a9c;
    void setupFromString(gd::string setup) = win 0x259890, imac 0x2db530, m1 0x275a20;
    void step(float dt) = win 0x258da0;
    void updateCustomColor(cocos2d::ccColor3B color1, cocos2d::ccColor3B color2) = win inline, imac 0x2d9610, m1 0x273b88, ios inline {
        if (m_playerColor == 1) m_fromColor = color1;
        else if (m_playerColor == 2) m_fromColor = color2;
    }

    // void writeSaveString(fmt::BasicWriter<char>& writer) = win 0x251dd0, m1 0x269514, imac 0x2c5730, ios 0x111e0;
    bool m_stepFinished;
    bool m_paused;
    cocos2d::ccColor3B m_color;
    float m_currentOpacity;
    float m_deltaTime;
    cocos2d::ccColor3B m_fromColor;
    cocos2d::ccColor3B m_toColor;
    float m_duration;
    bool m_blending;
    int m_playerColor;
    int m_colorID;
    float m_fromOpacity;
    float m_toOpacity;
    cocos2d::ccHSVValue m_copyHSV;
    int m_copyID;
    bool m_copyColorCalculated;
    bool m_copyOpacity;
    bool m_copyColorLoop;
    int m_uniqueID;
    int m_controlID;
    bool m_legacyHSV;
    ColorActionSprite* m_colorSprite;
    InheritanceNode* m_inheritanceNode;
    float m_actionDelay;
    float m_stepInterval;
}

[[link(android)]]
class ColorAction2 {
    ColorAction2(cocos2d::ccColor3B fromColor, cocos2d::ccColor3B toColor, float duration, double unused, bool blending, int playerColor, float fromOpacity, float toOpacity) = imac 0x4ed060, m1 0x447340;

    void resetAction() = imac 0x4ed260, m1 0x4474f8;
    void step(float dt);
    void updateCustomColor(cocos2d::ccColor3B color1, cocos2d::ccColor3B color2) = imac 0x4ed280, m1 0x447504;

    bool m_stepFinished;
    bool m_paused;
    cocos2d::ccColor3B m_color;
    float m_currentOpacity;
    float m_deltaTime;
    cocos2d::ccColor3B m_fromColor;
    cocos2d::ccColor3B m_toColor;
    float m_duration;
    bool m_blending;
    int m_playerColor;
    int m_colorID;
    float m_fromOpacity;
    float m_toOpacity;
    cocos2d::ccHSVValue m_copyHSV;
    int m_copyID;
    bool m_copyColorCalculated;
    bool m_copyOpacity;
    bool m_copyColorLoop;
    int m_uniqueID;
    bool m_legacyHSV;
    ColorActionSprite* m_colorSprite;
    float m_actionDelay;
    float m_stepInterval;
}

[[link(android)]]
class ColorActionSprite : cocos2d::CCNode {
    // virtual ~ColorActionSprite();
    ColorActionSprite() {
        m_opacity = 255.f;
        m_colorID = 0;
        m_colorAction = nullptr;
    }

    static ColorActionSprite* create() = win inline, m1 0x273424 {
        auto ret = new ColorActionSprite();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x258c40, m1 0x2734d0, imac 0x2d8e60;

    float m_opacity;
    cocos2d::ccColor3B m_color;
    cocos2d::ccColor3B m_copyColor;
    int m_colorID;
    cocos2d::ccColor3B m_pulseColor;
    ColorAction* m_colorAction;
}

[[link(android)]]
class ColorChannelSprite : cocos2d::CCSprite {
    // virtual ~ColorChannelSprite();

    static ColorChannelSprite* create() = win 0x258740, m1 0x272d8c, imac 0x2d8700;

    virtual bool init() = win 0x258800, imac 0x2d87a0, m1 0x272e34;

    void updateBlending(bool enabled) = win 0x258b30;
    void updateCopyLabel(int channelID, bool copyColorLoop) = win 0x258820, imac 0x2d87c0, m1 0x37d60;
    void updateOpacity(float alpha) = win 0x2589e0, imac 0x2d8980, m1 0x272fe8;
    void updateValues(ColorAction* action) = win inline, imac 0x2d8be0, m1 0x27323c {
        if (!action) {
            this->setColor(cocos2d::ccWHITE);
            this->updateCopyLabel(0, false);
            this->updateOpacity(1.f);
            this->updateBlending(false);
            return;
        }
        this->updateCopyLabel(action->m_copyID, action->m_copyColorLoop);
        this->updateOpacity(action->m_fromOpacity);
        this->updateBlending(action->m_blending);
        if (action->m_copyID != 0 && !action->m_copyOpacity) {
            this->setColor(cocos2d::ccGRAY);
        }
        else {
            this->setColor(action->m_fromColor);
        }
    }

    cocos2d::CCLabelBMFont* m_copyLabel;
    cocos2d::CCLabelBMFont* m_opacityLabel;
    cocos2d::CCLabelBMFont* m_blendingLabel;
}

[[link(android)]]
class ColorSelectDelegate {
    virtual void colorSelectClosed(cocos2d::CCNode* popup) {}
}

[[link(android)]]
class ColorSelectLiveOverlay : FLAlertLayer {
    // virtual ~ColorSelectLiveOverlay();

    static ColorSelectLiveOverlay* create(ColorAction* baseAction, ColorAction* detailAction, EffectGameObject* object) = win 0x8bd30, imac 0x5681d0, m1 0x4b6a88;
    static ColorSelectLiveOverlay* createWithActions(ColorAction* baseAction, ColorAction* detailAction) = win inline, imac 0x568390 {
        return ColorSelectLiveOverlay::create(baseAction, detailAction, nullptr);
    }
    static ColorSelectLiveOverlay* createWithObject(EffectGameObject* object) = win inline, imac 0x5681b0, m1 0x4b6a78 {
        return ColorSelectLiveOverlay::create(nullptr, nullptr, object);
    }

    virtual void keyBackClicked() = win 0x8d290, m1 0x4b83d0, imac 0x569ea0;
    virtual void show() = win 0x8bb10, m1 0x4b8488, imac 0x569f50;

    void closeColorSelect(cocos2d::CCObject* sender) = imac 0x569600, m1 0x4b7bc8;
    void colorValueChanged(cocos2d::ccColor3B color) = win inline, imac 0x569e90, m1 0x4b83cc, ios inline {}
    CCMenuItemToggler* createToggleButton(gd::string label, cocos2d::SEL_MenuHandler selector, bool toggled, cocos2d::CCMenu* menu, cocos2d::CCPoint position) = win inline, m1 0x4b8134, ios inline {
        auto onSprite = cocos2d::CCSprite::createWithSpriteFrameName("GJ_checkOn_001.png");
        auto offSprite = cocos2d::CCSprite::createWithSpriteFrameName("GJ_checkOff_001.png");
        onSprite->setScale(.7f);
        offSprite->setScale(.7f);
        auto toggler = CCMenuItemToggler::create(offSprite, onSprite, this, selector);
        toggler->toggle(toggled);
        menu->addChild(toggler);
        toggler->setPosition(menu->convertToNodeSpace(position));
        toggler->setSizeMult(1.5f);
        auto labelNode = cocos2d::CCLabelBMFont::create(label.c_str(), "bigFont.fnt");
        this->addChild(labelNode);
        labelNode->setAnchorPoint({ .0f, .5f });
        labelNode->setPosition(position + cocos2d::CCPoint { onSprite->getContentSize().width * .5f + 4.2f, 0.f });
        labelNode->limitLabelWidth(110.f, .35f, .0f);
        return toggler;
    }
    void determineStartValues() = win inline, imac 0x569200, m1 0x4b790c {
        if (m_effectGameObject) {
            m_targetColor = m_effectGameObject->m_triggerTargetColor;
            m_mainColor = m_targetColor;
            m_opacity = m_effectGameObject->m_opacity;
        }
        else {
            m_targetColor = m_baseColorAction->m_fromColor;
            m_mainColor = m_targetColor;
            m_opacity = m_baseColorAction->m_fromOpacity;
            if (m_detailColorAction) m_detailColor = m_detailColorAction->m_fromColor;
        }
    }
    cocos2d::ccColor3B getColorValue() = win inline, imac 0x569fb0, m1 0x4b84d4, ios inline {
        return { 255, 255, 255 };
    }
    bool init(ColorAction* baseAction, ColorAction* detailAction, EffectGameObject* object) = win 0x8be80, imac 0x5683a0;
    void onSelectTab(cocos2d::CCObject* sender) = win 0x8d150, imac 0x5698e0, m1 0x4b7dec;
    void selectColor(cocos2d::ccColor3B color) = win 0x8d2e0, m1 0x4b7c28;
    void sliderChanged(cocos2d::CCObject* sender) = win 0x8ce10;
    void textChanged(CCTextInputNode* node) = win inline, imac 0x569fc0, m1 0x4b84dc, ios inline {}
    void textInputClosed(CCTextInputNode* node) = win inline, imac 0x569fd0, m1 0x4b84e0, ios inline {}
    void toggleControls(bool visible) = win 0x8d720, m1 0x4b84e4;
    void updateColorLabel() = win 0x8d560, imac 0x569a10, m1 0x4b7f38;
    void updateColorValue() = win inline, ios inline {
        if (m_updateColor) return;
        if (m_effectGameObject) {
            m_effectGameObject->m_triggerTargetColor = m_targetColor;
        }
        else {
            if (m_detailColorSelected) m_detailColorAction->m_fromColor = m_targetColor;
            else m_baseColorAction->m_fromColor = m_targetColor;
        }
    }
    void updateOpacity() = win inline, ios inline {
        if (m_updateColor) return;
        if (m_effectGameObject) {
            m_effectGameObject->m_opacity = m_opacity;
        }
        else {
            if (m_detailColorSelected) m_detailColorAction->m_fromOpacity = m_opacity;
            else m_baseColorAction->m_fromOpacity = m_opacity;
        }
    }

    EffectGameObject* m_effectGameObject;
    cocos2d::CCArray* m_barSprites;
    cocos2d::CCArray* m_12buttons;
    ColorAction* m_baseColorAction;
    ColorAction* m_detailColorAction;
    cocos2d::ccColor3B m_mainColor;
    cocos2d::ccColor3B m_detailColor;
    cocos2d::ccColor3B m_targetColor;
    float m_unk2ac;
    int m_unk2b0;
    int m_unk2b4;
    float m_opacity;
    ColorSelectDelegate* m_delegate;
    bool m_disableTextDelegate;
    bool m_unk2c9;
    bool m_updateColor;
    Slider* m_hueSlider;
    Slider* m_saturationSlider;
    Slider* m_valueSlider;
    Slider* m_opacitySlider;
    cocos2d::CCSprite* m_colorSprite;
    cocos2d::CCSprite* m_oldColorSprite;
    cocos2d::CCSprite* m_saturationSprite;
    cocos2d::CCSprite* m_valueSprite;
    cocos2d::CCSprite* m_opacitySprite;
    double m_hue;
    double m_saturation;
    double m_value;
    cocos2d::CCLabelBMFont* m_colorLabel;
    bool m_detailColorSelected;
    bool m_closeButtonPressed;
}

[[link(android)]]
class ColorSelectPopup : SetupTriggerPopup, cocos2d::extension::ColorPickerDelegate, GJSpecialColorSelectDelegate {
    ColorSelectPopup() {
        m_colorPicker = nullptr;
        m_unk3c0 = false;
        m_opacityLabel = nullptr;
        m_fadeTimeSlider = nullptr;
        m_opacitySlider = nullptr;
        m_currentColorSprite = nullptr;
        m_originalColorSprite = nullptr;
        m_delegate = nullptr;
        m_fadeTime = 0.f;
        m_playerColor = 0;
        m_blending = 0;
        m_opacity = 1.f;
        m_colorAction = nullptr;
        m_colorInput = nullptr;
        m_backgroundTrigger = false;
        m_tintGround = false;
        m_legacyHSV = false;
        m_colorTrigger = false;
        m_noChannel = false;
        m_newColorTrigger = false;
        m_colorID = 0;
        m_initializing = false;
        m_copyColorID = 0;
        m_copyOpacity = false;
        m_hsv = { 0.f, 1.f, 1.f, false, false };
        m_fadeTimeInput = nullptr;
        m_showCopyObjects = false;
    }
    ~ColorSelectPopup() = win inline, m1 0x636c6c {
        CC_SAFE_RELEASE(m_colorAction);
        CC_SAFE_RELEASE(m_colorObjects);
        CC_SAFE_RELEASE(m_copyObjects);
    }

    static gd::string colorToHex(cocos2d::ccColor3B color) = win 0x927b0, imac 0x729390, m1 0x63b284;
    static ColorSelectPopup* create(ColorAction* action) = win inline, imac 0x724890, m1 0x636f50 {
        return ColorSelectPopup::create(nullptr, nullptr, action);
    }
    static ColorSelectPopup* create(cocos2d::ccColor3B color) = win inline, m1 0x636f60 {
        auto action = ColorAction::create();
        action->m_color = color;
        return ColorSelectPopup::create(action);
    }
    static ColorSelectPopup* create(EffectGameObject* effect, cocos2d::CCArray* array) = win inline, imac 0x7245a0, m1 0x636d50 {
        return ColorSelectPopup::create(effect, array, nullptr);
    }
    static ColorSelectPopup* create(EffectGameObject* effect, cocos2d::CCArray* array, ColorAction* action) = win 0x8db10, imac 0x7245b0, m1 0x636d58;
    static cocos2d::ccColor3B hexToColor(gd::string hex) = win 0x91b40, m1 0x63b6dc;

    virtual void show() = win 0x92c80, m1 0x63c808, imac 0x72a7b0;
    virtual void determineStartValues() = win 0x90470, m1 0x63a6ac, imac 0x728500;
    virtual void textChanged(CCTextInputNode* node) = win 0x92db0, m1 0x63c8d4, imac 0x72a8a0;
    virtual void colorValueChanged(cocos2d::ccColor3B color) = win 0x91830, imac 0x728d70, m1 0x63ad64;
    virtual void colorSelectClosed(GJSpecialColorSelect* select, int id) = win 0x93770, m1 0x63cdb8, imac 0x72ae40;
    virtual void keyBackClicked() = win 0x91820, m1 0x63ad58, imac 0x728d40;

    void closeColorSelect(cocos2d::CCObject* sender) = win 0x91580, imac 0x726fd0, m1 0x639370;
    cocos2d::ccColor3B getColorValue() = win inline, imac 0x728b10, m1 0x63abc0, ios inline {
        return m_colorPicker->getColorValue();
    }
    bool init(EffectGameObject* object, cocos2d::CCArray* objects, ColorAction* action) = win 0x8dd00, imac 0x7248e0, m1 0x636f9c;
    void onCopy(cocos2d::CCObject* sender) = win 0x90e40, m1 0x6398cc;
    void onCopyOpacity(cocos2d::CCObject* sender) = win 0x90be0, imac 0x727d20;
    void onDefault(cocos2d::CCObject* sender) = win 0x90f40, m1 0x63994c;
    void onHSVLegacyMode(cocos2d::CCObject* sender);
    void onPaste(cocos2d::CCObject* sender) = win 0x90ec0, m1 0x639900;
    void onPlayerColor1(cocos2d::CCObject* sender) = m1 0x639c64;
    void onPlayerColor2(cocos2d::CCObject* sender) = m1 0x639d18;
    void onSelectSpecialColor(cocos2d::CCObject* sender) = imac 0x727e50, m1 0x63a034;
    void onTintGround(cocos2d::CCObject* sender);
    void onToggleHSVMode(cocos2d::CCObject* sender) = win 0x935e0, imac 0x727ce0, m1 0x639ef0;
    void onToggleTintMode(cocos2d::CCObject* sender) = win 0x90a90, imac 0x727c30, m1 0x639e48;
    void onUpdateCopyColor(cocos2d::CCObject* sender) = win 0x93500, imac 0x727ea0, m1 0x63a098;
    void onUpdateCustomColor(cocos2d::CCObject* sender) = win 0x92d30, imac 0x728170, m1 0x63a33c;
    void selectColor(cocos2d::ccColor3B color) = win inline, imac 0x727550, m1 0x639830, ios inline {
        m_colorPicker->setColorValue(color);
    }
    void sliderChanged(cocos2d::CCObject* sender) = m1 0x639508;
    void updateColorLabels();
    void updateColorValue() = win inline {
        if (m_colorAction) {
            m_colorAction->m_fromColor = m_currentColor;
        }
        else if (m_gameObject) {
            m_gameObject->m_triggerTargetColor = m_currentColor;
        }
        else if (m_gameObjects) {
            for (int i = 0; i < m_gameObjects->count(); i++) {
                static_cast<EffectGameObject*>(m_gameObjects->objectAtIndex(i))->m_triggerTargetColor = m_currentColor;
            }
        }
    }
    void updateCopyColor() = win 0x93910, imac 0x72ad40, m1 0x63ccf0;
    void updateCopyColorTextInputLabel();
    void updateCustomColorIdx() = win 0x93350, imac 0x72a810, m1 0x63c85c;
    void updateDuration() = m1 0x63ac5c;
    void updateDurLabel() = m1 0x4bb58;
    void updateHSVMode() = win 0x93620;
    void updateHSVValue() = win inline, imac 0x728c70, m1 0x63acc8 {
        if (m_colorAction) {
            m_colorAction->m_copyHSV = m_hsv;
        }
        else if (m_gameObject) {
            m_gameObject->m_hsvValue = m_hsv;
        }
        else if (m_gameObjects) {
            for (int i = 0; i < m_gameObjects->count(); i++) {
                static_cast<EffectGameObject*>(m_gameObjects->objectAtIndex(i))->m_hsvValue = m_hsv;
            }
        }
    }
    void updateOpacity() = win 0x91390, imac 0x728b30, m1 0x63abd4;
    void updateOpacityLabel() = win 0x91510, imac 0x727580, m1 0x639868;
    void updateTextInputLabel();

    cocos2d::extension::CCControlColourPicker* m_colorPicker;
    bool m_unk3c0;
    cocos2d::CCLabelBMFont* m_opacityLabel;
    Slider* m_fadeTimeSlider;
    Slider* m_opacitySlider;
    CCMenuItemToggler* m_playerColor1Toggle;
    CCMenuItemToggler* m_playerColor2Toggle;
    cocos2d::ccColor3B m_originalColor;
    cocos2d::CCSprite* m_currentColorSprite;
    cocos2d::CCSprite* m_originalColorSprite;
    cocos2d::ccColor3B m_currentColor;
    ColorSelectDelegate* m_delegate;
    float m_fadeTime;
    int m_playerColor;
    int m_blending;
    float m_opacity;
    ColorAction* m_colorAction;
    CCTextInputNode* m_colorInput;
    bool m_backgroundTrigger;
    bool m_tintGround;
    bool m_legacyHSV;
    bool m_colorTrigger;
    bool m_noChannel;
    bool m_newColorTrigger;
    int m_colorID;
    bool m_initializing;
    int m_copyColorID;
    bool m_copyOpacity;
    ConfigureHSVWidget* m_hsvWidget;
    cocos2d::ccHSVValue m_hsv;
    cocos2d::CCArray* m_colorObjects;
    cocos2d::CCArray* m_copyObjects;
    CCTextInputNode* m_copyColorInput;
    CCTextInputNode* m_fadeTimeInput;
    void* m_unk488;
    void* m_unk490;
    bool m_showCopyObjects;
    CCTextInputNode* m_rInput;
    CCTextInputNode* m_gInput;
    CCTextInputNode* m_bInput;
    CCTextInputNode* m_hexInput;
}

[[link(android)]]
class ColorSetupDelegate {
    virtual void colorSetupClosed(int id) {}
}

[[link(android)]]
class CommentCell : TableViewCell, LikeItemDelegate, FLAlertLayerProtocol {
    CommentCell(char const* identifier, float width, float height) = m1 0x1fa7d4, ios inline : TableViewCell(identifier, width, height) {
        this->init();
    }
    ~CommentCell() = win inline, m1 0x1fa5b8 {
        CC_SAFE_RELEASE(m_comment);
    }

    virtual bool init() = win 0xb5c00, imac 0x254980, m1 0x1fa834;
    virtual void draw() = win 0xade40, m1 0x1faaf8, imac 0x254c90;
    virtual void likedItem(LikeItemType type, int id, bool liked) = win 0xb7f80, m1 0x1faba4, imac 0x254d60;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0xb81f0, m1 0x1faf20, imac 0x255110;

    void incrementDislikes() = win inline, imac 0x254f00, m1 0x1fad40, ios inline {
        m_comment->m_likeCount--;
        this->updateLabelValues();
    }
    void incrementLikes() = win inline, imac 0x254e50, m1 0x1fac8c, ios inline {
        m_comment->m_likeCount++;
        this->updateLabelValues();
    }
    void loadFromComment(GJComment* comment) = win 0xb5c20, imac 0x35b840;
    void onConfirmDelete(cocos2d::CCObject* sender) = win 0xb8080, imac 0x254ba0;
    void onDelete() = win inline {
        if (!m_comment) return;
        auto glm = GameLevelManager::sharedState();
        if (m_accountComment) glm->deleteAccountComment(m_comment->m_commentID, m_comment->m_accountID);
        else glm->deleteLevelComment(m_comment->m_commentID, m_comment->m_levelID);
        m_comment->m_commentDeleted = true;
        this->loadFromComment(m_comment);
    }
    void onGoToLevel(cocos2d::CCObject* sender) = win 0xb8350, imac 0x2549e0, m1 0x1fa87c;
    void onLike(cocos2d::CCObject* sender) = win 0xb7e20;
    void onUndelete() = win inline, imac 0x2550f0, m1 0x1faf0c, ios inline {
        if (!m_comment) return;
        m_comment->m_commentDeleted = false;
        this->loadFromComment(m_comment);
    }
    void onUnhide(cocos2d::CCObject* sender) = win 0xb8330, imac 0x254a90, m1 0x1fa924;
    void onViewProfile(cocos2d::CCObject* sender) = win 0xb81b0, imac 0x2549b0;
    void updateBGColor(int index) = win inline {
        if (m_compactMode) {
            m_backgroundLayer->setColor(index % 2 == 0 ? cocos2d::ccColor3B { 156, 85, 42 } : cocos2d::ccColor3B { 144, 79, 39 });
        }
        else {
            m_backgroundLayer->setColor(index % 2 == 0 ? cocos2d::ccColor3B { 161, 88, 44 } : cocos2d::ccColor3B { 194, 114, 62 });
        }
    }
    void updateLabelValues() = win 0xb7fc0;

    cocos2d::CCSprite* m_iconSprite;
    cocos2d::CCLabelBMFont* m_likeLabel;
    GJComment* m_comment;
    bool m_accountComment;
    bool m_unk259;
    bool m_compactMode;
}

[[link(android)]]
class CommentUploadDelegate {
    virtual void commentUploadFinished(int parentID) {}
    virtual void commentUploadFailed(int parentID, CommentError errorType) {}
    virtual void commentDeleteFailed(int id, int parentID) {}
}

[[link(android)]]
class CommunityCreditNode : cocos2d::CCNode {
    // virtual ~CommunityCreditNode();

    static CommunityCreditNode* create(int unlockType, int iconID, int unknown, gd::string author) = win 0x93fa0, imac 0x31dfb0, m1 0x2ac128;

    bool init(int unlockType, int iconID, int unknown, gd::string author) = win inline, ios inline {
        if (!CCNode::init()) return false;
        m_unlockType = unlockType;
        m_iconID = iconID;
        m_unknown = unknown;
        m_author = author;
        return true;
    }

    int m_unlockType;
    int m_iconID;
    int m_unknown;
    gd::string m_author;
}

[[link(android)]]
class CommunityCreditsPage : FLAlertLayer {
    CommunityCreditsPage() {
        m_pageObjects = nullptr;
        m_prevButton = nullptr;
        m_nextButton = nullptr;
        m_page = -1;
    }
    ~CommunityCreditsPage() = win inline {
        CC_SAFE_RELEASE(m_pageObjects);
    }

    static CommunityCreditsPage* create() = win inline, m1 0x2ac4d0 {
        auto ret = new CommunityCreditsPage();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x940e0, m1 0x2ac5d4, imac 0x31e5b0;
    virtual void registerWithTouchDispatcher() = win 0x42660, m1 0x2ae8dc, imac 0x320b10;
    virtual void keyBackClicked() = win 0x846c0, m1 0x2ae860, imac 0x320aa0;
    virtual void show() = win 0x96240, m1 0x2ae6d4, imac 0x320910;

    void FLAlert_Clicked(FLAlertLayer* alert, bool btn2) = win inline, ios inline {}
    void goToPage(int page) = win 0x96120, imac 0x320800, m1 0x2ae5c0;
    void onClose(cocos2d::CCObject* sender) = win 0x84690, imac 0x320790, m1 0x2ae544;
    void onSwitchPage(cocos2d::CCObject* sender) = imac 0x3207c0, m1 0x2ae580;

    cocos2d::CCDictionary* m_pageObjects;
    CCMenuItemSpriteExtra* m_prevButton;
    CCMenuItemSpriteExtra* m_nextButton;
    int m_page;
}

[[link(android)]]
class ConfigureHSVWidget : cocos2d::CCNode, TextInputDelegate {
    // virtual ~ConfigureHSVWidget();

    static ConfigureHSVWidget* create(cocos2d::ccHSVValue hsv, bool noBackground, bool addInputs) = win 0x96a30, imac 0x42f4e0, m1 0x3a1d08;
    static cocos2d::ccHSVValue getHSV(GameObject* object, cocos2d::CCArray* objects, int mode) = win 0x98180, m1 0x3a36dc;

    virtual void textInputOpened(CCTextInputNode* node) = win inline, imac 0x430d60, m1 0x3a3480 {}
    virtual void textInputClosed(CCTextInputNode* node) = win 0x8b870, imac 0x430d80, m1 0x3a3488;
    virtual void textChanged(CCTextInputNode* node) = win 0x97640, m1 0x3a34a4, imac 0x430dc0;

    void createTextInputNode(cocos2d::CCPoint position, int tag) = win 0x973e0, imac 0x430220, m1 0x3a2984;
    bool init(cocos2d::ccHSVValue hsv, bool noBackground, bool addInputs) = win 0x96b00;
    void onClose() = win inline, ios inline {
        cocos2d::CCDictElement* element;
        cocos2d::CCDictElement* temp;
        HASH_ITER(hh, m_inputs->m_pElements, element, temp) {
            static_cast<CCTextInputNode*>(element->getObject())->onClickTrackNode(false);
        }
    }
    void onResetHSV(cocos2d::CCObject* sender) = win 0x97bf0, imac 0x430640, m1 0x3a2e10;
    void onToggleSConst(cocos2d::CCObject* sender) = m1 0x3a2d28;
    void onToggleVConst(cocos2d::CCObject* sender) = m1 0x3a2d9c;
    void sliderChanged(cocos2d::CCObject* sender) = m1 0x3a2be0;
    void updateLabels() = win 0x97c70;
    void updateSliders() = win 0x97900, imac 0x430c80, m1 0x3a33c4;

    cocos2d::CCLabelBMFont* m_hueLabel;
    cocos2d::CCLabelBMFont* m_saturationLabel;
    cocos2d::CCLabelBMFont* m_brightnessLabel;
    Slider* m_hueSlider;
    Slider* m_saturationSlider;
    Slider* m_brightnessSlider;
    cocos2d::ccHSVValue m_hsv;
    bool m_mixed;
    HSVWidgetDelegate* m_delegate;
    bool m_addInputs;
    bool m_updating;
    cocos2d::CCDictionary* m_inputs;
}

[[link(android)]]
class ConfigureValuePopup : FLAlertLayer, TextInputDelegate {
    // virtual ~ConfigureValuePopup();

    static ConfigureValuePopup* create(ConfigureValuePopupDelegate* delegate, float value, float minimum, float maximum, gd::string title, gd::string description) = win 0x98480;

    virtual void keyBackClicked() = win 0x99600, m1 0x5489fc, imac 0x625340;
    virtual void textInputClosed(CCTextInputNode* node) = win 0x8b870, m1 0x54887c, imac 0x625170;
    virtual void textChanged(CCTextInputNode* node) = win 0x99370, m1 0x548898, imac 0x6251b0;

    bool init(ConfigureValuePopupDelegate* delegate, float value, float minimum, float maximum, gd::string title, gd::string description) = win 0x98660;
    void onClose(cocos2d::CCObject* sender) = win 0x99580;
    void sliderChanged(cocos2d::CCObject* sender) = win 0x990c0, imac 0x624e10;
    void updateTextInputLabel();

    int m_type;
    float m_value;
    float m_minimum;
    float m_maximum;
    bool m_enableDelegate;
    bool m_disableTextDelegate;
    ConfigureValuePopupDelegate* m_delegate;
    CCTextInputNode* m_input;
    Slider* m_slider;
}

[[link(android)]]
class ConfigureValuePopupDelegate {
    virtual void valuePopupClosed(ConfigureValuePopup* popup, float value) {}
}

[[link(android)]]
class CountTriggerAction {
    // CountTriggerAction(CountTriggerAction&&);
    CountTriggerAction() {}
    CountTriggerAction(int targetID, int targetCount, bool activateGroup, bool multiActivate, int itemID, int previousCount, gd::vector<int> const& remapKeys, int uniqueID, int controlID) {
        m_disabled = false;
        m_previousCount = previousCount;
        m_targetCount = targetCount;
        m_targetGroupID = targetID;
        m_activateGroup = activateGroup;
        m_triggerUniqueID = uniqueID;
        m_controlID = controlID;
        m_itemID = itemID;
        m_multiActivate = multiActivate;
        m_remapKeys = remapKeys;
    }

    bool m_disabled;
    int m_previousCount;
    int m_targetCount;
    int m_targetGroupID;
    bool m_activateGroup;
    int m_triggerUniqueID;
    int m_controlID;
    int m_itemID;
    bool m_multiActivate;
    gd::vector<int> m_remapKeys;
}

[[link(android)]]
class CountTriggerGameObject : EffectGameObject {
    // virtual ~CountTriggerGameObject();
    CountTriggerGameObject() {
        m_pickupCount = 0;
        m_pickupTriggerMode = 0;
        m_multiActivate = false;
        m_isOverride = false;
        m_pickupTriggerMultiplier = 1.f;
    }

    static CountTriggerGameObject* create(char const* frame) = win inline, m1 0x18ab98 {
        auto ret = new CountTriggerGameObject();
        if (ret->init(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void triggerObject(GJBaseGameLayer* layer, int uniqueID, gd::vector<int> const* remapKeys) = win 0x4baea0, m1 0x18acb4, imac 0x1d6750;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4bb310, m1 0x18aec8, imac 0x1d69c0;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x4bb670, m1 0x18b254, imac 0x1d6de0;

    bool init(char const* frame) = win inline, m1 0x18ac6c, ios inline {
        return EffectGameObject::init(frame);
    }

    // property 77
    int m_pickupCount;
    // property 88
    int m_pickupTriggerMode;
    // property 104
    bool m_multiActivate;
    // property 139
    bool m_isOverride;
    // property 449
    float m_pickupTriggerMultiplier;
}

[[link(android)]]
class CreateGuidelinesLayer : FLAlertLayer, FLAlertLayerProtocol {
    CreateGuidelinesLayer() {
        m_delegate = nullptr;
        m_elapsed = 0.f;
        m_recording = false;
        m_unk2b5 = false;
    }
    ~CreateGuidelinesLayer() = win 0x99770;

    static CreateGuidelinesLayer* create(CustomSongDelegate* delegate, AudioGuidelinesType type) = win inline, imac 0x50ac80, m1 0x4622ec {
        auto ret = new CreateGuidelinesLayer();
        if (ret->init(delegate, type)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void update(float dt) = win 0x9b440, imac 0x50ca40, m1 0x464070;
    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x9b710, m1 0x4642cc, imac 0x50ccb0;
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline, m1 0x4643fc, imac 0x50cda0 {}
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x9b790, m1 0x464404, imac 0x50cdc0;
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x71260, m1 0x4644e4, imac 0x50ce80;
    virtual void registerWithTouchDispatcher() = win 0x9b7f0, m1 0x464500, imac 0x50cec0;
    virtual void keyBackClicked() = win 0x9b690, imac 0x50cc10, m1 0x464248;
    virtual void keyDown(cocos2d::enumKeyCodes key, double timestamp) = win 0x9b840, imac 0x50cf00, m1 0x464538;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x9b5b0, m1 0x46413c, imac 0x50cb10;
    virtual void onClose(cocos2d::CCObject* sender) = win 0x84690, imac 0x50cbe0, m1 0x46420c;
    virtual void keyUp(cocos2d::enumKeyCodes key, double timestamp) = win inline, imac 0x50cf50, m1 0x46457c {}
    virtual void playMusic() = win 0x9acf0, m1 0x463644, imac 0x50c0d0;
    virtual void registerTouch() = win 0x9b6b0, imac 0x50cc60, m1 0x464284;
    virtual void onInfo(cocos2d::CCObject* sender) = win 0x9b460, imac 0x50ca60, m1 0x464080;
    virtual void onRecord(cocos2d::CCObject* sender) = win 0x9ab60, imac 0x50bfc0, m1 0x463530;
    virtual void recordingDidStop() = win 0x9ae50, imac 0x50c160, m1 0x4636e4;

    void doClearGuidelines() = win inline, imac 0x50bf30, m1 0x463488 {
        m_infoLabel->setString("Guidelines cleared.");
        if (m_delegate) {
            auto settings = m_delegate->getLevelSettings();
            settings->m_guidelineString = "";
            settings->m_guidelinesUpdated = true;
        }
    }
    gd::string getMergedRecordString(gd::string str1, gd::string str2) = win 0x9b0e0, imac 0x50c4b0, m1 0x463a2c;
    bool init(CustomSongDelegate* delegate, AudioGuidelinesType type) = win 0x99830;
    void onClearGuidelines(cocos2d::CCObject* sender) = imac 0x50bd40;
    void onStop(cocos2d::CCObject* sender) = m1 0x463380;
    void toggleItems(bool visible) = win 0x9b360;

    CustomSongDelegate* m_delegate;
    CCTextInputNode* m_offsetInput;
    cocos2d::CCArray* m_nonRecordingObjects;
    cocos2d::CCArray* m_recordingObjects;
    cocos2d::CCLabelBMFont* m_infoLabel;
    cocos2d::CCSprite* m_circleSprite;
    float m_elapsed;
    bool m_recording;
    bool m_unk2b5;
    int m_guidelines;
    gd::string m_guidelineString;
}

[[link(android)]]
class CreateMenuItem : CCMenuItemSpriteExtra {
    // virtual ~CreateMenuItem();

    static CreateMenuItem* create(cocos2d::CCNode* normal, cocos2d::CCNode* selected, cocos2d::CCObject* target, cocos2d::SEL_MenuHandler selector) = win 0x1294f0, imac 0x2ee50, m1 0x2bfb4;

    bool init(cocos2d::CCNode* normal, cocos2d::CCNode* selected, cocos2d::CCObject* target, cocos2d::SEL_MenuHandler selector) = win inline, ios inline {
        return CCMenuItemSpriteExtra::init(normal, selected, target, selector);
    }

    gd::string m_spriteFileName;
    int m_objectID;
    int m_pageIndex;
    int m_tabIndex;
}

[[link(android)]]
class CreateParticlePopup : FLAlertLayer, TextInputDelegate, ColorSelectDelegate, SliderDelegate {
    // virtual ~CreateParticlePopup();

    static CreateParticlePopup* create(gd::string str) = win inline, imac 0x46e2c0, m1 0x2484c4, ios inline {
        return CreateParticlePopup::create(nullptr, nullptr, str);
    }
    static CreateParticlePopup* create(ParticleGameObject* object, cocos2d::CCArray* objects) = win inline, imac 0x46e030, m1 0x3d5c78 {
        return CreateParticlePopup::create(object, objects, "");
    }
    static CreateParticlePopup* create(ParticleGameObject* object, cocos2d::CCArray* objects, gd::string str) = win 0x42bb90, imac 0x46e050, m1 0x3d5ca0;

    virtual void update(float dt) = win 0x432240, m1 0x3dd028, imac 0x475f90;
    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x434f20, imac 0x476bc0, m1 0x3ddb98;
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x435020, m1 0x3ddc88, imac 0x476cd0;
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x435450, m1 0x3de01c, imac 0x4770b0;
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x71260, m1 0x3de058, imac 0x477100;
    virtual void keyBackClicked() = win 0x434f10, m1 0x3dda04, imac 0x476a20;
    virtual void sliderBegan(Slider* slider) = win 0x434650, imac 0x4768e0, m1 0x3dd8b4;
    virtual void sliderEnded(Slider* slider) = win 0x434710, imac 0x4769c0, m1 0x3dd9cc;
    virtual void colorSelectClosed(cocos2d::CCNode* popup) = win 0x431b00, imac 0x475cb0, m1 0x3dcd5c;
    virtual void textInputShouldOffset(CCTextInputNode* node, float yOffset) = win 0x7b620, m1 0x3dda10, imac 0x476a50;
    virtual void textInputReturn(CCTextInputNode* node) = win 0x7b680, m1 0x3ddae0, imac 0x476b10;
    virtual void textInputClosed(CCTextInputNode* node) = win 0x8b870, m1 0x3dd21c, imac 0x4761b0;
    virtual void textChanged(CCTextInputNode* node) = win 0x432560, m1 0x3dd238, imac 0x4761f0;

    void centerAlignParticle(cocos2d::CCObject* sender) = win 0x431ff0, imac 0x472f10, m1 0x3da438;
    void createParticleSlider(gjParticleValue value, int page, bool centerLabel, cocos2d::CCPoint position, cocos2d::CCArray* displayNodes) = win 0x4305c0, imac 0x473650;
    cocos2d::CCNode* getPage(int page) = win inline, m1 0x3da82c, ios inline {
        return static_cast<cocos2d::CCNode*>(m_pageNodes->objectAtIndex(page - 1));
    }
    CCMenuItemSpriteExtra* getPageButton(int page) = win inline, m1 0x3dbac0, ios inline {
        return static_cast<CCMenuItemSpriteExtra*>(m_pageButtons->objectAtIndex(page - 1));
    }
    cocos2d::CCArray* getPageContainer(int page) = win inline, m1 0x3da838, ios inline {
        return static_cast<cocos2d::CCArray*>(m_pageObjectArrays->objectAtIndex(page - 1));
    }
    cocos2d::CCDictionary* getPageInputNodes(int page) = win inline, m1 0x3dab88, ios inline {
        return static_cast<cocos2d::CCDictionary*>(m_inputDicts->objectAtIndex(page));
    }
    cocos2d::CCMenu* getPageMenu(int page) = win inline, imac 0x4732c0, m1 0x3da824, ios inline {
        return m_buttonMenu;
    }
    cocos2d::CCDictionary* getPageSliders(int page) = win inline, m1 0x3dab90, ios inline {
        return static_cast<cocos2d::CCDictionary*>(m_sliderDicts->objectAtIndex(page));
    }
    bool init(ParticleGameObject* object, cocos2d::CCArray* objects, gd::string str);
    float maxSliderValueForType(gjParticleValue type) = win 0x433750, m1 0x3dd894;
    float minSliderValueForType(gjParticleValue type) = win 0x433820, m1 0x3dd874;
    void onAnimateActiveOnly(cocos2d::CCObject* sender);
    void onAnimateOnTrigger(cocos2d::CCObject* sender);
    void onCalcEmission(cocos2d::CCObject* sender) = win 0x432750, imac 0x474ef0, m1 0x3dc32c;
    void onClose(cocos2d::CCObject* sender) = win 0x434dd0, imac 0x472aa0, m1 0x3da02c;
    void onCopySettings(cocos2d::CCObject* sender) = win 0x431720, imac 0x472c70, m1 0x3da1c0;
    void onDuplicateColor(cocos2d::CCObject* sender) = win 0x4315f0, imac 0x4734e0, m1 0x3daa3c;
    void onDurationForever(cocos2d::CCObject* sender) = win 0x4326b0, imac 0x474e50, m1 0x3dc29c;
    void onDynamicColor(cocos2d::CCObject* sender) = win 0x4312c0, imac 0x474270;
    void onDynamicRotation(cocos2d::CCObject* sender);
    void onEmitterMode(cocos2d::CCObject* sender) = win 0x434a70, imac 0x473310, m1 0x3da844;
    void onEndRGBVarSync(cocos2d::CCObject* sender);
    void onMaxEmission(cocos2d::CCObject* sender) = win 0x432700, imac 0x474ea0, m1 0x3dc2e4;
    void onMode(cocos2d::CCObject* sender) = win 0x431de0, imac 0x472e50, m1 0x3da380;
    void onOrderSensitive(cocos2d::CCObject* sender);
    void onPage(cocos2d::CCObject* sender) = win 0x432040, imac 0x473040, m1 0x3da598;
    void onPasteSettings(cocos2d::CCObject* sender) = win 0x431970, m1 0x3da2d8;
    void onPosType(cocos2d::CCObject* sender) = win 0x4349f0, imac 0x473240, m1 0x3da794;
    void onQuickStart(cocos2d::CCObject* sender);
    void onSelectColor(cocos2d::CCObject* sender) = win 0x4314c0, imac 0x472f60, m1 0x3da488;
    void onSelectParticleTexture(cocos2d::CCObject* sender) = win 0x431ec0, imac 0x4744e0, m1 0x3db960;
    void onStartRGBVarSync(cocos2d::CCObject* sender);
    void onToggleBlending(cocos2d::CCObject* sender) = imac 0x473f80;
    void onToggleStartRadiusEqualToEnd(cocos2d::CCObject* sender);
    void onToggleStartRotationIsDir(cocos2d::CCObject* sender) = imac 0x474050;
    void onToggleStartSizeEqualToEnd(cocos2d::CCObject* sender);
    void onToggleStartSpinEqualToEnd(cocos2d::CCObject* sender);
    void onUniformColor(cocos2d::CCObject* sender) = win 0x4313e0;
    bool particleValueIsInt(gjParticleValue type) = win 0x4347d0, m1 0x2008d8, ios inline {
        switch (type) {
            case gjParticleValue::MaxParticles: case gjParticleValue::Emission:
            case gjParticleValue::Angle: case gjParticleValue::AngleVar:
            case gjParticleValue::Speed: case gjParticleValue::SpeedVar:
            case gjParticleValue::PosVarX: case gjParticleValue::PosVarY:
            case gjParticleValue::GravityX: case gjParticleValue::GravityY:
            case gjParticleValue::AccelRad: case gjParticleValue::AccelRadVar:
            case gjParticleValue::AccelTan: case gjParticleValue::AccelTanVar:
            case gjParticleValue::StartSize: case gjParticleValue::StartSizeVar:
            case gjParticleValue::EndSize: case gjParticleValue::EndSizeVar:
            case gjParticleValue::StartSpin: case gjParticleValue::StartSpinVar:
            case gjParticleValue::EndSpin: case gjParticleValue::EndSpinVar:
            case gjParticleValue::StartRad: case gjParticleValue::StartRadVar:
            case gjParticleValue::EndRad: case gjParticleValue::EndRadVar:
            case gjParticleValue::RotSec: case gjParticleValue::RotSecVar:
                return true;
            default:
                return false;
        }
    }
    void sliderChanged(cocos2d::CCObject* sender) = m1 0x3dc10c;
    gd::string titleForParticleValue(gjParticleValue type) = win 0x432810, imac 0x474a70, m1 0x3dbedc;
    void toggleGravityMode(bool gravityMode) = win 0x434af0, imac 0x474630;
    void updateColorSprite(int tag) = win inline {
        if (tag == 1) {
            auto color = m_particle->getStartColor();
            m_startColorSprite->setColor({ (uint8_t)(color.r * 255.f), (uint8_t)(color.g * 255.f), (uint8_t)(color.b * 255.f) });
        }
        else if (tag == 2) {
            auto color = m_particle->getEndColor();
            m_endColorSprite->setColor({ (uint8_t)(color.r * 255.f), (uint8_t)(color.g * 255.f), (uint8_t)(color.b * 255.f) });
        }
    }
    void updateInputNodeStringForType(gjParticleValue type) = win 0x434840, m1 0x3dbf08;
    void updateParticleValueForType(float value, gjParticleValue type, cocos2d::CCParticleSystemQuad* particle) = win 0x433940, imac 0x474fa0;
    void updateSliderForType(gjParticleValue type) = win 0x4345b0, imac 0x474d80, m1 0x3dc1dc;
    float valueForParticleValue(gjParticleValue type) = win 0x4330c0, imac 0x4762d0, m1 0x3dd320;
    void willClose() = win 0x434d40, m1 0x3dccf4;

    ParticleGameObject* m_targetObject;
    cocos2d::CCArray* m_targetObjects;
    cocos2d::CCArray* m_particles;
    bool m_disableTextDelegate;
    cocos2d::CCParticleSystemQuad* m_particle;
    cocos2d::CCParticleSystemQuad* m_standaloneParticle;
    int m_touchID;
    cocos2d::CCPoint m_touchDelta;
    cocos2d::CCArray* m_inputDicts;
    cocos2d::CCArray* m_sliderDicts;
    cocos2d::CCArray* m_pageNodes;
    cocos2d::CCArray* m_pageButtons;
    cocos2d::CCArray* m_pageMenus;
    cocos2d::CCArray* m_pageObjectArrays;
    ParticlePreviewLayer* m_previewLayer;
    CCMenuItemSpriteExtra* m_mode1Button;
    CCMenuItemSpriteExtra* m_mode2Button;
    CCMenuItemSpriteExtra* m_mode3Button;
    float m_elapsed;
    int m_selectedMode;
    CCMenuItemToggler* m_freeToggler;
    CCMenuItemToggler* m_relativeToggler;
    CCMenuItemToggler* m_groupedToggler;
    CCMenuItemToggler* m_objColorToggler;
    CCMenuItemToggler* m_uniformColorToggler;
    CCMenuItemToggler* m_gravityToggler;
    CCMenuItemToggler* m_radiusToggler;
    cocos2d::CCSprite* m_selectSprite;
    cocos2d::CCSprite* m_particleColorSprite;
    cocos2d::CCSprite* m_startColorSprite;
    cocos2d::CCSprite* m_endColorSprite;
    cocos2d::CCArray* m_gravityObjects;
    cocos2d::CCArray* m_radiusObjects;
    bool m_perfLogEnabled;
    float m_perfLogElapsed;
    cocos2d::CCLabelBMFont* m_perfLogLabel;
    int m_particleIndex;
    int m_page;
    bool m_useObjectColor;
    bool m_animateOnTrigger;
    bool m_onlyAnimateActive;
    bool m_quickStart;
    float m_respawnResult;
}

[[link(android)]]
class CreatorLayer : cocos2d::CCLayer, cocos2d::CCSceneTransitionDelegate, DialogDelegate {
    // virtual ~CreatorLayer();
    CreatorLayer() {
        m_secretDoorSprite = nullptr;
        m_questsSprite = nullptr;
        m_vaultDialogIndex = -1;
        m_versusDialogIndex = 0;
    }

    static CreatorLayer* create() = win inline, m1 0x237260 {
        auto ret = new CreatorLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static cocos2d::CCScene* scene() = win 0x9bff0, m1 0x23717c;

    virtual bool init() = win 0x9c160, m1 0x23731c, imac 0x297190;
    virtual void keyBackClicked() = win 0x9f9e0, m1 0x239540, imac 0x299550;
    virtual void sceneWillResume() = win 0x9f880, m1 0x2394d0, imac 0x2994d0;
    virtual void dialogClosed(DialogLayer* layer) = win 0x9f760, imac 0x2993d0, m1 0x2393cc;

    bool canPlayOnlineLevels() = win inline, m1 0x239378, ios inline {
        return true;
    }
    void checkQuestsStatus() = win 0x9f640, imac 0x2989e0, m1 0x238a38;
    void onAdventureMap(cocos2d::CCObject* sender) = win 0x9e270, imac 0x298430, m1 0x23848c;
    void onBack(cocos2d::CCObject* sender) = m1 0x239318;
    void onChallenge(cocos2d::CCObject* sender) = win 0x9e440, imac 0x2984a0, m1 0x238520;
    void onDailyLevel(cocos2d::CCObject* sender) = m1 0x238558;
    void onEventLevel(cocos2d::CCObject* sender) = win 0x9e420, imac 0x298510, m1 0x238598;
    void onFameLevels(cocos2d::CCObject* sender) = win inline, m1 0x239380, ios inline {
        cocos2d::CCDirector::sharedDirector()->pushScene(cocos2d::CCTransitionFade::create(0.5f, LevelBrowserLayer::scene(GJSearchObject::create(SearchType::HallOfFame))));
        GameManager::sharedState()->m_sceneEnum = 1;
    }
    void onFeaturedLevels(cocos2d::CCObject* sender) = win 0x9d930, m1 0x238600;
    void onGauntlets(cocos2d::CCObject* sender) = m1 0x2385b8;
    void onLeaderboards(cocos2d::CCObject* sender);
    void onMapPacks(cocos2d::CCObject* sender) = win 0x9db60, m1 0x2386c8;
    void onMultiplayer(cocos2d::CCObject* sender) = win 0x9dca0, imac 0x2980c0, m1 0x2380cc;
    void onMyLevels(cocos2d::CCObject* sender) = win 0x9d330, m1 0x238750;
    void onOnlineLevels(cocos2d::CCObject* sender) = win 0x9dae0, m1 0x238714;
    void onOnlyFullVersion(cocos2d::CCObject* sender) = imac 0x2987e0, m1 0x238818;
    void onPaths(cocos2d::CCObject* sender) = win 0x9d9f0, m1 0x23864c;
    void onSavedLevels(cocos2d::CCObject* sender) = win 0x9d540, m1 0x237fc4;
    void onSecretVault(cocos2d::CCObject* sender) = win 0x9e5b0;
    void onTopLists(cocos2d::CCObject* sender) = imac 0x298600, m1 0x238668;
    void onTreasureRoom(cocos2d::CCObject* sender) = win 0x9edc0, m1 0x238d84;
    void onWeeklyLevel(cocos2d::CCObject* sender) = win 0x9e400, m1 0x238578;

    cocos2d::CCSprite* m_secretDoorSprite;
    cocos2d::CCSprite* m_questsSprite;
    int m_vaultDialogIndex;
    int m_versusDialogIndex;
}

[[link(android)]]
class CurrencyRewardDelegate {
    virtual void currencyWillExit(CurrencyRewardLayer* layer) {}
}

[[link(android)]]
class CurrencyRewardLayer : cocos2d::CCLayer {
    // virtual ~CurrencyRewardLayer();
    // CurrencyRewardLayer();

    static CurrencyRewardLayer* create(int orbs, int stars, int moons, int diamonds, CurrencySpriteType demonKey, int keyCount, CurrencySpriteType shardType, int shardsCount, cocos2d::CCPoint position, CurrencyRewardType rewardType, float yOffset, float time) = win 0x9fc30, imac 0x7a5560, m1 0x6ac52c;

    virtual void update(float dt) = win 0xa2960, imac 0x7a8570, m1 0x6af3b0;

    void createObjects(CurrencySpriteType type, int count, cocos2d::CCPoint position, float time) = win inline, imac 0x7a7770, m1 0x6ae6dc {
        this->createObjectsFull(type, count, nullptr, position, time);
    }
    void createObjectsFull(CurrencySpriteType type, int count, cocos2d::CCSprite* sprite, cocos2d::CCPoint position, float time) = win 0xa1c50, imac 0x29c240, m1 0x6ae7a0;
    void createUnlockObject(cocos2d::CCSprite* sprite, cocos2d::CCPoint position, float time) = win inline, imac 0x7a77c0, m1 0x6ae744 {
        this->createObjectsFull(CurrencySpriteType::Icon, 1, sprite, position, time);
    }
    void incrementCount(int count) = win inline {
        if (m_orbsLabel == nullptr) return;
        m_orbs += count;
        this->pulseSprite(m_orbsSprite);
        m_orbsLabel->setString(cocos2d::CCString::createWithFormat("%i", count)->getCString());
    }
    void incrementDiamondsCount(int count) = win inline {
        if (m_diamondsLabel == nullptr) return;
        m_diamonds += count;
        this->pulseSprite(m_diamondsSprite);
        m_diamondsLabel->setString(cocos2d::CCString::createWithFormat("%i", count)->getCString());
    }
    void incrementMoonsCount(int count) = win inline {
        if (m_moonsLabel == nullptr) return;
        m_moons += count;
        this->pulseSprite(m_moonsSprite);
        m_moonsLabel->setString(cocos2d::CCString::createWithFormat("%i", count)->getCString());
    }
    void incrementSpecialCount1(int count) = win inline {
        if (m_keysLabel == nullptr) return;
        m_keys += count;
        this->pulseSprite(m_keysSprite);
        m_keysLabel->setString(cocos2d::CCString::createWithFormat("%i", count)->getCString());
    }
    void incrementSpecialCount2(int count) = win inline {
        if (m_shardsLabel == nullptr) return;
        m_shards += count;
        this->pulseSprite(m_shardsSprite);
        m_shardsLabel->setString(cocos2d::CCString::createWithFormat("%i", count)->getCString());
    }
    void incrementStarsCount(int count) = win inline {
        if (m_starsLabel == nullptr) return;
        m_stars += count;
        this->pulseSprite(m_starsSprite);
        m_starsLabel->setString(cocos2d::CCString::createWithFormat("%i", count)->getCString());
    }
    bool init(int orbs, int stars, int moons, int diamonds, CurrencySpriteType demonKey, int keyCount, CurrencySpriteType shardType, int shardsCount, cocos2d::CCPoint position, CurrencyRewardType rewardType, float yOffset, float time) = win 0x9fe80;
    void pulseSprite(cocos2d::CCSprite* sprite) = win 0xa3330, imac 0x7a95a0, m1 0x6b01e0;

    CurrencyRewardDelegate* m_delegate;
    cocos2d::CCArray* m_objects;
    cocos2d::CCLabelBMFont* m_orbsLabel;
    cocos2d::CCLabelBMFont* m_starsLabel;
    cocos2d::CCLabelBMFont* m_moonsLabel;
    cocos2d::CCLabelBMFont* m_diamondsLabel;
    cocos2d::CCLabelBMFont* m_keysLabel;
    cocos2d::CCLabelBMFont* m_shardsLabel;
    cocos2d::CCSprite* m_orbsSprite;
    cocos2d::CCSprite* m_starsSprite;
    cocos2d::CCSprite* m_moonsSprite;
    cocos2d::CCSprite* m_diamondsSprite;
    CurrencySprite* m_keysSprite;
    CurrencySprite* m_shardsSprite;
    cocos2d::CCSpriteBatchNode* m_currencyBatchNode;
    cocos2d::CCSpriteBatchNode* m_orbBatchNode;
    int m_orbs;
    int m_stars;
    int m_moons;
    int m_diamonds;
    int m_keys;
    int m_shards;
    float m_elapsed;
    float m_unknown;
    float m_time;
    cocos2d::CCPoint m_orbsPosition;
    cocos2d::CCPoint m_starsPosition;
    cocos2d::CCPoint m_moonsPosition;
    cocos2d::CCPoint m_diamondsPosition;
    cocos2d::CCPoint m_keysPosition;
    cocos2d::CCPoint m_shardsPosition;
    bool m_particlesAdded;
    bool m_objectsAdded;
    cocos2d::CCNode* m_mainNode;
    int m_rewardCount;
    CurrencyRewardType m_rewardType;
}

[[link(android)]]
class CurrencySprite : CCSpritePlus {
    CurrencySprite() {
        m_unkFloat1 = 0.f;
        m_unkFloat2 = 0.f;
        m_unkFloat3 = 0.f;
        m_remaining = 0.f;
        m_count = 1;
        m_particleSystem = nullptr;
        m_spriteType = CurrencySpriteType::Orb;
        m_burstSprite = nullptr;
    }
    ~CurrencySprite() = win inline, m1 0x6b02c0 {
        CC_SAFE_RELEASE(m_burstSprite);
    }

    static CurrencySprite* create(CurrencySpriteType type, bool burst) = win inline, imac 0x7a7660, m1 0x6ae5e0 {
        auto ret = new CurrencySprite();
        if (ret->init(type, burst)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static CurrencySprite* createWithSprite(cocos2d::CCSprite* sprite) = win 0xa4be0, m1 0x6af2c8;
    static CurrencySpriteType rewardToSpriteType(int rewardType) = win 0xa4e00, m1 0x6b0e20;
    static gd::string spriteTypeToStat(CurrencySpriteType type) = win 0xa4eb0, imac 0x7a7560;

    bool init(CurrencySpriteType type, bool burst) = win 0xa3400, imac 0x7a9780, m1 0x6b03a8;
    bool initWithSprite(cocos2d::CCSprite* sprite) = win inline {
        if (!cocos2d::CCSprite::init()) return false;
        this->addChild(sprite);
        sprite->setPosition({ 0.f, 0.f });
        m_burstSprite = cocos2d::CCSprite::createWithSpriteFrameName("shineBurst_001.png");
        m_burstSprite->retain();
        auto factor = (float)rand() / (float)RAND_MAX > .5f ? 1.f : -1.f;
        m_burstSprite->runAction(cocos2d::CCRepeatForever::create(cocos2d::CCRotateBy::create(1.f, 90.f * factor)));
        m_burstSprite->setScale(2.f);
        m_burstSprite->setColor({ 255, 255, 255 });
        auto shineBurst = cocos2d::CCSprite::createWithSpriteFrameName("shineBurst_001.png");
        m_burstSprite->addChild(shineBurst);
        shineBurst->setPosition(m_burstSprite->convertToNodeSpace({ 0.f, 0.f }));
        shineBurst->setScale(.8f);
        shineBurst->setColor({ 255, 255, 255 });
        shineBurst->runAction(cocos2d::CCRepeatForever::create(cocos2d::CCRotateBy::create(1.f, -180.f * factor)));
        return true;
    }

    float m_unkFloat1;
    float m_unkFloat2;
    float m_unkFloat3;
    float m_remaining;
    int m_count;
    cocos2d::CCParticleSystemQuad* m_particleSystem;
    CurrencySpriteType m_spriteType;
    cocos2d::CCPoint m_position;
    cocos2d::CCSprite* m_burstSprite;
}

[[link(android)]]
class CustomizeObjectLayer : FLAlertLayer, TextInputDelegate, HSVWidgetDelegate, ColorSelectDelegate, ColorSetupDelegate {
    // virtual ~CustomizeObjectLayer();
    //CustomizeObjectLayer() = ios 0x577b8;

    static CustomizeObjectLayer* create(GameObject* object, cocos2d::CCArray* objects) = win 0xa5290, imac 0x1f4ad0, m1 0x1a2948;

    virtual void keyBackClicked() = win 0xaa110, m1 0x1a6c20, imac 0x1f9260;
    virtual void textInputOpened(CCTextInputNode* node) = win 0xa96a0, imac 0x1f8eb0, m1 0x1a6874;
    virtual void textInputClosed(CCTextInputNode* node) = win 0x8b870, m1 0x1a6998, imac 0x1f8fc0;
    virtual void textChanged(CCTextInputNode* node) = win 0xa9830, m1 0x1a69b4, imac 0x1f9000;
    virtual void hsvPopupClosed(HSVWidgetPopup* popup, cocos2d::ccHSVValue value) = win 0xa8dd0, imac 0x1f8c60, m1 0x1a6674;
    virtual void colorSelectClosed(cocos2d::CCNode* popup) = win 0xa8760, imac 0x1f8a00, m1 0x1a6438;
    virtual void colorSetupClosed(int id) = win 0xa83c0, imac 0x1f8590, m1 0x1a6028;

    CCMenuItemToggler* createToggleButton(gd::string text, cocos2d::SEL_MenuHandler selector, bool toggled, cocos2d::CCMenu* menu, cocos2d::CCPoint position) = win inline, imac 0x1f8a30, m1 0x1a6444, ios inline {
        auto onSprite = cocos2d::CCSprite::createWithSpriteFrameName("GJ_checkOn_001.png");
        onSprite->setScale(.8f);
        auto offSprite = cocos2d::CCSprite::createWithSpriteFrameName("GJ_checkOff_001.png");
        offSprite->setScale(.8f);
        auto toggler = CCMenuItemToggler::create(offSprite, onSprite, this, selector);
        toggler->toggle(toggled);
        menu->addChild(toggler);
        toggler->setPosition(menu->convertToNodeSpace(position));
        toggler->setSizeMult(1.5f);
        m_detailTabNodes->addObject(toggler);
        auto label = cocos2d::CCLabelBMFont::create(text.c_str(), "bigFont.fnt");
        m_mainLayer->addChild(label);
        label->setAnchorPoint({ .0f, .5f });
        label->setPosition(m_mainLayer->convertToNodeSpace(position + cocos2d::CCPoint { onSprite->getContentSize().width * .5f + 5.6f, 0.f }));
        label->setScale(.5f);
        m_detailTabNodes->addObject(label);
        return toggler;
    }
    void determineStartValues() = win 0xa8770, imac 0x1f6f40, m1 0x1a4acc;
    int getActiveMode(bool ignoreDefault) = win 0xa93e0, imac 0x1f7f30, m1 0x1a5a90;
    ButtonSprite* getButtonByTag(int tag) = win 0xa9c50, m1 0x1a63a0;
    cocos2d::ccHSVValue getHSV() = win inline, imac 0x1f8c30, m1 0x1a6660, ios inline {
        return ConfigureHSVWidget::getHSV(m_targetObject, m_targetObjects, m_selectedMode);
    }
    void highlightSelected(ButtonSprite* sprite) = win 0xa9f00, imac 0x1f8830, m1 0x1a6284;
    bool init(GameObject* object, cocos2d::CCArray* objects) = win 0xa5430, imac 0x55c360;
    void onBreakApart(cocos2d::CCObject* sender) = win 0xa9b40;
    void onBrowse(cocos2d::CCObject* sender) = m1 0x1a5a4c;
    void onClear(cocos2d::CCObject* sender) = win 0xa9ab0, imac 0x1f7c30, m1 0x1a57a4;
    void onClose(cocos2d::CCObject* sender) = win 0xaa030, m1 0x1a4a38;
    void onCopy(cocos2d::CCObject* sender) = m1 0x1a5980;
    void onEditColor(cocos2d::CCObject* sender) = win 0xa84a0, imac 0x1f7870, m1 0x1a542c;
    void onHSV(cocos2d::CCObject* sender) = win 0xa8ba0, imac 0x1f72a0, m1 0x1a4e04;
    void onLiveEdit(cocos2d::CCObject* sender) = win 0xa7f30, imac 0x1f78d0, m1 0x1a5480;
    void onNextColorChannel(cocos2d::CCObject* sender) = m1 0x1a5858;
    void onPaste(cocos2d::CCObject* sender) = win 0xa8090, m1 0x1a59a8;
    void onSelectColor(cocos2d::CCObject* sender) = win 0xa9cd0, imac 0x1f75e0, m1 0x1a5170;
    void onSelectMode(cocos2d::CCObject* sender) = win 0xa9010, imac 0x1f7070, m1 0x1a4bd8;
    void onSettings(cocos2d::CCObject* sender) = win 0xa81e0, m1 0x1a4ddc;
    void onUpdateCustomColor(cocos2d::CCObject* sender) = win 0x99110, imac 0x1f7690, m1 0x1a5238;
    void recreateLayer() = win inline, imac 0x1f8460, m1 0x1a5f14 {
        CC_SAFE_RETAIN(m_targetObject);
        CC_SAFE_RETAIN(m_targetObjects);
        cocos2d::CCDirector::sharedDirector()->getTouchDispatcher()->unregisterForcePrio(this);
        this->onClose(nullptr);
        CustomizeObjectLayer::create(m_targetObject, m_targetObjects)->show();
        CC_SAFE_RELEASE(m_targetObject);
        CC_SAFE_RELEASE(m_targetObjects);
    }
    void sliderChanged(cocos2d::CCObject* sender) = m1 0x1a5534;
    void toggleVisible() = win 0xa9220, imac 0x1f8d50;
    void updateChannelLabel(int channel) = win inline, imac 0x1f81b0, m1 0x1a5d0c {
        if (channel > 999) {
            m_selectedColorLabel->setString(GJSpecialColorSelect::textForColorIdx(channel));
        }
        else if (channel > 0) {
            m_selectedColorLabel->setString(cocos2d::CCString::createWithFormat("%i", channel)->getCString());
        }
        else {
            m_selectedColorLabel->setString(" ");
        }
    }
    void updateColorSprite() = win 0xa8550, imac 0x1f80e0, m1 0x1a5c3c;
    void updateCurrentSelection() = win 0xa9570, imac 0x1f8020, m1 0x1a5b74;
    void updateCustomColorLabels() = win 0xa9bc0, imac 0x1f7760, m1 0x1a530c;
    void updateHSVButtons() = win 0xa89a0, imac 0x1f7440, m1 0x4bd0c;
    void updateKerningLabel() = win 0xa7d30, imac 0x1f7a10, m1 0x1a5580;
    void updateSelected(int id) = win 0xa9d90, imac 0x1f86a0, m1 0x1a613c;

    GameObject* m_targetObject;
    cocos2d::CCArray* m_targetObjects;
    cocos2d::CCArray* m_colorButtons;
    cocos2d::CCArray* m_colorTabNodes;
    cocos2d::CCArray* m_textTabNodes;
    cocos2d::CCArray* m_unkArray;
    cocos2d::CCArray* m_detailTabNodes;
    int m_selectedMode;
    int m_customColorChannel;
    bool m_hasBaseColor;
    bool m_hasDetailColor;
    bool m_glowDisabled;
    CCMenuItemSpriteExtra* m_baseButton;
    CCMenuItemSpriteExtra* m_detailButton;
    CCMenuItemSpriteExtra* m_textButton;
    CCMenuItemSpriteExtra* m_baseColorHSV;
    CCMenuItemSpriteExtra* m_detailColorHSV;
    cocos2d::CCLabelBMFont* m_titleLabel;
    cocos2d::CCLabelBMFont* m_selectedColorLabel;
    CCTextInputNode* m_customColorInput;
    CCTextInputNode* m_textInput;
    int m_kerningAmount;
    cocos2d::CCLabelBMFont* m_kerningLabel;
    Slider* m_kerningSlider;
    ButtonSprite* m_customColorButtonSprite;
    CCMenuItemSpriteExtra* m_customColorButton;
    CCMenuItemSpriteExtra* m_arrowDown;
    CCMenuItemSpriteExtra* m_arrowUp;
    cocos2d::extension::CCScale9Sprite* m_customColorInputBG;
    ColorChannelSprite* m_colorSprite;
    CCMenuItemSpriteExtra* m_colorSpriteButton;
    CCMenuItemSpriteExtra* m_liveSelectButton;
    bool m_showTextInput;
    bool m_customColorSelected;
    bool m_disableTextDelegate;
}

[[link(android)]]
class CustomizeObjectSettingsPopup : SetupTriggerPopup {
    // virtual ~CustomizeObjectSettingsPopup();
    CustomizeObjectSettingsPopup() {
        m_customizeLayer = nullptr;
        m_settingsChanged = false;
    }

    static CustomizeObjectSettingsPopup* create(GameObject* object, cocos2d::CCArray* objects, CustomizeObjectLayer* layer) = win inline, imac 0x1f8210 {
        auto ret = new CustomizeObjectSettingsPopup();
        if (ret->init(object, objects, layer)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void onClose(cocos2d::CCObject* sender) = win 0xaa580, m1 0x1a719c, imac 0x1f9840;
    virtual void onCustomToggleTriggerValue(cocos2d::CCObject* sender) = win 0xaa4d0, imac 0x1f97d0, m1 0x1a711c;

    bool init(GameObject* object, cocos2d::CCArray* objects, CustomizeObjectLayer* layer) = win 0xaa120;

    CustomizeObjectLayer* m_customizeLayer;
    bool m_settingsChanged;
}

[[link(android)]]
class CustomListView : BoomListView {
    CustomListView() {
        m_cellMode = 0;
    }

    static CustomListView* create(cocos2d::CCArray* entries, BoomListType type, float height, float width) {
        return CustomListView::create(entries, nullptr, height, width, 0, type, 0.0f);
    }
    static CustomListView* create(cocos2d::CCArray* entries, TableViewCellDelegate* delegate, float height, float width, int page, BoomListType type, float y) = win 0xaa740, imac 0x2401e0, m1 0x1e7a7c;
    static float getCellHeight(BoomListType type) = win 0xab520, m1 0x1e8508;

    virtual void setupList(float yOffset) = win 0xabcf0, m1 0x1f3fa8, imac 0x24d3a0;
    virtual TableViewCell* getListCell(char const* identifier) = win 0xaa870, imac 0x240320, m1 0x1e7b8c;
    virtual void loadCell(TableViewCell* cell, int index) = win 0xab630, imac 0x241ec0, m1 0x1e8bc8;

    void reloadAll() = win 0xac3c0, m1 0x1f4564;

    int m_cellMode;
}

[[link(android)]]
class CustomMusicCell : CustomSongCell {
    // virtual ~CustomMusicCell();
    CustomMusicCell(char const* identifier, float width, float height) = win inline, m1 0x1fa17c, ios inline : CustomSongCell(identifier, width, height) {
        this->init();
    }

    void loadFromObject(SongInfoObject* object) = win 0xb4e90, imac 0x243be0, m1 0x1ea940;
    void updateBGColor(int index) = win inline, imac 0x243d20, m1 0x1eaa70 {
        m_backgroundLayer->setColor(index % 2 == 0 ? cocos2d::ccColor3B { 50, 50, 50 } : cocos2d::ccColor3B { 75, 75, 75 });
        m_backgroundLayer->setOpacity(255);
    }
}

[[link(android)]]
class CustomSFXCell : TableViewCell, CustomSFXDelegate {
    // virtual ~CustomSFXCell();
    CustomSFXCell(char const* identifier, float width, float height) = m1 0x1f9fa0, ios inline : TableViewCell(identifier, width, height) {
        this->init();
    }

    virtual bool init() = win 0xb4bb0, imac 0x253dc0, m1 0x1f9ff0;
    virtual void draw() = win 0xade40, m1 0x1fa094, imac 0x253ec0;
    virtual void sfxObjectSelected(SFXInfoObject* object) = win 0xb4cc0, imac 0x253de0, m1 0x1fa000;
    virtual int getActiveSFXID() = win 0xb48b0, imac 0x253e60, m1 0x1fa05c;

    void loadFromObject(SFXInfoObject* object) = win 0xb4bd0, imac 0x244170, m1 0x1eaf48;
    bool shouldReload() = win inline, imac 0x24e3c0, m1 0x1f4cf0, ios inline {
        return (m_sfxObject->m_sfxID == this->getActiveSFXID()) != m_selected;
    }
    void updateBGColor(int index) = win 0xb4d00;

    SFXInfoObject* m_sfxObject;
    bool m_selected;
    bool m_compactMode;
}

[[link(android)]]
class CustomSFXDelegate {
    virtual void sfxObjectSelected(SFXInfoObject* object) {}
    virtual int getActiveSFXID() { return 0; }
    virtual bool overridePlaySFX(SFXInfoObject* object) { return false; }
}

[[link(android)]]
class CustomSFXWidget : cocos2d::CCNode, MusicDownloadDelegate, FLAlertLayerProtocol {
    // virtual ~CustomSFXWidget();

    static CustomSFXWidget* create(SFXInfoObject* object, CustomSFXDelegate* delegate, bool showDelete, bool showPlay, bool showDownload, bool noBackground, bool compactMode) = win 0xc0660, imac 0x5e2360, m1 0x50cee0;

    virtual void downloadSFXFinished(int id) = win 0xc2620, m1 0x50f040, imac 0x5e45f0;
    virtual void downloadSFXFailed(int id, GJSongError errorType) = win 0xc26a0, imac 0x5e46a0, m1 0x50f0e0;
    virtual void songStateChanged() = win 0xc1f70, imac 0x5e4580, m1 0x50f018;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0xc27a0, imac 0x5e48c0, m1 0x50f338;

    void deleteSFX() = win inline, imac 0x5e40c0, m1 0x50eb68 {
        FMODAudioEngine::sharedEngine()->stopAllEffects();
        MusicDownloadManager::sharedState()->deleteSFX(m_sfxObject->m_sfxID);
        this->updateSFXInfo();
        m_errorLabel->setVisible(true);
        m_errorLabel->setColor({ 255, 100, 0 });
        m_errorLabel->setString("SFX Deleted");
        m_errorLabel->limitLabelWidth(230.f, .4f, .0f);
    }
    void downloadFailed() = win inline, m1 0x50ef64 {
        this->hideLoadingArt();
        this->unschedule(schedule_selector(CustomSFXWidget::updateDownloadProgress));
        m_showCancel = false;
        this->updateSFXInfo();
    }
    void hideLoadingArt() = win 0xc1930, m1 0x50e328;
    bool init(SFXInfoObject* object, CustomSFXDelegate* delegate, bool showDelete, bool showPlay, bool showDownload, bool noBackground, bool compactMode) = win 0xc07a0, imac 0x5e2480;
    void onCancelDownload(cocos2d::CCObject* sender);
    void onDelete(cocos2d::CCObject* sender) = win 0xc1690;
    void onDownload(cocos2d::CCObject* sender) = win 0xc1a50, imac 0x5e33d0, m1 0x50de94;
    void onPlayback(cocos2d::CCObject* sender) = win 0xc1c20, m1 0x50e114;
    void onSelect(cocos2d::CCObject* sender) = win 0xc1c00, imac 0x5e3650, m1 0x50e0f4;
    void showLoadingArt() = win 0xc17d0, imac 0x5e41c0, m1 0x50ec74;
    void startDownload() = win inline, m1 0x50ede8 {
        m_showCancel = false;
        MusicDownloadManager::sharedState()->downloadSFX(m_sfxID);
        this->startMonitorDownload();
    }
    void startMonitorDownload() = win 0xc1b50, m1 0x50eabc;
    void updateDownloadProgress(float dt) = win 0xc1e40, m1 0x50eea0;
    void updateError(GJSongError errorType) = win inline, imac 0x5e4760, m1 0x50f1ac {
        m_errorLabel->setVisible(true);
        m_errorLabel->setColor({ 255, 50, 25 });
        switch (errorType) {
            case GJSongError::FailedToFetch:
                m_errorLabel->setString("Failed to fetch SFX info.");
                break;
            case GJSongError::NotAllowed:
                m_errorLabel->setString("SFX is not allowed for use.");
                break;
            case GJSongError::DownloadCancelled:
                m_errorLabel->setString("Download canceled.");
                break;
            default:
                m_errorLabel->setString("Download failed. Please try again later.");
                break;
        }
        m_errorLabel->limitLabelWidth(230.f, .4f, .0f);
    }
    void updateLengthMod(float mod) = win inline, imac 0x5e45b0, m1 0x50f024 {
        m_lengthMod = mod;
        this->updateSFXInfo();
    }
    void updatePlaybackBtn() = win inline, imac 0x5e40b0, m1 0x50eb64, ios inline {}
    void updateProgressBar(int progress) = m1 0x50e2b0;
    void updateSFXInfo() = win 0xc1f80, imac 0x496c80, m1 0x50e448;
    void updateSFXObject(SFXInfoObject* object) = win inline, imac 0x5e3910, m1 0x50e3bc {
        m_errorLabel->setVisible(false);
        if (m_sfxObject != object) {
            CC_SAFE_RETAIN(object);
            CC_SAFE_RELEASE(m_sfxObject);
            m_sfxObject = object;
        }
        if (m_sfxObject) m_sfxID = m_sfxObject->m_sfxID;
        else m_sfxID = 0;
        this->updateSFXInfo();
    }
    bool verifySFXID(int id) = win inline, imac 0x5e45d0, m1 0x3b1b24, ios inline {
        return m_sfxID == id && m_sfxID != 0;
    }

    SFXInfoObject* m_sfxObject;
    cocos2d::CCMenu* m_buttonMenu;
    cocos2d::CCLabelBMFont* m_titleLabel;
    cocos2d::CCLabelBMFont* m_idLabel;
    cocos2d::CCLabelBMFont* m_errorLabel;
    CCMenuItemSpriteExtra* m_downloadButton;
    CCMenuItemSpriteExtra* m_cancelButton;
    CCMenuItemSpriteExtra* m_selectButton;
    CCMenuItemSpriteExtra* m_playButton;
    CCMenuItemSpriteExtra* m_deleteButton;
    cocos2d::CCSprite* m_progressOutlineSprite;
    cocos2d::CCSprite* m_progressBarSprite;
    cocos2d::CCSprite* m_clockSprite;
    CustomSFXDelegate* m_delegate;
    bool m_showDelete;
    bool m_showPlay;
    bool m_showDownload;
    bool m_showCancel;
    bool m_compactMode;
    int m_sfxID;
    float m_lengthMod;
}

[[link(android)]]
class CustomSongCell : TableViewCell, CustomSongDelegate {
    // virtual ~CustomSongCell();
    CustomSongCell(char const* identifier, float width, float height) = win 0xb4570, imac 0x253940, m1 0x1f9ce0, ios inline : TableViewCell(identifier, width, height) {
        this->init();
    }

    virtual bool init() = win 0xb46a0, imac 0x2539c0, m1 0x1f9d2c;
    virtual void draw() = win 0xade40, m1 0x1f9eb8, imac 0x253bd0;
    virtual void songIDChanged(int id) = win 0xb4870, imac 0x253ab0, m1 0x1f9dfc;
    virtual int getActiveSongID() = win 0xb48b0, imac 0x253b30, m1 0x1f9e58;
    virtual gd::string getSongFileName() = win 0xb48d0, imac 0x253b90, m1 0x1f9e90;
    virtual LevelSettingsObject* getLevelSettings() = win inline, imac 0x253bb0, m1 0x1f9ea8 { return nullptr; }

    void loadFromObject(SongInfoObject* object) = win 0xb46b0, imac 0x2439e0, m1 0x1ea718;
    void onDelete(cocos2d::CCObject* sender) = win 0xb4900, imac 0x2539e0, m1 0x1f9d38;
    bool shouldReload() = win inline, imac 0x24e400, m1 0x1f4d34, ios inline {
        return (m_songInfoObject->m_songID == this->getActiveSongID()) != m_selected;
    }
    void updateBGColor(int index) = win inline, imac 0x243b80, m1 0x1ea8c0 {
        m_backgroundLayer->setColor(index % 2 == 0 ? cocos2d::ccColor3B { 50, 50, 50 } : cocos2d::ccColor3B { 75, 75, 75 });
        m_backgroundLayer->setOpacity(255);
    }

    SongInfoObject* m_songInfoObject;
    bool m_selected;
}

[[link(android)]]
class CustomSongDelegate {
    virtual void songIDChanged(int id) {}
    virtual int getActiveSongID() { return 0; }
    virtual gd::string getSongFileName() { return ""; }
    virtual LevelSettingsObject* getLevelSettings() { return nullptr; }
}

[[link(android)]]
class CustomSongLayer : FLAlertLayer, TextInputDelegate, GJDropDownLayerDelegate, MusicBrowserDelegate {
    // virtual ~CustomSongLayer();
    CustomSongLayer() {
        m_songDelegate = nullptr;
        m_songIDInput = nullptr;
        m_delegate = nullptr;
    }

    static CustomSongLayer* create(CustomSongDelegate* delegate) = win inline, m1 0x1bfe00 {
        auto ret = new CustomSongLayer();
        if (ret->init(delegate)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyBackClicked() = win 0xc44a0, m1 0x1c15ac, imac 0x215fd0;
    virtual void show() = win 0xc44b0, imac 0x2160c0, m1 0x1c1698;
    virtual void textChanged(CCTextInputNode* node) = win 0xc3e50, imac 0x215a60, m1 0x1c107c;
    virtual void textInputOpened(CCTextInputNode* node) = win 0xc3da0, m1 0x1c0ffc, imac 0x215a00;
    virtual void textInputClosed(CCTextInputNode* node) = win 0xc3da0, m1 0x1c0f7c, imac 0x2159a0;
    virtual void textInputShouldOffset(CCTextInputNode* node, float yOffset) = win 0x7b620, m1 0x1c109c, imac 0x215a80;
    virtual void textInputReturn(CCTextInputNode* node) = win 0x7b680, m1 0x1c116c, imac 0x215b40;
    virtual void dropDownLayerWillClose(GJDropDownLayer* layer) = win 0xc4230, m1 0x1c141c, imac 0x215e70;
    virtual void musicBrowserClosed(MusicBrowser* browser) = win 0xc4300, m1 0x1c14e4, imac 0x215f20;

    bool init(CustomSongDelegate* delegate) = win 0xc2c40;
    void onClose(cocos2d::CCObject* sender) = win 0xc43d0, m1 0x1c0a94;
    void onCreateLines(cocos2d::CCObject* sender) = m1 0x1c0bec;
    void onMusicBrowser(cocos2d::CCObject* sender) = win 0xc3ee0, imac 0x215570, m1 0x1c0b88;
    void onNCSBrowser(cocos2d::CCObject* sender) = imac 0x215550, m1 0x1c0b6c;
    void onNewgroundsBrowser(cocos2d::CCObject* sender) = win 0xc4040, imac 0x2155c0, m1 0x1c0bd0;
    void onOptions(cocos2d::CCObject* sender) = imac 0x215620, m1 0x1c0c28;
    void onSearch(cocos2d::CCObject* sender) = win 0xc39c0, m1 0x1c0c48;
    void onSongBrowser(cocos2d::CCObject* sender) = m1 0x1c0b08;
    void showNewgroundsMessage() = win inline, imac 0x2157b0, m1 0x1c0dc4 {
        FLAlertLayer::create(
            nullptr,
            "Newgrounds Info",
            "There are thousands of great custom songs for you to choose from Newgrounds. "
            "Please do not upload music you did not create. "
            "You are only allowed to use songs from artists that have been scouted on Newgrounds. "
            "For more information, please check the <cy>Audio Guidelines</c>.",
            "OK",
            nullptr,
            380.f
        )->show();
    }

    CustomSongDelegate* m_songDelegate;
    CCTextInputNode* m_songIDInput;
    CustomSongWidget* m_songWidget;
    CustomSongLayerDelegate* m_delegate;
}

[[link(android)]]
class CustomSongLayerDelegate {
    virtual void customSongLayerClosed() {}
}

[[link(android), depends(GJAssetDownloadAction)]]
class CustomSongWidget : cocos2d::CCNode, MusicDownloadDelegate, FLAlertLayerProtocol {
    CustomSongWidget() {
        m_songInfoObject = nullptr;
        m_songLabel = nullptr;
        m_artistLabel = nullptr;
        m_songIDLabel = nullptr;
        m_downloadBtn = nullptr;
        m_selectSongBtn = nullptr;
        m_playbackBtn = nullptr;
        m_deleteBtn = nullptr;
        m_sliderGroove = nullptr;
        m_sliderBar = nullptr;
        m_ncsLogo = nullptr;
        m_bgSpr = nullptr;
        m_songDelegate = nullptr;
        m_showSelectSongBtn = false;
        m_showPlayMusicBtn = false;
        m_showDownloadBtn = false;
        m_isNotDownloading = false;
        m_isRobtopSong = false;
        m_isMusicLibrary = false;
        m_customSongID = 0;
        m_lengthMod = 0.f;
        m_isInCell = false;
        m_playbackDelegate = nullptr;
        m_hasLibrarySongs = false;
        m_hasSFX = false;
        m_unkBool2 = false;
        m_totalBytes = 0;
    }
    ~CustomSongWidget() = win inline, m1 0x53e3dc {
        MusicDownloadManager::sharedState()->removeMusicDownloadDelegate(this);
        CC_SAFE_RELEASE(m_songInfoObject);
    }

    static CustomSongWidget* create(SongInfoObject* songInfo, CustomSongDelegate* songDelegate, bool showSongSelect, bool showPlayMusic, bool showDownload, bool isRobtopSong, bool unkBool, bool isMusicLibrary, int unk) = win 0xc8250, imac 0x370c10;

    virtual void loadSongInfoFinished(SongInfoObject* object) = win 0xccca0, imac 0x61fc70, m1 0x54391c;
    virtual void loadSongInfoFailed(int id, GJSongError errorType) = win 0xcce30, m1 0x543bc0, imac 0x61ff50;
    virtual void downloadSongFinished(int id) = win 0xccf20, m1 0x543ebc, imac 0x620250;
    virtual void downloadSongFailed(int id, GJSongError errorType) = win 0xccf40, m1 0x544050, imac 0x6203f0;
    virtual void downloadSFXFinished(int id) = win 0xcd080, imac 0x620910, m1 0x54455c;
    virtual void downloadSFXFailed(int id, GJSongError errorType) = win 0xcd0a0, m1 0x544570, imac 0x620940;
    virtual void musicActionFinished(GJMusicAction action) = win 0xcd650, imac 0x620d80, m1 0x544948;
    virtual void musicActionFailed(GJMusicAction action) = win 0xcd680, m1 0x544990, imac 0x620de0;
    virtual void songStateChanged() = win 0xcb4e0, m1 0x542ac0, imac 0x61ed90;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0xcd9f0, imac 0x620e80, m1 0x544a2c;

    void addExtraVisuals(bool newMusic, bool newLibraryMusic) = win inline {
        if (newMusic && !newLibraryMusic) {
            auto newMusicIcon = cocos2d::CCSprite::createWithSpriteFrameName("newMusicIcon_001.png");
            this->addChild(newMusicIcon, 4);
            newMusicIcon->setPosition({ -157.f, 20.f });
        }
        if (!newMusic && newLibraryMusic) {
            auto newMusicIcon = cocos2d::CCSprite::createWithSpriteFrameName("newMusicIcon2_001.png");
            this->addChild(newMusicIcon, 4);
            newMusicIcon->setPosition({ -157.f, 20.f });
            auto background = cocos2d::extension::CCScale9Sprite::create("GJ_square07.png", { 0.f, 0.f, 80.f, 80.f });
            background->setColor({ 255, 255, 0 });
            background->setContentSize({ 320.f, 30.f });
            this->addChild(background, -1);
        }
    }
    void deleteSong() = win 0xca040, imac 0x61e370, m1 0x5421ac;
    void downloadAssetFailed(int id, GJAssetType type, GJSongError errorType);
    void downloadAssetFinished(int id, GJAssetType type) = win 0xcd4c0;
    void downloadFailed() = win inline, m1 0x542a74 {
        m_sliderGroove->setVisible(false);
        this->unschedule(schedule_selector(CustomSongWidget::updateDownloadProgress));
        m_isNotDownloading = true;
        this->updateSongInfo();
    }
    void getSongInfoIfUnloaded() = win 0xcaa00, imac 0x61e6f0;
    bool init(SongInfoObject* songInfo, CustomSongDelegate* songDelegate, bool showSongSelect, bool showPlayMusic, bool showDownload, bool isRobtopSong, bool unkBool, bool isMusicLibrary, int unk) = win 0xc8490;
    void onCancelDownload(cocos2d::CCObject* sender) = win 0xcaac0;
    void onDelete(cocos2d::CCObject* sender) = win 0xc9f20;
    void onDownload(cocos2d::CCObject* sender) = win 0xcabe0, imac 0x61b4d0, m1 0x53f684;
    void onGetSongInfo(cocos2d::CCObject* sender) = win 0xcab50;
    void onInfo(cocos2d::CCObject* sender) = win 0xc9c30;
    void onMore(cocos2d::CCObject* sender) = win 0xca240, imac 0x61bc00, m1 0x53fd70;
    void onPlayback(cocos2d::CCObject* sender) = win 0xcaee0, imac 0x61b970, m1 0x53fadc;
    void onSelect(cocos2d::CCObject* sender) = win 0xcae80, imac 0x61b880, m1 0x53f9f0;
    void positionInfoObjects() = win 0x2940b0;
    void processNextMultiAsset();
    void showError(bool fast) = win 0xcd7a0, m1 0x5422f0;
    void startDownload() = win 0xcadc0, m1 0x5428ec;
    void startMonitorDownload() = win inline, m1 0x541ed8 {
        this->updateProgressBar(0);
        m_sliderGroove->setVisible(true);
        this->unschedule(schedule_selector(CustomSongWidget::updateDownloadProgress));
        this->schedule(schedule_selector(CustomSongWidget::updateDownloadProgress), 1.f / 30.f);
    }
    void startMultiAssetDownload() = win 0xcd0c0;
    void toggleUpdateButton(bool enabled) = win inline, imac 0x61e7f0, m1 0x5425fc, ios inline {
        m_getSongInfoBtn->setColor(enabled ? cocos2d::ccColor3B { 255, 255, 255 } : cocos2d::ccColor3B { 166, 166, 166 });
        m_getSongInfoBtn->setEnabled(enabled);
    }
    void updateDownloadProgress(float dt) = win 0xcb3b0, m1 0x5429b0;
    void updateError(GJSongError errorType) = win 0xcd6d0, imac 0x620170, m1 0x543dd8;
    void updateLengthMod(float lengthMod) = win inline, m1 0x542b0c {
        this->m_lengthMod = lengthMod;
        this->updateSongInfo();
    }
    void updateMultiAssetInfo(bool update) = win 0xcc6c0, imac 0x61f5d0, m1 0x3be7c;
    void updatePlaybackBtn() = win 0xcb2c0;
    void updateProgressBar(int progress) = win 0xcb460, m1 0x540f44;
    void updateSongInfo() = win 0xcb510, m1 0x541060;
    void updateSongObject(SongInfoObject* songInfo) = win inline, imac 0x61d0d0, m1 0x540fbc {
        m_errorLabel->setVisible(false);
        if (m_bgSpr) m_bgSpr->setVisible(false);
        if (m_songInfoObject != songInfo) {
            CC_SAFE_RETAIN(songInfo);
            CC_SAFE_RELEASE(m_songInfoObject);
            m_songInfoObject = songInfo;
        }
        m_customSongID = songInfo ? songInfo->m_songID : 0;
        this->updateSongInfo();
    }
    void updateWithMultiAssets(gd::string songList, gd::string sfxList, int bytes) = win 0xcc370, imac 0x61ee00, m1 0x542b14;
    bool verifySongID(int id) = win inline, imac 0x61fc50, ios inline {
        return m_customSongID == id && m_customSongID != 0;
    }

    SongInfoObject* m_songInfoObject;
    cocos2d::CCMenu* m_buttonMenu;
    cocos2d::CCLabelBMFont* m_songLabel;
    cocos2d::CCLabelBMFont* m_artistLabel;
    cocos2d::CCLabelBMFont* m_songIDLabel;
    cocos2d::CCLabelBMFont* m_errorLabel;
    CCMenuItemSpriteExtra* m_downloadBtn;
    CCMenuItemSpriteExtra* m_cancelDownloadBtn;
    CCMenuItemSpriteExtra* m_selectSongBtn;
    CCMenuItemSpriteExtra* m_getSongInfoBtn;
    CCMenuItemSpriteExtra* m_playbackBtn;
    CCMenuItemSpriteExtra* m_moreBtn;
    CCMenuItemSpriteExtra* m_deleteBtn;
    CCMenuItemSpriteExtra* m_infoBtn;
    cocos2d::CCSprite* m_sliderGroove;
    cocos2d::CCSprite* m_sliderBar;
    cocos2d::CCSprite* m_ncsLogo;
    cocos2d::extension::CCScale9Sprite* m_bgSpr;
    CustomSongDelegate* m_songDelegate;
    bool m_showSelectSongBtn;
    bool m_showPlayMusicBtn;
    bool m_showDownloadBtn;
    bool m_isNotDownloading;
    bool m_isRobtopSong;
    bool m_isMusicLibrary;
    int m_customSongID;
    float m_lengthMod;
    bool m_isInCell;
    SongPlaybackDelegate* m_playbackDelegate;
    bool m_hasLibrarySongs;
    bool m_hasSFX;
    bool m_unkBool2;
    gd::map<int, bool> m_songs;
    gd::map<int, bool> m_sfx;
    gd::vector<GJAssetDownloadAction> m_undownloadedAssets;
    int m_totalBytes;
    gd::set<int> m_nextSongIDs;
}

[[link(android)]]
class DailyLevelNode : cocos2d::CCNode, FLAlertLayerProtocol {
    DailyLevelNode() {
        m_level = nullptr;
        m_page = nullptr;
        m_timeLabel = nullptr;
        m_unkBool = false;
        m_needsDownloading = false;
    }
    ~DailyLevelNode() = win inline, m1 0x1dbcb0 {
        cocos2d::CCDirector::sharedDirector()->getTouchDispatcher()->unregisterForcePrio(this);
        CC_SAFE_RELEASE(m_level);
    }

    static DailyLevelNode* create(GJGameLevel* level, DailyLevelPage* page, bool isNew) = win inline, imac 0x231ba0, m1 0x1db5d4 {
        auto ret = new DailyLevelNode();
        if (ret->init(level, page, isNew)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0xd3180, m1 0x1dccac, imac 0x2331f0;

    bool init(GJGameLevel* level, DailyLevelPage* page, bool isNew) = win 0xd20e0;
    void onClaimReward(cocos2d::CCObject* sender) = win 0xd2e40;
    void onSkipLevel(cocos2d::CCObject* sender) = win 0xd2f60;
    void showSkipButton() = win 0xd2de0, imac 0x231720, m1 0x1db138;
    void updateTimeLabel(gd::string text) = win inline, imac 0x2315b0, m1 0x1dafdc, ios inline {
        if (m_timeLabel) m_timeLabel->setString(text.c_str());
    }

    GJGameLevel* m_level;
    DailyLevelPage* m_page;
    cocos2d::CCLabelBMFont* m_timeLabel;
    cocos2d::CCPoint m_unkPoint;
    CCMenuItemSpriteExtra* m_skipButton;
    bool m_unkBool;
    bool m_needsDownloading;
}

[[link(android)]]
class DailyLevelPage : FLAlertLayer, FLAlertLayerProtocol, GJDailyLevelDelegate, LevelDownloadDelegate {
    // virtual ~DailyLevelPage();
    //DailyLevelPage() = ios 0x1c66c0;

    static DailyLevelPage* create(GJTimedLevelType type) = win 0xce420, m1 0x1d9260;

    virtual void registerWithTouchDispatcher() = win 0x42660, m1 0x1db950, imac 0x231f20;
    virtual void keyBackClicked() = win 0x869f0, m1 0x1db8b4, imac 0x231e90;
    virtual void show() = win 0x86810, m1 0x1db724, imac 0x231cf0;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win inline, m1 0x1db8ac, imac 0x231e70 {}
    virtual void dailyStatusFinished(GJTimedLevelType type) = win 0xcf9b0, imac 0x231360, m1 0x1dada0;
    virtual void dailyStatusFailed(GJTimedLevelType type, GJErrorCode errorType) = win 0xcfcb0, imac 0x2317b0, m1 0x1db1ac;
    virtual void levelDownloadFinished(GJGameLevel* level) = win 0xcffe0, m1 0x1db418, imac 0x231a00;
    virtual void levelDownloadFailed(int response) = win 0xd0040, m1 0x1db500, imac 0x231ac0;

    void claimLevelReward(DailyLevelNode* node, GJGameLevel* level, cocos2d::CCPoint position) = win 0xd1b00, m1 0x1db988;
    void createDailyNode(GJGameLevel* level, bool instant, float delay, bool isNew) = win 0xd0290, imac 0x231170, m1 0x1dabbc;
    void createNodeIfLoaded() = win 0xd01a0, m1 0x1db540;
    void downloadAndCreateNode() = win 0xd00f0, m1 0x1db0c4;
    void exitDailyNode(DailyLevelNode* node, float delay) = win 0xd0580, imac 0x2315f0, m1 0x1db00c;
    int getDailyTime() = win inline, m1 0x1db6ac {
        __timeb64 current;
        _ftime64_s(&current);
        auto currentTime = ((current.time & 0xfffff) * 1000 + current.millitm) / 1000.0;
        return std::max<int>(GameLevelManager::sharedState()->getDailyTimer(m_type) - currentTime, 0);
    }
    gd::string getDailyTimeString(int timeLeft) = win 0xd0650, imac 0x230ae0, m1 0x1da340;
    bool init(GJTimedLevelType type) = win 0xce560, imac 0x22fe10;
    void onClose(cocos2d::CCObject* sender) = win 0x869b0, m1 0x1da288;
    void onTheSafe(cocos2d::CCObject* sender) = win 0xd2000, imac 0x230a70, m1 0x1da2d4;
    void refreshDailyPage() = win inline {
        if (auto dailyNode = m_dailyNode) {
            if (dailyNode->m_needsDownloading) return;
            if (auto level = dailyNode->m_level) {
                m_dailyNode = nullptr;
                this->createDailyNode(level, true, 0.f, false);
                dailyNode->removeMeAndCleanup();
            }
        }
    }
    void skipDailyLevel(DailyLevelNode* node, GJGameLevel* level) = win 0xd1dd0, m1 0x1dbb40;
    void tryGetDailyStatus() = win 0xd0060;
    callback void updateTimers(float dt) = win 0xd17b0, m1 0x1da960;

    cocos2d::CCLabelBMFont* m_timeLabel;
    LoadingCircle* m_timeCircle;
    LoadingCircle* m_nodeCircle;
    bool m_gettingDailyStatus;
    DailyLevelNode* m_dailyNode;
    bool m_downloadStarted;
    GJTimedLevelType m_type;
    int m_downloadLevelID;
}

[[link(android)]]
class DashRingObject : RingObject {
    // virtual ~DashRingObject();
    DashRingObject() {
        m_dashSpeed = 1.f;
        m_endBoost = 1.f;
        m_maxDuration = 0.f;
        m_allowCollide = false;
        m_stopSlide = false;
    }

    static DashRingObject* create(char const* frame) = win inline {
        auto ret = new DashRingObject();
        if (ret->init(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4a2120, m1 0x16ed28, imac 0x1b4de0;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x4a2360, m1 0x16ee80, imac 0x1b4f50;

    bool init(char const* frame) = win inline, m1 0x16ecd8, ios inline {
        return RingObject::init(frame);
    }

    // property 586
    float m_dashSpeed;
    // property 588
    float m_endBoost;
    // property 590
    float m_maxDuration;
    // property 587
    bool m_allowCollide;
    // property 589
    bool m_stopSlide;
}

[[link(android)]]
class DelayedSpawnNode {
    EffectGameObject* m_gameObject;
    float m_spawnDelay;
}

[[link(android)]]
class DemonFilterDelegate {
    virtual void demonFilterSelectClosed(int filter) {}
}

[[link(android)]]
class DemonFilterSelectLayer : FLAlertLayer {
    DemonFilterSelectLayer() {
        m_demons = nullptr;
        m_unkPtr = nullptr;
        m_currentDemon = 0;
        m_delegate = nullptr;
    }
    ~DemonFilterSelectLayer() = win inline {
        CC_SAFE_RELEASE(m_demons);
    }

    static DemonFilterSelectLayer* create() = win inline, m1 0x54e690 {
        auto ret = new DemonFilterSelectLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x3176d0, m1 0x551e94, imac 0x62ef70;
    virtual void keyBackClicked() = win 0x317e20, imac 0x62f550, m1 0x552484;

    void onClose(cocos2d::CCObject* sender) = win 0x317dd0, imac 0x62f500, m1 0x552424;
    void selectRating(cocos2d::CCObject* sender) = win 0x317d10, m1 0x55235c;

    cocos2d::CCArray* m_demons;
    void* m_unkPtr;
    int m_currentDemon;
    DemonFilterDelegate* m_delegate;
}

[[link(android)]]
class DemonInfoPopup : FLAlertLayer {
    // ~DemonInfoPopup();

    static DemonInfoPopup* create(int easyClassic, int mediumClassic, int hardClassic, int insaneClassic, int extremeClassic, int easyPlatformer, int mediumPlatformer, int hardPlatformer, int insanePlatformer, int extremePlatformer, int weekly, int gauntlet) = win 0x3c6ce0, imac 0x7c0cb0, m1 0x6c6274;
    static DemonInfoPopup* createFromString(gd::string str) = win 0x3c6910, imac 0x7be890, m1 0x6c3e18;

    virtual void keyBackClicked() = win 0x846c0, imac 0x7c17d0, m1 0x6c6d44;

    bool init(int easyClassic, int mediumClassic, int hardClassic, int insaneClassic, int extremeClassic, int easyPlatformer, int mediumPlatformer, int hardPlatformer, int insanePlatformer, int extremePlatformer, int weekly, int gauntlet) = win 0x3c6e40;
    void onClose(cocos2d::CCObject* sender) = win 0x84690, imac 0x7c17a0, m1 0x6c6d08;
}

[[link(android)]]
class DialogDelegate {
    virtual void dialogClosed(DialogLayer* layer) {}
}

[[link(android)]]
class DialogLayer : cocos2d::CCLayerColor, TextAreaDelegate {
    DialogLayer() {
        m_animateTime = 0.f;
        m_mainLayer = nullptr;
        m_characterLabel = nullptr;
        m_textArea = nullptr;
        m_characterSprite = nullptr;
        m_dialogObjects = nullptr;
        m_touchID = -1;
        m_navButtonSprite = nullptr;
        m_animating = false;
        m_skippable = false;
        m_delegate = nullptr;
        m_handleTap = false;
        m_animationType = DialogAnimationType::FromCenter;
        m_noRemove = false;
    }
    ~DialogLayer() = win inline, m1 0x348034 {
        cocos2d::CCDirector::sharedDirector()->getTouchDispatcher()->unregisterForcePrio(this);
        CC_SAFE_RELEASE(m_dialogObjects);
    }

    static DialogLayer* create(DialogObject* object, int background) = win inline, imac 0x3c6cf0, m1 0x348274 {
        return DialogLayer::createDialogLayer(object, nullptr, background);
    }
    static DialogLayer* createDialogLayer(DialogObject* object, cocos2d::CCArray* objects, int background) = win 0xd34b0, imac 0x3c6d00, m1 0x348280;
    static DialogLayer* createWithObjects(cocos2d::CCArray* objects, int background) = win inline, imac 0x3c6e40, m1 0x348390 {
        return DialogLayer::createDialogLayer(nullptr, objects, background);
    }

    virtual void onEnter() = win 0x52e40, m1 0x34932c, imac 0x3c7e80;
    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0xd40b0, m1 0x349200, imac 0x3c7d30;
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline, imac 0x3c7dd0, m1 0x3492a8 {}
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0xd40e0, imac 0x3c7d90, m1 0x349270;
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0xd4100, imac 0x3c7df0, m1 0x3492b0;
    virtual void registerWithTouchDispatcher() = win 0x52df0, m1 0x3492f4, imac 0x3c7e40;
    virtual void keyBackClicked() = win 0xd4020, imac 0x3c7c00, m1 0x3490dc;
    virtual void keyDown(cocos2d::enumKeyCodes key, double timestamp) = win 0xd43d0, imac 0x3c8200, m1 0x349688;
    virtual void fadeInTextFinished(TextArea* textArea) = win 0xd4120, m1 0x349330, imac 0x3c7e90;

    void addToMainScene() = win 0xd3fc0, m1 0x349084;
    void animateIn(DialogAnimationType type) = win inline, imac 0x3c7fd0 {
        __timeb64 current;
        _ftime64_s(&current);
        m_animateTime = ((current.time & 0xfffff) * 1000 + current.millitm) / 1000.0;
        auto director = cocos2d::CCDirector::sharedDirector();
        switch (type) {
            case DialogAnimationType::FromCenter: {
                m_mainLayer->setScale(.1f);
                m_mainLayer->runAction(cocos2d::CCEaseElasticOut::create(cocos2d::CCScaleTo::create(.5f, 1.f), .6f));
                break;
            }
            case DialogAnimationType::FromLeft: {
                auto position = m_mainLayer->getPosition();
                m_mainLayer->setPosition({ -191.f, position.y });
                m_mainLayer->runAction(cocos2d::CCEaseElasticOut::create(cocos2d::CCMoveTo::create(.5f, position), .6f));
                break;
            }
            case DialogAnimationType::FromRight: {
                auto position = m_mainLayer->getPosition();
                m_mainLayer->setPosition({ director->getScreenRight() + 191.f, position.y });
                m_mainLayer->runAction(cocos2d::CCEaseElasticOut::create(cocos2d::CCMoveTo::create(.5f, position), .6f));
                break;
            }
            case DialogAnimationType::FromTop: {
                auto position = m_mainLayer->getPosition();
                m_mainLayer->setPosition({ position.x, director->getScreenTop() + 51.f });
                m_mainLayer->runAction(cocos2d::CCEaseElasticOut::create(cocos2d::CCMoveTo::create(.5f, position), .6f));
                break;
            }
            case DialogAnimationType::FromTop2: {
                auto position = m_mainLayer->getPosition();
                m_mainLayer->setPosition({ position.x, director->getScreenTop() - 51.f });
                m_mainLayer->runAction(cocos2d::CCEaseElasticOut::create(cocos2d::CCMoveTo::create(.5f, position), .6f));
                break;
            }
            default: break;
        }

        auto opacity = this->getOpacity();
        if (opacity > 0) {
            this->setOpacity(0);
            this->runAction(cocos2d::CCFadeTo::create(.14f, opacity));
        }
    }
    void animateInDialog() = win inline, m1 0x349680, ios inline {
        this->animateIn(m_animationType);
    }
    void animateInRandomSide() = win 0xd4190;
    void displayDialogObject(DialogObject* object) = win 0xd3ac0, m1 0x348914;
    void displayNextObject() = win 0xd3a60, m1 0x348874;
    void finishCurrentAnimation() = win inline, imac 0x3c7a60, m1 0x348f5c {
        m_animating = false;
        if (m_textArea) {
            m_textArea->m_delegate = nullptr;
            m_textArea->stopAllCharacterActions();
            m_textArea->showAll();
        }
        m_navButtonSprite->stopAllActions();
        m_navButtonSprite->setOpacity(255);
        this->updateNavButtonFrame();
    }
    void handleDialogTap() = win 0xd3e90, m1 0x348dfc;
    bool init(DialogObject* object, cocos2d::CCArray* objects, int background) = win 0xd3600;
    void onClose() = win 0xd4030, imac 0x3c7b20;
    void updateChatPlacement(DialogChatPlacement placement) = win inline, m1 0x348d40 {
        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
            switch (placement) {
                case DialogChatPlacement::Center:
                        m_mainLayer->setPosition({winSize.width * 0.5F, winSize.height * 0.5F});
                        break;
                case DialogChatPlacement::Top:
                        m_mainLayer->setPosition({winSize.width * 0.5F, (winSize.height - 50.F) - 20.F});
                        break;
                case DialogChatPlacement::Bottom:
                        m_mainLayer->setPosition({winSize.width * 0.5F, 70.F});
                        break;
            }
    }
    void updateNavButtonFrame() = win 0xd3e10, imac 0x3c77e0, m1 0x348ce0;

    float m_animateTime;
    cocos2d::CCLayer* m_mainLayer;
    cocos2d::CCLabelBMFont* m_characterLabel;
    TextArea* m_textArea;
    cocos2d::CCSprite* m_characterSprite;
    cocos2d::CCArray* m_dialogObjects;
    int m_touchID;
    cocos2d::CCSprite* m_navButtonSprite;
    bool m_animating;
    bool m_skippable;
    DialogDelegate* m_delegate;
    bool m_handleTap;
    DialogAnimationType m_animationType;
    bool m_noRemove;
}

[[link(android)]]
class DialogObject : cocos2d::CCObject {
    // virtual ~DialogObject();
    DialogObject() {
        m_characterFrame = 0;
        m_textScale = 1.f;
        m_skippable = false;
    }

    static DialogObject* create(gd::string character, gd::string text, int characterFrame, float textScale, bool skippable, cocos2d::ccColor3B color) = win 0xd32f0, imac 0x3c67a0, m1 0x347e04;

    bool init(gd::string character, gd::string text, int characterFrame, float textScale, bool skippable, cocos2d::ccColor3B color) = win inline, imac 0x3c6930, m1 0x347fbc, ios inline {
        m_character = character;
        m_text = text;
        m_characterFrame = characterFrame;
        m_textScale = textScale;
        m_color = color;
        m_skippable = skippable;
        return true;
    }

    gd::string m_text;
    gd::string m_character;
    int m_characterFrame;
    cocos2d::ccColor3B m_color;
    float m_textScale;
    bool m_skippable;
}

[[link(android)]]
class DownloadMessageDelegate {
    virtual void downloadMessageFinished(GJUserMessage* message) {}
    virtual void downloadMessageFailed(int id) {}
}

[[link(android)]]
class DrawGridLayer : cocos2d::CCLayer {
    // virtual ~DrawGridLayer();

    static DrawGridLayer* create(cocos2d::CCNode* parent, LevelEditorLayer* layer) = win 0x2e8950, imac 0xdcb10, m1 0xc2e0c;

    virtual void update(float dt) = win 0x2e8e50, m1 0xdfe3c, imac 0x100de0;
    virtual void draw() = win 0x2e9050, m1 0xdff50, imac 0x100f70;

    void addAudioLineObject(AudioLineGuideGameObject* object) = win inline, imac 0xea1b0, ios inline {
        m_audioLineObjects[object->m_uniqueID] = object;
    }
    void addToEffects(EffectGameObject* object) = win inline, m1 0xce1f4 {
        if (!m_effectGameObjects->containsObject(object)) {
            m_effectGameObjects->addObject(object);
            m_sortEffects = true;
        }
    }
    void addToGuides(GameObject* object) = win inline, m1 0xce6a4 {
        if (!m_guideObjects->containsObject(object)) {
            m_guideObjects->addObject(object);
        }
    }
    void addToSpeedObjects(EffectGameObject* object) = win inline, m1 0xce730 {
        if (!m_speedObjects->containsObject(object)) {
            m_speedObjects->addObject(object);
            m_updateSpeedObjects = true;
            object->updateSpeedModType();
        }
    }
    cocos2d::CCPoint getPortalMinMax(GameObject* object) = win inline, imac 0x100d00, m1 0xdfd70 {
        auto objectType = object->getType();
        float height;
        if (objectType == GameObjectType::BallPortal) height = 240.f;
        else if (objectType == GameObjectType::SpiderPortal) height = 270.f;
        else height = 300.f;
        auto minimum = std::max((int)((object->getPosition().y - height * .5f) / 30.f) * 30.f, 90.f);
        return { minimum, minimum + height };
    }
    bool init(cocos2d::CCNode* parent, LevelEditorLayer* layer) = win inline {
        if (!cocos2d::CCLayer::init()) return false;
        m_objectLayer = parent;
        m_editorLayer = layer;
        m_timeMarkers = nullptr;
        m_effectGameObjects = cocos2d::CCArray::create();
        m_effectGameObjects->retain();
        m_guideObjects = cocos2d::CCArray::create();
        m_guideObjects->retain();
        m_speedObjects = cocos2d::CCArray::create();
        m_speedObjects->retain();
        m_slowSpeed = 251.16008f;
        m_normalSpeed = 311.5801f;
        m_fastSpeed = 387.42014f;
        m_fasterSpeed = 468.00015f;
        m_fastestSpeed = 576.0002f;
        m_currentSpeed = 311.5801f;
        m_pointArray1 = new std::array<cocos2d::CCPoint, 400>();
        m_pointArray2 = new std::array<cocos2d::CCPoint, 400>();
        m_pointArray3 = new std::array<cocos2d::CCPoint, 400>();
        return true;
    }
    void loadTimeMarkers(gd::string markers) = win 0x2e8b30, imac 0xdefc0;
    cocos2d::CCPoint posForTime(float time) = win inline, imac 0xf0610, ios inline {
        return LevelTools::posForTime(time, m_speedObjects, (int)m_editorLayer->m_levelSettings->m_startSpeed, m_editorLayer->m_levelSettings->m_platformerMode, m_editorLayer->m_gameState.m_rotateChannel);
    }
    void postUpdate() = win inline, imac 0x100dc0, ios inline {
        m_oldPlaybackTime = m_playbackTime;
    }
    void removeAudioLineObject(AudioLineGuideGameObject* object) = win inline, imac 0xea760, ios inline {
        m_audioLineObjects.erase(object->m_uniqueID);
    }
    void removeFromEffects(EffectGameObject* object) = win inline, imac 0xea730, m1 0xce63c, ios inline {
        m_effectGameObjects->removeObject(object);
        m_sortEffects = true;
    }
    void removeFromGuides(GameObject* object) = win inline, m1 0xce698 {
        m_guideObjects->removeObject(object);
    }
    void removeFromSpeedObjects(EffectGameObject* object) = win inline, m1 0xce6e4 {
        if (m_speedObjects->containsObject(object)) {
            m_speedObjects->removeObject(object);
            m_updateSpeedObjects = true;
        }
    }
    void sortSpeedObjects() = win inline, imac 0x100ce0, m1 0xdfd60, ios inline {
        LevelTools::sortSpeedObjects(m_speedObjects, m_editorLayer);
    }
    float timeForPos(cocos2d::CCPoint position, int order, int channel, bool songTriggers, bool ignoreWarp, bool ignoreRotate, int id) = win inline, imac 0xeeb20, m1 0xd22a4 {
        return LevelTools::timeForPos(position, m_speedObjects, (int)m_editorLayer->m_levelSettings->m_startSpeed, order, channel, songTriggers, m_editorLayer->m_levelSettings->m_platformerMode, ignoreWarp, ignoreRotate, id);
    }
    void updateMusicGuideTime(float time) = win inline, imac 0x100f50 {
        m_musicTime = time;
        m_playbackTime = time;
        m_oldPlaybackTime = time;
    }
    void updateTimeMarkers() = win inline, imac 0xeea80, m1 0xd21f8 {
        m_updateTimeMarkers = true;
        m_updateSpeedObjects = false;
        this->sortSpeedObjects();
        this->loadTimeMarkers(m_timeMarkerString);
    }

    std::array<cocos2d::CCPoint, 400>* m_pointArray1;
    std::array<cocos2d::CCPoint, 400>* m_pointArray2;
    std::array<cocos2d::CCPoint, 400>* m_pointArray3;
    gd::unordered_map<int, AudioLineGuideGameObject*> m_audioLineObjects;
    float m_musicTime;
    float m_playbackTime;
    float m_oldPlaybackTime;
    float m_playbackX;
    float m_playbackY;
    bool m_sortEffects;
    LevelEditorLayer* m_editorLayer;
    gd::string m_timeMarkerString;
    cocos2d::CCNode* m_objectLayer;
    cocos2d::CCArray* m_timeMarkers;
    cocos2d::CCArray* m_effectGameObjects;
    cocos2d::CCArray* m_guideObjects;
    cocos2d::CCArray* m_speedObjects;
    double m_unk258;
    float m_currentSpeed;
    float m_slowSpeed;
    float m_normalSpeed;
    float m_fastSpeed;
    float m_fasterSpeed;
    float m_fastestSpeed;
    bool m_updateTimeMarkers;
    bool m_updateSpeedObjects;
    float m_gridSize;
}

[[link(android)]]
class DungeonBarsSprite : cocos2d::CCNode {
    // virtual ~DungeonBarsSprite();
    DungeonBarsSprite() {
        m_barsSprite = nullptr;
    }

    static DungeonBarsSprite* create() = win inline, imac 0x4a4670, m1 0x408224 {
        auto ret = new DungeonBarsSprite();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x3ef470, m1 0x40b6d8, imac 0x4a7f60;
    virtual void visit() = win 0x3ef4f0, imac 0x4a7fe0, m1 0x40b75c;

    void animateOutBars() = win inline, imac 0x4a6940, m1 0x40a278 {
        auto a1 = cocos2d::CCMoveBy::create(0.08, { -1.5f, 0.0f });
        auto a2 = cocos2d::CCMoveBy::create(0.08, { 1.5f, 0.0f });
        auto a3 = cocos2d::CCMoveBy::create(0.08, { -1.5f, 0.0f });
        auto a4 = cocos2d::CCMoveBy::create(0.08, { 1.5f, 0.0f });
        auto a5 = cocos2d::CCMoveBy::create(0.08, { -1.5f, 0.0f });
        auto a6 = cocos2d::CCMoveBy::create(0.08, { 1.5f, 0.0f });
        auto a7 = cocos2d::CCMoveBy::create(2.5, { 0.0f, -130.0f });

        auto seq = cocos2d::CCSequence::create(
            a1, a2, a3, a4, a5, a6,
            cocos2d::CCEaseElasticIn::create(a7, 1.6f),
            nullptr
        );
        this->m_barsSprite->runAction(seq);
    }

    cocos2d::CCSprite* m_barsSprite;
}

[[link(android)]]
class DynamicBitset {
    void resize(size_t size) = win 0x3a49b0 {
        m_bits.resize(size / 32 + 1);
    }

    gd::vector<unsigned int> m_bits;
}

[[link(android)]]
class DynamicScrollDelegate {
    virtual void updatePageWithObject(cocos2d::CCObject* layer, cocos2d::CCObject* object) {}
}

[[link(android)]]
class EditButtonBar : cocos2d::CCNode {
    // virtual ~EditButtonBar();

    static EditButtonBar* create(cocos2d::CCArray* objects, cocos2d::CCPoint position, int tab, bool hasCreateItems, int columns, int rows) = win 0xd4490, imac 0x5e1680, m1 0x50c374;

    int getPage() = win inline, m1 0x50cbcc {
        return m_scrollLayer->getRelativePageForNum(m_scrollLayer->m_page);
    }
    void goToPage(int page) = win 0xd4f10, m1 0x50cbd8;
    bool init(cocos2d::CCArray* objects, cocos2d::CCPoint position, int tab, bool hasCreateItems, int columns, int rows) = win inline, m1 0x50c470 {
        if (!cocos2d::CCNode::init()) return false;
        m_buttonArray = cocos2d::CCArray::create();
        m_buttonArray->retain();
        m_buttonArray->addObjectsFromArray(objects);
        m_pagesArray = cocos2d::CCArray::create();
        m_pagesArray->retain();
        m_position = position;
        m_tabIndex = tab;
        m_hasCreateItems = hasCreateItems;
        this->loadFromItems(m_buttonArray, rows, columns, false);
        return true;
    }
    void loadFromItems(cocos2d::CCArray* objects, int rows, int columns, bool keepPage) = win 0xd45f0;
    void onLeft(cocos2d::CCObject* sender) = win 0xd4fe0, m1 0x50cb48;
    void onRight(cocos2d::CCObject* sender) = win 0xd4f70;
    void reloadItems(int rowCount, int columnCount) = win inline, imac 0x5e1df0, m1 0x50ca4c {
        if (m_buttonArray) this->loadFromItems(m_buttonArray, rowCount, columnCount, false);
    }

    cocos2d::CCPoint m_position;
    int m_tabIndex;
    bool m_hasCreateItems;
    cocos2d::CCArray* m_buttonArray;
    BoomScrollLayer* m_scrollLayer;
    cocos2d::CCArray* m_pagesArray;
}

[[link(android)]]
class EditGameObjectPopup : SetupTriggerPopup {
    // virtual ~EditGameObjectPopup();
    EditGameObjectPopup() {}

    static EditGameObjectPopup* create(EffectGameObject* object, cocos2d::CCArray* objects, bool platformer) = win inline {
        auto ret = new EditGameObjectPopup();
        if (ret->init(object, objects, platformer)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init(EffectGameObject* object, cocos2d::CCArray* objects, bool platformer) = win 0x29ada0;
}

[[link(android)]]
class EditLevelLayer : cocos2d::CCLayer, TextInputDelegate, FLAlertLayerProtocol, UploadActionDelegate, UploadPopupDelegate, SetIDPopupDelegate {
    EditLevelLayer() {
        m_buttonMenu = nullptr;
        m_level = nullptr;
        m_textInputs = nullptr;
        m_folderLabel = nullptr;
        m_exiting = false;
        m_levelType = GJLevelType::Default;
        m_descriptionPopup = nullptr;
    }
    ~EditLevelLayer() = win inline, m1 0x1a7720 {
        CC_SAFE_RELEASE(m_textInputs);
        CC_SAFE_RELEASE(m_level);
        CC_SAFE_RELEASE(m_descriptionPopup);
        auto glm = GameLevelManager::sharedState();
        if (glm->m_uploadActionDelegate == this) glm->m_uploadActionDelegate = nullptr;
    }

    static EditLevelLayer* create(GJGameLevel* level) = win inline, m1 0x1a7934 {
        auto ret = new EditLevelLayer();
        if (ret && ret->init(level)) {
            ret->autorelease();
            return ret;
        }
        CC_SAFE_DELETE(ret);
        return nullptr;
    }
    static cocos2d::CCScene* scene(GJGameLevel* level) = win 0xd52d0, imac 0x1fa020, m1 0x1a7830;

    virtual void keyBackClicked() = win 0xd9ac0, m1 0x1ab83c, imac 0x1fe1d0;
    virtual void keyDown(cocos2d::enumKeyCodes key, double timestamp) = win 0xd9ad0, imac 0x1fe200, m1 0x1ab848;
    virtual void setIDPopupClosed(SetIDPopup* popup, int value) = win 0xd95a0, m1 0x1ab73c, imac 0x1fe0d0;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0xd8c60, m1 0x1ab388, imac 0x1fdcf0;
    virtual void textInputOpened(CCTextInputNode* node) = win 0xd7b10, m1 0x1aabb8, imac 0x1fd530;
    virtual void textInputClosed(CCTextInputNode* node) = win 0xd7510, imac 0x1fd1c0, m1 0x1aa874;
    virtual void textChanged(CCTextInputNode* node) = win 0xd7c80, imac 0x1fd610, m1 0x1aacc8;
    virtual void uploadActionFinished(int id, int response) = win 0xd9b40, m1 0x1ab8cc, imac 0x1fe2a0;
    virtual void uploadActionFailed(int id, int response) = win 0xd9c80, imac 0x1fe440, m1 0x1aba7c;
    virtual void onClosePopup(UploadActionPopup* popup) = win 0xd9b00, m1 0x1ab87c, imac 0x1fe250;

    void closeTextInputs() = win 0xd74b0, m1 0x1aa818;
    void confirmClone(cocos2d::CCObject* sender);
    void confirmDelete(cocos2d::CCObject* sender) = imac 0x1fc800;
    void confirmMoveToTop(cocos2d::CCObject* sender) = imac 0x1fca90;
    bool init(GJGameLevel* level) = win 0xd5460;
    void onBack(cocos2d::CCObject* sender) = win 0xd9630;
    void onClone() = win inline {
        auto director = cocos2d::CCDirector::sharedDirector();
        if (director->getIsTransitioning() || m_exiting) return;
        this->setKeypadEnabled(false);
        m_exiting = true;
        GameManager::sharedState()->m_sceneEnum = 2;
        auto level = GameLevelManager::sharedState()->createNewLevel();
        level->copyLevelInfo(m_level);
        this->verifyLevelName();
        level->m_originalLevel = m_level->m_originalLevel;
        director->replaceScene(cocos2d::CCTransitionFade::create(.5f, EditLevelLayer::scene(level)));
    }
    void onDelete() = win inline, m1 0x1ab348 {
        m_buttonMenu->setEnabled(false);
        GameLevelManager::sharedState()->deleteLevel(m_level);
        this->onBack(nullptr);
    }
    void onEdit(cocos2d::CCObject* sender) = win 0xd82d0;
    void onGuidelines(cocos2d::CCObject* sender) = win 0xd6830, imac 0x1fd080;
    void onHelp(cocos2d::CCObject* sender);
    void onLevelInfo(cocos2d::CCObject* sender) = win 0xd6a50, m1 0x1aa478;
    void onLevelLeaderboard(cocos2d::CCObject* sender) = m1 0x1aa2c8;
    void onLevelOptions(cocos2d::CCObject* sender) = m1 0x1aa7f8;
    void onMoveToTop() = win inline, m1 0x1ab710, ios inline {
        LocalLevelManager::sharedState()->moveLevelToTop(m_level);
    }
    void onPlay(cocos2d::CCObject* sender) = win 0xd7e70;
    void onSetFolder(cocos2d::CCObject* sender) = win 0xd9510, imac 0x1fcb70, m1 0x1aa21c;
    void onShare(cocos2d::CCObject* sender) = win 0xd8470, imac 0x1fbb40, m1 0x1a91ec;
    void onTest(cocos2d::CCObject* sender) = win inline, m1 0x1ab2b8, ios inline {
        this->closeTextInputs();
        GameManager::sharedState()->m_sceneEnum = 3;
        cocos2d::CCDirector::sharedDirector()->replaceScene(cocos2d::CCTransitionFade::create(.5f, PlayLayer::scene(m_level, false, false)));
    }
    void onUpdateDescription(cocos2d::CCObject* sender);
    void playStep2() = m1 0x1ab1a4;
    void playStep3() = m1 0x1ab268;
    void setupLevelInfo() = win 0xd6c70;
    void updateDescText(char const* text) = win inline, ios inline {}
    void verifyLevelName() = win 0xd97e0, imac 0x1fd790;

    cocos2d::CCMenu* m_buttonMenu;
    GJGameLevel* m_level;
    cocos2d::CCArray* m_textInputs;
    cocos2d::CCLabelBMFont* m_folderLabel;
    bool m_exiting;
    GJLevelType m_levelType;
    gd::string m_levelName;
    UploadActionPopup* m_descriptionPopup;
}

[[link(android)]]
class EditorOptionsLayer : GJOptionsLayer {
    // virtual ~EditorOptionsLayer();
    EditorOptionsLayer() {
        m_buttonsPerRow = 0;
        m_buttonRows = 0;
    }

    static EditorOptionsLayer* create() = win inline, imac 0x29d630, m1 0x23cdcc {
        auto ret = new EditorOptionsLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x290ea0, imac 0x29d890, m1 0x23cf68;
    virtual void onClose(cocos2d::CCObject* sender) = win 0x2918f0, m1 0x23d984, imac 0x29e280;
    virtual void setupOptions() = win 0x290ed0, imac 0x29d8c0, m1 0x23cf84;

    void onButtonRows(cocos2d::CCObject* sender) = win 0x291860, imac 0x29e210, m1 0x23d904;
    void onButtonsPerRow(cocos2d::CCObject* sender) = win 0x2917d0, imac 0x29e190, m1 0x23d87c;

    int m_buttonsPerRow;
    int m_buttonRows;
    cocos2d::CCLabelBMFont* m_buttonsPerRowLabel;
    cocos2d::CCLabelBMFont* m_buttonRowsLabel;
}

[[link(android)]]
class EditorPauseLayer : CCBlockLayer, FLAlertLayerProtocol {
    // virtual ~EditorPauseLayer();
    EditorPauseLayer() {
        m_saved = false;
        m_guidelinesOffButton = nullptr;
        m_guidelinesOnButton = nullptr;
        m_editorLayer = nullptr;
    }

    static EditorPauseLayer* create(LevelEditorLayer* layer) = win inline, m1 0x231150 {
        auto ret = new EditorPauseLayer();
        if (ret && ret->init(layer)) {
            ret->autorelease();
            return ret;
        }
        CC_SAFE_DELETE(ret);
        return nullptr;
    }

    virtual void keyBackClicked() = win 0xde620, m1 0x234ea8, imac 0x294ac0;
    virtual void keyDown(cocos2d::enumKeyCodes key, double timestamp) = win 0xde630, imac 0x294bb0, m1 0x234f80;
    virtual void customSetup() = win 0xda570, m1 0x231d18, imac 0x291580;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0xde500, m1 0x234dcc, imac 0x2949e0;

    void doResetUnused() = win inline, m1 0x234234, ios inline {
        m_editorLayer->resetUnusedColorChannels();
    }
    bool init(LevelEditorLayer* layer) = win 0xd9ee0, imac 0x290d30, m1 0x231228;
    void onAlignX(cocos2d::CCObject* sender) = m1 0x233f94;
    void onAlignY(cocos2d::CCObject* sender) = m1 0x233fc8;
    void onBuildHelper(cocos2d::CCObject* sender) = m1 0x233f68;
    void onCopyWColor(cocos2d::CCObject* sender) = m1 0x233f58;
    void onCreateExtras(cocos2d::CCObject* sender) = m1 0x233f18;
    void onCreateLoop(cocos2d::CCObject* sender) = win 0xdcd20, m1 0x233f78;
    void onCreateTemplate(cocos2d::CCObject* sender) = win inline, m1 0x23423c, ios inline {
        auto objects = cocos2d::CCArray::create();
        auto lel = GameManager::sharedState()->m_levelEditorLayer;
        if (auto selectedObject = lel->m_editorUI->m_selectedObject) {
            objects->addObject(selectedObject);
        }
        else if (auto selectedObjects = lel->m_editorUI->getSelectedObjects()) {
            objects->addObjectsFromArray(selectedObjects);
        }
    }
    void onExitEditor(cocos2d::CCObject* sender) = win 0xde2c0, m1 0x234d94;
    void onExitNoSave(cocos2d::CCObject* sender) = win 0xde390;
    void onHelp(cocos2d::CCObject* sender);
    void onKeybindings(cocos2d::CCObject* sender) = m1 0x2341fc;
    void onNewGroupX(cocos2d::CCObject* sender) = m1 0x234028;
    void onNewGroupY(cocos2d::CCObject* sender) = m1 0x234038;
    void onOptions(cocos2d::CCObject* sender) = win 0xdc8e0, m1 0x234218;
    void onPasteWColor(cocos2d::CCObject* sender) = m1 0x233f48;
    void onReGroup(cocos2d::CCObject* sender) = m1 0x233f84;
    void onResetUnusedColors(cocos2d::CCObject* sender) = win 0xdcb10;
    void onResume(cocos2d::CCObject* sender) = win 0xdd690;
    void onSave(cocos2d::CCObject* sender) = win 0xde150;
    void onSaveAndExit(cocos2d::CCObject* sender) = win 0xde280;
    void onSaveAndPlay(cocos2d::CCObject* sender) = win 0xddf00;
    void onSelectAll(cocos2d::CCObject* sender) = win 0xdcdc0, m1 0x233ffc;
    void onSelectAllLeft(cocos2d::CCObject* sender) = m1 0x234008;
    void onSelectAllRight(cocos2d::CCObject* sender) = m1 0x234018;
    void onSong(cocos2d::CCObject* sender);
    void onUnlockAllLayers(cocos2d::CCObject* sender) = win 0xdcc70, m1 0x233f10;
    void playStep2() = win 0xddf80, m1 0x234c68;
    void playStep3() = win 0xde0b0, m1 0x234d38;
    void saveLevel() = win 0xdd860, imac 0x2943e0;
    void toggleDebugDraw(cocos2d::CCObject* sender) = m1 0x2341e0;
    void toggleEditorBackground(cocos2d::CCObject* sender) = win inline, m1 0x234748, ios inline {
        auto gameManager = GameManager::sharedState();
        gameManager->toggleGameVariable("0078");
        m_editorLayer->toggleBackground(!gameManager->getGameVariable("0078"));
    }
    void toggleEditorColorMode(cocos2d::CCObject* sender) = m1 0x234194;
    void toggleEditorGrid(cocos2d::CCObject* sender) = m1 0x234080;
    void toggleEditorGround(cocos2d::CCObject* sender) = m1 0x2340d0;
    void toggleEffectDuration(cocos2d::CCObject* sender) = win inline, m1 0x234710, ios inline {
        GameManager::sharedState()->toggleGameVariable("0058");
    }
    void toggleEffectLines(cocos2d::CCObject* sender) = win inline, m1 0x23472c, ios inline {
        GameManager::sharedState()->toggleGameVariable("0043");
    }
    void toggleFollowPlayer(cocos2d::CCObject* sender) = win inline, m1 0x2346d8, ios inline {
        GameManager::sharedState()->toggleGameVariable("0001");
    }
    void toggleGridOnTop(cocos2d::CCObject* sender) = win inline, m1 0xb418, ios inline {
        auto gameManager = GameManager::sharedState();
        gameManager->toggleGameVariable("0039");
        m_editorLayer->m_drawGridLayer->getParent()->reorderChild(m_editorLayer->m_drawGridLayer, gameManager->getGameVariable("0039") ? 1399 : -1599);
    }
    void toggleHideInvisible(cocos2d::CCObject* sender) = m1 0x2341c4;
    void toggleIgnoreDamage(cocos2d::CCObject* sender) = m1 0x234048;
    void togglePlaytestMusic(cocos2d::CCObject* sender) = win inline, m1 0x2346f4, ios inline {
        GameManager::sharedState()->toggleGameVariable("0002");
    }
    void togglePreviewAnim(cocos2d::CCObject* sender) = win 0xdd160, m1 0x234164;
    void togglePreviewParticles(cocos2d::CCObject* sender) = m1 0x234134;
    void togglePreviewShaders(cocos2d::CCObject* sender) = m1 0x234118;
    void toggleRecordOrder(cocos2d::CCObject* sender) = win inline, ios inline {
        GameManager::sharedState()->toggleGameVariable("0104");
    }
    void toggleSelectFilter(cocos2d::CCObject* sender) = m1 0x234064;
    void toggleShowObjectInfo(cocos2d::CCObject* sender) = m1 0x23409c;
    void uncheckAllPortals(cocos2d::CCObject* sender) = win 0xdca30;
    void updateSongButton() = win 0xdd5e0;

    bool m_saved;
    CCMenuItemSpriteExtra* m_guidelinesOffButton;
    CCMenuItemSpriteExtra* m_guidelinesOnButton;
    LevelEditorLayer* m_editorLayer;
    PAD = win 0x20, android32 0x10, android64 0x20, imac 0x20, m1 0x20, ios 0x20;
}

[[link(android), depends(GameObjectEditorState), depends(GJTransformState)]]
class EditorUI : cocos2d::CCLayer, FLAlertLayerProtocol, ColorSelectDelegate, GJRotationControlDelegate, GJScaleControlDelegate, GJTransformControlDelegate, MusicDownloadDelegate, SetIDPopupDelegate {
    EditorUI() = win 0xdea00;
    ~EditorUI() = win inline, imac 0x8d40, m1 0x7b30 {
        CC_SAFE_RELEASE(m_selectedObjects);
        CC_SAFE_RELEASE(m_deleteObjects);
        CC_SAFE_RELEASE(m_createButtonArray);
        CC_SAFE_RELEASE(m_customObjectButtonArray);
        CC_SAFE_RELEASE(m_createButtonBars);
        CC_SAFE_RELEASE(m_tabsArray);
        CC_SAFE_RELEASE(m_editButtonDict);
        CC_SAFE_RELEASE(m_rotationControl);
        CC_SAFE_RELEASE(m_scaleControl);
        CC_SAFE_RELEASE(m_transformControl);
        CC_SAFE_RELEASE(m_snapPositions);
        CC_SAFE_RELEASE(m_uiItems);
        CC_SAFE_RELEASE(m_customTabControls);
    }

    static EditorUI* create(LevelEditorLayer* editorLayer) = win inline, m1 0x7cfc {
        auto ret = new EditorUI();
        if (ret->init(editorLayer)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static EditorUI* get() {
        auto lel = LevelEditorLayer::get();
        if (!lel) return nullptr;
        return lel->m_editorUI;
    }
    static int getRandomStartKey(int specialTemplate) = win 0x12d560, imac 0x612b80, m1 0x537dfc;
    static int getSmartObjectKey(int key, GJSmartDirection direction) = win 0x12d800, m1 0x538040;
    static int smartTypeForKey(int key) = win 0x12d4c0, m1 0x537ddc;

    virtual void draw() = win 0x122d10, m1 0x438f8, imac 0x4e430;
    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x123850, m1 0x442e0, imac 0x4eec0;
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x123ed0, m1 0x44908, imac 0x4f4d0;
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x124620, m1 0x44e28, imac 0x4fa60;
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x71260, m1 0x455e0, imac 0x50330;
    virtual void registerWithTouchDispatcher() = win 0x9b7f0, m1 0x455fc, imac 0x50370;
    virtual void keyBackClicked() = win 0x1149c0, m1 0x36d84, imac 0x3ea10;
    virtual void keyDown(cocos2d::enumKeyCodes key, double timestamp) = win 0x125360, m1 0x45634, imac 0x503b0;
    virtual EditorUI* getUI() = win 0xdee40 { return this; }
    virtual void setIDPopupClosed(SetIDPopup* popup, int value) = win 0xe6c90, imac 0x33280, m1 0x3010c;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0xe6a90, m1 0x2ff3c, imac 0x33100;
    virtual void updateTransformControl() = win 0x115440, imac 0x40480, m1 0x384b0;
    virtual void transformChangeBegin() = win 0x115930, m1 0x38d54, imac 0x40e20;
    virtual void transformChangeEnded() = win inline, imac 0x40f00, m1 0x38e00 {}
    virtual cocos2d::CCNode* getTransformNode() = win 0xdee50, imac 0x543a0, m1 0x48d74;
    virtual void transformScaleXChanged(float scaleX) = win 0x121860, m1 0x42360, imac 0x4cbe0;
    virtual void transformScaleYChanged(float scaleY) = win 0x121880, m1 0x42528, imac 0x4cdf0;
    virtual void transformScaleXYChanged(float scaleX, float scaleY) = win 0x1218a0, imac 0x4cf50, m1 0x4265c;
    virtual void transformSkewXChanged(float skewX) = win 0x1218c0, m1 0x42794, imac 0x4d0c0;
    virtual void transformSkewYChanged(float skewY) = win 0x1218e0, m1 0x428c8, imac 0x4d220;
    virtual void transformRotationXChanged(float rotationX) = win 0x121900, m1 0x429fc, imac 0x4d380;
    virtual void transformRotationYChanged(float rotationY) = win 0x121920, m1 0x42b30, imac 0x4d4e0;
    virtual void transformRotationChanged(float rotation) = win 0x121940, imac 0x4d640, m1 0x42c64;
    virtual void transformResetRotation() = win 0x121960, m1 0x42d9c, imac 0x4d7b0;
    virtual void transformRestoreRotation() = win 0x121990, m1 0x42e54, imac 0x4d8a0;
    virtual void songStateChanged() = win 0x1120e0, m1 0x35bf8, imac 0x3d8b0;
    virtual void colorSelectClosed(cocos2d::CCNode* popup) = win 0x11f730, m1 0x40738, imac 0x4a080;
    virtual void keyUp(cocos2d::enumKeyCodes key, double timestamp) = win 0x1267f0, imac 0x51630, m1 0x46508;
    virtual void scrollWheel(float y, float x) = win 0x126830, imac 0x516d0, m1 0x46580;
    virtual void angleChangeBegin() = win 0x123150, m1 0x439d4, imac 0x4e510;
    virtual void angleChangeEnded() = win inline, imac 0x4e550, m1 0x439f0 {}
    virtual void angleChanged(float rotation) = win 0x123160, m1 0x439f8, imac 0x4e570;
    virtual void updateScaleControl() = win 0x114e30, imac 0x3ee50, m1 0x3717c;
    virtual void anchorPointMoved(cocos2d::CCPoint anchorPoint) = win 0x115940, m1 0x38e08, imac 0x40f20;
    virtual void scaleChangeBegin() = win 0x114f90, m1 0x377c0, imac 0x3f5f0;
    virtual void scaleChangeEnded() = win inline, m1 0x377dc, imac 0x3f630 {}
    virtual void scaleXChanged(float scaleX, bool lock) = win 0x114fa0, m1 0x377e4, imac 0x3f650;
    virtual void scaleYChanged(float scaleY, bool lock) = win 0x115050, m1 0x37e04, imac 0x3fd80;
    virtual void scaleXYChanged(float scaleX, float scaleY, bool lock) = win 0x115100, m1 0x37f38, imac 0x3fec0;

    void activateRotationControl(cocos2d::CCObject* sender) = win 0x123010, m1 0x35928;
    void activateScaleControl(cocos2d::CCObject* sender) = win 0x114b60, m1 0x36eac;
    void activateTransformControl(cocos2d::CCObject* sender) = win 0x1151b0, m1 0x4098d4;
    void addObjectsToSmartTemplate(GJSmartTemplate* smartTemplate, cocos2d::CCArray* objects) = win 0x115c70;
    void addSnapPosition(cocos2d::CCPoint position) = win inline, m1 0x32f84, ios inline {
        auto node = cocos2d::CCNode::create();
        node->setPosition(position);
        m_snapPositions->addObject(node);
    }
    void alignObjects(cocos2d::CCArray* objects, bool axisY) = win 0x121f60;
    void applyOffset(GameObject* object) = imac 0x3a5f0;
    cocos2d::CCPoint applySpecialOffset(cocos2d::CCPoint position, GameObject* object, cocos2d::CCPoint offset) = win 0x1226a0, imac 0x4e220, m1 0x4371c;
    bool arrayContainsClass(cocos2d::CCArray* objects, int classType) = win inline, imac 0x49140, m1 0x3fa50 {
        for (int i = 0; i < objects->count(); i++) {
            if ((int)static_cast<GameObject*>(objects->objectAtIndex(i))->m_classType == classType) return true;
        }
        return false;
    }
    void assignNewGroups(bool groupY);
    bool canAllowMultiActivate(GameObject* object, cocos2d::CCArray* objects) = win inline {
        if (object) {
            return object->canAllowMultiActivate();
        }
        else {
            for (int i = 0; i < objects->count(); i++) {
                auto obj = static_cast<GameObject*>(objects->objectAtIndex(i));
                if (!obj->canAllowMultiActivate()) {
                    return false;
                }
            }
            return true;
        }
    }
    bool canSelectObject(GameObject* object) = win 0x110350, m1 0x2f694;
    void centerCameraOnObject(GameObject* object) = win inline, m1 0x3046c {
        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        auto scale = m_editorLayer->m_objectLayer->getScale();
        m_editorLayer->m_objectLayer->setPosition(winSize * .5f - object->getPosition() * scale);
        this->constrainGameLayerPosition();
    }
    void changeSelectedObjects(cocos2d::CCArray* objects, bool ignoreFilter) = win inline, m1 0x34edc {
        this->deselectAll();
        if (objects->count() == 0) return;
        this->selectObjects(objects, ignoreFilter);
        m_canActivateControls = true;
        this->updateObjectInfoLabel();
        this->updateScaleControl();
    }
    void checkDiffAfterTransformAnchor(cocos2d::CCPoint diff, cocos2d::CCArray* objects) = win 0x1159c0, imac 0x41070, m1 0x38f34;
    void checkLiveColorSelect() = win 0x110670, imac 0x3c670, m1 0x34ae8;
    void clickOnPosition(cocos2d::CCPoint position) = win 0xe2720;
    void closeLiveColorSelect() = m1 0x34c20, ios inline {
        if (m_colorOverlay) {
            m_colorOverlay->closeColorSelect(nullptr);
            m_colorOverlay = nullptr;
        }
    }
    void closeLiveHSVSelect() = m1 0x34d74, ios inline {
        if (m_hsvOverlay) {
            m_hsvOverlay->closeColorSelect(nullptr);
            m_hsvOverlay = nullptr;
        }
    }
    void colorSelectClosed(cocos2d::ccColor3B color) = win inline, imac 0x4a070, m1 0x40734, ios inline {}
    void constrainGameLayerPosition() = win inline, imac 0x2efa0, m1 0x2c110, ios inline {
        this->constrainGameLayerPosition(-100.f, -100.f);
    }
    void constrainGameLayerPosition(float x, float y) = win 0x1229c0, imac 0x2a990, m1 0x282b0;
    int convertKeyBasedOnNeighbors(int smartKey, int objectID, cocos2d::CCPoint position, cocos2d::CCArray* objects) = win 0x12def0;
    int convertToBaseKey(int objectID) = win 0x12ddf0;
    gd::string copyObjects(cocos2d::CCArray* objects, bool copyColors, bool sort) = win 0x112e40, imac 0x30d60, m1 0x2dce4;
    gd::string copyObjectsDetailed(cocos2d::CCArray* objects) = win inline, imac 0x3dea0, m1 0x36198 {
        qsort(objects->data->arr, objects->data->num, sizeof(GameObject*), [](void const* a, void const* b) {
            auto objA = *static_cast<GameObject* const*>(a);
            auto objB = *static_cast<GameObject* const*>(b);
            return objA->m_uniqueID - objB->m_uniqueID;
        });
        auto groupCenter = this->getGroupCenter(objects, false);
        std::string result = "";
        for (auto obj : geode::cocos::CCArrayExt<cocos2d::CCObject*, false>(objects)) {
            auto object = static_cast<GameObject*>(obj);
            if (object->m_objectID == 749) continue;
            auto position = object->getPosition();
            object->setPosition(position - groupCenter);
            result += object->getSaveString(m_editorLayer) + ";";
            object->setPosition(position);
        }
        return result;
    }
    cocos2d::CCArray* createCustomItems() = win 0xe47c0;
    GameObject* createEdgeForObject(GameObject* object, int type) = win 0x12e6d0, imac 0x613f10;
    void createExtraObject(int id, cocos2d::CCPoint position, GameObject* object, cocos2d::CCArray* objects, int zOrder, int editorLayer) = win 0x132cc0, imac 0x6184a0, m1 0x53c860;
    cocos2d::CCArray* createExtras(cocos2d::CCArray* objects) = win inline, imac 0x615af0, m1 0x53a410 {
        if (!objects || objects->count() == 0) return nullptr;
        auto extras = cocos2d::CCArray::create();
        for (int i = 0; i < objects->count(); i++) {
            auto object = static_cast<GameObject*>(objects->objectAtIndex(i));
            if (object->m_objectID > 2807 && object->m_objectID < 2838) {
                this->createExtrasForObject(object->m_objectID, object, extras);
            }
        }
        return extras;
    }
    void createExtrasForObject(int id, GameObject* object, cocos2d::CCArray* objects) = win 0x12ff60;
    void createGlow() = win inline, ios inline {}
    void createLoop() = win 0x119670, m1 0x102de8;
    void createMoveMenu() = win 0x11ad70, m1 0x3d3a0;
    void createNewKeyframeAnim() = win 0x1193d0, imac 0x45500, m1 0x3ca80;
    GameObject* createObject(int objectID, cocos2d::CCPoint position) = win 0x10ff60, imac 0x3a4e0, m1 0x32fcc;
    cocos2d::CCArray* createOutlines(cocos2d::CCArray* objects) = win 0x12ed30;
    void createPrefab(GJSmartTemplate* smartTemplate, gd::string key, int id) = win 0x1179e0, imac 0x54f1c0, m1 0x6ac634;
    cocos2d::CCArray* createRockBases(cocos2d::CCArray* objects) = win 0x12f630;
    cocos2d::CCArray* createRockEdges(cocos2d::CCArray* objects) = win 0x12e360, imac 0x613b70;
    void createSmartObjectsFromTemplate(GJSmartTemplate* smartTemplate, cocos2d::CCArray* objects, bool useNearby, bool dontDelete, bool referenceOnly, bool dontPaste);
    void createSmartObjectsFromType(int type, cocos2d::CCArray* objects, bool extras, bool dontDelete) = imac 0x43d80, m1 0x3b5fc;
    UndoObject* createUndoObject(UndoCommand command, bool addToList) = win 0x110f70, imac 0x3cd30, m1 0xae740;
    void createUndoSelectObject(bool redo) = win 0x111290, m1 0x2b82c;
    void deactivateRotationControl() = win inline, imac 0xb960, m1 0xa448 {
        m_rotationTouchID = -1;
        if (m_rotationControl->isVisible()) {
            m_rotationControl->setVisible(false);
            m_rotationControl->finishTouch();
        }
    }
    void deactivateScaleControl() = win 0x114d60, imac 0xbb30, m1 0xa5cc;
    void deactivateTransformControl() = win 0x1153b0, imac 0xbc30, m1 0xa6ec;
    void deleteObject(GameObject* object, bool noUndo) = win inline, imac 0x32a30, m1 0x2f8cc {
        if (!object) return;
        object->m_wasSelected = object->m_isSelected;
        m_editorLayer->removeObject(object, noUndo);
        this->deactivateRotationControl();
        this->deactivateScaleControl();
        this->deactivateTransformControl();
    }
    void deleteSmartBlocksFromObjects(cocos2d::CCArray* objects) = win 0x117df0, m1 0x313f0;
    void deleteTypeFromObjects(int id, cocos2d::CCArray* objects) = win inline, imac 0x34720, m1 0x314b0 {
        for (int i = 0; i < objects->count(); i++) {
            auto obj = static_cast<GameObject*>(objects->objectAtIndex(i));
            if (obj->m_objectID != id) continue;
            if (obj->m_linkedGroup > 0) {
                if (auto stickyGroup = m_editorLayer->getStickyGroup(obj->m_linkedGroup)) stickyGroup->removeObject(obj, true);
            }
            this->deleteObject(obj, true);
            objects->removeObjectAtIndex(i, true);
        }
    }
    void deselectAll() = win 0x1114c0, imac 0x32d00, m1 0x2fb84;
    void deselectObject() = win inline, imac 0x32f10, m1 0x2fd6c {
        this->stopActionByTag(124);
        if (m_selectedObject) m_selectedObject->deselectObject();
        m_selectedObject = nullptr;
        this->toggleEditObjectButton();
        m_canActivateControls = true;
        m_lastTouchPoint = cocos2d::CCPoint { 0.f, 0.f };
    }
    void deselectObject(GameObject* object) = win 0x1113a0, imac 0x32c60, m1 0x2fadc;
    void deselectObjectsColor() = win 0x1107d0, m1 0x34e6c;
    void deselectTargetPortals() = win 0xe68b0, imac 0x328d0, m1 0x2f77c;
    void disableButton(CreateMenuItem* button) = win inline, imac 0x2e9c0, m1 0x2bacc {
        auto sprite = static_cast<ButtonSprite*>(button->getNormalImage());
        if (sprite->m_subBGSprite) sprite->m_subBGSprite->setColor({ 127, 127, 127 });
        else if (sprite->m_BGSprite) sprite->m_BGSprite->setColor({ 127, 127, 127 });
        if (button->m_objectID < 0) return;
        auto object = static_cast<EffectGameObject*>(sprite->m_subSprite);
        if (object->m_classType == GameObjectClassType::Effect && object->isColorObject() && object->m_shouldPreview) {
            object->setObjectColor({ 127, 100, 100 });
        }
        else {
            object->setObjectColor({ 127, 127, 127 });
        }
        object->setChildColor({ 127, 100, 100 });
    }
    void doCopyObjects(bool withColor) = win 0x1131e0, imac 0x3e060, m1 0x3637c;
    void doPasteInPlace(bool withColor) = win inline, ios inline {
        auto& clipboard = GameManager::sharedState()->m_editorClipboard;
        if (clipboard.empty()) return;
        this->pasteObjects(clipboard, withColor, false);
        this->updateButtons();
        this->updateObjectInfoLabel();
    }
    void doPasteObjects(bool withColor) = win 0x113370;
    void dynamicGroupUpdate(bool reGroup) = win 0x1188f0;
    int edgeForObject(int id, int type) = win inline, imac 0x6140d0, m1 0x5391ec {
        if (id == 1348) {
            switch (type) {
                case 0: return 1359;
                case 3: return 1395;
                case 7: return 1363;
            }
        }
        else if (id == 1349) {
            switch (type) {
                case 0: return 1360;
                case 1: return 1357;
                case 4: return 1364;
            }
        }
        else if (id == 1350) {
            switch (type) {
                case 2: return 1361;
                case 3: return 1356;
                case 6: return 1365;
            }
        }
        else if (id == 1351) {
            switch (type) {
                case 1: return 1358;
                case 2: return 1362;
                case 5: return 1366;
            }
        }
        else if (id == 1431 || id == 1432 || id == 1433) {
            switch (type) {
                case 0: return 1435;
                case 1: return 1436;
                case 2: return 1437;
                case 3: return 1434;
                case 4: return 1439;
                case 5: return 1441;
                case 6: return 1440;
                case 7: return 1438;
            }
        }
        else if (id == 1461) {
            switch (type) {
                case 0: return 1629;
                case 1: return 1625;
                case 2: return 1633;
                case 3: return 1621;
                case 4: return 1638;
                case 5: return 1640;
                case 6: return 1639;
                case 7: return 1637;
            }
        }
        else if (id == 1462) {
            switch (type) {
                case 0: return 1630;
                case 1: return 1627;
                case 2: return 1634;
                case 3: return 1623;
                case 4: return 1642;
                case 5: return 1644;
                case 6: return 1643;
                case 7: return 1641;
            }
        }
        else if (id == 1463) {
            switch (type) {
                case 0: return 1631;
                case 1: return 1626;
                case 2: return 1635;
                case 3: return 1622;
                case 4: return 1646;
                case 5: return 1648;
                case 6: return 1647;
                case 7: return 1645;
            }
        }
        else if (id == 1464) {
            switch (type) {
                case 0: return 1632;
                case 1: return 1628;
                case 2: return 1636;
                case 3: return 1624;
                case 4: return 1650;
                case 5: return 1652;
                case 6: return 1651;
                case 7: return 1649;
            }
        }
        return 0;
    }
    bool editButton2Usable() = win 0x11a560, imac 0x48d90, m1 0x3f6d4;
    bool editButtonUsable() = win 0x119d10, imac 0x48030, m1 0x3f120;
    void editColor() = win 0x11edd0, imac 0x3c800, m1 0x34c50;
    bool editColorButtonUsable() = win inline, ios inline {
        return m_selectedObject || m_selectedObjects->count() != 0;
    }
    void editGroup(cocos2d::CCObject* sender);
    void editHSV() = win 0x11f050, imac 0x3c9a0, m1 0x34da4;
    void editObject(cocos2d::CCObject* sender) = win 0x11bf30;
    void editObject2(cocos2d::CCObject* sender);
    void editObject3(cocos2d::CCObject* sender) = win inline, ios inline {
        this->editObjectSpecial(1);
    }
    void editObjectSpecial(int type) = win 0x11ded0, m1 0x3fdd8;
    int editorLayerForArray(cocos2d::CCArray* objects, bool layer2) = win inline, imac 0x2d9b0, m1 0x2ab58 {
        if (!objects) return 0;
        auto previousLayer = -1;
        auto currentLayer = -1;
        for (int i = 0; i < objects->count(); i++) {
            auto obj = static_cast<GameObject*>(objects->objectAtIndex(i));
            currentLayer = layer2 ? obj->m_editorLayer2 : obj->m_editorLayer;
            if (previousLayer != -1 && previousLayer != currentLayer) return 0;
            previousLayer = currentLayer;
        }
        return currentLayer != -1 ? currentLayer : 0;
    }
    void enableButton(CreateMenuItem* button) = win inline, imac 0x2e8b0, m1 0x2b998 {
        auto sprite = static_cast<ButtonSprite*>(button->getNormalImage());
        if (sprite->m_subBGSprite) sprite->m_subBGSprite->setColor({ 255, 255, 255 });
        else if (sprite->m_BGSprite) sprite->m_BGSprite->setColor({ 255, 255, 255 });
        if (button->m_objectID < 0) return;
        auto object = static_cast<EffectGameObject*>(sprite->m_subSprite);
        if (object->m_classType == GameObjectClassType::Effect && object->isColorObject() && object->m_shouldPreview) {
            object->setObjectColor({ 200, 200, 255 });
        }
        else {
            auto objectID = object->m_objectID;
            if (objectID == 918 || objectID == 919 || (objectID != 1584 && objectID != 2012) && object->getMainColorMode() != 1010) {
                object->setObjectColor({ 255, 255, 255 });
            }
            else {
                object->setObjectColor({ 0, 0, 0 });
            }
        }
        object->setChildColor({ 200, 200, 255 });
    }
    void findAndSelectObject(int id, bool useUniqueID) = win 0xe6f20;
    void findSnapObject(cocos2d::CCArray* objects, float offset) = win 0x123380, m1 0x11830c;
    void findSnapObject(cocos2d::CCPoint position, float offset) = win 0x123280, imac 0x4e6a0, m1 0x43b20;
    void findTriggerTest() = win inline, m1 0x3ca30, ios inline {
        auto objects = m_editorLayer->getAllObjects();
        for (int i = 0; i < objects->count(); i++) {
            auto obj = static_cast<GameObject*>(objects->objectAtIndex(i));
        }
    }
    void flipObjectsX(cocos2d::CCArray* objects);
    void flipObjectsY(cocos2d::CCArray* objects);
    CCMenuItemSpriteExtra* getButton(char const* text, int width, cocos2d::SEL_MenuHandler selector, cocos2d::CCMenu* menu) = win inline, imac 0x2eaa0, m1 0x2bbd8, ios inline {
        auto sprite = ButtonSprite::create(text, width, 0, 1.f, true, "goldFont.fnt", "GJ_button_01.png", 0.f);
        auto button = CCMenuItemSpriteExtra::create(sprite, this, selector);
        if (menu) menu->addChild(button);
        return button;
    }
    CreateMenuItem* getCreateBtn(int id, int bg) = win 0x10e9c0, imac 0x33710, m1 0x305c8;
    CreateMenuItem* getCreateMenuItemButton(cocos2d::CCSprite* sprite, cocos2d::SEL_MenuHandler selector, cocos2d::CCMenu* menu, float scale, int background, cocos2d::CCPoint offset) = win inline, imac 0x2ece0, m1 0x2be3c {
        const char* backgroundImage;
        switch (background) {
            case 2: backgroundImage = "GJ_button_02.png"; break;
            case 3: backgroundImage = "GJ_button_03.png"; break;
            case 4: backgroundImage = "GJ_button_04.png"; break;
            case 5: backgroundImage = "GJ_button_05.png"; break;
            case 6: backgroundImage = "GJ_button_06.png"; break;
            default: backgroundImage = "GJ_button_01.png"; break;
        }
        auto buttonSprite = ButtonSprite::create(sprite, 32, 0, 32.f, 1.f, true, backgroundImage, true);
        auto button = CreateMenuItem::create(buttonSprite, nullptr, this, selector);
        button->setScale(scale);
        button->m_baseScale = scale;
        if (menu) menu->addChild(button);
        buttonSprite->updateSpriteOffset(offset);
        return button;
    }
    GameObject* getCycledObject(cocos2d::CCArray* objects, bool dontSkipSelected) = win inline, imac 0x32700, m1 0x2f554 {
        GameObject* cycledObject = nullptr;
        for (int i = 0; i < objects->count(); i++) {
            auto obj = static_cast<GameObject*>(objects->objectAtIndex(i));
            if ((!dontSkipSelected && obj->m_isSelected) || (cycledObject && cycledObject->m_unk460 <= obj->m_unk460 )) break;
            if (this->canSelectObject(obj)) cycledObject = obj;
        }
        if (cycledObject) cycledObject->m_unk460 = m_cycledObjectIndex;
        return cycledObject;
    }
    void getEditColorTargets(ColorAction*& mainColor, ColorAction*& detailColor, EffectGameObject*& object) = win 0x11eb40, imac 0x49bf0, m1 0x403bc;
    cocos2d::CCPoint getGridSnappedPos(cocos2d::CCPoint pos) = win inline, imac 0x356a0, m1 0x32370 {
        auto size = m_editorLayer->m_drawGridLayer->m_gridSize;
        auto xVal = std::floorf(pos.x / size);
        auto yVal = std::floorf(pos.y / size);
        return this->getLimitedPosition(ccp((xVal + 0.5) * size, (yVal + 0.5) * size));
    }
    cocos2d::CCPoint getGroupCenter(cocos2d::CCArray* objects, bool absolute) = win 0x122d80, m1 0x33fbc;
    void getGroupInfo(GameObject* selectedObject, cocos2d::CCArray* selectedObjects, int& objectID, int& classType, int& objectType) = win inline, m1 0x3f5bc {
        objectID = classType = objectType = -1;
        if (selectedObject) {
            objectID = selectedObject->m_objectID;
            classType = (int)selectedObject->m_classType;
            objectType = (int)selectedObject->m_savedObjectType;
        } else if (selectedObjects) {
            for (int i = 0; i < selectedObjects->count(); i++) {
                auto obj = static_cast<GameObject*>(selectedObjects->objectAtIndex(i));
                if (objectID != 0) {
                    if (objectID == -1) objectID = obj->m_objectID;
                    else if (objectID != obj->m_objectID) objectID = 0;
                }
                if (classType != 0) {
                    if (classType == -1) classType = (int)obj->m_classType;
                    else if (classType != (int)obj->m_classType) classType = 0;
                }
                if (objectType != 0) {
                    if (objectType == -1) objectType = (int)obj->m_savedObjectType;
                    else if (objectType != (int)obj->m_savedObjectType) objectType = 0;
                }
            }
        }
    }
    cocos2d::CCPoint getLimitedPosition(cocos2d::CCPoint position) = win 0x120150;
    CCMenuItemSpriteExtra* getModeBtn(char const* frameName, int tag) = win inline, m1 0xa768, ios inline {
        auto button = CCMenuItemSpriteExtra::create(cocos2d::CCSprite::createWithSpriteFrameName(frameName), this, menu_selector(EditorUI::toggleMode));
        button->setTag(tag);
        return button;
    }
    cocos2d::CCNode* getNeighbor(int smartKey, cocos2d::CCPoint position, GJSmartDirection direction, cocos2d::CCArray* objects) = win 0x118820, imac 0x445a0, m1 0x3bd90;
    cocos2d::CCPoint getRelativeOffset(GameObject* object) = win inline, imac 0x3a3c0, m1 0x32e8c {
        return GameToolbox::getRelativeOffset(object, this->offsetForKey(object->m_objectID));
    }
    cocos2d::CCArray* getSelectedObjects() = win 0x110ec0, imac 0x3cc80, m1 0x35050;
    CCMenuItemSpriteExtra* getSimpleButton(gd::string frameName, cocos2d::SEL_MenuHandler selector, cocos2d::CCMenu* menu) = win inline, ios inline {
        auto sprite = cocos2d::CCSprite::createWithSpriteFrameName(frameName.c_str());
        sprite->setScale(std::min(18.f / sprite->getContentSize().width, 18.f / sprite->getContentSize().height));
        auto button = CCMenuItemSpriteExtra::create(sprite, this, selector);
        if (menu) menu->addChild(button);
        return button;
    }
    SmartGameObject* getSmartNeighbor(SmartGameObject* object, cocos2d::CCPoint position, GJSmartDirection direction, cocos2d::CCArray* objects) = win 0x118700, imac 0x42930, m1 0x3a398;
    float getSnapAngle(GameObject* object, cocos2d::CCArray* objects) = win inline, imac 0x4a810, m1 0x40e20 {
        if (objects && objects->count() > 0) {
            for (int i = 0; i < objects->count(); i++) {
                auto rotation = m_editorLayer->rotationForSlopeNearObject(static_cast<GameObject*>(objects->objectAtIndex(i)));
                if (rotation != -1.f) return rotation;
            }
            return -1.f;
        }
        else if (object) return m_editorLayer->rotationForSlopeNearObject(object);
        else return -1.f;
    }
    CCMenuItemSpriteExtra* getSpriteButton(char const* spriteFrameName, cocos2d::SEL_MenuHandler selector, cocos2d::CCMenu* menu, float scale) = win inline, imac 0xbd00, m1 0xa7c0, ios inline {
        return this->getSpriteButton(spriteFrameName, selector, menu, scale, 1, {0, 0});
    }
    CCMenuItemSpriteExtra* getSpriteButton(char const* spriteFrameName, cocos2d::SEL_MenuHandler selector, cocos2d::CCMenu* menu, float scale, int buttonKind, cocos2d::CCPoint offset) = win 0xe28b0, imac 0xbe70, m1 0xa92c;
    CCMenuItemSpriteExtra* getSpriteButton(cocos2d::CCSprite* sprite, cocos2d::SEL_MenuHandler selector, cocos2d::CCMenu* menu, float scale, int buttonKind, cocos2d::CCPoint offset) = win 0xe2940, imac 0x2eb10, m1 0x2bc54;
    cocos2d::CCPoint getTouchPoint(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline, imac 0x4ece0, m1 0x44130 {
        return this->convertToWorldSpace(cocos2d::CCDirector::sharedDirector()->convertToGL(touch->getLocationInView()));
    }
    GJTransformState& getTransformState() = win inline, imac 0x3ced0, ios inline {
        m_transformControl->saveToState(m_transformState);
        return m_transformState;
    }
    float getXMin(int offset) = win 0x122c00, imac 0x2efc0, m1 0x2c120;
    bool init(LevelEditorLayer* editorLayer) = win 0xdf3b0, imac 0x4b9cf0;
    bool isLiveColorSelectTrigger(GameObject* object) = win inline, ios inline {
        return object && object->m_classType == GameObjectClassType::Effect && (object->m_isColorTrigger || object->m_objectID == 1006);
    }
    bool isSpecialSnapObject(int id) = win 0x1290a0, imac 0x4bed0, m1 0x42288;
    bool liveEditColorUsable() = win inline, ios inline {
        return m_selectedObject || m_selectedObjects->count() != 0;
    }
    CreateMenuItem* menuItemFromObjectString(gd::string str, int id) = win 0x10e7b0, imac 0x31a10, m1 0x2e89c;
    cocos2d::CCPoint moveForCommand(EditCommand command) = win 0x11f880, imac 0x4a280, m1 0x40908;
    void moveGamelayer(cocos2d::CCPoint offset) = win 0xe2d90, imac 0x2f3b0, m1 0x2c484;
    void moveObject(GameObject* object, cocos2d::CCPoint offset) = win 0x11fcf0, m1 0x36c14;
    void moveObjectCall(EditCommand command) = win 0x11fa60;
    void moveObjectCall(cocos2d::CCObject* sender) = m1 0x3fd70;
    cocos2d::CCPoint offsetForKey(int id) = win 0x1269e0, imac 0x35770, m1 0x32448;
    void onAssignNewGroupID() = ios inline {
        auto selectedObjects = m_selectedObject ? cocos2d::CCArray::createWithObject(m_selectedObject) : m_selectedObjects;
        if (selectedObjects->count() == 0) return;
        auto groupID = m_editorLayer->getNextFreeGroupID(nullptr);
        for (int i = 0; i < selectedObjects->count(); i++) {
            auto obj = static_cast<GameObject*>(selectedObjects->objectAtIndex(i));
            if (obj->addToGroup(groupID) == 1) m_editorLayer->addToGroup(obj, groupID, false);
        }
        this->updateObjectInfoLabel();
    }
    void onColorFilter(cocos2d::CCObject* sender) = m1 0x2ee84;
    void onCopy(cocos2d::CCObject* sender) = m1 0x28758;
    void onCopyState(cocos2d::CCObject* sender) = win 0x1143a0;
    bool onCreate() = win 0x10f430, imac 0x2e170, m1 0x2b238;
    void onCreateButton(cocos2d::CCObject* sender) = win 0x10efa0, imac 0x347e0, m1 0x3157c;
    void onCreateObject(int id) = win 0x10f630;
    void onDelete(cocos2d::CCObject* sender) = win 0xe5e40;
    void onDeleteAll(cocos2d::CCObject* sender) = win inline, imac 0x32ce0, m1 0x2fb60, ios inline {
        this->deselectAll();
        m_editorLayer->removeAllObjects();
    }
    void onDeleteCustomItem(cocos2d::CCObject* sender) = win 0xe4560;
    void onDeleteInfo(cocos2d::CCObject* sender) = win 0xe5cf0, imac 0x31e00, m1 0x2ec78;
    void onDeleteSelected(cocos2d::CCObject* sender) = win 0xe6470, m1 0xac84;
    void onDeleteSelectedType(cocos2d::CCObject* sender) = win 0xe6a10;
    void onDeleteStartPos(cocos2d::CCObject* sender) = m1 0x2eb84;
    void onDeselectAll(cocos2d::CCObject* sender) = win 0x111480, m1 0x29614;
    void onDuplicate(cocos2d::CCObject* sender) = win 0x112cc0, imac 0x2acc0, m1 0x28580;
    void onEditColor(cocos2d::CCObject* sender) = win 0x11ead0, m1 0x28768;
    void onFindObject(cocos2d::CCObject* sender) = win 0xe7ed0, m1 0x2ef3c;
    void onGoToBaseLayer(cocos2d::CCObject* sender) = win 0x114820, imac 0x2c690;
    void onGoToLayer(cocos2d::CCObject* sender) = win 0x1146c0, m1 0x217550;
    void onGroupDown(cocos2d::CCObject* sender) = win 0x11f4f0, imac 0x2c660;
    void onGroupIDFilter(cocos2d::CCObject* sender) = win 0xe7190, m1 0x2ed58;
    void onGroupSticky(cocos2d::CCObject* sender) = m1 0xb390;
    void onGroupUp(cocos2d::CCObject* sender) = win 0x11f4d0, imac 0x2c640;
    void onLockLayer(cocos2d::CCObject* sender) = m1 0x299f4;
    void onNewCustomItem(cocos2d::CCObject* sender) = win 0xe4070, imac 0x30830, m1 0x2d804;
    void onPaste(cocos2d::CCObject* sender) = m1 0x28760;
    void onPasteColor(cocos2d::CCObject* sender) = win 0x1145b0, m1 0x297bc;
    void onPasteInPlace(cocos2d::CCObject* sender) = win inline, m1 0x3672c, ios inline {
        this->doPasteInPlace(false);
    }
    void onPasteState(cocos2d::CCObject* sender) = win 0x114420, m1 0x29768;
    void onPause(cocos2d::CCObject* sender) = win 0xe1a80;
    void onPlayback(cocos2d::CCObject* sender) = win 0x111ae0;
    void onPlaytest(cocos2d::CCObject* sender) = win 0x1120f0;
    void onResetSpecialFilter(cocos2d::CCObject* sender) = m1 0x2eedc;
    void onSelectBuildTab(cocos2d::CCObject* sender) = imac 0x33db0;
    void onSettings(cocos2d::CCObject* sender) = win 0xe1a00;
    void onStopPlaytest(cocos2d::CCObject* sender) = win 0x112570;
    void onTargetIDChange(int change) = win 0x122420, imac 0x4df30, m1 0x43430;
    void onToggleGuide(EffectGameObject* object) = win inline, imac 0x2f2e0, m1 0x2c3c8 {
        object->m_shouldPreview = !object->m_shouldPreview;
        if (m_editorLayer->tryUpdateSpeedObject(object, false)) m_speedObjectsUpdated = true;
        this->tryUpdateTimeMarkers();
    }
    void onToggleSelectedOrder(EffectGameObject* object) = win inline, imac 0x2f320, m1 0x2c40c {
        auto playbackObject = m_editorLayer->m_playbackObject;
    }
    void onUngroupSticky(cocos2d::CCObject* sender);
    void onUpdateDeleteFilter(cocos2d::CCObject* sender) = win 0xe7540, imac 0x31d70, m1 0x2ebec;
    void orderDownCustomItem(cocos2d::CCObject* sender) = imac 0x315e0;
    void orderUpCustomItem(cocos2d::CCObject* sender) = imac 0x31520, m1 0x2e3b0;
    cocos2d::CCArray* pasteObjects(gd::string str, bool withColor, bool noUndo) = win 0x1135f0;
    void playCircleAnim(cocos2d::CCPoint position, float radius, float duration) = win inline, imac 0x336a0, m1 0x30544, ios inline {
        auto circleWave = CCCircleWave::create(1.f, radius, duration, false, false);
        circleWave->m_color.r = 255;
        circleWave->m_color.g = 255;
        circleWave->m_color.b = 255;
        circleWave->setPosition(position);
        this->addChild(circleWave, 0);
        circleWave->m_circleMode = CircleMode::Outline;
    }
    void playerTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline, ios inline {
        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        auto touchLocation = this->convertToNodeSpace(touch->getLocation());
        if (m_editorLayer->m_gameState.m_isDualMode) {
            if (winSize.width * .5f < touchLocation.x) {
                if (m_playerTouchID2 == -1) {
                    m_playerTouchID2 = touch->getID();
                    m_editorLayer->queueButton(1, true, true);
                }
            }
        }
        else if (GameManager::sharedState()->getGameVariable("0011")) {
            if (m_playerTouchID2 == -1) {
                m_playerTouchID2 = touch->getID();
                m_editorLayer->queueButton(1, true, true);
            }
        }
        if (m_playerTouchID1 == -1) {
            m_playerTouchID1 = touch->getID();
            m_editorLayer->queueButton(1, true, false);
        }
    }
    void playerTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline, imac 0x4ee60, m1 0x44290, ios inline {
        if (touch->getID() == m_playerTouchID1) {
            m_playerTouchID1 = -1;
            m_editorLayer->queueButton(1, false, false);
        }
        else if (touch->getID() == m_playerTouchID2) {
            m_playerTouchID2 = -1;
            m_editorLayer->queueButton(1, false, true);
        }
    }
    void playtestStopped() = win 0x1125b0, m1 0x35c04;
    bool positionIsInSnapped(cocos2d::CCPoint position) = win inline, imac 0x3a400, m1 0x32ed0 {
        for (int i = 0; i < m_snapPositions->count(); i++) {
            auto& snapPos = static_cast<cocos2d::CCNode*>(m_snapPositions->objectAtIndex(i))->getPosition();
            if (snapPos.x == position.x && snapPos.y == position.y) return true;
        }
        return false;
    }
    cocos2d::CCPoint positionWithoutOffset(GameObject* object) = win inline, imac 0x4e1b0, m1 0x436bc {
        return object->getPosition() - this->getRelativeOffset(object);
    }
    void processSelectObjects(cocos2d::CCArray* objects) = win 0x1117a0, imac 0x3d1d0, m1 0x35534;
    void processSmartObjectsFromType(int type, cocos2d::CCArray* objects, cocos2d::CCArray* objects2, cocos2d::CCArray* objects3, cocos2d::CCArray* objects4) = win 0x118470;
    void recreateButtonTabs() = win inline {
        m_reloadItems = false;
        auto gameManager = GameManager::sharedState();
        auto buttonsPerRow = gameManager->getIntGameVariable("0049");
        auto buttonRows = gameManager->getIntGameVariable("0050");
        for (int i = 0; i < m_createButtonBars->count(); i++) {
            static_cast<EditButtonBar*>(m_createButtonBars->objectAtIndex(i))->reloadItems(buttonsPerRow, buttonRows);
        }
        m_editButtonBar->reloadItems(buttonsPerRow, buttonRows);
    }
    void redoLastAction(cocos2d::CCObject* sender) = win 0x1118d0, m1 0xac20;
    void reloadCustomItems() = win 0xe4cd0, m1 0x2e2bc;
    void removeOffset(GameObject* object) = imac 0x3a570, m1 0x33050;
    void replaceGroupID(GameObject* object, int oldID, int newID) = win 0x119020, imac 0x45090, m1 0x3c5d8;
    void repositionObjectsToCenter(cocos2d::CCArray* objects, cocos2d::CCPoint position, bool absolute) = win 0x114300, imac 0x345c0, m1 0x31350;
    void resetObjectEditorValues(cocos2d::CCArray* objects) = win inline, imac 0x406d0, m1 0x386b4 {
        if (!objects) return;
        for (int i = 0; i < objects->count(); i++) {
            auto obj = static_cast<GameObject*>(objects->objectAtIndex(i));
            obj->updateStartPos();
            m_objectEditorStates[obj->m_uniqueID].loadValues(obj);
        }
    }
    void resetSelectedObjectsColor() = win 0x11f7b0;
    void resetUI() = win 0xe4db0, imac 0x2a640, m1 0x27f8c;
    void rotateObjects(cocos2d::CCArray* objects, float rotation, cocos2d::CCPoint pivotPoint) = win 0x121070, imac 0x4e7b0;
    float rotationforCommand(EditCommand command) = win inline, ios inline {
        switch (command) {
            case EditCommand::RotateCW: return 90.f;
            case EditCommand::RotateCCW: return -90.f;
            case EditCommand::RotateCW45: return 45.f;
            case EditCommand::RotateCCW45: return -45.f;
            default: return 0.f;
        }
    }
    void scaleObjects(cocos2d::CCArray* objects, float scaleX, float scaleY, cocos2d::CCPoint pivotPoint, ObjectScaleType type, bool move) = win 0x121490, imac 0x3f6e0, m1 0x37874;
    void selectAll() = win inline, m1 0x35314 {
        auto objects = m_editorLayer->m_objects;
        auto selected = cocos2d::CCArray::create();
        for (int i = 0; i < objects->count(); i++) {
            auto obj = static_cast<GameObject*>(objects->objectAtIndex(i));
            if (m_editorLayer->validGroup(obj, false)) {
                selected->addObject(obj);
            }
        }
    }
    void selectAllWithDirection(bool left) = win 0x1115f0, imac 0x3d2b0, m1 0x3561c;
    void selectBuildTab(int tab) = win 0x114870;
    void selectObject(GameObject* object, bool ignoreFilter) = win 0x110570, imac 0x2e790, m1 0x2b868;
    void selectObjects(cocos2d::CCArray* objects, bool ignoreFilter) = win 0x110860, imac 0x3c160, m1 0x34628;
    void selectObjectsInRect(cocos2d::CCRect rect) = win inline, imac 0x3cb80, m1 0x34f54 {
        auto objects = m_editorLayer->objectsInRect(rect, false);
        if (objects->count() > 0) {
            for (int i = 0; i < objects->count(); i++) {
                auto obj = static_cast<GameObject*>(objects->objectAtIndex(i));
                if ((m_selectedObject && m_selectedObject->m_uniqueID != obj->m_uniqueID) || !m_selectedObjects->containsObject(obj)) {
                    this->createUndoSelectObject(false);
                    break;
                }
            }
            this->selectObjects(objects, false);
            this->updateSpecialUIElements();
        }
    }
    void setupCreateMenu() = win 0xe8020, m1 0x3e294c;
    void setupDeleteMenu() = win 0xe4fb0;
    void setupEditMenu() = win inline, m1 0x27f54, ios inline {
        this->createMoveMenu();
        this->updateEditMenu();
    }
    void setupTransformControl() = win inline, ios inline {}
    bool shouldDeleteObject(GameObject* object) = win 0xe6340;
    bool shouldSnap(GameObject* object) = win inline, imac 0x4ebf0, m1 0x4402c, ios inline {
        return (int)object->getRotation() % 90 == 0;
    }
    void showDeleteConfirmation() = win inline, imac 0x33020, ios inline {
        FLAlertLayer::create(
            this,
            "Delete All",
            "Are you sure you want to <cr>Delete</c> all objects? (<cy>This action cannot be undone</c>)",
            "Cancel",
            "Yes",
            300.f
        )->show();
    }
    void showLiveColorSelectForMode(int colorID) = win 0x11ef20, imac 0x49fc0, m1 0x406b4;
    void showLiveColorSelectForModeSpecial(int colorID) = win inline, imac 0x49ea0, m1 0x405d8 {
        if (m_selectedObject) {
            m_selectedObject->deselectObject();
        }
        else {
            for (auto obj : geode::cocos::CCArrayExt<cocos2d::CCObject*, false>(m_selectedObjects)) {
                static_cast<GameObject*>(obj)->deselectObject();
            }
        }
        this->showLiveColorSelectForMode(colorID);
    }
    void showMaxBasicError() = win 0x112b80;
    void showMaxCoinError() = win inline {
        auto alert = FLAlertLayer::create(
            this,
            "Max Coins",
            "You cannot add more than <cy>3</c> <cg>coins</c> in a single level.",
            "OK",
            nullptr,
            300.f,
            false,
            0.f,
            1.f
        );
        alert->setTag(122);
        alert->show();
    }
    void showMaxError() = win 0x112a50, imac 0x34970;
    void showUI(bool show) = win 0x111940, m1 0x35a90;
    void sliderChanged(cocos2d::CCObject* sender) = win 0xe2a80, imac 0xb770, m1 0xa27c;
    cocos2d::CCSprite* spriteFromObjectString(gd::string str, bool absoluteCenter, bool useGroup, int objLimit, cocos2d::CCArray* objects, cocos2d::CCArray* group, GameObject* groupParent) = win 0x10dea0;
    void toggleDuplicateButton() = win inline, imac 0x2d2c0, m1 0x2a4f8 {
        if (m_selectedObject || m_selectedObjects->count() != 0) {
            m_copyPasteBtn->m_animationEnabled = true;
            m_copyPasteBtn->setColor({ 255, 255, 255 });
            m_copyPasteBtn->setOpacity(255);
            m_copyBtn->m_animationEnabled = true;
            m_copyBtn->setColor({ 255, 255, 255 });
            m_copyBtn->setOpacity(255);
        }
        else {
            m_copyPasteBtn->m_animationEnabled = false;
            m_copyPasteBtn->setColor({ 166, 166, 166 });
            m_copyPasteBtn->setOpacity(175);
            m_copyBtn->m_animationEnabled = false;
            m_copyBtn->setColor({ 166, 166, 166 });
            m_copyBtn->setOpacity(175);
        }
        auto hasClipboard = !GameManager::sharedState()->m_editorClipboard.empty();
        m_pasteBtn->m_animationEnabled = hasClipboard;
        if (hasClipboard) {
            m_pasteBtn->setColor({ 255, 255, 255 });
            m_pasteBtn->setOpacity(255);
        }
        else {
            m_pasteBtn->setColor({ 166, 166, 166 });
            m_pasteBtn->setOpacity(175);
        }
    }
    void toggleEditObjectButton() = win 0x11a930, m1 0x2a434;
    void toggleEnableRotate(cocos2d::CCObject* sender) = win 0x110220, m1 0xaaa0;
    void toggleFreeMove(cocos2d::CCObject* sender) = m1 0xa9c4;
    void toggleLockUI(bool lockUI) = win inline, imac 0x2d1e0, m1 0x26b308 {
        m_isPaused = lockUI;
    }
    void toggleMode(cocos2d::CCObject* sender) = win 0xe4ed0, imac 0x2a900, m1 0x2820c;
    void toggleObjectInfoLabel() = m1 0x2a1f8;
    void toggleSnap(cocos2d::CCObject* sender);
    void toggleSpecialEditButtons() = win 0x11aa30, m1 0x2a660;
    void toggleStickyControls(bool enable) = win inline {
        m_stickyControlsEnabled = enable;
        m_linkBtn->setEnabled(enable);
              m_linkBtn->setVisible(enable);
              m_unlinkBtn->setEnabled(enable);
              m_unlinkBtn->setVisible(enable);
    }
    void toggleSwipe(cocos2d::CCObject* sender) = m1 0xa8c4;
    void transformObject(GameObject* object, EditCommand command, bool noOffset);
    void transformObjectCall(EditCommand command) = win 0x120210, imac 0x4a480, m1 0x40ed4;
    void transformObjectCall(cocos2d::CCObject* sender) = m1 0x3fda4;
    void transformObjects(cocos2d::CCArray* objs, cocos2d::CCPoint anchor, float scaleX, float scaleY, float rotateX, float rotateY, float warpX, float warpY) = win 0x121a80, imac 0x407f0, m1 0x387c4;
    void transformObjectsActive() = win 0x1219c0;
    void transformObjectsReset() = win inline {
        auto selectedObjects = m_selectedObjects;
        if (!selectedObjects || selectedObjects->count() == 0) {
            if (!m_selectedObject) return;
            selectedObjects = cocos2d::CCArray::createWithObject(m_selectedObject);
        }
        if (selectedObjects) this->transformObjects(selectedObjects, m_pivotPoint, 1.f, 1.f, 0.f, 0.f, m_transformState.m_skewX, m_transformState.m_skewY);
    }
    void triggerSwipeMode() = win 0x123770, imac 0x4ec20, m1 0x2a5744;
    void tryUpdateTimeMarkers() = win inline, imac 0x2f310, m1 0x2c408, ios inline {}
    void undoLastAction(cocos2d::CCObject* object) = win 0x111860, m1 0xabbc;
    void updateButtons() = win 0xe1e90, m1 0x29b48;
    void updateCreateMenu(bool selectTab) = win 0x10efe0, imac 0x2e280, m1 0x2b370;
    void updateDeleteButtons() = win 0xe76c0, m1 0x2ef84;
    void updateDeleteMenu() = win inline, imac 0x2d3f0, m1 0x2a624, ios inline {
        m_deleteMenu->setVisible(m_selectedMode == 1);
        this->updateDeleteButtons();
    }
    void updateEditButtonColor(int tag, cocos2d::ccColor3B color) = win 0x1149d0, imac 0x3ea40, m1 0x36d90;
    void updateEditColorButton() = win 0x11e960, imac 0x49290, m1 0x3fbcc;
    void updateEditMenu() = win inline, imac 0x2e860, m1 0x2b950, ios inline {
        m_editButtonBar->setVisible(m_selectedMode == 3);
    }
    void updateGridNodeSize() = win 0xe2c40, imac 0x2f170, m1 0x2c2a8;
    void updateGridNodeSize(int objectID) = win inline, m1 0x2c38c, ios inline {
        auto size = ObjectToolbox::sharedState()->gridNodeSizeForKey(objectID);
        m_gridSize = size;
        m_editorLayer->m_drawGridLayer->m_gridSize = size;
    }
    void updateGroupIDBtn2() = win inline, imac 0x3e9e0, ios inline {
        m_goToBaseBtn->setVisible(m_editorLayer->m_currentLayer >= 0);
    }
    void updateGroupIDLabel() = win 0x11f520;
    void updateObjectInfoLabel() = win 0xe2ea0, m1 0x2c500;
    void updatePlaybackBtn() = win 0x111fa0, imac 0x2d0d0, m1 0x2a30c;
    void updateSlider() = win 0xe2b80, imac 0x2ab80, m1 0x28468;
    void updateSpecialUIElements() = win inline, m1 0x2b96c, ios inline {
        this->updateObjectInfoLabel();
        this->updateScaleControl();
    }
    void updateZoom(float zoom) = win 0x112720, m1 0x35cc4;
    float valueFromXPos(float xPos) = win inline, imac 0x2f0e0, m1 0x2c218 {
        auto xMin = this->getXMin(0);
        auto sectionCount = std::max(m_editorLayer->getSectionCount(), 100);
        auto scale = m_editorLayer->m_objectLayer->getScale();
        return std::clamp(-(xPos - xMin) / (sectionCount * 100.f * scale), 0.f, 1.f);
    }
    float xPosFromValue(float value) = win inline, imac 0x2ef20, m1 0x2c094 {
        auto xMin = this->getXMin(0);
        auto sectionCount = std::max(m_editorLayer->getSectionCount(), 100);
        auto scale = m_editorLayer->m_objectLayer->getScale();
        return sectionCount * 100.f * scale * value - xMin;
    }
    void zoomGameLayer(bool zoomingIn) = win inline, imac 0x3dc80, m1 0x35f48, ios inline {
        auto scale = m_editorLayer->m_objectLayer->getScale();
        this->updateZoom(std::clamp(zoomingIn ? scale + .1f : scale - .1f, .1f, 4.f));
    }
    void zoomIn(cocos2d::CCObject* sender) = win 0x112680, imac 0xc8b0, m1 0xb2d4;
    void zoomOut(cocos2d::CCObject* sender) = win 0x1126d0, imac 0xc900, m1 0xb32c;

    gd::unordered_map<int, GameObjectEditorState> m_objectEditorStates;
    GJTransformState m_transformState;
    bool m_isPlayingMusic;
    EditButtonBar* m_customTabBar;
    bool m_alertShown;
    cocos2d::CCArray* m_uiItems;
    float m_gridSize;
    int m_playerTouchID1;
    int m_playerTouchID2;
    bool m_playbackActive;
    float m_playbackStartWarp;
    float m_playbackStartTime;
    UndoObject* m_undoObject;
    bool m_spaceSwiping;
    bool m_noSnapUndo;
    bool m_editingObject;
    bool m_increaseScale;
    bool m_refreshPosition;
    int m_rotationTouchID;
    int m_scaleTouchID;
    int m_touchID;
    int m_transformTouchID;
    cocos2d::CCLabelBMFont* m_objectInfoLabel;
    GJRotationControl* m_rotationControl;
    cocos2d::CCPoint m_pivotPoint;
    bool m_canActivateControls;
    GJScaleControl* m_scaleControl;
    GJTransformControl* m_transformControl;
    cocos2d::CCNode* m_transformNode;
    cocos2d::CCNode* m_transformChild;
    cocos2d::CCDictionary* m_editButtonDict;
    EditButtonBar* m_createButtonBar;
    EditButtonBar* m_editButtonBar;
    Slider* m_positionSlider;
    float m_unk308;
    float m_constrainedHeight;
    float m_toolbarHeight;
    bool m_swipeEnabled;
    bool m_swipeActive;
    bool m_swipeSelected;
    bool m_continuousSnap;
    bool m_freeMoveEnabled;
    bool m_snapObjectExists;
    bool m_snapSelected;
    bool m_stickyControlsEnabled;
    bool m_linkControlsEnabled;
    bool m_speedObjectsUpdated;
    cocos2d::CCPoint m_createPosition;
    cocos2d::CCArray* m_snapPositions;
    cocos2d::CCPoint m_snapPosition;
    cocos2d::CCArray* m_selectedObjects;
    cocos2d::CCMenu* m_deleteMenu;
    cocos2d::CCArray* m_customTabControls;
    CCMenuItemSpriteExtra* m_deleteModeBtn;
    CCMenuItemSpriteExtra* m_buildModeBtn;
    CCMenuItemSpriteExtra* m_editModeBtn;
    CCMenuItemSpriteExtra* m_swipeBtn;
    CCMenuItemSpriteExtra* m_freeMoveBtn;
    CCMenuItemSpriteExtra* m_deselectBtn;
    CCMenuItemSpriteExtra* m_snapBtn;
    CCMenuItemSpriteExtra* m_rotateBtn;
    CCMenuItemSpriteExtra* m_playbackBtn;
    CCMenuItemSpriteExtra* m_playtestBtn;
    CCMenuItemSpriteExtra* m_playtestStopBtn;
    CCMenuItemSpriteExtra* m_trashBtn;
    CCMenuItemSpriteExtra* m_linkBtn;
    CCMenuItemSpriteExtra* m_unlinkBtn;
    CCMenuItemToggler* m_linkControlsToggler;
    CCMenuItemSpriteExtra* m_undoBtn;
    CCMenuItemSpriteExtra* m_redoBtn;
    CCMenuItemSpriteExtra* m_editObjectBtn;
    CCMenuItemSpriteExtra* m_editGroupBtn;
    CCMenuItemSpriteExtra* m_editHSVBtn;
    CCMenuItemSpriteExtra* m_editSpecialBtn;
    cocos2d::CCObject* m_unk3F0;
    CCMenuItemSpriteExtra* m_copyPasteBtn;
    CCMenuItemSpriteExtra* m_copyBtn;
    CCMenuItemSpriteExtra* m_pasteBtn;
    CCMenuItemSpriteExtra* m_copyValuesBtn;
    CCMenuItemSpriteExtra* m_pasteStateBtn;
    CCMenuItemSpriteExtra* m_pasteColorBtn;
    CCMenuItemSpriteExtra* m_goToLayerBtn;
    cocos2d::CCArray* m_createButtonBars;
    cocos2d::CCMenu* m_tabsMenu;
    cocos2d::CCArray* m_tabsArray;
    cocos2d::CCSprite* m_deleteAllSprite;
    cocos2d::CCSprite* m_customDeleteSprite;
    CCMenuItemSpriteExtra* m_deleteButton;
    CCMenuItemSpriteExtra* m_deleteAllButton;
    CCMenuItemSpriteExtra* m_deleteFilterNone;
    CCMenuItemSpriteExtra* m_deleteFilterStatic;
    CCMenuItemSpriteExtra* m_deleteFilterDetails;
    CCMenuItemSpriteExtra* m_deleteFilterCustom;
    cocos2d::CCLabelBMFont* m_currentLayerLabel;
    CCMenuItemSpriteExtra* m_layerNextBtn;
    CCMenuItemSpriteExtra* m_layerPrevBtn;
    CCMenuItemSpriteExtra* m_goToBaseBtn;
    ButtonSprite* m_deleteGroupSprite;
    ButtonSprite* m_deleteColorSprite;
    void* m_unk4b8;
    void* m_unk4c0;
    int m_selectedObjectIndex;
    cocos2d::CCArray* m_createButtonArray;
    cocos2d::CCArray* m_customObjectButtonArray;
    cocos2d::CCArray* m_deleteObjects;
    int m_selectedMode;
    LevelEditorLayer* m_editorLayer;
    cocos2d::CCPoint m_swipeStart;
    cocos2d::CCPoint m_swipeEnd;
    cocos2d::CCPoint m_swipePosition;
    cocos2d::CCPoint m_lastTouchPoint;
    cocos2d::CCPoint m_cameraTest;
    cocos2d::CCPoint m_clickAtPosition;
    GameObject* m_selectedObject;
    GameObject* m_snapObject;
    bool m_isDraggingCamera;
    bool m_continueSwipe;
    bool m_findSnap;
    void* m_unk540;
    int m_selectedTab;
    int m_cycledObjectIndex;
    ColorSelectLiveOverlay* m_colorOverlay;
    HSVLiveOverlay* m_hsvOverlay;
    double m_keyTime;
    double m_keyTime2;
    bool m_swipeModeTriggered;
    cocos2d::CCSprite* m_layerLockSprite;
    void* m_unk580;
    bool m_pressedSpace;
    float m_editorZoom;
    bool m_isPaused;
    bool m_reloadItems;
}

[[link(android)]]
class EditTriggersPopup : SetupTriggerPopup {
    // virtual ~EditTriggersPopup();

    static EditTriggersPopup* create(EffectGameObject* object, cocos2d::CCArray* objects);

    virtual void determineStartValues() = win 0x28f0a0, m1 0x23a650, imac 0x29a870;
    virtual void onClose(cocos2d::CCObject* sender) = win 0x28f0b0, m1 0x23a654, imac 0x29a880;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x28ed40, m1 0x23a370;
}

[[link(android)]]
class EffectGameObject : EnhancedGameObject {
    // virtual ~EffectGameObject();
    EffectGameObject() = imac 0x1f3b70, m1 0x1a1dd4, win 0x4953b0;

    static EffectGameObject* create(char const* frame) = win inline, m1 0x172514 {
        auto ret = new EffectGameObject();
        if (ret->init(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void setOpacity(unsigned char opacity) = win 0x4a5b80, m1 0x1728f4, imac 0x1b90a0;
    virtual void firstSetup() = win 0x4a8440, m1 0x173e44, imac 0x1bae10;
    virtual void customSetup() = win 0x4a8470, m1 0x156eb0, imac 0x1966c0;
    virtual void triggerObject(GJBaseGameLayer* layer, int uniqueID, gd::vector<int> const* remapKeys) = win 0x4a5bc0, m1 0x172978, imac 0x1b9120;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4a8760, m1 0x1582cc, imac 0x197a50;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x4ab8b0, imac 0x18c070, m1 0x14f0cc;
    virtual void setRScaleX(float scaleX) = win 0x4a5580, m1 0x1725b8, imac 0x1b8c80;
    virtual void setRScaleY(float scaleY) = win 0x4a55d0, m1 0x1725c8, imac 0x1b8ca0;
    virtual void triggerActivated(float xPosition) = win 0x4a8420, imac 0x1bada0, m1 0x173dd0;
    virtual void restoreObject() = win 0x4a8210, imac 0x1bab60, m1 0x173b8c;
    virtual float spawnXPosition() = win 0x4a83e0, m1 0x173d8c, imac 0x1bad60;
    virtual bool canReverse() = win 0x4ab6d0, imac 0x1bafb0, m1 0x17409c;
    virtual bool isSpecialSpawnObject() = win inline, m1 0x174128, imac 0x1bb020 { return false; }
    virtual bool canBeOrdered() = win 0x4ab840, m1 0x1742c8, imac 0x1bb1c0;
    virtual cocos2d::CCLabelBMFont* getObjectLabel() = win 0x495620, imac 0x1f3860, m1 0x1a1b64;
    virtual void setObjectLabel(cocos2d::CCLabelBMFont* label) = win 0x495630, imac 0x1f3870, m1 0x1a1b6c;
    virtual void stateSensitiveOff(GJBaseGameLayer* layer) = win 0x4a8160, imac 0x1baad0, m1 0x173b00;

    int getTargetColorIndex() = win inline, imac 0x1bab80, m1 0x173ba0 {
        switch (m_objectID) {
            case 29: return 1000;
            case 30: return 1001;
            case 105: return 1004;
            case 744: return 1003;
            case 900: return 1009;
            case 915: return 1002;
            default: return m_targetColor;
        }
    }
    bool init(char const* frame) = win 0x4a5510, m1 0x149424, ios inline {
        if (!EnhancedGameObject::init(frame)) return false;
        m_classType = GameObjectClassType::Effect;
        m_triggerTargetColor.r = 255;
        m_triggerTargetColor.g = 255;
        m_triggerTargetColor.b = 255;
        m_legacyHSV = true;
        m_duration = .5f;
        return true;
    }
    void playTriggerEffect() = m1 0x1725d8;
    void resetSpawnTrigger() = win inline, imac 0x1bade0, m1 0x173e10 {
        m_activatedByPlayer1 = false;
        m_activatedByPlayer2 = false;
        m_spawnXPosition = this->getPosition().x;
    }
    void setTargetID(int id) = win inline, m1 0x16053c {
        m_targetGroupID = std::clamp(id, 0, 9999);
    }
    void setTargetID2(int id) = win inline, m1 0x160554 {
        m_centerGroupID = std::clamp(id, 0, 9999);
    }
    void triggerEffectFinished() = m1 0x8fbe8;
    void updateInteractiveHover(float offset) = win 0x4a82c0;
    void updateSpecialColor() = win 0x4a8240;
    void updateSpeedModType() = win 0x4ab580, imac 0x1baef0, m1 0x173f38;

    // this is probably pretty wrong :D
    bool m_unknownBool;
    cocos2d::ccColor3B m_triggerTargetColor;
    // property 10
    float m_duration;
    // property 35
    float m_opacity;
    bool m_triggerEffectPlaying;
    // property 51
    int m_targetGroupID;
    // property 71
    int m_centerGroupID;
    // property 11
    bool m_isTouchTriggered;
    // property 62
    bool m_isSpawnTriggered;
    // property 369
    bool m_hasCenterEffect;
    // property 75
    float m_shakeStrength;
    // property 84
    float m_shakeInterval;
    // property 14
    bool m_tintGround;
    // property 15
    bool m_usesPlayerColor1;
    // property 16
    bool m_usesPlayerColor2;
    // property 17
    bool m_usesBlending;
    // property 28, property 29
    cocos2d::CCPoint m_moveOffset;
    // property 30
    EasingType m_easingType;
    // property 85
    float m_easingRate;
    // property 58
    bool m_lockToPlayerX;
    // property 59
    bool m_lockToPlayerY;
    // property 141
    bool m_lockToCameraX;
    // property 142
    bool m_lockToCameraY;
    // property 100
    bool m_useMoveTarget;
    // property 101
    MoveTargetType m_moveTargetMode;
    // property 143
    float m_moveModX;
    // property 144
    float m_moveModY;
    // property 393
    bool m_smallStep;
    // property 394
    bool m_isDirectionFollowSnap360;
    // property 395
    int m_targetModCenterID;
    // property 396
    float m_directionModeDistance;
    // property 397
    bool m_isDynamicMode;
    // property 544
    bool m_isSilent;
    // property 538
    int m_specialTarget;
    // property 68
    float m_rotationDegrees;
    // property 69
    int m_times360;
    // property 70
    bool m_lockObjectRotation;
    // property 401
    int m_rotationTargetID;
    // property 402
    float m_rotationOffset;
    // property 403
    int m_dynamicModeEasing;
    // property 72
    float m_followXMod;
    // property 73
    float m_followYMod;
    // property 90
    float m_followYSpeed;
    // property 91
    float m_followYDelay;
    // property 92
    int m_followYOffset;
    // property 105
    float m_followYMaxSpeed;
    // property 45
    float m_fadeInDuration;
    // property 46
    float m_holdDuration;
    // property 47
    float m_fadeOutDuration;
    // property 48
    int m_pulseMode;
    // property 52
    int m_pulseTargetType;
    // property 49
    cocos2d::ccHSVValue m_hsvValue;
    // property 50
    int m_copyColorID;
    // property 60
    bool m_copyOpacity;
    // property 65
    bool m_pulseMainOnly;
    // property 66
    bool m_pulseDetailOnly;
    // property 86
    bool m_pulseExclusive;
    // property 210
    bool m_legacyHSV;
    // property 56
    bool m_activateGroup;
    // property 81
    bool m_touchHoldMode;
    // property 82
    TouchTriggerType m_touchToggleMode;
    // property 198
    TouchTriggerControl m_touchPlayerMode;
    // property 89
    bool m_isDualMode;
    // property 76
    int m_animationID;
    float m_spawnXPosition;
    int m_spawnOrder;
    // property 87
    bool m_isMultiTriggered;
    // property 102
    bool m_previewDisable;
    // property 441
    bool m_spawnOrdered;
    // property 93
    bool m_triggerOnExit;
    // property 95
    int m_itemID2;
    // property 534
    int m_controlID;
    // property 535
    bool m_targetControlID;
    // property 94
    bool m_isDynamicBlock;
    // property 80
    int m_itemID;
    // property 138
    bool m_targetPlayer1;
    // property 200
    bool m_targetPlayer2;
    // property 201
    bool m_followCPP;
    // property 78
    bool m_subtractCount;
    // property 381
    bool m_collectibleIsPickupItem;
    // property 382
    bool m_collectibleIsToggleTrigger;
    // property 440
    int m_collectibleParticleID;
    // property 383
    int m_collectiblePoints;
    // property 463
    bool m_hasNoAnimation;
    void* m_unk698;
    int m_forceModID;
    bool m_rotateFollowP1;
    bool m_rotateFollowP2;
    float m_unk6a8;
    float m_unk6ac;
    float m_unk6b0;
    bool m_unk6b4;
    // property 148
    float m_gravityValue;
    // property 284
    bool m_isSinglePTouch;
    // property 371
    float m_zoomValue;
    // property 111
    bool m_cameraIsFreeMode;
    // property 112
    bool m_cameraEditCameraSettings;
    // property 113
    float m_cameraEasingValue;
    // property 114
    float m_cameraPaddingValue;
    // property 370
    bool m_cameraDisableGridSnap;
    // property 118
    bool m_endReversed;
    // property 120
    float m_timeWarpTimeMod;
    // property 13
    bool m_shouldPreview;
    // property 115
    int m_ordValue;
    // property 170
    int m_channelValue;
    // property 117
    bool m_isReverse;
    short m_speedModType;
    cocos2d::CCPoint m_speedStart;
    // property 12
    int m_secretCoinID;
    bool m_unk6f4;
    bool m_unk6f5;
    cocos2d::CCPoint m_endPosition;
    float m_spawnTriggerDelay;
    float m_gravityMod;
    bool m_unk708;
    cocos2d::CCLabelBMFont* m_objectLabel;
    // property 280
    bool m_ignoreGroupParent;
    // property 281
    bool m_ignoreLinkedObjects;
    bool m_channelChanged;
}

[[link(android), depends(CAState), depends(PulseEffectAction), depends(CountTriggerAction), depends(OpacityEffectAction), depends(TouchToggleAction), depends(CollisionTriggerAction), depends(ToggleTriggerAction), depends(SpawnTriggerAction), depends(GroupCommandObject2), depends(TimerItem), depends(TimerTriggerAction)]]
class EffectManagerState {
    // ~EffectManagerState();
    // EffectManagerState();

    gd::vector<CAState> m_unkVecCAState;
    gd::vector<PulseEffectAction> m_unkVecPulseEffectAction;
    gd::unordered_map<int,gd::vector<PulseEffectAction>> m_unorderedMapInt_vectorPulseEffectAction;
    gd::unordered_map<int,gd::vector<CountTriggerAction>> m_unorderedMapInt_vectorCountTriggerAction;
    gd::unordered_set<int> m_unorderedSet_int1;
    gd::map<int,int> m_mapInt_Int;
    gd::unordered_map<int,OpacityEffectAction> m_unorderedMapInt_OpacityEffectAction;
    gd::vector<TouchToggleAction> m_vectorTouchToggleAction;
    gd::vector<CollisionTriggerAction> m_vectorCollisionTriggerAction;
    gd::vector<ToggleTriggerAction> m_vectorToggleTriggerAction;
    gd::vector<SpawnTriggerAction> m_vectorSpawnTriggerAction;
    gd::unordered_map<int,int> m_itemCountMap;
    gd::unordered_map<int,bool> m_unorderedMapInt_bool;
    gd::vector<GroupCommandObject2> m_vectorGroupCommandObject2;
    gd::unordered_map<int,std::pair<double,double>> m_unorderedMapInt_pair_double_double;
    gd::unordered_set<int> m_unorderedSet_int2;
    gd::unordered_map<int,TimerItem> m_timerItemMap;
    gd::unordered_map<int,gd::vector<TimerTriggerAction>> m_unorderedMapInt_vectorTimerTriggerAction;
}

[[link(android)]]
class EndLevelLayer : GJDropDownLayer {
    EndLevelLayer() = m1 0x422fe4 {
        m_playLayer = nullptr;
        m_notLocal = false;
        m_coinsVerified = false;
        m_unknown3 = false;
        m_exiting = false;
        m_animateCoins = false;
        m_endEffectPlayed = false;
        m_sideMenu = nullptr;
        m_coinsToAnimate = nullptr;
        m_orbs = 0;
        m_stars = 0;
        m_moons = 0;
        m_diamonds = 0;
        m_hidden = false;
    }
    ~EndLevelLayer() = win inline {
        CC_SAFE_RELEASE(m_coinsToAnimate);
    }

    static EndLevelLayer* create(PlayLayer* playLayer) = win inline, m1 0x41f654 {
        auto ret = new EndLevelLayer();
        if (ret->init(playLayer)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyBackClicked() = win 0x135710, m1 0x4227c4, imac 0x4c2c50;
    virtual void keyDown(cocos2d::enumKeyCodes key, double timestamp) = win 0x136db0, imac 0x4c33f0, m1 0x422f60;
    virtual void customSetup() = win 0x132e90, m1 0x41f928, imac 0x4bfab0;
    virtual void showLayer(bool instant) = win 0x134ce0, m1 0x421a30, imac 0x4c1e20;
    virtual void enterAnimFinished() = win inline, imac 0x4c2b70, m1 0x422718 {}
    virtual void keyUp(cocos2d::enumKeyCodes key, double timestamp) = win inline, m1 0x422fdc, imac 0x4c3480 {}

    void coinEnterFinished(cocos2d::CCPoint position) = win 0x135ea0, imac 0x4c3000, m1 0x422b54;
    void coinEnterFinishedO(cocos2d::CCObject* sender) = win 0x135e60, imac 0x4c2fc0, m1 0x422b08;
    void currencyEnterFinished() = m1 0x422d74;
    void diamondEnterFinished() = m1 0x422e68;
    gd::string getCoinString() = win 0x1349a0, imac 0x4c1620, m1 0x4211ac;
    const char* getEndText() = win 0x136e00, m1 0x4213f4;
    void goEdit() = win 0x135350, imac 0x4c2b90, m1 0x422720;
    bool init(PlayLayer* playLayer) = win inline, imac 0x4bf750, m1 0x41f6e8, ios inline {
        m_playLayer = playLayer;
        return GJDropDownLayer::init(" ", 230.f, true);
    }
    void onEdit(cocos2d::CCObject* sender) = win 0x135250, m1 0x4216f0;
    void onEveryplay(cocos2d::CCObject* sender) = win inline, imac 0x4c2b80, m1 0x42271c, ios inline {}
    void onHideLayer(cocos2d::CCObject* sender) = win 0x135420, imac 0x4c1d30, m1 0x421944;
    void onLevelLeaderboard(cocos2d::CCObject* sender) = win 0x1348a0, m1 0x4218d8;
    void onMenu(cocos2d::CCObject* sender) = win 0x1350d0, m1 0x4215ec;
    void onReplay(cocos2d::CCObject* sender) = win 0x134ec0, m1 0x4214d8;
    void onRestartCheckpoint(cocos2d::CCObject* sender) = win 0x135500, m1 0x421784;
    void playCoinEffect(float duration) = win 0x135c20, imac 0x4c2310, m1 0x10fea8;
    void playCurrencyEffect(float duration) = m1 0x4220a8;
    void playDiamondEffect(float duration) = m1 0x4223e0;
    void playEndEffect() = win 0x136af0, m1 0x4228ec;
    void playStarEffect(float duration) = win 0x135720, m1 0x421bc0;
    void starEnterFinished() = win 0x135ac0, m1 0x4227d0;
    void tryShowBanner(float dt) = m1 0x421a00;

    PlayLayer* m_playLayer;
    bool m_notLocal;
    bool m_coinsVerified;
    bool m_unknown3;
    bool m_exiting;
    bool m_animateCoins;
    bool m_endEffectPlayed;
    cocos2d::CCMenu* m_sideMenu;
    cocos2d::CCArray* m_coinsToAnimate;
    cocos2d::CCPoint m_starsPosition;
    cocos2d::CCPoint m_orbsPosition;
    cocos2d::CCPoint m_diamondsPosition;
    int m_orbs;
    int m_stars;
    int m_moons;
    int m_diamonds;
    bool m_secretKey;
    bool m_hidden;
}

[[link(android)]]
class EndPortalObject : GameObject {
    // virtual ~EndPortalObject();
    EndPortalObject() {
        m_gradientBar = nullptr;
        m_flippedX = false;
        m_startPosHeightRelated = false;
    }

    static EndPortalObject* create() = win inline, imac 0x39bee0, m1 0x32143c {
        auto ret = new EndPortalObject();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x137d90, imac 0x39bf80, m1 0x3214d8;
    virtual void setPosition(cocos2d::CCPoint const& position) = win 0x1382a0, m1 0x321948, imac 0x39c470;
    virtual void setVisible(bool visible) = win 0x138400, imac 0x39c580, m1 0x321a40;

    cocos2d::CCPoint getSpawnPos() = win 0x1381e0, m1 0x3218e4;
    void triggerObject(GJBaseGameLayer* layer) = win inline, m1 0x321874 {
        auto playLayer = GameManager::sharedState()->m_playLayer;
        if (!playLayer->m_player1->m_isDead) {
            playLayer->m_levelEndAnimationStarted = true;
            playLayer->m_uiLayer->disableMenu();
            playLayer->playEndAnimationToPos(this->getStartPos());
        }
    }
    void updateColors(cocos2d::ccColor3B color) = win inline, imac 0x39c2b0, m1 0x3217a8 {
        if (m_particle) {
            m_particle->setStartColor({ color.r / 255.f, color.g / 255.f, color.b / 255.f, 1.f });
            m_particle->setEndColor({ color.r / 255.f, color.g / 255.f, color.b / 255.f, 1.f });
        }
        m_gradientBar->setColor(color);
    }
    void updateEndPos(bool updateParticle) = win 0x138450, m1 0x321aa4;

    cocos2d::CCSprite* m_gradientBar;
    bool m_flippedX;
    bool m_startPosHeightRelated;
}

[[link(android)]]
class EndTriggerGameObject : EffectGameObject {
    // virtual ~EndTriggerGameObject();
    EndTriggerGameObject() {
        m_noEffects = false;
        m_noSFX = false;
        m_instant = false;
    }

    static EndTriggerGameObject* create() = win inline {
        auto ret = new EndTriggerGameObject();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x4bc8f0, m1 0x18e9e0, imac 0x1db780;
    virtual void triggerObject(GJBaseGameLayer* layer, int uniqueID, gd::vector<int> const* remapKeys) = win 0x4bc960, m1 0x18ea30, imac 0x1db7d0;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4bcd90, m1 0x18f5ac, imac 0x1dc5f0;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x4bca50, m1 0x18eafc, imac 0x1db8a0;

    // property 460
    bool m_noEffects;
    // property 461
    bool m_noSFX;
    // property 487
    bool m_instant;
}

[[link(android)]]
class EnhancedGameObject : GameObject {
    // virtual ~EnhancedGameObject();
    EnhancedGameObject() {
        m_poweredOn = false;
        m_state = 0;
        m_animationRandomizedStartValue = 0;
        m_animationStart = 0.f;
        m_unk540 = 0.f;
        m_unk544 = 0.f;
        m_unk548 = false;
        m_randomFrameTime = 1.f;
        m_visible = false;
        m_shouldNotHideAnimFreeze = false;
        m_usesSpecialAnimation = false;
        m_frameTime = 1.f;
        m_frames = 1;
        m_hasCustomAnimation = false;
        m_hasCustomRotation = false;
        m_disableRotation = false;
        m_rotationSpeed = 0.f;
        m_rotationAngle = 0.f;
        m_rotationDelta = 0.f;
        m_rotationAnimationSpeed = 0.f;
        m_animationRandomizedStart = false;
        m_animationSpeed = 1.f;
        m_animationShouldUseSpeed = false;
        m_animateOnTrigger = false;
        m_disableDelayedLoop = false;
        m_disableAnimShine = false;
        m_singleFrame = 0;
        m_animationOffset = false;
        m_animationTriggered = false;
        m_unkAnimationInt = 0;
        m_maybeAnimationVariableXInt = 0;
        m_maybeAnimationVariableYInt = 0;
        m_animateOnlyWhenActive = false;
        m_isNoMultiActivate = false;
        m_isMultiActivate = false;
        m_activated = false;
        m_activatedByPlayer1 = false;
        m_activatedByPlayer2 = false;
        m_hasUniqueCoin = false;
    }

    static EnhancedGameObject* create(char const* frame) = win inline, imac 0x5a18f0, m1 0x4e5ef8 {
        auto ret = new EnhancedGameObject();
        if (ret->init(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void customSetup() = win 0x1a4fb0, imac 0x5cc2d0, m1 0x4fae40;
    virtual void resetObject() = win 0x1a4970, m1 0x4fa79c, imac 0x5cbb10;
    virtual void deactivateObject(bool deactivate) = win 0x1a6ab0, m1 0x4fc07c, imac 0x5cf1f0;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x1a4c80, imac 0x5cbde0, m1 0x4faa54;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x1a6c10, m1 0x4fc1c8, imac 0x5cf330;
    virtual void triggerActivated(float xPosition) = win 0x1a4ac0, imac 0x5cbc70, m1 0x4fa8c8;
    virtual void restoreObject() = win 0x1a4a20, imac 0x5cbba0, m1 0x4fa818;
    virtual void animationTriggered() = win 0x1a4bb0, m1 0x4fa9c4, imac 0x5cbd40;
    virtual void activatedByPlayer(PlayerObject* player) = win 0x1a4ad0, imac 0x5cbc80, m1 0x4fa8d4;
    virtual bool hasBeenActivatedByPlayer(PlayerObject* player) = win 0x1a4b30, imac 0x5cbcd0, m1 0x4fa934;
    virtual bool hasBeenActivated() = win 0x1a4b90, m1 0x4fa9a4, imac 0x5cbd20;
    virtual void saveActiveColors() = win 0x1a4c10, m1 0x4fa9d8, imac 0x5cbd60;
    virtual bool canAllowMultiActivate() = win 0x1a4810, imac 0x5cb810, m1 0x4fa668;
    virtual bool getHasSyncedAnimation() = win 0x18b620, imac 0x1f3810, m1 0x1a1b3c;
    virtual bool getHasRotateAction() = win 0x18b630, imac 0x1f3820, m1 0x1a1b44;
    virtual bool canMultiActivate(bool multiActivate) = win 0x1a4aa0, m1 0x4fa8a8, imac 0x5cbc50;
    virtual void powerOnObject(int state) = win 0x1a4a60, imac 0x5cbbe0, m1 0x4fa850;
    virtual void powerOffObject() = win 0x1a4a80, m1 0x4fa864, imac 0x5cbc00;
    virtual void stateSensitiveOff(GJBaseGameLayer* layer) {}
    virtual void updateSyncedAnimation(float totalTime, int frameIndex) = win 0x1a7df0, imac 0x25b580, m1 0x2003fc;
    virtual void updateAnimateOnTrigger(bool animate) = win 0x1a9ab0, m1 0x201838, imac 0x25d4d0;

    void createRotateAction(float angle, int clockwiseDirection) = win 0x1a72c0, imac 0x5cc230, m1 0x4fadd0;
    bool init(char const* frame) = win 0x1a47c0;
    void previewAnimateOnTrigger() = win inline, imac 0x25d5c0, m1 0x201930 {
        m_animateOnTrigger = false;
        m_isDisabled2 = false;
        this->updateSyncedAnimation(0.f, -1);
        m_animateOnTrigger = true;
    }
    void refreshRotateAction() = win inline, imac 0x5d0ff0, m1 0x4fd7b8 {
        this->createRotateAction(m_rotationAngle, 0);
    }
    void resetSyncedAnimation() = win inline {
        m_unk544 = 0.f;
        m_animationStart = m_unk548 ? -1.f : 0.f;
        m_unkAnimationInt = 0;
        this->updateSyncedAnimation(-m_animationRandomizedStartValue, -1);
    }
    void setupAnimationVariables() = win 0x1a9bb0, imac 0x25d650, m1 0x2019a0;
    void triggerAnimation() = win inline {
        if (!m_animateOnlyWhenActive || m_isActivated) {
            m_animationTriggered = true;
            m_isDisabled2 = false;
            m_maybeAnimationVariableXInt = -1;
            this->updateSyncedAnimation(0.f, -1);
            m_animationRandomizedStartValue = 0;
        }
    }
    void updateRotateAction(float dt) = win 0x1a7350;
    void updateState(int state) = win inline, imac 0x5cbc20, m1 0x4fa87c {
        if (m_state < state) m_poweredOn = false;
        if (!m_poweredOn) this->powerOffObject();
    }
    void updateUserCoin() = win 0x1a6930;
    void waitForAnimationTrigger() = win inline, imac 0x25d340, m1 0x201678 {
        m_animationTriggered = false;
        m_isDisabled2 = true;
        m_animationRandomizedStartValue = 0;
        m_animationStart = 0.f;
        m_unk540 = 0.f;
        m_unk544 = 0.f;
        this->setOpacity(0);
    }

    bool m_poweredOn;
    int m_state;
    int m_animationRandomizedStartValue;
    float m_animationStart;
    float m_unk540;
    float m_unk544;
    bool m_unk548;
    float m_randomFrameTime;
    bool m_visible;
    bool m_shouldNotHideAnimFreeze;
    bool m_usesSpecialAnimation;
    float m_frameTime;
    short m_frames;
    bool m_hasCustomAnimation;
    bool m_hasCustomRotation;
    // property 98
    bool m_disableRotation;
    // property 97
    float m_rotationSpeed;
    float m_rotationAngle;
    float m_rotationDelta;
    float m_rotationAnimationSpeed;
    // property 106
    bool m_animationRandomizedStart;
    // property 107
    float m_animationSpeed;
    // property 122
    bool m_animationShouldUseSpeed;
    // property 123
    bool m_animateOnTrigger;
    // property 126
    bool m_disableDelayedLoop;
    // property 127
    bool m_disableAnimShine;
    // property 462
    int m_singleFrame;
    // property 592
    bool m_animationOffset;
    bool m_animationTriggered;
    int m_unkAnimationInt;
    int m_maybeAnimationVariableXInt;
    int m_maybeAnimationVariableYInt;
    // property 214
    bool m_animateOnlyWhenActive;
    // property 444
    bool m_isNoMultiActivate;
    // property 99
    bool m_isMultiActivate;
    bool m_activated;
    bool m_activatedByPlayer1;
    bool m_activatedByPlayer2;
    bool m_hasUniqueCoin;
}

[[link(android)]]
class EnhancedTriggerObject : EffectGameObject {
    // virtual ~EnhancedTriggerObject();
    EnhancedTriggerObject() {
        m_minXID = 0;
        m_minYID = 0;
        m_maxXID = 0;
        m_maxYID = 0;
    }

    static EnhancedTriggerObject* create(char const* frame) = win inline, m1 0x17528c {
        auto ret = new EnhancedTriggerObject();
        if (ret->init(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4b1b20, m1 0x175c64, imac 0x1bd1b0;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x4b1850, m1 0x1753a0, imac 0x1bc690;

    bool init(char const* frame) = win inline, ios inline {
        return EffectGameObject::init(frame);
    }

    // property 516
    int m_minXID;
    // property 517
    int m_minYID;
    // property 518
    int m_maxXID;
    // property 519
    int m_maxYID;
}

[[link(android)]]
class EnterEffectInstance {
    // ~EnterEffectInstance();
    // EnterEffectInstance(EnterEffectInstance const&);
    // EnterEffectInstance(EnterEffectInstance&&);
    // Sabe: idk why but this makes it so my mod works :shrug:
    EnterEffectInstance() {}
    EnterEffectInstance(EnterEffectObject* object, int targetID, int centerID, int unknown, int targetGroupIndex, int easeIndexCount, int controlID) = win 0x204330 {
        m_gameObject = object;
        m_reversed = false;
        m_targetID = targetID;
        m_centerID = centerID;
        m_unkFloat3 = unknown;
        m_easeIndex = 0;
        m_paused = false;
        m_paused2 = false;
        m_unkBool4 = false;
        m_targetGroupIndex = targetGroupIndex;
        m_controlID = controlID;
        if (easeIndexCount > 0) m_easeIndices.resize(easeIndexCount);
        this->loadValuesFromObject(m_gameObject);
    }

    void animateValue(int key, float value, float distance, float duration, int easingType, float easingRate, int easingBuffer) = win 0x139560, m1 0x4ff748;
    float getValue(int key) = win inline, ios inline {
        switch (key) {
            case 0: return m_length;
            case 1: return m_lengthVariance;
            case 2: return m_offset;
            case 3: return m_offsetVariance;
            case 4: return m_modFront;
            case 5: return m_modBack;
            case 6: return m_deadzone;
            case 7: return m_moveDistance;
            case 8: return m_moveDistanceVariance;
            case 9: return m_moveAngle;
            case 10: return m_moveAngleVariance;
            case 11: return m_moveX;
            case 12: return m_moveXVariance;
            case 13: return m_moveY;
            case 14: return m_moveYVariance;
            case 15: return m_scaleX;
            case 16: return m_scaleXVariance;
            case 17: return m_scaleY;
            case 18: return m_scaleYVariance;
            case 19: return m_rotation;
            case 20: return m_rotationVariance;
            case 21: return m_tint;
            case 22: return m_unk074;
            case 23: return m_toOpacity;
            case 24: return m_fromOpacity;
            case 25: return m_offsetY;
            case 26: return m_offsetYVariance;
            case 27: return m_relativeFade;
            case 28: return m_hue;
            case 29: return m_saturation;
            case 30: return m_value;
            default: return 0;
        }
    }
    void loadTransitions(EnterEffectObject* object, float time) = win 0x138980, imac 0x5d2bb0, m1 0x4ff054;
    void loadValuesFromObject(EnterEffectObject* object) = win 0x1387e0, imac 0x5d2aa0, m1 0x4fef84;
    void setValue(int key, float value) = win 0x139980, m1 0x4ff914;
    void updateTransitions(float dt, GJBaseGameLayer* layer) = win 0x139750, imac 0x5d38c0, m1 0x4ffa30;

    gd::map<int,EnterEffectAnimValue> m_enterEffectAnimMap;
    float m_length;
    float m_lengthVariance;
    float m_offset;
    float m_offsetVariance;
    float m_offsetY;
    float m_offsetYVariance;
    float m_modFront;
    float m_modBack;
    float m_deadzone;
    float m_moveDistance;
    float m_moveDistanceVariance;
    float m_moveAngle;
    float m_moveAngleVariance;
    float m_moveX;
    float m_moveXVariance;
    float m_moveY;
    float m_moveYVariance;
    float m_relativeFade;
    float m_scaleX;
    float m_scaleXVariance;
    float m_scaleY;
    float m_scaleYVariance;
    float m_rotation;
    float m_rotationVariance;
    float m_tint;
    float m_unk074;
    float m_toOpacity;
    float m_fromOpacity;
    cocos2d::ccHSVValue m_hsvValue;
    float m_hue;
    float m_saturation;
    float m_value;
    EnterEffectObject* m_gameObject;
    bool m_reversed;
    int m_targetID;
    int m_centerID;
    int m_unkFloat3;
    int m_easeIndex;
    bool m_paused;
    bool m_paused2;
    bool m_unkBool4;
    int m_targetGroupIndex;
    gd::vector<int> m_easeIndices;
    int m_controlID;
}

[[link(android)]]
class EnterEffectObject : EffectGameObject {
    // virtual ~EnterEffectObject();
    // make every member zero
    EnterEffectObject() = imac 0x1f3a40, m1 0x1a1cf4 {
        m_enterType = 0;
        m_length = 0;
        m_lengthVariance = 0;
        m_offset = 0;
        m_offsetVariance = 0;
        m_offsetY = 0;
        m_offsetYVariance = 0;
        m_moveDistance = 0;
        m_moveDistanceVariance = 0;
        m_areaScaleX = 0.0f;
        m_areaScaleXVariance = 0.0f;
        m_areaScaleY = 0.0f;
        m_areaScaleYVariance = 0.0f;
        m_moveAngle = 0;
        m_moveAngleVariance = 0;
        m_startAngle = false;
        m_relative = false;
        m_relativeFade = 0.0f;
        m_easingInType = EasingType::None;
        m_easingInRate = 2.0f;
        m_easingInBuffer = 0;
        m_easingOutType = EasingType::None;
        m_easingOutRate = 2.0f;
        m_easingOutBuffer = 0;
        m_moveX = 0;
        m_moveXVariance = 0;
        m_moveY = 0;
        m_moveYVariance = 0;
        m_tintChannelID = 0;
        m_property224 = 0;
        m_directionType = 0;
        m_xyMode = false;
        m_easeOutEnabled = false;
        m_modFront = 1.0f;
        m_modBack = 1.0f;
        m_areaTint = 0.0f;
        m_property285 = 0.0f;
        m_effectID = 0;
        m_areaRotation = 0.0f;
        m_areaRotationVariance = 0.0f;
        m_toOpacity = 0.0f;
        m_fromOpacity = 0.0f;
        m_inbound = false;
        m_hsvEnabled = false;
        m_deadzone = 0.0f;
        m_twoDirections = false;
        m_dontEditAreaParent = false;
        m_priority = 0;
        m_unk7d8 = 0;
        m_enterChannel = 0;
        m_useEffectID = false;
        m_negativeTargetX = false;
        m_areaRange = 0;
        m_unk7fc = 0;
    }

    static EnterEffectObject* create(char const* frame) = win inline, imac 0x184370, m1 0x149300 {
        auto ret = new EnterEffectObject();
        if (ret->init(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void customSetup() = win 0x497f60, imac 0x196630, m1 0x156e48;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4980c0, imac 0x196a10, m1 0x157204;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x4962c0, imac 0x184510, m1 0x14946c;

    bool init(char const* frame) = win inline, m1 0x1493b0, ios inline {
        if (!EffectGameObject::init(frame)) return false;
        m_objectType = GameObjectType::EnterEffectObject;
        m_unk390 = 45;
        return true;
    }
    void resetEnterAnimValues() = win inline, imac 0x1969a0, m1 0x1571c8 {
        m_length = -99;
        m_lengthVariance = -99;
        m_offset = -99;
        m_offsetVariance = -99;
        m_offsetY = -99;
        m_offsetYVariance = -99;
        m_modFront = -99.f;
        m_modBack = -99.f;
        m_deadzone = -99.f;
        m_moveDistance = -99;
        m_moveDistanceVariance = -99;
        m_moveAngle = -99;
        m_moveAngleVariance = -99;
        m_moveX = -99;
        m_moveXVariance = -99;
        m_moveY = -99;
        m_moveYVariance = -99;
        m_areaScaleX = -99.f;
        m_areaScaleXVariance = -99.f;
        m_areaScaleY = -99.f;
        m_areaScaleYVariance = -99.f;
        m_areaRotation = -99.f;
        m_areaRotationVariance = -99.f;
        m_areaTint = -99.f;
        m_property285 = -99.f;
        m_toOpacity = -99.f;
        m_fromOpacity = -99.f;
        m_relativeFade = -99.f;
    }

    // property 217
    int m_enterType;
    // property 222
    int m_length;
    // property 223
    int m_lengthVariance;
    // property 220
    int m_offset;
    // property 221
    int m_offsetVariance;
    // property 252
    int m_offsetY;
    // property 253
    int m_offsetYVariance;
    // property 218
    int m_moveDistance;
    // property 219
    int m_moveDistanceVariance;
    // property 233
    float m_areaScaleX;
    // property 234
    float m_areaScaleXVariance;
    // property 235
    float m_areaScaleY;
    // property 236
    float m_areaScaleYVariance;
    // property 231
    int m_moveAngle;
    // property 232
    int m_moveAngleVariance;
    bool m_startAngle;
    cocos2d::CCPoint m_anglePosition;
    // property 287
    bool m_relative;
    // property 288
    float m_relativeFade;
    // property 242
    EasingType m_easingInType;
    // property 243
    float m_easingInRate;
    int m_easingInBuffer;
    // property 248
    EasingType m_easingOutType;
    // property 249
    float m_easingOutRate;
    int m_easingOutBuffer;
    // property 237
    int m_moveX;
    // property 238
    int m_moveXVariance;
    // property 239
    int m_moveY;
    // property 240
    int m_moveYVariance;
    // property 260
    int m_tintChannelID;
    // property 224
    int m_property224;
    // property 262
    int m_directionType;
    // property 241
    bool m_xyMode;
    // property 261
    bool m_easeOutEnabled;
    // property 263
    float m_modFront;
    // property 264
    float m_modBack;
    // property 265
    float m_areaTint;
    // property 285
    float m_property285;
    // property 225
    int m_effectID;
    // property 270
    float m_areaRotation;
    // property 271
    float m_areaRotationVariance;
    // property 275
    float m_toOpacity;
    // property 286
    float m_fromOpacity;
    // property 276
    bool m_inbound;
    // property 278
    bool m_hsvEnabled;
    // property 282
    float m_deadzone;
    // property 283
    bool m_twoDirections;
    // property 539
    bool m_dontEditAreaParent;
    // property 341
    int m_priority;
    int m_unk7d8;
    // property 344
    int m_enterChannel;
    // property 355
    bool m_useEffectID;
    cocos2d::CCPoint m_unk7e4;
    cocos2d::CCPoint m_unk7ec;
    bool m_negativeTargetX;
    int m_areaRange;
    int m_unk7fc;
}

[[link(android)]]
class EventLinkTrigger : EffectGameObject {
    // virtual ~EventLinkTrigger();
    EventLinkTrigger() {
        m_resetRemap = false;
        m_extraID = 0;
        m_extraID2 = 0;
    }

    static EventLinkTrigger* create() = win inline, imac 0x1d1140 {
        auto ret = new EventLinkTrigger();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x4b84c0, m1 0x186290, imac 0x1d1220;
    virtual void triggerObject(GJBaseGameLayer* layer, int uniqueID, gd::vector<int> const* remapKeys) = win 0x4b8530, m1 0x1862e0, imac 0x1d1270;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4b8a00, imac 0x1d2170, m1 0x186ee4;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x4b8610, m1 0x1863a4, imac 0x1d1330;

    // property 430
    gd::set<int> m_eventIDs;
    // property 431
    bool m_resetRemap;
    // property 447
    int m_extraID;
    // property 525
    int m_extraID2;
}

[[link(android)]]
class ExplodeItemNode : cocos2d::CCNode {
    // virtual ~ExplodeItemNode();

    static ExplodeItemNode* create(cocos2d::CCRenderTexture* texture) = win 0x384220, imac 0x213280, m1 0x1beb88;

    virtual void update(float dt) = win 0x384c90, imac 0x214250, m1 0x1bfa6c;

    void createSprites(int countX, int countY, float xVel, float xVar, float yVel, float yVar, float dur, float durVar, cocos2d::ccColor4F startColor, cocos2d::ccColor4F endColor, bool noParticles) = win 0x3842e0;
    bool init(cocos2d::CCRenderTexture* texture) = win inline {
        if (!cocos2d::CCNode::init()) return false;
        m_floorHeight = 90.f;
        m_renderTexture = texture;
        texture->retain();
        m_sprites = cocos2d::CCArray::create();
        m_sprites->retain();
        return true;
    }

    cocos2d::CCRenderTexture* m_renderTexture;
    cocos2d::CCArray* m_sprites;
    float m_unk1;
    float m_floorHeight;
    bool m_noGravity;
}

[[link(android)]]
class ExplodeItemSprite : cocos2d::CCSprite {
    // virtual ~ExplodeItemSprite();
    ExplodeItemSprite() {
        m_xVelocity = 0.f;
        m_yVelocity = 0.f;
        m_timeRemaining = 0.f;
        m_fadeOutTime = 0.f;
        m_rotVelocity = 0.f;
        m_particles = nullptr;
    }

    static ExplodeItemSprite* create() = win inline, m1 0x1bf9c8 {
        auto ret = new ExplodeItemSprite();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x385060, m1 0x1bfd5c, imac 0x2145e0;

    float m_xVelocity;
    float m_yVelocity;
    float m_timeRemaining;
    float m_fadeOutTime;
    float m_rotVelocity;
    cocos2d::CCParticleSystemQuad* m_particles;
}

[[link(android)]]
class ExtendedLayer : cocos2d::CCLayer {
    // virtual ~ExtendedLayer();
    ExtendedLayer() {
        m_delegate = nullptr;
    }

    static ExtendedLayer* create() = win inline, m1 0x3294f0 {
        auto ret = new ExtendedLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x3ed20, m1 0x32b7f0, imac 0x3a7090;
    virtual void setPosition(cocos2d::CCPoint const& position) = win 0x3ed40, m1 0x32b7f4, imac 0x3a70a0;

    BoomScrollLayerDelegate* m_delegate;
}

[[link(android)]]
class FileOperation {
    static gd::string getFilePath() = imac 0x625510, m1 0x548bf8;
    static void readFile() = imac 0x625520, m1 0x548c04;
    static void saveFile() = imac 0x6254a0, m1 0x548b64;
}

[[link(android)]]
class FileSaveManager : GManager {
    // virtual ~FileSaveManager();

    static FileSaveManager* sharedState() = imac 0x6ce0, m1 0x61b4;

    virtual bool init() = imac 0x6d70, m1 0x623c;
    virtual void firstLoad() = imac 0x6da0, m1 0x626c;

    cocos2d::CCDictionary* getStoreData() = imac 0x72a0, m1 0x6734;
    void loadDataFromFile(char const* filename) = imac 0x6d90, m1 0x6260;

    cocos2d::CCDictionary* m_storeData;
}

[[link(android)]]
class FindBPMLayer : CreateGuidelinesLayer {
    // virtual ~FindBPMLayer();

    static FindBPMLayer* create(int songID) = win 0x9b8d0, imac 0x50cf70, m1 0x464584;

    virtual void onClose(cocos2d::CCObject* sender) = win 0x9bec0, m1 0x464a34, imac 0x50d4d0;
    virtual void playMusic() = win 0x9bd30, m1 0x4648a0, imac 0x50d340;
    virtual void registerTouch() = win 0x9bdd0, imac 0x50d3d0, m1 0x46493c;
    virtual void onInfo(cocos2d::CCObject* sender) = win inline, m1 0x464a30, imac 0x50d4c0 {}
    virtual void onRecord(cocos2d::CCObject* sender) = win 0x9baf0, m1 0x4647c0, imac 0x50d230;
    virtual void recordingDidStop() = win 0x9bcb0, imac 0x50d270, m1 0x4647f8;

    void calculateBPM() = win inline, m1 0x464864, ios inline {
        if (m_beats > 1) {
            m_beatsPerMinute = roundf(60.f / ((m_elapsed - m_startOffset) / (float)(m_beats - 1)));
        }
    }
    bool init(int songID) = win inline {
        if (!CreateGuidelinesLayer::init(nullptr, AudioGuidelinesType::BPMFinder)) return false;
        m_songID = songID;
        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        m_bpmLabel = cocos2d::CCLabelBMFont::create("BPM", "bigFont.fnt");
        m_mainLayer->addChild(m_bpmLabel, 1);
        m_bpmLabel->setPosition(winSize * .5f);
        m_recordingObjects->addObject(m_bpmLabel);
        auto songObject = MusicDownloadManager::sharedState()->getSongInfoObject(m_songID);
        if (songObject && songObject->m_BPM > 0) {
            m_infoLabel->setString(cocos2d::CCString::createWithFormat("BPM: %i", songObject->m_BPM)->getCString());
        }
        this->toggleItems(false);
        return true;
    }

    int m_songID;
    cocos2d::CCLabelBMFont* m_bpmLabel;
    float m_startOffset;
    int m_beats;
    int m_beatsPerMinute;
}

[[link(android)]]
class FindObjectPopup : SetIDPopup {
    // virtual ~FindObjectPopup();
    FindObjectPopup() {
        m_unknownBool = false;
    }

    static FindObjectPopup* create() = win inline, m1 0x24b698 {
        auto ret = new FindObjectPopup();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x29c270, imac 0x2ad2f0, m1 0x24b7b4;

    void onFindObjectID(cocos2d::CCObject* sender) = win inline, imac 0x2ad3d0, m1 0x24b8d4, ios inline {
        m_unknownBool = !m_unknownBool;
    }

    bool m_unknownBool;
}

[[link(android)]]
class FLAlertLayer : cocos2d::CCLayerColor {
    FLAlertLayer() = win 0x51740 {
        m_buttonMenu = nullptr;
        m_controlConnected = -1;
        m_mainLayer = nullptr;
        m_ZOrder = 0;
        m_noElasticity = false;
        m_reverseKeyBack = false;
        m_scene = nullptr;
        m_alertProtocol = nullptr;
        m_scrollingLayer = nullptr;
        m_button2 = nullptr;
        m_button1 = nullptr;
        m_joystickConnected = -1;
        m_containsBorder = 0;
        m_forcePrioRegistered = false;
    }
    ~FLAlertLayer() = win 0x51870, imac 0x49a810, m1 0x3fec00;

    static FLAlertLayer* create(char const* title, const gd::string& desc, char const* btn) {
        return FLAlertLayer::create(nullptr, title, desc, btn, nullptr, 300.0);
    }
    static FLAlertLayer* create(FLAlertLayerProtocol* delegate, char const* title, gd::string desc, char const* btn1, char const* btn2) {
        return FLAlertLayer::create(delegate, title, desc, btn1, btn2, 300.0);
    }
    static FLAlertLayer* create(FLAlertLayerProtocol* delegate, char const* title, gd::string desc, char const* btn1, char const* btn2, float width) = win 0x51920, m1 0x3ff120, imac 0x49ab90;
    static FLAlertLayer* create(FLAlertLayerProtocol* delegate, char const* title, gd::string desc, char const* btn1, char const* btn2, float width, bool scroll, float height, float textScale) = win 0x519d0, m1 0x3fef78, imac 0x49ac50;

    virtual void onEnter() = win 0x52e40, m1 0x40048c, imac 0x49c1b0;
    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x52a90, m1 0x3fff64, imac 0x49bcf0;
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x52be0, m1 0x400218, imac 0x49bf40;
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x52b30, m1 0x4000bc, imac 0x49be10;
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x52ba0, m1 0x400180, imac 0x49bec0;
    virtual void registerWithTouchDispatcher() = win 0x52df0, m1 0x400454, imac 0x49c170;
    virtual void keyBackClicked() = win 0x52910, imac 0x49bbd0, m1 0x3ffe44;
    virtual void keyDown(cocos2d::enumKeyCodes key, double timestamp) = win 0x52890, imac 0x49bb20, m1 0x3ffda4;
    virtual void show() = win 0x52c20, imac 0x49bfc0, m1 0x4002b0;

    void incrementForcePrio() = win inline {
        if (!m_forcePrioRegistered) {
            m_forcePrioRegistered = true;
            cocos2d::CCDirector::sharedDirector()->getTouchDispatcher()->registerForcePrio(this, 2);
        }
    }
    bool init(int opacity) = win 0x51ae0, imac 0x49b940, m1 0x3ffbc8;
    bool init(FLAlertLayerProtocol* delegate, char const* title, gd::string desc, char const* btn1, char const* btn2, float width, bool scroll, float height, float textScale) = win 0x51bf0, m1 0x3ff208, imac 0x49aee0;
    void onBtn1(cocos2d::CCObject* sender) = win 0x529d0, m1 0x3ffce4;
    void onBtn2(cocos2d::CCObject* sender) = win 0x52a30, m1 0x3ffd44;

    cocos2d::CCMenu* m_buttonMenu;
    FLAlertLayerProtocol* m_alertProtocol;
    cocos2d::CCNode* m_scene;
    bool m_reverseKeyBack;
    cocos2d::ccColor3B m_color;
    cocos2d::CCLayer* m_mainLayer;
    int m_ZOrder;
    bool m_noElasticity;
    cocos2d::ccColor3B m_color2;
    ButtonSprite* m_button1;
    ButtonSprite* m_button2;
    ScrollingLayer* m_scrollingLayer;
    int m_controlConnected;
    bool m_containsBorder;
    bool m_noAction;
    int m_joystickConnected;
    bool m_forcePrioRegistered;
}

[[link(android)]]
class FLAlertLayerProtocol {
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) {}
}

[[link(android), depends(FMODAudioState), depends(FMODSoundState), depends(FMODMusic), depends(FMODSound), depends(FMODQueuedEffect), depends(FMODQueuedMusic), depends(FMODSoundTween)]]
class FMODAudioEngine : cocos2d::CCNode {
    FMODAudioEngine() = win 0x53120 {
        m_musicVolume = 1.f;
        m_sfxVolume = 1.f;
        m_backgroundMusicFade = .0f;
        m_musicFadeStart = .0f;
        m_pulse1 = .0f;
        m_pulse2 = .0f;
        m_pulse3 = .0f;
        m_pulseCounter = 0;
        m_metering = false;
        m_backgroundMusicChannel = nullptr;
        m_system = nullptr;
        m_mainDSP = nullptr;
        m_globalChannelDSP = nullptr;
        m_globalChannel = nullptr;
        m_reverbChannel = nullptr;
        m_lastResult = FMOD_RESULT::FMOD_OK;
        m_sampleRate = 0;
        m_reducedQuality = false;
        m_allAudioPaused = false;
        m_musicOffset = 0;
        m_stopped = false;
        m_reverbPreset = FMODReverbPreset::Generic;
        m_showAudioVisualizer = false;
        m_musicVisualizerTime = .0f;
        m_musicVisualizerPeak = .0f;
        m_musicVisualizerVolume = .0f;
        m_sfxVisualizerTime = .0f;
        m_sfxVisualizerPeak = .0f;
        m_sfxVisualizerVolume = .0f;
    }
    ~FMODAudioEngine() = win inline, m1 0x35b058 {
        m_system->close();
        if (m_system) m_system->release();
    }

    static FMODAudioEngine* get() {
        return FMODAudioEngine::sharedEngine();
    }
    static float pitchForIdx(int index) = win 0x56a00, imac 0x3e3110, m1 0x36082c;
    static gd::string reverbToString(FMODReverbPreset preset) = win 0x54d10, imac 0x3dd610, m1 0x35c088;
    static FMODAudioEngine* sharedEngine() = win inline, imac 0x3dc5e0, m1 0x35b390 {
        auto** instancePtr = reinterpret_cast<FMODAudioEngine**>(geode::base::get() + 0x6c1e88);
        if (!*instancePtr) {
            *instancePtr = new FMODAudioEngine();
            (*instancePtr)->init();
        }
        return *instancePtr;
    }

    virtual void update(float dt) = win 0x553e0, m1 0x35cb64, imac 0x3de2b0;

    void activateQueuedMusic(int channel) = win inline {
        if (m_audioState.m_queuedMusicForChannels2.count(channel) != 0) {
            this->triggerQueuedMusic(m_audioState.m_queuedMusicForChannels2[channel]);
            m_audioState.m_queuedMusicForChannels2.erase(channel);
        }
        else if (m_audioState.m_queuedMusicForChannels1.count(channel) != 0) {
            m_audioState.m_queuedMusicForChannels1[channel].m_noPrepare = true;
        }
    }
    FMOD::Channel* channelForChannelID(int id) = win 0x584d0, imac 0x3df930;
    FMOD::Channel* channelForUniqueID(int id) = win inline, m1 0x362324, ios inline {
        return this->channelForChannelID(this->channelIDForUniqueID(id));
    }
    int channelIDForUniqueID(int id) = win 0x58410;
    void channelLinkSound(int id, FMODSound* sound) = win inline, imac 0x3e4720 {
        sound->m_playCount++;
        sound->m_playIndex = (*reinterpret_cast<int*>(geode::base::get() + 0x6a4e04))++;
        m_channelIDToSoundPath[id] = sound->m_filePath;
    }
    void channelStopped(FMOD::Channel* channel, bool remove) = win 0x58100, imac 0x3e4ec0;
    void channelUnlinkSound(int id) = win 0x57e70, imac 0x3e4c60, m1 0x361e54;
    void clearAllAudio() = win 0x55330, imac 0x3ddb10, m1 0x35c5e8;
    int countActiveEffects() = win inline, imac 0x3e2a90, m1 0x4d449c {
        return m_channelIDToChannel.size() - countActiveMusic();
    }
    int countActiveMusic() = win inline, imac 0x2de800, m1 0x3602d4 {
        int count = 0;
        for (auto& music : m_fmodMusic) {
            if (music.second.m_channelID > 0) {
                ++count;
            }
        }
        return count;
    }
    FMOD::Sound* createStream(gd::string path) = win 0x5cbc0, imac 0x3e9c10, m1 0x365f4c;
    void disableMetering() = win inline, imac 0x3e30e0, m1 0x360818 {
        this->m_metering = false;
    }
    void enableMetering() = win inline, imac 0x3e30b0, m1 0x3607f8 {
        this->m_metering = true;
        this->m_pulse1 = 0.1f;
        this->m_pulse2 = 0.1f;
        this->m_pulse3 = 0.0f;
    }
    void fadeInBackgroundMusic(float value) = win inline, imac 0x3e64c0, m1 0x3632a0 {
        m_backgroundMusicChannel->setVolume(value);
        m_backgroundMusicFade = value;
        m_musicFadeStart = -1.f;
    }
    void fadeInMusic(float duration, int channel) = win 0x5c410, m1 0x363914;
    void fadeMusic(float duration, int channel, float startVolume, float endVolume) = win 0x5c690, imac 0x3e9b30, m1 0x365ea4;
    void fadeOutMusic(float duration, int channel) = win 0x5c550, m1 0x365e08;
    gd::string getActiveMusic(int id) = win inline {
        if (m_fmodMusic.count(id) == 0) return "";
        return m_fmodMusic[id].m_filePath;
    }
    FMOD::Channel* getActiveMusicChannel(int musicID) = win inline, m1 0x34af08 {
        if (m_fmodMusic.count(musicID) == 0) return nullptr;
        return this->channelForChannelID(m_fmodMusic[musicID].m_channelID);
    }
    float getBackgroundMusicVolume() = win inline, imac 0x3e6500, m1 0x3632e0 {
        return m_musicVolume;
    }
    FMOD::ChannelGroup* getChannelGroup(int id, bool reverb) = win 0x56b70, imac 0x3e3290, m1 0x3609cc;
    float getEffectsVolume() = win inline, imac 0x3e6540, m1 0x363300 {
        return m_sfxVolume;
    }
    gd::string getFMODStatus(int unused) = win 0x5ce00, imac 0x3e9eb0, m1 0x3661a4;
    float getMeteringValue() = win inline, imac 0x3e30f0, m1 0x360820 {
        return m_pulse1;
    }
    int getMusicChannelID(int musicID) = win inline {
        if (m_fmodMusic.count(musicID) == 0) return 0;
        return m_fmodMusic[musicID].m_channelID;
    }
    unsigned int getMusicLengthMS(int channel) = win 0x5c380;
    float getMusicTime(int channel) = win inline {
        return this->getMusicTimeMS(channel) / 1000.f;
    }
    unsigned int getMusicTimeMS(int channel) = win 0x5c320;
    int getNextChannelID() = win inline, imac 0x3e4780, m1 0x361a80, ios inline {
        return (*reinterpret_cast<int*>(geode::base::get() + GEODE_WINDOWS(0x69c0e4) GEODE_IOS(0x83ef50)))++;
    }
    gd::map<std::pair<int, int>, FMODSoundTween>& getTweenContainer(AudioTargetType type) = win inline, ios inline {
        switch (type) {
            case AudioTargetType::SFXGroup:
                return m_audioState.m_tweensForEffectGroups;
            case AudioTargetType::MusicChannel:
                return m_audioState.m_tweensForMusicChannels;
            default:
                return m_audioState.m_tweensForEffectChannels;
        }
    }
    bool isAnyPersistentPlaying() = win inline, imac 0x3e7a90, m1 0x30d190 {
        for (auto& [id, music] : m_fmodMusic) {
            if (music.m_dontReset) return true;
        }
        return false;
    }
    bool isChannelStopping(int channel) = win inline, ios inline {
        return m_stoppedChannels.count(channel) != 0;
    }
    bool isEffectLoaded(gd::string path) = win inline, imac 0x3e3f60, m1 0x361354, ios inline {
        return m_fmodSounds.count(path) != 0;
    }
    bool isMusicPlaying(int musicID) = win 0x59d50, imac 0x3e6570, m1 0x36331c;
    bool isMusicPlaying(gd::string path, int musicID) = win 0x59f30, imac 0x3e66a0, m1 0x36343c;
    bool isPersistentMatchPlaying(gd::string path, int musicID) = win 0x5ada0, imac 0x3e6d90, m1 0x363a6c;
    bool isSoundReady(FMOD::Sound* sound) = win inline, imac 0x3e7ac0, m1 0x3645c4, ios inline {
        FMOD_OPENSTATE state;
        m_lastResult = sound->getOpenState(&state, nullptr, nullptr, nullptr);
        return state == FMOD_OPENSTATE_READY || state == FMOD_OPENSTATE_ERROR || state == FMOD_OPENSTATE_PLAYING;
    }
    int lengthForSound(gd::string path) = win 0x59a20, imac 0x3e6210;
    void loadAndPlayMusic(gd::string path, unsigned int time, int musicID) = win 0x5a060, imac 0x3e6990, m1 0x3636ac;
    void loadAudioState(FMODAudioState& state) = win 0x55f70, imac 0x3dfd50;
    void loadMusic(gd::string path) = win inline {
        this->loadMusic(path, 1.f, 0.f, 1.f, false, 0, 0, false);
    }
    void loadMusic(gd::string path, float speed, float unknown, float volume, bool shouldLoop, int musicID, int channelID, bool dontReset) = win 0x5a2d0, imac 0x3e0d70;
    void pauseAllAudio() = win inline {
        if (m_allAudioPaused) return;
        m_allAudioPaused = true;
        m_backgroundMusicChannel->setPaused(true);
        m_globalChannel->setPaused(true);
    }
    void pauseAllEffects() = win inline, imac 0x3e61d0, m1 0x363044 {
        m_globalChannel->setPaused(true);
    }
    void pauseAllMusic(bool force) = win inline, imac 0x3e65b0, m1 0x36336c {
        for (auto& [id, music] : m_fmodMusic) {
            if (force || !music.m_dontReset) {
                if (auto ch = this->channelForChannelID(music.m_channelID))
                    ch->setPaused(true);
            }
        }
    }
    void pauseEffect(unsigned int effect) = win inline, imac 0x3e61b0, m1 0x36303c, ios inline {}
    void pauseMusic(int musicChannel) = win inline, m1 0x365de4, ios inline {
        auto* channel = this->getActiveMusicChannel(musicChannel);
        if (channel)
            channel->setPaused(true);
    }
    int playEffect(gd::string path) = win 0x56de0, m1 0x360f90, imac 0x3e3b80;
    int playEffect(gd::string path, float speed, float unknown, float volume) = win 0x56e60;
    int playEffectAdvanced(gd::string path, float speed, float unknown, float volume, float pitch, bool fastFourierTransform, bool reverb, int startMillis, int endMillis, int fadeIn, int fadeOut, bool loopEnabled, int effectID, bool override, bool noPreload, int channelID, int uniqueID, float minInterval, int sfxGroup) = win 0x56f50, imac 0x3e1580;
    int playEffectAsync(gd::string path) = win inline {
        return this->playEffectAdvanced(path, 1.f, 0.f, 1.f, 0.f, false, false, 0, 0, 0, 0, false, 0, false, true, 0, 0, 0.f, 0);
    }
    void playMusic(gd::string path, bool shouldLoop, float fadeInTime, int channel) = win 0x5a160, imac 0x3e6a60, m1 0x363790;
    FMODSound* preloadEffect(gd::string path) = win 0x592b0, imac 0x3dd0f0;
    FMOD::Sound* preloadEffectAsync(gd::string path) = win 0x596a0, imac 0x3e47a0;
    FMOD::Sound* preloadMusic(gd::string path, bool noRelease, int musicID) = win 0x5c7e0, imac 0x3e6eb0, m1 0x6bdf60;
    void printResult(FMOD_RESULT result) = win inline, imac 0x3ea110, m1 0x3663e8, ios inline {}
    void queuedEffectFinishedLoading(gd::string path) = win 0x5b0c0, imac 0x3e7b00, m1 0x364620;
    int queuePlayEffect(gd::string audioFilename, float speed, float unknown, float volume, float pitch, bool fastFourierTransform, bool reverb, int start, int end, int fadeIn, int fadeOut, bool loop, int effectID, bool override, int uniqueID, float minInterval, int group) = win 0x57970, imac 0x3e3f80, m1 0x361374;
    void queueStartMusic(gd::string audioFilename, float pitch, float unknown, float volume, bool loop, int start, int end, int fadeIn, int fadeOut, int musicID, bool, int channelID, bool noPrepare, bool dontReset) = win 0x5aac0, imac 0x141e10, m1 0x364328;
    int registerChannel(FMOD::Channel* channel, int channelID, int effectID) = win 0x57b40, imac 0x3e4590;
    void releaseRemovedSounds() = win inline {
        for (int i = 0; i < m_removedSounds.size();) {
            auto sound = m_removedSounds[i];
            FMOD_OPENSTATE state;
            m_lastResult = sound->getOpenState(&state, nullptr, nullptr, nullptr);
            if (state == FMOD_OPENSTATE_READY || state == FMOD_OPENSTATE_ERROR) {
                sound->release();
                m_removedSounds.erase(m_removedSounds.begin() + i);
            }
            else i++;
        }
    }
    void resumeAllAudio() = win inline {
        if (!m_allAudioPaused) return;
        m_allAudioPaused = false;
        m_backgroundMusicChannel->setPaused(false);
        m_globalChannel->setPaused(false);
    }
    void resumeAllEffects() = win inline, m1 0x363050 {
        m_globalChannel->setPaused(false);
    }
    void resumeAllMusic() = win 0x59ed0, imac 0x3e6640, m1 0x3633e8;
    void resumeAudio() = win inline {
        this->start();
    }
    void resumeEffect(unsigned int effect) = win inline, imac 0x3e61c0, m1 0x363040, ios inline {}
    void resumeMusic(int musicChannel) = win inline, imac 0x3e13a0, m1 0x35f11c {
        auto* channel = this->getActiveMusicChannel(musicChannel);
        if (channel)
            channel->setPaused(false);
    }
    void saveAudioState(FMODAudioState& state) = win 0x55940;
    void setBackgroundMusicVolume(float volume) = win inline, imac 0x3e6510, m1 0x3632e8 {
        m_musicVolume = volume;
        m_musicFadeStart = 0.f;
        if (m_backgroundMusicChannel) m_backgroundMusicChannel->setVolume(volume);
    }
    void setChannelPitch(int id, AudioTargetType type, float pitch) = win 0x591a0;
    void setChannelVolume(int id, AudioTargetType type, float volume) = win 0x58e00;
    void setChannelVolumeMod(int id, AudioTargetType type, float volumeMod) = win 0x58fd0;
    void setEffectsVolume(float volume) = win inline, imac 0x3e6550, m1 0x363308 {
        m_sfxVolume = volume;
        if (m_globalChannel) m_globalChannel->setVolume(volume);
    }
    void setMusicTimeMS(unsigned int time, bool dontWait, int musicID) = win 0x5c1e0, imac 0x3e22d0;
    void setup() = win 0x53c10, imac 0x3dc990, m1 0x2404c0;
    void setupAudioEngine() = win 0x540f0, imac 0x3dcde0;
    void start() = win 0x552d0;
    void startMusic(int start, int end, int fadeIn, int fadeOut, bool loop, int musicID, bool noResume, bool dontReset) = win 0x5a640, imac 0x3e7200, m1 0x363ea8;
    void stop() = win inline {
        if (m_stopped) return;
        m_stopped = true;
        m_system->mixerSuspend();
        m_system->update();
        this->pauseSchedulerAndActions();
    }
    void stopAllEffects() = win 0x59900, m1 0x35c698;
    void stopAllMusic(bool clear) = win 0x59dc0; // this is wrong, its inlined but idk how to reimplement it
    float stopAndGetFade(FMOD::Channel* channel) = win 0x58a70, imac 0x3e5a60, m1 0x3628c0;
    void stopAndRemoveMusic(int id) = win 0x5cad0;
    void stopChannel(int id) = win inline, imac 0x3e4510 {
        this->stopChannel(id, AudioTargetType::SFXChannel, false, 0.f);
    }
    void stopChannel(FMOD::Channel* channel, bool loop, float delay) = win 0x58860, m1 0x36278c;
    void stopChannel(int id, AudioTargetType type, bool loop, float delay) = win 0x58590;
    void stopChannelTween(int id, AudioTargetType target, AudioModType mod) = win inline, ios inline {
        this->getTweenContainer(target).erase({ id, (int)mod });
    }
    void stopChannelTweens(int id, AudioTargetType target) = win inline, imac 0x3e2d50, m1 0x3604b8, ios inline {
        this->stopChannelTween(id, target, AudioModType::Volume);
        this->stopChannelTween(id, target, AudioModType::Pitch);
    }
    void stopMusic(int id) = win inline {
        this->stopAndRemoveMusic(id);
    }
    void stopMusicNotInSet(gd::unordered_set<int>& musicIDs) = win inline, imac 0x3e94a0, m1 0x3659c4 {
        std::unordered_set<int> totalIDs;
        for (auto& [id, _] : m_fmodMusic) {
            totalIDs.insert(id);
        }
        for (auto& id : totalIDs) {
            if (musicIDs.count(id) == 0) {
                this->stopMusic(id);
            }
        }
    }
    FMODSound* storeEffect(FMOD::Sound* sound, gd::string path) = win 0x59560, imac 0x3e6090, m1 0x362efc;
    void swapMusicIndex(int musicID, int channelID) = win 0x5bd30;
    void testFunction(int unknown) = win inline, imac 0x3e3100, m1 0x360828, ios inline {}
    void triggerQueuedMusic(FMODQueuedMusic music) = win 0x5b9f0;
    void unloadAllEffects() = win 0x59af0, m1 0x68428;
    void unloadEffect(gd::string path) = win inline, m1 0x3630b4, ios inline {}
    void unregisterChannel(int id) = win 0x57c70, m1 0x361cc4;
    void updateBackgroundFade() = win inline, m1 0x35d7f8 {
        if (m_musicFadeStart == 0.f) return;
        if (m_musicFadeStart < 0.f) m_musicFadeStart = m_audioState.m_elapsed;
        auto backgroundFade = m_backgroundMusicFade;
        auto fade = m_audioState.m_elapsed - m_musicFadeStart;
        if (backgroundFade <= 0.f || fade / backgroundFade > 1.f) backgroundFade = 1.f;
        else if (fade / backgroundFade >= 0.f) backgroundFade = fade / backgroundFade;
        else backgroundFade = 0.f;
        backgroundFade *= m_musicVolume;
        m_backgroundMusicChannel->setVolume(backgroundFade);
        if (m_backgroundMusicFade <= fade) m_musicFadeStart = 0.f;
    }
    void updateChannel(int channel, AudioTargetType target, AudioModType mod, float duration, float value) = win 0x58bb0, m1 0x3629bc;
    void updateChannelTweens(float dt) = win 0x56810, m1 0x35d9ec;
    void updateMetering() = win inline {
        FMOD_DSP_METERING_INFO info{};
        m_mainDSP->getMeteringInfo(nullptr, &info);
        auto peak = info.numchannels == 2 ? (info.peaklevel[0] + info.peaklevel[1]) / 2.f : info.peaklevel[0];
        auto volume = m_musicVolume;
        if (volume > 0.f) peak /= volume;
        peak += .1f;
        m_pulse1 = peak;
        auto counter = m_pulseCounter;
        if (counter < 3 || peak < m_pulse2 * 1.1f || (peak < m_pulse3 * .95f && peak > m_pulse3 * .2f)) {
            peak = m_pulse2 * .93f;
        }
        else {
            m_pulse3 = peak;
            peak *= 1.1f;
            counter = 0;
        }
        m_pulse1 = peak;
        if (peak <= .1f) m_pulse3 = 0.f;
        m_pulse2 = peak;
        m_pulseCounter = counter + 1;
    }
    void updateQueuedEffects() = win 0x5af10, imac 0x3de7a0;
    void updateQueuedMusic() = win 0x5b6f0, imac 0x3decd0, m1 0x6c8c68;
    void updateReverb(FMODReverbPreset preset, bool force) = win 0x54450;
    void updateTemporaryEffects() = win 0x5b460, imac 0x2dfea0;
    FMOD_OPENSTATE waitUntilSoundReady(FMOD::Sound* sound) = win inline, imac 0x30f410 {
        if (!sound) return FMOD_OPENSTATE_ERROR;
        FMOD_OPENSTATE state;
        m_lastResult = sound->getOpenState(&state, nullptr, nullptr, nullptr);
        while (state != FMOD_OPENSTATE_READY && state != FMOD_OPENSTATE_ERROR && state != FMOD_OPENSTATE_PLAYING) {
            m_lastResult = sound->getOpenState(&state, nullptr, nullptr, nullptr);
        }
        return state;
    }

    gd::unordered_map<int, FMODMusic> m_fmodMusic;
    gd::unordered_map<gd::string, FMODSound> m_fmodSounds;
    gd::unordered_set<gd::string> m_temporarySoundPaths;
    float m_musicVolume;
    float m_sfxVolume;
    float m_backgroundMusicFade;
    float m_musicFadeStart;
    float m_pulse1;
    float m_pulse2;
    float m_pulse3;
    int m_pulseCounter;
    bool m_metering;
    FMOD::ChannelGroup* m_backgroundMusicChannel;
    FMOD::System* m_system;
    FMOD::DSP* m_mainDSP;
    FMOD::DSP* m_globalChannelDSP;
    FMOD::ChannelGroup* m_globalChannel;
    FMOD::ChannelGroup* m_reverbChannel;
    FMOD_RESULT m_lastResult;
    int m_sampleRate;
    bool m_reducedQuality;
    bool m_allAudioPaused;
    int m_musicOffset;
    bool m_stopped;
    FMODAudioState m_audioState;
    gd::vector<FMOD::Sound*> m_removedSounds;
    gd::unordered_map<int, FMOD::DSP*> m_channelIDToDSP;
    gd::unordered_map<int, FMOD::Channel*> m_channelIDToChannel;
    gd::unordered_set<int> m_stoppedChannels;
    FMODReverbPreset m_reverbPreset;
    gd::unordered_map<int, int> m_channelIDToEffectID;
    gd::unordered_map<int, int> m_effectIDToChannelID;
    gd::unordered_map<int, gd::string> m_channelIDToSoundPath;
    gd::vector<FMODQueuedEffect> m_queuedEffects;
    gd::unordered_map<gd::string, FMOD::Sound*> m_soundPathToSound;
    gd::unordered_map<int, FMOD::ChannelGroup*> m_globalChannelGroups;
    gd::unordered_map<int, FMOD::ChannelGroup*> m_reverbChannelGroups;
    bool m_showAudioVisualizer;
    float m_musicVisualizerTime;
    float m_musicVisualizerPeak;
    float m_musicVisualizerVolume;
    float m_sfxVisualizerTime;
    float m_sfxVisualizerPeak;
    float m_sfxVisualizerVolume;
}

[[link(android), depends(FMODSoundTween), depends(FMODQueuedMusic), depends(FMODSoundState)]]
class FMODAudioState {
    // ~FMODAudioState();
    FMODAudioState() = win 0x52e90 {
        m_interval = 0.f;
        m_elapsed = 0.f;
    }

    float m_interval;
    float m_elapsed;
    gd::map<std::pair<int,int>,FMODSoundTween> m_tweensForEffectChannels;
    gd::map<std::pair<int,int>,FMODSoundTween> m_tweensForEffectGroups;
    gd::map<std::pair<int,int>,FMODSoundTween> m_tweensForMusicChannels;
    gd::unordered_map<int,float> m_volumeForEffectChannels;
    gd::unordered_map<int,float> m_volumeModForEffectChannels;
    gd::unordered_map<int,float> m_pitchForEffectChannels;
    gd::unordered_map<int,float> m_volumeForEffectGroups;
    gd::unordered_map<int,float> m_volumeModForEffectGroups;
    gd::unordered_map<int,float> m_pitchForEffectGroups;
    gd::unordered_map<int,float> m_volumeForMusicChannels;
    gd::unordered_map<int,float> m_volumeModForMusicChannels;
    gd::unordered_map<int,float> m_pitchForMusicChannels;
    gd::unordered_map<int,float> m_intervalForEffects;
    gd::unordered_map<int,FMODQueuedMusic> m_queuedMusicForChannels1;
    gd::unordered_map<int,FMODQueuedMusic> m_queuedMusicForChannels2;
    gd::unordered_map<int,FMODSoundState> m_soundStateForChannels;
    uint64_t m_unkUint64_1;
}

[[link(android)]]
class FMODLevelVisualizer : cocos2d::CCNode {
    // virtual ~FMODLevelVisualizer();

    static FMODLevelVisualizer* create() = win 0x29e610, m1 0x24e3dc;

    virtual bool init() = win 0x29e690, m1 0x24e464, imac 0x2b0320;

    void updateVisualizer(float volume, float peak, float time) = win 0x29eb50, imac 0x2b0730, m1 0x24e8c8;

    float m_width;
}

class FMODMusic {
    int m_channelID;
    FMOD::Sound* m_sound;
    gd::string m_filePath;
    bool m_ogg;
    bool m_dontReset;
}

[[link(android)]]
class FMODQueuedEffect {
    gd::string m_filePath;
    float m_speed;
    float m_unk024;
    float m_volume;
    float m_pitch;
    bool m_fastFourierTransform;
    bool m_reverb;
    int m_start;
    int m_end;
    int m_fadeIn;
    int m_fadeOut;
    bool m_loop;
    int m_effectID;
    bool m_override;
    bool m_unk04d;
    int m_channelID;
    FMOD::Sound* m_sound;
    int m_uniqueID;
    int m_minInterval;
    int m_group;
}

[[link(android)]]
class FollowRewardPage : FLAlertLayer, FLAlertLayerProtocol, GameRateDelegate, RewardedVideoDelegate {
    // virtual ~FollowRewardPage();

    static FollowRewardPage* create() = win 0x139c40, m1 0x392a58;

    virtual bool init() = win 0x139d60, m1 0x392b68, imac 0x41f360;
    virtual void registerWithTouchDispatcher() = win 0x42660, m1 0x394b08, imac 0x421520;
    virtual void keyBackClicked() = win 0x846c0, m1 0x394a8c, imac 0x4214b0;
    virtual void show() = win 0x86810, m1 0x39485c, imac 0x421280;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x13d270, imac 0x421400, m1 0x3949e4;
    virtual void rewardedVideoFinished() = win 0x13bfb0, imac 0x421260, m1 0x39484c;
    virtual void updateRate() = win 0x13ba80, imac 0x420b50, m1 0x394174;

    void onClose(cocos2d::CCObject* sender) = win 0x84690, imac 0x420450, m1 0x393a94;
    void onRewardedVideo(cocos2d::CCObject* sender);
    void onSpecialItem(cocos2d::CCObject* sender) = win 0x13bfc0, imac 0x420480, m1 0x393ad0;
    void switchToOpenedState(CCMenuItemSpriteExtra* button) = win 0x13d190, imac 0x420a80, m1 0x394090;

    cocos2d::CCArray* m_chests;
    bool m_videoPlaying;
}

[[link(android)]]
class FontObject : cocos2d::CCObject {
    // virtual ~FontObject();
    FontObject() {
        m_fontWidths = {};
    }

    static FontObject* createWithConfigFile(char const* font, float scale) = win inline, imac 0x21fe80, m1 0x1cab4c {
        auto ret = new FontObject();
        if (ret->initWithConfigFile(font, scale)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    int getFontWidth(int character) = win inline, imac 0x220900, m1 0x1cb41c {
        return m_fontWidths[character];
    }
    bool initWithConfigFile(char const* font, float scale) = win inline, imac 0x21fef0, m1 0x1cabc0, ios inline {
        this->parseConfigFile(font, scale);
        return true;
    }
    void parseConfigFile(char const* font, float scale) = win 0x3b680, imac 0x21ff00;

    std::array<int, 300> m_fontWidths;
}

[[link(android)]]
class ForceBlockGameObject : EffectGameObject {
    // virtual ~ForceBlockGameObject();
    ForceBlockGameObject() {
        m_force = 0.f;
        m_minForce = 0.f;
        m_maxForce = 0.f;
        m_relativeForce = false;
        m_forceRange = false;
        m_forceID = 0;
    }

    static ForceBlockGameObject* create(char const* frame) = win inline, m1 0x19af30 {
        auto ret = new ForceBlockGameObject();
        if (ret->init(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4c19c0, m1 0x19bc98, imac 0x1ec690;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x4c15e0, m1 0x19b048, imac 0x1eb6d0;

    cocos2d::CCPoint calculateForceToTarget(GameObject* target) = win 0x4c1b50, imac 0x1ec860, m1 0x19be28;
    bool init(char const* frame) = win inline, ios inline {
        return EffectGameObject::init(frame);
    }

    // property 149
    float m_force;
    // property 526
    float m_minForce;
    // property 527
    float m_maxForce;
    // property 528
    bool m_relativeForce;
    // property 529
    bool m_forceRange;
    // property 530
    int m_forceID;
}

[[link(android)]]
class FRequestProfilePage : FLAlertLayer, FLAlertLayerProtocol, UploadActionDelegate, UploadPopupDelegate, FriendRequestDelegate {
    // virtual ~FRequestProfilePage();

    static FRequestProfilePage* create(bool sent) = win 0x13d910, imac 0x78f680, m1 0x697fac;

    virtual void registerWithTouchDispatcher() = win 0x42660, m1 0x69963c, imac 0x790f30;
    virtual void keyBackClicked() = win 0x13ef10, m1 0x699630, imac 0x790f00;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x13ecf0, imac 0x790e20, m1 0x699538;
    virtual void onClosePopup(UploadActionPopup* popup) = win 0x13ef20, m1 0x699674, imac 0x790f70;
    virtual void uploadActionFinished(int id, int response) = win 0x13ef70, m1 0x6996fc, imac 0x790fe0;
    virtual void uploadActionFailed(int id, int response) = win 0x13f0e0, m1 0x6998bc, imac 0x791190;
    virtual void loadFRequestsFinished(cocos2d::CCArray* scores, char const* key) = win 0x13f850, m1 0x699c80, imac 0x791550;
    virtual void loadFRequestsFailed(char const* key, GJErrorCode errorType) = win 0x13f8d0, m1 0x699d8c, imac 0x791640;
    virtual void setupPageInfo(gd::string info, char const* key) = win 0x13f970, m1 0x699eec, imac 0x791790;
    virtual void forceReloadRequests(bool sent) = win 0x13f950, m1 0x699eb8, imac 0x791750;

    void deleteSelected() = win 0x13ea80, m1 0x699368;
    bool init(bool sent) = win 0x13dab0, imac 0x22d600;
    bool isCorrect(char const* key);
    void loadPage(int page);
    void onClose(cocos2d::CCObject* sender) = win 0x13edb0;
    void onDeleteSelected(cocos2d::CCObject* sender);
    void onNextPage(cocos2d::CCObject* sender) = win 0x13fb00;
    void onPrevPage(cocos2d::CCObject* sender) = win 0x13fb10;
    void onSentRequests(cocos2d::CCObject* sender) = win 0x13ed20;
    void onToggleAllObjects(cocos2d::CCObject* sender) = m1 0x698e94;
    void onUpdate(cocos2d::CCObject* sender);
    void setupCommentsBrowser(cocos2d::CCArray* scores) = win 0x13f6b0, m1 0x699b0c;
    void untoggleAll();
    void updateLevelsLabel() = win inline, imac 0x791c90, m1 0x69a48c, ios inline {}
    void updatePageArrows() = win inline, m1 0x69a490, ios inline {
        m_prevButton->setVisible(m_pageStartIdx != 0);
        m_nextButton->setVisible(m_pageStartIdx + m_pageEndIdx < m_itemCount);
    }

    bool m_sent;
    gd::string m_key;
    cocos2d::CCLabelBMFont* m_pageLabel;
    cocos2d::CCLabelBMFont* m_errorLabel;
    GJCommentListLayer* m_listLayer;
    LoadingCircle* m_circle;
    UploadActionPopup* m_uploadPopup;
    void* m_unk2e8;
    CCMenuItemSpriteExtra* m_nextButton;
    CCMenuItemSpriteExtra* m_prevButton;
    CCMenuItemSpriteExtra* m_refreshButton;
    int m_itemCount;
    int m_pageStartIdx;
    int m_pageEndIdx;
    int m_page;
    bool m_toggledAll;
}

[[link(android)]]
class FriendRequestDelegate {
    virtual void loadFRequestsFinished(cocos2d::CCArray* scores, char const* key) {}
    virtual void loadFRequestsFailed(char const* key, GJErrorCode errorType) {}
    virtual void setupPageInfo(gd::string info, char const* key) {}
    virtual void forceReloadRequests(bool sent) {}
}

[[link(android)]]
class FriendRequestPopup : FLAlertLayer, UploadActionDelegate, UploadPopupDelegate, FLAlertLayerProtocol {
    // virtual ~FriendRequestPopup();

    static FriendRequestPopup* create(GJFriendRequest* request) = win 0x295830, imac 0x2a4950, m1 0x243688;

    virtual void keyBackClicked() = win 0x296e10, m1 0x244b40, imac 0x2a5eb0;
    virtual void uploadActionFinished(int id, int response) = win 0x296e20, m1 0x244c1c, imac 0x2a5fa0;
    virtual void uploadActionFailed(int id, int response) = win 0x296fd0, imac 0x2a6170, m1 0x244e10;
    virtual void onClosePopup(UploadActionPopup* popup) = win 0x297090, m1 0x244f78, imac 0x2a62c0;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x2970f0, imac 0x2a6430, m1 0x2450fc;

    void blockUser() = win inline {
        if (GameLevelManager::sharedState()->blockUser(m_request->m_accountID)) {
            m_popup = UploadActionPopup::create(this, "Blocking user...");
            m_popup->show();
        }
    }
    bool init(GJFriendRequest* request) = win 0x295970;
    void loadFromGJFriendRequest(GJFriendRequest* request) = win 0x295fe0;
    void onAccept(cocos2d::CCObject* sender);
    void onBlock(cocos2d::CCObject* sender) = win 0x296bb0, m1 0x244824;
    void onClose(cocos2d::CCObject* sender) = win 0x296900;
    void onRemove(cocos2d::CCObject* sender);

    void* m_unk;
    GJFriendRequest* m_request;
    LoadingCircle* m_circle;
    CCMenuItemSpriteExtra* m_closeBtn;
    UploadActionPopup* m_popup;
}

[[link(android)]]
class FriendsProfilePage : FLAlertLayer, FLAlertLayerProtocol, UploadActionDelegate, UploadPopupDelegate, UserListDelegate {
    // virtual ~FriendsProfilePage();

    static FriendsProfilePage* create(UserListType type) = win 0x13fc90, imac 0x6574d0, m1 0x5777a8;

    virtual void registerWithTouchDispatcher() = win 0x42660, m1 0x5786d0, imac 0x658510;
    virtual void keyBackClicked() = win 0x140d20, imac 0x6584e0, m1 0x5786c4;
    virtual void getUserListFinished(cocos2d::CCArray* scores, UserListType type) = win 0x140850, m1 0x578364, imac 0x658170;
    virtual void getUserListFailed(UserListType type, GJErrorCode errorType) = win 0x1409a0, m1 0x578474, imac 0x6582b0;
    virtual void userListChanged(cocos2d::CCArray* scores, UserListType type) = win 0x8b870, imac 0x6583b0, m1 0x57859c;
    virtual void forceReloadList(UserListType type) = win 0x140a10, m1 0x5785b8, imac 0x6583f0;

    bool init(UserListType type) = win 0x13fde0;
    void onBlocked(cocos2d::CCObject* sender) = win 0x140bd0, m1 0x577ff0;
    void onClose(cocos2d::CCObject* sender) = win 0x140c60, m1 0x577f38;
    void onUpdate(cocos2d::CCObject* sender) = m1 0x57807c;
    void setupUsersBrowser(cocos2d::CCArray* users, UserListType type) = win 0x1404f0, imac 0x4b8e0, m1 0x5780e0;

    UserListType m_type;
    cocos2d::CCLabelBMFont* m_noInternet;
    cocos2d::CCLabelBMFont* m_totalFriends;
    GJCommentListLayer* m_listLayer;
    LoadingCircle* m_circle;
    void* m_unk532;
    cocos2d::CCArray* m_users;
    CCMenuItemSpriteExtra* m_refreshBtn;
}

[[link(android)]]
class GameCell : TableViewCell {
    // virtual ~GameCell();
    GameCell(char const* identifier, float width, float height) = win inline, m1 0x29c54c, ios inline : TableViewCell(identifier, width, height) {
        this->init();
    }

    virtual bool init() = win 0x3c850, imac 0x30cfd0, m1 0x29c598;
    virtual void draw() = win 0x3cc50, m1 0x29c66c, imac 0x30d090;

    void loadFromString(gd::string str) = win 0x3c860, m1 0x29c158;
    void onTouch(cocos2d::CCObject* sender) = m1 0x29c5a4;
    void updateBGColor(int index) = win inline, imac 0x30d030, m1 0x29c5f0, ios inline {
        m_backgroundLayer->setColor(index % 2 == 0 ? cocos2d::ccColor3B { 0, 255, 0 } : cocos2d::ccColor3B { 255, 255, 255 });
        m_backgroundLayer->setOpacity(255);
    }

    void* m_unk230;
    gd::string m_gameLink;
}

[[link(android)]]
class GameEffectsManager : cocos2d::CCNode {
    // virtual ~GameEffectsManager();

    static GameEffectsManager* create(PlayLayer* playLayer) = m1 0x1ae8b0;

    void addParticleEffect(cocos2d::CCParticleSystemQuad* particle, int unused) = m1 0x1aeac0;
    bool init(PlayLayer* playLayer) = imac 0x201b30, m1 0x1ae90c;
    void scaleParticle(cocos2d::CCParticleSystemQuad* particle, float scale) = imac 0x201b40, m1 0x1ae918;

    PlayLayer* m_playLayer;
}

[[link(android)]]
class GameLevelManager : cocos2d::CCNode {
    static GameLevelManager* get() {
        return GameLevelManager::sharedState();
    }
    static cocos2d::CCDictionary* responseToDict(gd::string response, bool colon) = win 0x16abd0, m1 0x484310;
    // virtual ~GameLevelManager();
    static GameLevelManager* sharedState() = win 0x142d50, imac 0x51a460, m1 0x470bd4;

    virtual bool init() = win 0x1442d0, m1 0x47fc30, imac 0x52b7d0;

    bool acceptFriendRequest(int accountID, int requestID) = win 0x1611b0, m1 0x4a49e0;
    int accountIDForUserID(int userID) = m1 0x48245c;
    void addDLToActive(char const* key) = win 0x149b60;
    bool areGauntletsLoaded() = win inline, m1 0x3fb70 {
        return m_savedGauntlets->count() != 0;
    }
    void banUser(int accountID) = win inline {}
    bool blockUser(int accountID) = win 0x161f40;
    void cleanupDailyLevels() = win 0x14a720, m1 0x48c41c;
    cocos2d::CCArray* createAndGetAccountComments(gd::string str, int accountID) = win inline {
        return this->createAndGetCommentsFull(str, accountID, true);
    }
    cocos2d::CCArray* createAndGetCommentsFull(gd::string str, int parentID, bool account) = win 0x15d020, imac 0x54fcf0, m1 0x4a01ac;
    cocos2d::CCArray* createAndGetLevelComments(gd::string str, int levelID) = win inline {
        return this->createAndGetCommentsFull(str, levelID, false);
    }
    cocos2d::CCArray* createAndGetLevelLists(gd::string str);
    cocos2d::CCArray* createAndGetLevels(gd::string str);
    cocos2d::CCArray* createAndGetMapPacks(gd::string str);
    cocos2d::CCArray* createAndGetScores(gd::string str, GJScoreType type) = win 0x1471b0, imac 0x532760, m1 0x485d7c;
    GJGameLevel* createNewLevel() = win 0x1448b0;
    GJLevelList* createNewLevelList() = win 0x145360;
    gd::string createPageInfo(int total, int start, int count) = win inline, imac 0x538280, m1 0x48b0b4 {
        return cocos2d::CCString::createWithFormat("%i%s%i%s%i", total, ":", start, ":", count)->getCString();
    }
    GJSmartTemplate* createSmartTemplate() = win inline, m1 0x48d194 {
        auto smartTemplate = GJSmartTemplate::create();
        smartTemplate->m_nameIndex = this->getNextFreeTemplateID();
        m_smartTemplates->insertObject(smartTemplate, 0);
        return smartTemplate;
    }
    void dataLoaded(DS_Dictionary* dict) = win 0x14b450, imac 0x2252a0;
    void deleteAccountComment(int id, int accountID) = win inline, imac 0x553240 {
        this->deleteComment(id, CommentType::Account, accountID);
    }
    void deleteComment(int id, CommentType type, int parentID) = win 0x15f0b0, imac 0x552a50, m1 0x4a2df4;
    bool deleteFriendRequests(int accountID, cocos2d::CCArray* accounts, bool sent) = win 0x160bb0, m1 0x4a40e8;
    void deleteLevel(GJGameLevel* level) = win 0x145090, imac 0x52c9e0, m1 0x480c10;
    void deleteLevelComment(int id, int levelID) = win inline, imac 0x552a40, m1 0x4a2de4 {
        this->deleteComment(id, CommentType::Level, levelID);
    }
    void deleteLevelList(GJLevelList* list) = win 0x145940;
    bool deleteSentFriendRequest(int accountID) = win inline, imac 0x553f40, m1 0x4a40dc {
        return this->deleteFriendRequests(accountID, nullptr, true);
    }
    void deleteServerLevel(int id) = win 0x154520, imac 0x4a0d80, m1 0x497d98;
    void deleteServerLevelList(int id) = win 0x150460, imac 0x5419a0, m1 0x416384;
    void deleteSmartTemplate(GJSmartTemplate* smartTemplate) = win inline, m1 0x48d1d8 {
        if (!smartTemplate) return;
        if (m_smartTemplate && m_smartTemplate->m_nameIndex == smartTemplate->m_nameIndex) m_smartTemplate = nullptr;
        m_smartTemplates->removeObject(smartTemplate);
    }
    bool deleteUserMessages(GJUserMessage* message, cocos2d::CCArray* messages, bool isSender) = win 0x15b4f0, imac 0x54e910, m1 0x49ee0c;
    void downloadLevel(int id, bool gauntletLevel) = win 0x151e40, imac 0x543700, m1 0x4953ac;
    void downloadUserMessage(int id, bool sent) = win 0x15aac0, m1 0x49e4c4;
    void encodeDataTo(DS_Dictionary* dict) = win 0x14af40, imac 0x53a980, m1 0x48d564;
    void firstSetup() = win 0x14ab80, m1 0x48d238;
    void followUser(int id) = win inline, m1 0x69da8 {
        m_followedCreators->setObject(cocos2d::CCString::create("1"), cocos2d::CCString::createWithFormat("%i", id)->getCString());
    }
    GJFriendRequest* friendRequestFromAccountID(int id) = win inline, m1 0x49d63c {
        return static_cast<GJFriendRequest*>(m_friendRequests->objectForKey(id));
    }
    void friendRequestWasRemoved(int accountID, bool sent);
    const char* getAccountCommentKey(int accountID, int page) = win inline, m1 0x49d9d4 {
        return cocos2d::CCString::createWithFormat("%i_%i", accountID, page)->getCString();
    }
    void getAccountComments(int accountID, int page, int total) = win 0x15c8b0, imac 0x54f8f0, m1 0x49d690;
    int getActiveDailyID(GJTimedLevelType type) = win inline, m1 0x4a96d4 {
        if (type == GJTimedLevelType::Daily) return m_activeDailyID;
        if (type == GJTimedLevelType::Weekly) return m_activeWeeklyID;
        if (type == GJTimedLevelType::Event) return m_activeEventID;
        return 0;
    }
    GJSmartTemplate* getActiveSmartTemplate() = win inline, imac 0x53a410, m1 0x48d0b4 {
        return m_smartTemplate;
    }
    cocos2d::CCArray* getAllSmartTemplates() = win inline, m1 0x48d208 {
        auto smartTemplates = cocos2d::CCArray::create();
        smartTemplates->addObjectsFromArray(m_smartTemplates);
        return smartTemplates;
    }
    cocos2d::CCDictionary* getAllUsedSongIDs() = win inline, m1 0x4aa858 {
        auto dict = cocos2d::CCDictionary::create();
        cocos2d::CCDictElement* element;
        cocos2d::CCDictElement* temp;
        HASH_ITER(hh, m_onlineLevels->m_pElements, element, temp) {
            auto level = static_cast<GJGameLevel*>(element->getObject());
            if (!level->m_levelNotDownloaded && level->m_songID > 0 && !dict->objectForKey(level->m_songID)) {
                dict->setObject(cocos2d::CCNode::create(), level->m_songID);
            }
        }
        auto localLevels = LocalLevelManager::sharedState()->m_localLevels;
        for (int i = 0; i < localLevels->count(); i++) {
            auto level = static_cast<GJGameLevel*>(localLevels->objectAtIndex(i));
            if (!level->m_levelNotDownloaded && level->m_songID > 0 && !dict->objectForKey(level->m_songID)) {
                dict->setObject(cocos2d::CCNode::create(), level->m_songID);
            }
        }
        return dict;
    }
    gd::string getBasePostString() = win 0x14c5f0;
    bool getBoolForKey(char const* key) = win inline {
        return m_searchFilters->valueForKey(key)->boolValue();
    }
    gd::string getCommentKey(int ID, int page, int mode, CommentKeyType keytype) = win inline, imac 0x546cf0, m1 0x49fb00 {
        return cocos2d::CCString::createWithFormat("comment_%i_%i_%i_%i", ID, page, mode, (int) keytype)->getCString();
    }
    int getCompletedDailyLevels() = win 0x148740, m1 0x489860;
    int getCompletedEventLevels(int minStars, int maxStars) = win 0x148940, m1 0x489a2c;
    int getCompletedGauntletDemons() = win inline {
        auto completed = 0;
        auto gsm = GameStatsManager::get();
        cocos2d::CCDictElement* element;
        cocos2d::CCDictElement* temp;
        HASH_ITER(hh, m_gauntletLevels->m_pElements, element, temp) {
            if (auto level = geode::cast::typeinfo_cast<GJGameLevel*>(element->getObject())) {
                if (level->m_stars.value() == 10 && level->m_normalPercent.value() == 100 && gsm->hasCompletedLevel(level)) {
                    completed++;
                }
            }
        }
        return completed;
    }
    int getCompletedGauntletLevels() = win inline {
        auto completed = 0;
        auto gsm = GameStatsManager::get();
        cocos2d::CCDictElement* element;
        cocos2d::CCDictElement* temp;
        HASH_ITER(hh, m_gauntletLevels->m_pElements, element, temp) {
            if (auto level = geode::cast::typeinfo_cast<GJGameLevel*>(element->getObject())) {
                if (level->m_stars.value() < 10 && level->m_normalPercent.value() == 100 && gsm->hasCompletedLevel(level)) {
                    completed++;
                }
            }
        }
        return completed;
    }
    cocos2d::CCArray* getCompletedLevels(bool useOrbCompletion) = win 0x1478e0;
    int getCompletedWeeklyLevels() = win 0x148530, m1 0x48968c;
    int getDailyID(GJTimedLevelType type) = win inline, m1 0x4a96a0 {
        if (type == GJTimedLevelType::Daily) return m_dailyID;
        if (type == GJTimedLevelType::Weekly) return m_weeklyID;
        if (type == GJTimedLevelType::Event) return m_eventID;
        return 0;
    }
    int getDailyTimer(GJTimedLevelType type) = win inline, m1 0x4a9708 {
        if (type == GJTimedLevelType::Daily) return m_dailyTimeLeft;
        if (type == GJTimedLevelType::Weekly) return m_weeklyTimeLeft;
        if (type == GJTimedLevelType::Event) return m_eventTimeLeft;
        return 0;
    }
    const char* getDeleteCommentKey(int parentID, int id, int type) = win inline, m1 0x4a110c, ios inline {
        return cocos2d::CCString::createWithFormat("delcomment_%i_%i_%i", id, type, parentID)->getCString();
    }
    const char* getDeleteMessageKey(int id, bool sent) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("delMsg_%i_%i", id, (int)sent)->getCString();
    }
    gd::string getDemonLevelsString() = win 0x147a70, imac 0x534cd0;
    const char* getDescKey(int levelID) = win inline, m1 0x4a10bc, ios inline {
        return cocos2d::CCString::createWithFormat("desc_%i", levelID)->getCString();
    }
    gd::string getDifficultyStr(bool isNA, bool isEasy, bool isNormal, bool isHard, bool isHarder, bool isInsane, bool isDemon, bool isAuto) = win 0x14d4f0, imac 0x53e2e0, m1 0x490800;
    const char* getDiffKey(int diff) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("Diff%i", diff)->getCString();
    }
    bool getDiffVal(int diff) = win inline {
        return m_searchFilters->valueForKey(this->getDiffKey(diff))->boolValue();
    }
    gd::string getFolderName(int id, bool local) = win 0x14aa50, imac 0x53a140, m1 0x48cdf8;
    const char* getFriendRequestKey(bool sent, int page) = win inline {
        return cocos2d::CCString::createWithFormat("fReq_%i_%i", (int)sent, page)->getCString();
    }
    void getFriendRequests(bool sent, int page, int total);
    const char* getGauntletKey(int id) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("%i", id)->getCString();
    }
    void getGauntletLevels(int id) = win 0x151af0, imac 0x543080, m1 0x494dc0;
    void getGauntlets() = win 0x151240, m1 0x4949f4;
    gd::string getGauntletSearchKey(int id) = win inline {
        return cocos2d::CCString::createWithFormat("gauntlet_%i", id)->getCString();
    }
    bool getGJChallenges() = win 0x167550, m1 0x4a8b78;
    bool getGJDailyLevelState(GJTimedLevelType type) = win 0x168950, m1 0x4a8fd8;
    bool getGJRewards(int type) = win 0x166060, imac 0x5584b0, m1 0x4a8430;
    bool getGJSecretReward(gd::string key) = win 0x164f30, m1 0x4a7fac;
    void getGJUserInfo(int id) = win 0x159e50, m1 0x49ce08;
    int getHighestLevelOrder() = win inline, m1 0x487bcc {
        auto result = 0;
        cocos2d::CCDictElement* element;
        cocos2d::CCDictElement* temp;
        HASH_ITER(hh, m_onlineLevels->m_pElements, element, temp) {
            auto level = static_cast<GJGameLevel*>(element->getObject());
            if (level->m_levelIndex > result) result = level->m_levelIndex;
        }
        return result;
    }
    int getIntForKey(char const* key) = win inline {
        return m_searchFilters->valueForKey(key)->intValue();
    }
    void getLeaderboardScores(char const* key) = imac 0x644760;
    gd::string getLengthStr(bool isTiny, bool isShort, bool isMedium, bool isLong, bool isXL, bool isPlat) = win 0x14d7a0, imac 0x53e8c0, m1 0x490d8c;
    const char* getLenKey(int len) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("Len%i", len)->getCString();
    }
    bool getLenVal(int len) = win inline {
        return m_searchFilters->valueForKey(this->getLenKey(len))->boolValue();
    }
    void getLevelComments(int ID, int page, int total, int mode, CommentKeyType keytype) = win 0x15be40, m1 0x49f670;
    const char* getLevelDownloadKey(int levelID, bool isGauntlet) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("%i_%i", levelID, isGauntlet)->getCString();
    }
    const char* getLevelKey(int levelID) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("%i", levelID)->getCString();
    }
    void getLevelLeaderboard(GJGameLevel* level, LevelLeaderboardType type, LevelLeaderboardMode mode);
    const char* getLevelLeaderboardKey(int levelID, LevelLeaderboardType type, LevelLeaderboardMode mode) = win inline, m1 0x49c5cc {
        return cocos2d::CCString::createWithFormat("ll_%i_%i_%i", levelID, (int)type, (int)mode)->getCString();
    }
    const char* getLevelListKey(int listID) = win inline, m1 0x481504, ios inline {
        return cocos2d::CCString::createWithFormat("%i", listID)->getCString();
    }
    void getLevelLists(GJSearchObject* object) = win 0x1507a0;
    void getLevelSaveData() = win 0x14ee00, m1 0x4925bc;
    const char* getLikeAccountItemKey(LikeItemType type, int id, bool liked, int parentID) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("like_%i_%i_%i_%i", type, id, (int)liked, parentID)->getCString();
    }
    const char* getLikeItemKey(LikeItemType type, int id, bool liked, int parentID) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("like_%i_%i_%i_%i", type, id, (int)liked, parentID)->getCString();
    }
    GJGameLevel* getLocalLevel(int uniqueID) = m1 0x48024c;
    GJGameLevel* getLocalLevelByName(gd::string name) = win inline, ios inline {
        auto localLevels = LocalLevelManager::sharedState()->m_localLevels;
        for (int i = 0; i < localLevels->count(); i++) {
            auto level = static_cast<GJGameLevel*>(localLevels->objectAtIndex(i));
            if (level->m_levelName == name) return level;
        }
        return nullptr;
    }
    GJLevelList* getLocalLevelList(int uniqueID) = win 0x1452f0;
    int getLowestLevelOrder() = win inline, m1 0x487c08 {
        auto result = INT_MAX;
        cocos2d::CCDictElement* element;
        cocos2d::CCDictElement* temp;
        HASH_ITER(hh, m_onlineLevels->m_pElements, element, temp) {
            auto level = static_cast<GJGameLevel*>(element->getObject());
            if (level->m_levelIndex < result) result = level->m_levelIndex;
        }
        return result;
    }
    GJGameLevel* getMainLevel(int levelID, bool dontGetLevelString) = win 0x144490, m1 0x47fd4c;
    const char* getMapPackKey(int pack) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("pack_%i", pack)->getCString();
    }
    void getMapPacks(GJSearchObject* object) = win 0x14f530, m1 0x49286c;
    const char* getMessageKey(int id) = win inline, m1 0x49e800, ios inline {
        return cocos2d::CCString::createWithFormat("message_%i", id)->getCString();
    }
    const char* getMessagesKey(bool sent, int page) = win inline {
        return cocos2d::CCString::createWithFormat("messages_%i_%i", (int)sent, page)->getCString();
    }
    void getNews() = win inline, ios inline {
        if (!m_testedNetwork) m_testedNetwork = true;
    }
    int getNextFreeTemplateID() = win inline, m1 0x48d0c4 {
        auto result = 0;
        auto dict = cocos2d::CCDictionary::create();
        auto node = cocos2d::CCNode::create();
        for (int i = 0; i < m_smartTemplates->count(); i++) {
            auto index = static_cast<GJSmartTemplate*>(m_smartTemplates->objectAtIndex(i))->m_nameIndex;
            if (index > result) result = index;
            dict->setObject(node, index);
        }
        for (int i = 0; i < 1001; i++) {
            if (!dict->objectForKey(i)) return i;
        }
        return result;
    }
    gd::string getNextLevelName(gd::string name) = win 0x144b70, imac 0x52c340, m1 0x48061c;
    void getOnlineLevels(GJSearchObject* object) = win 0x14dcb0, m1 0x491888;
    const char* getPageInfo(char const* key);
    const char* getPostCommentKey(int parentID) = win inline, m1 0x4a10e4 {
        return cocos2d::CCString::createWithFormat("c%i", parentID)->getCString();
    }
    const char* getRateStarsKey(int levelID) = win inline, m1 0x497b18, ios inline {
        return cocos2d::CCString::createWithFormat("%i", levelID)->getCString();
    }
    const char* getReportKey(int levelID) = win inline, m1 0x4a9f38, ios inline {
        return cocos2d::CCString::createWithFormat("%i", levelID)->getCString();
    }
    GJGameLevel* getSavedDailyLevel(int dailyID) = win 0x148c20;
    GJGameLevel* getSavedDailyLevelFromLevelID(int id) = win inline, m1 0x48a0f8 {
        cocos2d::CCDictElement* element;
        cocos2d::CCDictElement* temp;
        HASH_ITER(hh, m_dailyLevels->m_pElements, element, temp) {
            auto level = static_cast<GJGameLevel*>(element->getObject());
            if (level->m_levelID.value() == id) return level;
        }
        return nullptr;
    }
    GJMapPack* getSavedGauntlet(int id) = win inline {
        return static_cast<GJMapPack*>(m_savedGauntlets->objectForKey(this->getGauntletKey(id)));
    }
    GJGameLevel* getSavedGauntletLevel(int id) = win 0x148cf0;
    GJGameLevel* getSavedLevel(GJGameLevel* level) = win inline, imac 0x531050, m1 0x4847c0 {
        if (!level) return nullptr;
        else if (level->m_dailyID.value() > 0) return this->getSavedDailyLevel(level->m_dailyID.value());
        else if (level->m_gauntletLevel) return this->getSavedGauntletLevel(level->m_levelID.value());
        else return this->getSavedLevel(level->m_levelID.value());
    }
    GJGameLevel* getSavedLevel(int id) = win 0x148b50;
    GJLevelList* getSavedLevelList(int listID) = win inline {
        return static_cast<GJLevelList*>(m_favoriteLists->objectForKey(this->getLevelListKey(listID)));
    }
    cocos2d::CCArray* getSavedLevelLists(int folder) = win 0x147650, m1 0x487b04;
    cocos2d::CCArray* getSavedLevels(bool favorite, int folder) = win 0x147490;
    GJMapPack* getSavedMapPack(int id) = win inline {
        return static_cast<GJMapPack*>(m_savedPacks->objectForKey(this->getMapPackKey(id)));
    }
    cocos2d::CCScene* getSearchScene(char const* key) = win inline, imac 0x538930, m1 0x48b7c0 {
        if (auto searchObject = GJSearchObject::createFromKey(key)) {
            return LevelBrowserLayer::scene(searchObject);
        }
        return nullptr;
    }
    int getSplitIntFromKey(char const* key, int index) = win 0x15d5e0, imac 0x547290, m1 0x498894;
    gd::string getStarLevelsString() = win 0x147c70, imac 0x535070, m1 0x4883b0;
    cocos2d::CCArray* getStoredLevelComments(char const* key) = m1 0x4a14b0;
    cocos2d::CCArray* getStoredOnlineLevels(char const* key) = win 0x1498c0, imac 0x537f50, m1 0x48ad3c;
    cocos2d::CCArray* getStoredUserList(UserListType type) = win 0x1630e0;
    GJUserMessage* getStoredUserMessage(int id) = win inline, m1 0x49d65c {
        return static_cast<GJUserMessage*>(m_userMessages->objectForKey(id));
    }
    GJUserMessage* getStoredUserMessageReply(int id) = win inline, m1 0x49d684 {
        return static_cast<GJUserMessage*>(m_userReplies->objectForKey(id));
    }
    int getTimeLeft(char const* key, float length);
    void getTopArtists(int page, int total) = win 0x158ff0, imac 0x122680, m1 0x49c694;
    const char* getTopArtistsKey(int page) = win inline, m1 0x49ca3c {
        return cocos2d::CCString::createWithFormat("topArtists_%i", page)->getCString();
    }
    const char* getUploadMessageKey(int accountID) = win inline, m1 0x49e828, ios inline {
        return cocos2d::CCString::createWithFormat("uMsg_%i", accountID)->getCString();
    }
    const char* getUserInfoKey(int id) = win inline, m1 0x49cde0, ios inline {
        return cocos2d::CCString::createWithFormat("account_%i", id)->getCString();
    }
    void getUserList(UserListType type) = win 0x1629d0, m1 0x4a62ac;
    void getUserMessages(bool sent, int page, int total);
    void getUsers(GJSearchObject* object) = win 0x159790;
    void gotoLevelPage(GJGameLevel* level) = win 0x149500, m1 0x48a7d0;
    void handleIt(bool success, gd::string response, gd::string tag, GJHttpType type) = win 0x143030;
    void handleItDelayed(bool success, gd::string response, gd::string tag, GJHttpType type) = win inline, ios inline {
        auto result = GJHttpResult::create(true, response, tag, type);
        result->retain();
        m_pActionManager->addAction(cocos2d::CCSequence::create(
            cocos2d::CCDelayTime::create(.1f),
            cocos2d::CCCallFuncND::create(this, callfuncND_selector(GJMultiplayerManager::handleItND), result),
            nullptr
        ), this, false);
    }
    void handleItND(cocos2d::CCNode* node, void* data) = win inline, ios inline {
        auto result = static_cast<GJHttpResult*>(data);
        this->handleIt(result->m_success, result->m_response, result->m_requestTag, result->m_httpType);
        result->release();
    }
    bool hasDailyStateBeenLoaded(GJTimedLevelType type) = win inline, m1 0x4a9654 {
        if (type == GJTimedLevelType::Daily) return m_dailyTimeLeft > 0;
        if (type == GJTimedLevelType::Weekly) return m_weeklyTimeLeft > 0;
        if (type == GJTimedLevelType::Event) return m_eventTimeLeft > 0;
        return false;
    }
    bool hasDownloadedLevel(int id) = win 0x1537f0;
    bool hasDownloadedList(int id) = win inline, m1 0x4925b4, ios inline {
        return this->hasDownloadedLevel(-id);
    }
    bool hasLikedAccountItem(LikeItemType type, int id, bool liked, int parentID) = win 0x164e50;
    bool hasLikedItem(LikeItemType type, int id, bool liked, int parentID) = win 0x164e50;
    bool hasLikedItemFullCheck(LikeItemType type, int id, bool liked, int parentID) = win 0x164dc0, imac 0x5574e0, m1 0x4a73bc;
    bool hasRatedDemon(int id);
    bool hasRatedLevelStars(int id);
    bool hasReportedLevel(int id);
    void invalidateMessages(bool sent, bool reload);
    void invalidateRequests(bool sent, bool reload);
    void invalidateUserList(UserListType type, bool reload) = win inline, m1 0x33f364 {
        this->resetStoredUserList(type);
        if (reload && m_userListDelegate) m_userListDelegate->forceReloadList(type);
    }
    bool isDLActive(char const* tag) = win 0x149aa0;
    bool isFollowingUser(int id) = win 0x14a980;
    bool isTimeValid(char const* key, float length) = win 0x149dd0;
    bool isUpdateValid(int id) = win inline {
        const char* str = cocos2d::CCString::createWithFormat("%i", id)->getCString();

        return this->isTimeValid(str, 3600.f);
    }
    int itemIDFromLikeKey(char const* key) = win inline {
        std::string keyStr = key;
        auto parts = cocos2d::CCArray::create();
        auto start = 0;
        auto index = keyStr.find_first_of(",");
        auto size = keyStr.size();
        while (index != std::string::npos) {
            auto str = keyStr.substr(start, index - start);
            if (!str.empty() || start != size) {
                parts->addObject(cocos2d::CCString::create(str));
            }
            start = index + 1;
            index = keyStr.find_first_of(",", start);
        }
        return parts->count() > 4 ? atoi(static_cast<cocos2d::CCString*>(parts->objectAtIndex(2))->getCString()) : 0;
    }
    bool keyHasTimer(char const* key);
    int levelIDFromCommentKey(char const* key) = win 0x15d6e0;
    int levelIDFromPostCommentKey(char const* key) = win inline {
        std::string keyStr = key;
        auto parts = cocos2d::CCArray::create();
        auto start = 0;
        auto index = keyStr.find_first_of(",");
        auto size = keyStr.size();
        while (index != std::string::npos) {
            auto str = keyStr.substr(start, index - start);
            if (!str.empty() || start != size) {
                parts->addObject(cocos2d::CCString::create(str));
            }
            start = index + 1;
            index = keyStr.find_first_of(",", start);
        }
        return parts->count() > 1 ? atoi(static_cast<cocos2d::CCString*>(parts->objectAtIndex(1))->getCString()) : 0;
    }
    int likeFromLikeKey(char const* key) = win inline {
        std::string keyStr = key;
        auto parts = cocos2d::CCArray::create();
        auto start = 0;
        auto index = keyStr.find_first_of(",");
        auto size = keyStr.size();
        while (index != std::string::npos) {
            auto str = keyStr.substr(start, index - start);
            if (!str.empty() || start != size) {
                parts->addObject(cocos2d::CCString::create(str));
            }
            start = index + 1;
            index = keyStr.find_first_of(",", start);
        }
        return parts->count() > 4 ? atoi(static_cast<cocos2d::CCString*>(parts->objectAtIndex(3))->getCString()) : 0;
    }
    void likeItem(LikeItemType type, int id, bool liked, int parentID) = win 0x163ca0, imac 0x556b50, m1 0x4a6b94;
    void limitSavedLevels() = win 0x14a1d0, imac 0x5391c0, m1 0x48bf5c;
    void makeTimeStamp(char const* key) = win 0x149cd0, m1 0x48abfc;
    void markItemAsLiked(LikeItemType type, int id, bool liked, int parentID) = win 0x164c50, imac 0x557570;
    void markLevelAsDownloaded(int id) = win 0x1536d0;
    void markLevelAsRatedDemon(int id) = win inline {
        if (m_ratedDemons->count() > 999) m_ratedDemons->removeObjectForKey(m_ratedDemons->getFirstKey());
        m_ratedDemons->setObject(m_trueString, cocos2d::CCString::createWithFormat("%i", id)->getCString());
    }
    void markLevelAsRatedStars(int id) = win inline {
        if (m_ratedLevels->count() > 999) m_ratedLevels->removeObjectForKey(m_ratedLevels->getFirstKey());
        m_ratedLevels->setObject(m_trueString, this->getRateStarsKey(id));
    }
    void markLevelAsReported(int id) = win inline {
        if (m_reportedLevels->count() > 9) m_reportedLevels->removeObjectForKey(m_reportedLevels->getFirstKey());
        m_reportedLevels->setObject(m_trueString, this->getReportKey(id));
    }
    void markListAsDownloaded(int id) = win inline, imac 0x545560, m1 0x496de8 {
        this->markLevelAsDownloaded(-id);
    }
    void messageWasRemoved(int id, bool sent);
    void onAcceptFriendRequestCompleted(gd::string response, gd::string tag) = win 0x1614d0;
    void onBanUserCompleted(gd::string response, gd::string tag) = win inline {
        if (response != "-1") this->resetTimerForKey("leaderboard_top");
    }
    void onBlockUserCompleted(gd::string response, gd::string tag) = win 0x162250;
    void onDeleteCommentCompleted(gd::string response, gd::string tag) = win 0x15f590;
    void onDeleteFriendRequestCompleted(gd::string response, gd::string tag) = win 0x160fb0;
    void onDeleteServerLevelCompleted(gd::string response, gd::string tag);
    void onDeleteServerLevelListCompleted(gd::string response, gd::string tag) = win inline, imac 0x52a830, m1 0x47ef28 {
        m_queuedLists.erase(tag);
        auto responseInt = atoi(response.c_str());
        if (response == "-1") {
            if (m_levelListDeleteDelegate) m_levelListDeleteDelegate->levelListDeleteFailed(responseInt);
        }
        else {
            if (m_levelListDeleteDelegate) m_levelListDeleteDelegate->levelListDeleteFinished(responseInt);
        }
    }
    void onDeleteUserMessagesCompleted(gd::string response, gd::string tag) = win 0x15b960;
    void onDownloadLevelCompleted(gd::string response, gd::string tag) = win inline {
        this->processOnDownloadLevelCompleted(response, tag, false);
    }
    void onDownloadUserMessageCompleted(gd::string response, gd::string tag) = win 0x15ad00, imac 0x5250b0, m1 0x47a148;
    void onGetAccountCommentsCompleted(gd::string response, gd::string tag) = win 0x15cae0;
    void onGetFriendRequestsCompleted(gd::string response, gd::string tag) = win 0x15ff40, m1 0x47905c;
    void onGetGauntletsCompleted(gd::string response, gd::string tag);
    void onGetGJChallengesCompleted(gd::string response, gd::string tag) = win 0x1679b0, imac 0x527140;
    void onGetGJDailyLevelStateCompleted(gd::string response, gd::string tag) = win 0x168e30, m1 0x47cb8c;
    void onGetGJRewardsCompleted(gd::string response, gd::string tag) = win 0x1667d0, imac 0x5264e0, m1 0x47b418;
    void onGetGJSecretRewardCompleted(gd::string response, gd::string tag) = win 0x1653e0, imac 0x52a990;
    void onGetGJUserInfoCompleted(gd::string response, gd::string tag) = win 0x15a070, m1 0x477a20;
    void onGetLeaderboardScoresCompleted(gd::string response, gd::string tag);
    void onGetLevelCommentsCompleted(gd::string response, gd::string tag) = win 0x15c370;
    void onGetLevelLeaderboardCompleted(gd::string response, gd::string tag) = win inline, imac 0x3c5290 {
        this->removeDLFromActive(tag.c_str());
        if (response == "-1") {
            if (m_leaderboardManagerDelegate) m_leaderboardManagerDelegate->loadLeaderboardFailed(tag.c_str());
        }
        else {
            auto scores = this->createAndGetScores(response, GJScoreType::LevelScore);
            this->storeSearchResult(scores, " ", tag.c_str());
            if (m_leaderboardManagerDelegate) m_leaderboardManagerDelegate->loadLeaderboardFinished(scores, tag.c_str());
        }
    }
    void onGetLevelListsCompleted(gd::string response, gd::string tag) = win 0x150a30, m1 0x47e6cc;
    void onGetLevelSaveDataCompleted(gd::string response, gd::string tag) = win 0x14f0e0, imac 0x525ff0;
    void onGetMapPacksCompleted(gd::string response, gd::string tag) = win 0x14f740, m1 0x47468c;
    void onGetNewsCompleted(gd::string response, gd::string tag) = win inline, imac 0x52a980, m1 0x47f004, ios inline {}
    void onGetOnlineLevelsCompleted(gd::string response, gd::string tag);
    void onGetTopArtistsCompleted(gd::string response, gd::string tag) = win 0x159310;
    void onGetUserListCompleted(gd::string response, gd::string tag) = win 0x162be0, m1 0x478aac;
    void onGetUserMessagesCompleted(gd::string response, gd::string tag) = win 0x15a440, imac 0x247390, m1 0x47980c;
    void onGetUsersCompleted(gd::string response, gd::string tag) = win 0x1599f0, imac 0xd21a0, m1 0x47a590;
    void onLikeItemCompleted(gd::string response, gd::string tag) = win 0x1642b0, imac 0x25ac00, m1 0x47726c;
    void onProcessHttpRequestCompleted(cocos2d::extension::CCHttpClient* client, cocos2d::extension::CCHttpResponse* response) = win 0x142f40;
    void onRateDemonCompleted(gd::string response, gd::string tag) = win 0x1557c0, imac 0x4f4d0, m1 0x47d56c;
    void onRateStarsCompleted(gd::string response, gd::string tag) = win 0x154190, m1 0x47520c;
    void onReadFriendRequestCompleted(gd::string response, gd::string tag) = win inline, imac 0x523040, m1 0x4781f4 {
        m_friendReqAndUserBlocks->removeObjectForKey(tag);
    }
    void onRemoveFriendCompleted(gd::string response, gd::string tag) = win 0x161cf0;
    void onReportLevelCompleted(gd::string response, gd::string tag) = win 0x16a560, m1 0x477668;
    void onRequestUserAccessCompleted(gd::string response, gd::string tag) = win 0x1649e0, imac 0x525e70, m1 0x47adb0;
    void onRestoreItemsCompleted(gd::string response, gd::string tag) = win 0x169b80, imac 0x522300, m1 0x477454;
    void onSetLevelFeaturedCompleted(gd::string response, gd::string tag) = win inline, m1 0x4756a0 {}
    void onSetLevelStarsCompleted(gd::string response, gd::string tag);
    void onSubmitUserInfoCompleted(gd::string response, gd::string tag) = win inline, imac 0x5224c0, m1 0x477664 {}
    void onSuggestLevelStarsCompleted(gd::string response, gd::string tag) = win 0x1550f0;
    void onUnblockUserCompleted(gd::string response, gd::string tag) = win 0x162770;
    void onUpdateDescriptionCompleted(gd::string response, gd::string tag) = win 0x163a40, m1 0x4777d8;
    void onUpdateLevelCompleted(gd::string response, gd::string tag) = win inline {
        this->processOnDownloadLevelCompleted(response, tag, true);
    }
    void onUpdateUserScoreCompleted(gd::string response, gd::string tag) = win 0x157690, m1 0x4756a4;
    void onUploadCommentCompleted(gd::string response, gd::string tag) = win 0x15e3b0, m1 0x4765cc;
    void onUploadFriendRequestCompleted(gd::string response, gd::string tag) = win 0x1609e0;
    void onUploadLevelCompleted(gd::string response, gd::string tag) = win 0x14d2e0, imac 0x522a30;
    void onUploadLevelListCompleted(gd::string response, gd::string tag) = win inline, imac 0x52a640, m1 0x47ed8c {
        m_queuedLists.erase(tag);
        auto listID = atoi(response.c_str());
        auto uniqueID = atoi(tag.c_str());
        if (listID < 0) {
            if (m_listUploadDelegate) m_listUploadDelegate->listUploadFailed(this->getLocalLevelList(uniqueID), listID);
        }
        else {
            auto levelList = this->getLocalLevelList(uniqueID);
            if (levelList) {
                levelList->m_listID = listID;
                levelList->m_uploaded = true;
            }
            if (m_listUploadDelegate) m_listUploadDelegate->listUploadFinished(levelList);
        }
    }
    void onUploadUserMessageCompleted(gd::string response, gd::string tag) = win 0x15b2d0, m1 0x47a318;
    int pageFromCommentKey(char const* key) = win inline {
        std::string keyStr = key;
        auto parts = cocos2d::CCArray::create();
        auto start = 0;
        auto index = keyStr.find_first_of(",");
        auto size = keyStr.size();
        while (index != std::string::npos) {
            auto str = keyStr.substr(start, index - start);
            if (!str.empty() || start != size) {
                parts->addObject(cocos2d::CCString::create(str));
            }
            start = index + 1;
            index = keyStr.find_first_of(",", start);
        }
        return parts->count() > 2 ? atoi(static_cast<cocos2d::CCString*>(parts->objectAtIndex(2))->getCString()) : 0;
    }
    void parseRestoreData(gd::string str) = win inline, imac 0x559c20, m1 0x4a9a24, ios inline {}
    void performNetworkTest() = win inline, imac 0x51a610 {
        if (m_testedNetwork) return;
        m_testedNetwork = true;
        auto request = new cocos2d::extension::CCHttpRequest();
        request->setUrl("https://www.google.com");
        request->setReadTimeout(1);
        request->setRequestType(cocos2d::extension::CCHttpRequest::kHttpPost);
        request->setResponseCallback(this, httpresponse_selector(GameLevelManager::onProcessHttpRequestCompleted));
        request->setRequestData("temp", 4);
        request->setTag("tag");
        request->setType(56);
        cocos2d::extension::CCHttpClient::getInstance()->send(request);
        request->release();
    }
    void ProcessHttpRequest(gd::string endpoint, gd::string params, gd::string tag, GJHttpType httpType) = win 0x142da0, imac 0x51a970, m1 0x2ac248;
    void processOnDownloadLevelCompleted(gd::string response, gd::string tag, bool update) = win 0x1523b0, imac 0x375860, m1 0x495bec;
    void purgeUnusedLevels() = win 0x14a470, imac 0x129350, m1 0x48c16c;
    bool rateDemon(int id, int diff, bool moderator) = win 0x155390, m1 0x4989d4;
    void rateStars(int id, int diff) = win 0x153b00, imac 0x545910, m1 0x497180;
    void readFriendRequest(int id) = win 0x1616c0;
    void removeDelimiterChars(gd::string str, bool colon) = win 0x16a9a0;
    void removeDLFromActive(char const* key) = win 0x149c20;
    bool removeFriend(int accountID) = win 0x1619d0;
    void removeLevelDownloadedKeysFromDict(cocos2d::CCDictionary* dict);
    void removeUserFromList(int id, UserListType type) = win 0x162920, imac 0x555d60, m1 0x4a5d80;
    void reportLevel(int id) = win 0x16a2c0, m1 0x4a9a28;
    bool requestUserAccess() = win 0x164700, imac 0x557990, m1 0x4a790c;
    void resetAccountComments(int accountID) = win inline, m1 0x4a0f44 {
        for(int i = 0; i <= 1; i++) {
            auto key = getAccountCommentKey(accountID, i);
            if(getStoredOnlineLevels(key)) {
                m_storedLevels->removeObjectForKey(key);
            }
        }
    }
    void resetAllTimers() = win inline, m1 0x48b7b8, ios inline {
        m_timerDict->removeAllObjects();
    }
    void resetCommentTimersForAccountID(int id) = win 0x15ef10, imac 0x2e4e10, m1 0x4a2bd4;
    void resetCommentTimersForLevelID(int id, CommentKeyType type) = win 0x15ed40;
    void resetDailyLevelState(GJTimedLevelType type) = win inline, m1 0x212758 {
        if (type == GJTimedLevelType::Daily) {
            m_dailyTimeLeft = 0;
            m_dailyID = 0;
        }
        else if (type == GJTimedLevelType::Weekly) {
            m_weeklyTimeLeft = 0;
            m_weeklyID = 0;
        }
        else if (type == GJTimedLevelType::Event) {
            m_eventTimeLeft = 0;
            m_eventID = 0;
        }
    }
    void resetGauntlets() = win inline {
        m_savedGauntlets->removeAllObjects();
    }
    void resetStoredUserInfo(int id) = win inline, m1 0x49d630 {
        m_storedUserInfo->removeObjectForKey(id);
    }
    void resetStoredUserList(UserListType type) = win 0x163270, imac 0x554dc0, m1 0x4a4e64;
    void resetTimerForKey(char const* key) = win 0x14a120;
    void restoreItems() = imac 0xd29e0, m1 0x4a973c;
    void saveFetchedLevelLists(cocos2d::CCArray* lists) = win inline, ios inline {
        for (int i = 0; i < lists->count(); i++) {
            this->saveLevelList(static_cast<GJLevelList*>(lists->objectAtIndex(i)));
        }
    }
    void saveFetchedLevels(cocos2d::CCArray* levels) = win 0x1469e0, imac 0x530da0, m1 0x4845b8;
    void saveFetchedMapPacks(cocos2d::CCArray* packs) = win inline {
        for (int i = 0; i < packs->count(); i++) {
            this->saveMapPack(static_cast<GJMapPack*>(packs->objectAtIndex(i)));
        }
    }
    void saveGauntlet(GJMapPack* gauntlet) = win inline {
        m_savedGauntlets->setObject(gauntlet, this->getGauntletKey(gauntlet->m_packID));
    }
    void saveLevel(GJGameLevel* level) = win 0x148dc0, imac 0x5371c0;
    void saveLevelList(GJLevelList* list) = win 0x150f20;
    void saveLocalScore(int id, int value, int type) = win inline, imac 0x53a400, m1 0x48d0b0, ios inline {}
    void saveMapPack(GJMapPack* pack) = win inline {
        m_savedPacks->setObject(pack, this->getMapPackKey(pack->m_packID));
    }
    void setActiveSmartTemplate(GJSmartTemplate* smartTemplate) = win inline, imac 0x53a420, m1 0x48d0bc, ios inline {
        m_smartTemplate = smartTemplate;
    }
    void setBoolForKey(bool value, char const* key) = win inline {
        m_searchFilters->setObject(cocos2d::CCString::createWithFormat("%i", (int)value), key);
    }
    void setDiffVal(int diff, bool value);
    void setFolderName(int id, gd::string name, bool local) = win inline, imac 0x53a2e0, m1 0x48cf84 {
        auto dict = local ? m_localLevelsFolders : m_onlineFolders;
        dict->setObject(cocos2d::CCString::create(name), cocos2d::CCString::createWithFormat("%i", id)->getCString());
    }
    void setIntForKey(int value, char const* key) = win inline, m1 0x4aa428 {
        m_searchFilters->setObject(cocos2d::CCString::createWithFormat("%i", value), key);
    }
    void setLenVal(int diff, bool value);
    void setLevelFeatured(int id, int rank, bool epic) = win inline, imac 0x5478c0, m1 0x498e90, ios inline {}
    bool setLevelStars(int id, int stars, bool coins) = win inline, imac 0x5478b0, m1 0x498e88, ios inline { return false; }
    int specialFromLikeKey(char const* key) = win inline, ios inline {
        std::string keyStr = key;
        auto parts = cocos2d::CCArray::create();
        auto start = 0;
        auto index = keyStr.find_first_of(",");
        auto size = keyStr.size();
        while (index != std::string::npos) {
            auto str = keyStr.substr(start, index - start);
            if (!str.empty() || start != size) {
                parts->addObject(cocos2d::CCString::create(str));
            }
            start = index + 1;
            index = keyStr.find_first_of(",", start);
        }
        return parts->count() > 4 ? atoi(static_cast<cocos2d::CCString*>(parts->objectAtIndex(4))->getCString()) : 0;
    }
    void storeCommentsResult(cocos2d::CCArray* comments, gd::string pageInfo, char const* key) = win 0x15d7f0, imac 0x3ee260, m1 0x49e21c;
    void storeDailyLevelState(int id, int remaining, GJTimedLevelType type) = win inline, imac 0x559710, m1 0x4a94e8 {
        if (type != GJTimedLevelType::Daily && type != GJTimedLevelType::Weekly && type != GJTimedLevelType::Event) return;
        __timeb64 current;
        _ftime64_s(&current);
        auto currentTime = ((current.time & 0xfffff) * 1000 + current.millitm) / 1000.0;
        if (type == GJTimedLevelType::Daily) {
            m_dailyID = id;
            m_dailyTimeLeft = currentTime + remaining;
        }
        else if (type == GJTimedLevelType::Weekly) {
            m_weeklyID = id;
            m_weeklyTimeLeft = currentTime + remaining;
        }
        else if (type == GJTimedLevelType::Event) {
            m_eventID = id;
            m_eventTimeLeft = currentTime + remaining;
        }
    }
    void storeFriendRequest(GJFriendRequest* request) = win inline, m1 0x49d614, ios inline {
        if (request && request->m_accountID > 0) m_friendRequests->setObject(request, request->m_accountID);
    }
    void storeSearchResult(cocos2d::CCArray* levels, gd::string pageInfo, char const* searchKey) = win 0x1496b0, m1 0x48a950;
    void storeUserInfo(GJUserScore* score) = win inline, m1 0x49d12c, ios inline {
        if (score && score->m_accountID > 0) m_storedUserInfo->setObject(score, score->m_accountID);
    }
    void storeUserMessage(GJUserMessage* message) = win inline, m1 0x49d648, ios inline {
        if (message) m_userMessages->setObject(message, message->m_messageID);
    }
    void storeUserMessageReply(int id, GJUserMessage* message) = win inline, m1 0x49d668 {
        if (message) m_userReplies->setObject(message, id);
    }
    void storeUserName(int userID, int accountID, gd::string userName) = win 0x145d50, m1 0x481d58;
    void storeUserNames(gd::string usernameString) = win 0x145a50, imac 0x52d380, m1 0x48152c;
    void submitUserInfo() = win 0x169e80, imac 0x549b10, m1 0x49a744;
    void suggestLevelStars(int id, int stars, int feature) = win 0x154dd0, imac 0xac1c0, m1 0x4983d8;
    gd::string tryGetUsername(int accountID) = win 0x1460b0, m1 0x482154;
    CommentType typeFromCommentKey(char const* key) = win inline {
        std::string keyStr = key;
        auto parts = cocos2d::CCArray::create();
        auto start = 0;
        auto index = keyStr.find_first_of(",");
        auto size = keyStr.size();
        while (index != std::string::npos) {
            auto str = keyStr.substr(start, index - start);
            if (!str.empty() || start != size) {
                parts->addObject(cocos2d::CCString::create(str));
            }
            start = index + 1;
            index = keyStr.find_first_of(",", start);
        }
        return parts->count() > 3 ? (CommentType)atoi(static_cast<cocos2d::CCString*>(parts->objectAtIndex(3))->getCString()) : CommentType::Level;
    }
    LikeItemType typeFromLikeKey(char const* key) = win inline {
        std::string keyStr = key;
        auto parts = cocos2d::CCArray::create();
        auto start = 0;
        auto index = keyStr.find_first_of(",");
        auto size = keyStr.size();
        while (index != std::string::npos) {
            auto str = keyStr.substr(start, index - start);
            if (!str.empty() || start != size) {
                parts->addObject(cocos2d::CCString::create(str));
            }
            start = index + 1;
            index = keyStr.find_first_of(",", start);
        }
        return parts->count() > 4 ? (LikeItemType)atoi(static_cast<cocos2d::CCString*>(parts->objectAtIndex(1))->getCString()) : LikeItemType::Unknown;
    }
    bool unblockUser(int id) = win 0x162450;
    void unfollowUser(int id) = win inline {
        m_followedCreators->removeObjectForKey(cocos2d::CCString::createWithFormat("%i", id)->getCString());
    }
    bool updateDescription(int id, gd::string description) = win 0x1636f0, imac 0x179f60;
    void updateLevel(GJGameLevel* level) = win 0x1538c0, m1 0x496e38;
    void updateLevelOrders() = win 0x147700, m1 0x49ca0;
    void updateLevelRewards(GJGameLevel* level) = win 0x146400, m1 0x4825f0;
    void updateSavedLevelList(GJLevelList* list) = win 0x151000, imac 0x542350, m1 0x4941fc;
    void updateUsernames() = win inline, imac 0x5399b0, m1 0x48c690 {
        cocos2d::CCDictElement* element;
        cocos2d::CCDictElement* temp;
        HASH_ITER(hh, m_onlineLevels->m_pElements, element, temp) {
            auto level = static_cast<GJGameLevel*>(element->getObject());
            this->storeUserName(level->m_userID.value(), level->m_accountID.value(), level->m_creatorName);
        }
    }
    void updateUserScore() = win 0x155ca0, imac 0x5478d0, m1 0x498e94;
    void uploadAccountComment(gd::string content) = win inline {
        this->uploadComment(content, CommentType::Account, 0, 0);
    }
    void uploadComment(gd::string content, CommentType type, int levelID, int percent) = win 0x15dae0, imac 0x5512c0;
    bool uploadFriendRequest(int accountID, gd::string content) = win 0x1605d0, imac 0x43ae80, m1 0x4a3bd4;
    void uploadLevel(GJGameLevel* level) = win 0x14c800, imac 0x53ce50;
    void uploadLevelComment(int levelID, gd::string content, int percent) = win inline, imac 0x551230 {
        this->uploadComment(content, CommentType::Level, levelID, percent);
    }
    void uploadLevelList(GJLevelList* list) = win 0x14fe30, imac 0x540c50;
    void uploadUserMessage(int accountID, gd::string subject, gd::string content) = win 0x15ae80, m1 0x49e850;
    int userIDForAccountID(int id) = win inline, m1 0x482434 {
        return m_userIDtoAccountIDDict->valueForKey(id)->intValue();
    }
    GJUserScore* userInfoForAccountID(int id) = win inline, m1 0x482450 {
        return static_cast<GJUserScore*>(m_storedUserInfo->objectForKey(id));
    }
    gd::string userNameForUserID(int id) = win 0x145f30, m1 0x481fb4;
    bool verifyContainerOnlyHasLevels(cocos2d::CCDictionary* dict) = win 0x14b1e0, imac 0x4379c0, m1 0x48d768;
    void verifyLevelState(GJGameLevel* level) = win inline, m1 0x482478 {
        auto gsm = GameStatsManager::sharedState();
        if (gsm->hasCompletedLevel(level) && level->shouldCheatReset()) {
            gsm->uncompleteLevel(level);
            level->m_normalPercent = 0;
            level->m_orbCompletion = 0;
            level->m_newNormalPercent2 = 0;
            level->m_bestTime = 0;
            level->m_bestPoints = 0;
            level->m_isCompletionLegitimate = true;
        }
    }
    gd::string writeSpecialFilters(GJSearchObject* object) = win 0x14d9f0, imac 0x53f030, m1 0x49146c;

    gd::set<gd::string> m_queuedLists;
    cocos2d::CCDictionary* m_mainLevels;
    cocos2d::CCDictionary* m_searchFilters; //"value dict"
    cocos2d::CCDictionary* m_onlineLevels;
    cocos2d::CCDictionary* m_storedLevelData;
    cocos2d::CCDictionary* m_followedCreators;
    cocos2d::CCDictionary* m_favoriteLists;
    cocos2d::CCDictionary* m_downloadedLevels;
    cocos2d::CCDictionary* m_likedLevels;
    cocos2d::CCDictionary* m_ratedLevels;
    cocos2d::CCDictionary* m_ratedDemons;
    cocos2d::CCDictionary* m_reportedLevels;
    cocos2d::CCDictionary* m_onlineFolders;
    cocos2d::CCDictionary* m_localLevelsFolders;
    cocos2d::CCDictionary* m_dailyLevels;
    int m_dailyTimeLeft;
    int m_dailyID;
    int m_activeDailyID;
    int m_weeklyTimeLeft;
    int m_weeklyID;
    int m_activeWeeklyID;
    int m_eventTimeLeft;
    int m_eventID;
    int m_activeEventID;
    cocos2d::CCDictionary* m_gauntletLevels;
    gd::map<gd::string, bool> m_availableFilters;
    cocos2d::CCDictionary* m_timerDict;
    cocos2d::CCDictionary* m_knownUsers;
    cocos2d::CCDictionary* m_accountIDtoUserIDDict;
    cocos2d::CCDictionary* m_userIDtoAccountIDDict;
    cocos2d::CCDictionary* m_storedLevels;
    cocos2d::CCDictionary* m_pageInfo;
    cocos2d::CCDictionary* m_unkDict20;
    cocos2d::CCDictionary* m_savedPacks;
    cocos2d::CCDictionary* m_savedGauntlets;
    cocos2d::CCDictionary* m_downloadObjects;
    cocos2d::CCDictionary* m_friendReqAndUserBlocks;
    cocos2d::CCDictionary* m_storedUserInfo;
    cocos2d::CCDictionary* m_friendRequests;
    cocos2d::CCDictionary* m_userMessages;
    cocos2d::CCDictionary* m_userReplies;
    cocos2d::CCDictionary* m_localLeaderboardLevels;
    gd::string m_searchKey;
    gd::string m_mapPackKey;
    LeaderboardState m_leaderboardState;
    int m_leaderboardMode;
    bool m_returnToLocalLevels;
    LevelManagerDelegate* m_levelManagerDelegate;
    LevelDownloadDelegate* m_levelDownloadDelegate;
    LevelCommentDelegate* m_levelCommentDelegate;
    CommentUploadDelegate* m_commentUploadDelegate;
    LevelUploadDelegate* m_levelUploadDelegate;
    ListUploadDelegate* m_listUploadDelegate;
    LevelUpdateDelegate* m_levelUpdateDelegate;
    LeaderboardManagerDelegate* m_leaderboardManagerDelegate;
    LevelDeleteDelegate* m_levelDeleteDelegate;
    LevelListDeleteDelegate* m_levelListDeleteDelegate;
    UserInfoDelegate* m_userInfoDelegate;
    UploadActionDelegate* m_uploadActionDelegate;
    UserListDelegate* m_userListDelegate;
    FriendRequestDelegate* m_friendRequestDelegate;
    MessageListDelegate* m_messageListDelegate;
    DownloadMessageDelegate* m_downloadMessageDelegate;
    UploadMessageDelegate* m_uploadMessageDelegate;
    GJRewardDelegate* m_GJRewardDelegate;
    GJOnlineRewardDelegate* m_GJOnlineRewardDelegate;
    GJChallengeDelegate* m_GJChallengeDelegate;
    GJDailyLevelDelegate* m_GJDailyLevelDelegate;
    OnlineListDelegate* m_onlineListDelegate;
    void* m_levelRateInfoDelegate;
    SearchType m_searchType;
    int m_mapPack;
    gd::string m_tempSave;
    cocos2d::CCString* m_trueString;
    cocos2d::CCArray* m_smartTemplates;
    GJSmartTemplate* m_smartTemplate;
    bool m_testedNetwork;
}

[[link(android)]]
class GameLevelOptionsLayer : GJOptionsLayer {
    // virtual ~GameLevelOptionsLayer();

    static GameLevelOptionsLayer* create(GJGameLevel* level) = win 0x2a08e0;

    virtual void setupOptions() = win 0x2a0a40, m1 0x2500b4, imac 0x2b2110;
    virtual void didToggle(int tag) = win 0x2a0ac0, imac 0x2b2180, m1 0x250118;

    bool init(GJGameLevel* level) = win inline, imac 0x2b20b0, m1 0x25004c {
        m_gap = 40.f;
        m_maxLabelScale = .4f;
        if (level) {
            m_level = level;
            level->retain();
        }
        if (!GJOptionsLayer::init(2)) return false;
        this->preSetup();
        this->postSetup();
        return true;
    }

    GJGameLevel* m_level;
}

[[link(android), depends(UIButtonConfig)]]
class GameManager : GManager {
    // virtual ~GameManager();
    // GameManager() = win 0x17ab40, ios 0x32eafc;

    static GameManager* get() {
        return GameManager::sharedState();
    }
    static GameManager* sharedState() = win 0x17b4e0, imac 0x3765e0, m1 0x2ffc8c;

    virtual void update(float dt) = win 0x189c00, m1 0x312474, imac 0x38b680;
    virtual bool init() = win 0x17b530, imac 0x376640, m1 0x2ffcf8;
    virtual void encodeDataTo(DS_Dictionary* dict) = win 0x188ff0, imac 0x38aa80, m1 0x311898;
    virtual void dataLoaded(DS_Dictionary* dict) = win 0x186ad0, m1 0x30fdf8, imac 0x388ca0;
    virtual void firstLoad() = win 0x1886f0, imac 0x38a160, m1 0x311084;

    void accountStatusChanged() = win inline, m1 0x30c684 {
        if (m_menuLayer) m_menuLayer->updateUserProfileButton();
    }
    int activeIconForType(IconType type) = win 0x181ad0, imac 0x3806e0;
    void addCustomAnimationFrame(int objectID, int frameIndex, gd::string mainFrame, gd::string detailFrame) = win 0x1aeba0, m1 0x209bd4;
    void addDuplicateLastFrame(int objectID) = win inline, imac 0x553260, m1 0x209cec, ios inline {
        auto frames = this->framesForAnimation(objectID);
        auto mainFrame = static_cast<cocos2d::CCArray*>(m_mainFramesForAnimation->objectForKey(objectID))->stringAtIndex(frames - 1)->getCString();
        auto detailFrame = static_cast<cocos2d::CCArray*>(m_detailFramesForAnimation->objectForKey(objectID))->stringAtIndex(frames - 1)->getCString();
        this->addCustomAnimationFrame(objectID, frames, mainFrame, detailFrame);
        m_framesForAnimation->setObject(cocos2d::CCInteger::create(frames + 1), objectID);
    }
    void addGameAnimation(int objectID, int frames, float frameTime, gd::string mainAnimFrame, gd::string detailAnimFrame, int defaultFrame) = win 0x1aea30, imac 0x265db0, m1 0x209964;
    void addIconDelegate(cocos2d::CCObject* delegate, int key) = imac 0x381420, m1 0x309080;
    void addNewCustomObject(gd::string str) = win 0x183830, m1 0x30bf00;
    void addToGJLog(cocos2d::CCString* str) = win inline, m1 0x30ddec, ios inline {}
    void applicationDidEnterBackground() = win inline, imac 0x38b6d0, m1 0x3124c0 {}
    void applicationWillEnterForeground() = win 0x189c90, m1 0x3124c4;
    void calculateBaseKeyForIcons() = win inline {
        m_keyStartForIcon.resize(9);
        m_keyStartForIcon[0] = 0;
        m_keyStartForIcon[1] = 485;
        m_keyStartForIcon[2] = 654;
        m_keyStartForIcon[3] = 772;
        m_keyStartForIcon[4] = 921;
        m_keyStartForIcon[5] = 1017;
        m_keyStartForIcon[6] = 1085;
        m_keyStartForIcon[7] = 1154;
        m_keyStartForIcon[8] = 1197;
        for (int i = 0; i < 1205; i++) {
            m_iconLoadCounts[i] = 0;
        }
    }
    bool canShowRewardedVideo() = m1 0x307dbc;
    void checkSteamAchievementUnlock() = m1 0x302e94, ios inline {}
    void checkUsedIcons() = win 0x184210, imac 0x37ea10, m1 0x3068e8;
    void claimItemsResponse(gd::string str) = win inline, m1 0x307668, ios inline {}
    void clearGJLog() = win inline, m1 0x30ddf4 {
        m_gjLog->removeAllObjects();
    }
    cocos2d::ccColor3B colorForIdx(int index) = win 0x181390, m1 0x30766c;
    int colorForPos(int pos) = win inline, m1 0x307b38, ios inline {
        switch (pos) {
            case 4: return 16;
            case 5: return 4;
            case 6: return 5;
            case 7: return 6;
            case 8: return 13;
            case 9: return 7;
            case 10: return 8;
            case 11: return 9;
            case 12: return 29;
            case 13: return 10;
            case 15: return 11;
            case 16: return 12;
            case 19: return 15;
            case 20: return 27;
            case 21: return 32;
            case 22: return 28;
            case 23: return 38;
            case 24: return 20;
            case 25: return 33;
            case 26: return 21;
            case 27: return 34;
            case 28: return 22;
            case 29: return 39;
            case 30: return 23;
            case 31: return 35;
            case 32: return 24;
            case 33: return 36;
            case 34: return 25;
            case 35: return 37;
            case 36: return 30;
            case 37: return 26;
            case 38: return 31;
            case 39: return 19;
            default: return pos;
        }
    }
    gd::string colorKey(int id, UnlockType type) = win 0x17c7f0, imac 0x377e80, m1 0x3011e4;
    void completedAchievement(gd::string key) = win 0x17d230, imac 0x378c40, m1 0x3020a0;
    int countForType(IconType type) = win 0x181c40;
    int defaultFrameForAnimation(int objectID) = win inline, m1 0x201900, ios inline {
        if (auto frame = static_cast<cocos2d::CCInteger*>(m_defaultFrames->objectForKey(objectID))) {
            return frame->getValue();
        }
        return 1;
    }
    void didExitPlayscene() = win inline {
        if (this->m_unkBool8) {
            this->m_unkBool8 = false;
            if (cocos2d::CCDirector::sharedDirector()->getSmoothFixCounter() >= 10) {
                this->setGameVariable("0023", false);
            }
        }
    }
    void doQuickSave() = win inline, m1 0x312398 {
        m_quickSave = true;
        this->save();
        m_quickSave = false;
    }
    gd::string dpadConfigToString(UIButtonConfig& config) = win 0x1864d0, imac 0x387410, m1 0x30e858;
    void eventUnlockFeature(char const* key) = win inline, m1 0x307654, ios inline {}
    void fadeInMenuMusic() = win 0x17baf0, imac 0x376e50, m1 0x3005a4;
    void fadeInMusic(gd::string path) = win 0x17bbe0, imac 0x376f30;
    void finishedLoadingBGAsync(cocos2d::CCObject* obj) = win 0x182990;
    void finishedLoadingGAsync(int index) = win 0x182e30, m1 0x30b264;
    void finishedLoadingGAsync1(cocos2d::CCObject* obj) = win 0x182db0;
    void finishedLoadingGAsync2(cocos2d::CCObject* obj) = win 0x182df0;
    void finishedLoadingIconAsync(cocos2d::CCObject* obj) = m1 0x3091f4;
    void finishedLoadingMGAsync(int index) = win 0x182bd0, m1 0x30af04;
    void finishedLoadingMGAsync1(cocos2d::CCObject* obj) = win 0x182b50;
    void finishedLoadingMGAsync2(cocos2d::CCObject* obj) = win 0x182b90;
    void followTwitch() = win inline, m1 0x308410 {
        if (GameToolbox::doWeHaveInternet()) {
            cocos2d::CCApplication::sharedApplication()->openURL("https://www.twitch.tv/directory/category/geometry-dash");
            m_clickedTwitch = true;
            __timeb64 current;
            _ftime64_s(&current);
            m_socialsDuration = ((current.time & 0xfffff) * 1000 + current.millitm) / 1000.0;
        }
    }
    void followTwitter() = win inline, m1 0x308310 {
        if (GameToolbox::doWeHaveInternet()) {
            cocos2d::CCApplication::sharedApplication()->openURL("https://twitter.com/robtopgames");
            m_clickedTwitter = true;
            __timeb64 current;
            _ftime64_s(&current);
            m_socialsDuration = ((current.time & 0xfffff) * 1000 + current.millitm) / 1000.0;
        }
    }
    int framesForAnimation(int objectID) = win inline, m1 0x201ad8, ios inline {
        if (auto frames = static_cast<cocos2d::CCInteger*>(m_framesForAnimation->objectForKey(objectID))) {
            return frames->getValue();
        }
        return 1;
    }
    float frameTimeForAnimation(int objectID) = win inline, m1 0x201b08, ios inline {
        if (auto time = static_cast<cocos2d::CCFloat*>(m_frameTimeForAnimation->objectForKey(objectID))) {
            return time->getValue();
        }
        return 1.f;
    }
    int generateSecretNumber() = win 0x185d30;
    const char* getBGTexture(int index) = win inline, imac 0x383680, m1 0x30b300 {
        index = std::clamp(index, 0, 59);
        this->loadBackground(index);
        return cocos2d::CCString::createWithFormat("game_bg_%02d_001.png", index)->getCString();
    }
    LevelEditorLayer* getEditorLayer() {
        return m_levelEditorLayer;
    }
    const char* getFontFile(int index) = win inline {
        index = std::clamp(index, 0, 59);
        this->loadFont(index);
        if (index != 0) {
            return cocos2d::CCString::createWithFormat("gjFont%02d.fnt", index)->getCString();
        }
        return "bigFont.fnt";
    }
    const char* getFontTexture(int index) = win inline {
        index = std::clamp(index, 0, 59);
        this->loadFont(index);
        if (index != 0) {
            return cocos2d::CCString::createWithFormat("gjFont%02d.png", index)->getCString();
        }
        return "bigFont.png";
    }
    GJBaseGameLayer* getGameLayer() {
        return m_gameLayer;
    }
    bool getGameVariable(char const* key) = win 0x183150, imac 0x376d00, m1 0x300404;
    bool getGameVariableDefault(const char* key, bool defaultValue) {
        //helper function
        auto object = static_cast<cocos2d::CCString*>(m_valueKeeper->objectForKey(std::string("gv_") + key));
        if (object == nullptr)
            return defaultValue;
        return object->boolValue();
    }
    const char* getGTexture(int index) = win inline, imac 0x383720, m1 0x30b398 {
        index = std::clamp(index, 0, 22);
        this->loadGround(index);
        return cocos2d::CCString::createWithFormat("groundSquare_%02d_001.png", index)->getCString();
    }
    int getIconRequestID() = win inline, imac 0x382a70, m1 0x30a694 {
        return m_iconRequestID++;
    }
    int getIntGameVariable(char const* key) = win 0x183750, imac 0x383e90, m1 0x30bbb4;
    int getIntGameVariableDefault(const char* key, int defaultValue) {
        //helper function
        auto object = static_cast<cocos2d::CCString*>(m_valueKeeper->objectForKey(std::string("gv_") + key));
        if (object == nullptr)
            return defaultValue;
        return object->intValue();
    }
    gd::string getMenuMusicFile() = win 0x17b760, m1 0x2fff4c;
    const char* getMGTexture(int index) = win inline, imac 0x3836d0, m1 0x30b34c {
        index = std::clamp(index, 0, 3);
        this->loadMiddleground(index);
        return cocos2d::CCString::createWithFormat("fg_%02d_001.png", index)->getCString();
    }
    int getNextUniqueObjectKey() = win inline, m1 0x30bcd8 {
        auto customKeys = this->getOrderedCustomObjectKeys();
        auto result = -1;
        for (auto obj : geode::cocos::CCArrayExt<cocos2d::CCObject*, false>(customKeys)) {
            auto key = static_cast<cocos2d::CCString*>(obj)->intValue();
            if (key < result) result = key;
        }
        return result;
    }
    int getNextUsedKey(int index, bool up) = win inline, imac 0x384090, m1 0x30bdd0 {
        auto previous = 0;
        auto customKeys = this->getOrderedCustomObjectKeys();
        for (int i = 0; i < customKeys->count(); i++) {
            auto key = customKeys->stringAtIndex(i)->intValue();
            if (key == index) {
                if (up) return previous;
                else return i + 1 < customKeys->count() ? customKeys->stringAtIndex(i + 1)->intValue() : 0;
            }
            previous = key;
        }
        return 0;
    }
    cocos2d::CCArray* getOrderedCustomObjectKeys() = win inline, imac 0x384040, m1 0x30bd84 {
        auto keys = m_customObjectDict->allKeys();
        if (keys->count() != 0) {
            qsort(keys->data->arr, keys->data->num, sizeof(cocos2d::CCString*), [](void const* a, void const* b) {
                auto sa = *static_cast<cocos2d::CCString* const*>(a);
                auto sb = *static_cast<cocos2d::CCString* const*>(b);
                return sa->intValue() - sb->intValue();
            });
        }
        return keys;
    }
    int getPlayerBall() {
        return m_playerBall;
    }
    int getPlayerBird() {
        return m_playerBird;
    }
    int getPlayerColor() {
        return m_playerColor;
    }
    int getPlayerColor2() {
        return m_playerColor2;
    }
    int getPlayerDart() {
        return m_playerDart;
    }
    int getPlayerDeathEffect() {
        return m_playerDeathEffect;
    }
    int getPlayerFrame() {
        return m_playerFrame;
    }
    bool getPlayerGlow() {
        return m_playerGlow;
    }
    int getPlayerGlowColor() {
        return m_playerGlowColor;
    }
    int getPlayerJetpack() {
        return m_playerJetpack;
    }
    int getPlayerRobot() {
        return m_playerRobot;
    }
    int getPlayerShip() {
        return m_playerShip;
    }
    int getPlayerShipFire() {
        return m_playerShipFire;
    }
    int getPlayerSpider() {
        return m_playerSpider;
    }
    int getPlayerStreak() {
        return m_playerStreak;
    }
    int getPlayerSwing() {
        return m_playerSwing;
    }
    PlayLayer* getPlayLayer() {
        return m_playLayer;
    }
    gd::string getPracticeMusicFile() = win inline, m1 0x3000c0 {
        auto mdm = MusicDownloadManager::sharedState();
        if (m_customPracticeSongID > 0) {
            if (mdm->isSongDownloaded(m_customPracticeSongID)) {
                if (m_customPracticeSongID > 0) {
                    return mdm->pathForSong(m_customPracticeSongID);
                }
            }
            else {
                m_customPracticeSongID = 0;
            }
        }
        return "StayInsideMe.mp3";
    }
    bool getUGV(char const* key) = win 0x1834e0, imac 0x383c10, m1 0x30b8dc;
    void getUnlockForAchievement(gd::string key, int& id, UnlockType& type) = win 0x17c9e0, imac 0x3782b0;
    bool groundHasSecondaryColor(int index) = win inline, imac 0x383330, m1 0x30afa0, ios inline {
        return index == 8 || index == 9 || index == 10 || index == 11;
    }
    void iconAndTypeForKey(int key, int& id, int& type) = win inline, imac 0x3819a0, m1 0x3095b0, ios inline {
        for (int i = 0; i < 8; i++) {
            if (key < m_keyStartForIcon[i + 1]) {
                id = key - m_keyStartForIcon[i] + 1;
                type = i;
                return;
            }
        }
    }
    gd::string iconKey(int id, IconType type) = win 0x17c310, imac 0x3775b0, m1 0x300b8c;
    UnlockType iconTypeToUnlockType(IconType type) = win 0x17c620, m1 0x301010;
    bool isColorUnlocked(int id, UnlockType type) = win 0x17c920, m1 0x301414;
    bool isIconLoaded(int id, int type) = win inline, imac 0x380b60, m1 0x3088c4 {
        return m_iconLoadCounts[this->keyForIcon(id, type)] > 0;
    }
    bool isIconUnlocked(int id, IconType type) = win 0x17c540, imac 0x377a90;
    void itemPurchased(char const* key) = win inline, m1 0x30765c, ios inline {}
    void joinDiscord() = win inline, m1 0x308490 {
        if (GameToolbox::doWeHaveInternet()) {
            cocos2d::CCApplication::sharedApplication()->openURL("https://discord.com/invite/geometrydash");
            m_clickedDiscord = true;
            __timeb64 current;
            _ftime64_s(&current);
            m_socialsDuration = ((current.time & 0xfffff) * 1000 + current.millitm) / 1000.0;
        }
    }
    void joinReddit() = win inline, m1 0x308510 {
        if (GameToolbox::doWeHaveInternet()) {
            cocos2d::CCApplication::sharedApplication()->openURL("https://www.reddit.com/r/geometrydash/");
            m_clickedReddit = true;
            __timeb64 current;
            _ftime64_s(&current);
            m_socialsDuration = ((current.time & 0xfffff) * 1000 + current.millitm) / 1000.0;
        }
    }
    int keyForIcon(int id, int type) = win inline, imac 0x380c40, m1 0x308998, ios inline {
        return m_keyStartForIcon[type] + id - 1;
    }
    bool levelIsPremium(int unk1, int unk2) = win inline, m1 0x307660, ios inline { return false; }
    void likeFacebook() = win inline, m1 0x308290 {
        if (GameToolbox::doWeHaveInternet()) {
            cocos2d::CCApplication::sharedApplication()->openURL("https://www.facebook.com/geometrydash");
            m_clickedFacebook = true;
            __timeb64 current;
            _ftime64_s(&current);
            m_socialsDuration = ((current.time & 0xfffff) * 1000 + current.millitm) / 1000.0;
        }
    }
    void loadBackground(int index) = win 0x1828e0, imac 0x382e60, m1 0x30aa8c;
    void loadBackgroundAsync(int index) = win inline {
        index = std::clamp(index, 0, 59);
        if (m_loadingBG || m_loadedBgID == index) return;
        m_loadingBG = true;
        cocos2d::CCTextureCache::sharedTextureCache()->addImageAsync(
            cocos2d::CCString::createWithFormat("game_bg_%02d_001.png", index)->getCString(),
            this,
            callfuncO_selector(GameManager::finishedLoadingBGAsync),
            index,
            cocos2d::kCCTexture2DPixelFormat_RGBA8888
        );
    }
    void loadDeathEffect(int id) = win inline, imac 0x382cd0, m1 0x30a90c {
        if (id < 1) id = 1;
        if (id > 19) id = 20;
        if (id != m_loadedDeathEffect) {
            if (1 < m_loadedDeathEffect) {
                cocos2d::CCTextureCache::sharedTextureCache()->removeTextureForKey(
                    cocos2d::CCString::createWithFormat("PlayerExplosion_%02d.png", m_loadedDeathEffect-1)->getCString()
                );
            }
            if (1 < id) {
                cocos2d::CCTextureCache::sharedTextureCache()->addImage(
                    cocos2d::CCString::createWithFormat("PlayerExplosion_%02d.png", id-1)->getCString(),
                    false
                );
                cocos2d::CCSpriteFrameCache::sharedSpriteFrameCache()->addSpriteFramesWithFile(
                    cocos2d::CCString::createWithFormat("PlayerExplosion_%02d.plist", id-1)->getCString()
                );
            }
            m_loadedDeathEffect = id;
        }
    }
    void loadDpadFromString(UIButtonConfig& config, gd::string str) = win 0x1867c0, imac 0x388140, m1 0x30f350;
    void loadDPadLayout(int index, bool dual) = win 0x186220, imac 0x387d00;
    void loadFont(int index) = win 0x182830, imac 0x382b80, m1 0x30a788;
    void loadGround(int index) = win 0x182c90, imac 0x383340, m1 0x30afb0;
    void loadGroundAsync(int index) = win inline, imac 0x383460 {
        index = std::clamp(index, 0, 22);
        if (m_loadingG || m_loadedGroundID == index) return;
        m_loadingG = true;
        auto hasSecondary = this->groundHasSecondaryColor(index);
        m_finishedLoadingG1 = false;
        m_finishedLoadingG2 = !hasSecondary;
        cocos2d::CCTextureCache::sharedTextureCache()->addImageAsync(
            cocos2d::CCString::createWithFormat("groundSquare_%02d_001.png", index)->getCString(),
            this,
            callfuncO_selector(GameManager::finishedLoadingGAsync1),
            index,
            cocos2d::kCCTexture2DPixelFormat_RGBA8888
        );
        if (!hasSecondary) return;
        cocos2d::CCTextureCache::sharedTextureCache()->addImageAsync(
            cocos2d::CCString::createWithFormat("groundSquare_%02d_2_001.png", index)->getCString(),
            this,
            callfuncO_selector(GameManager::finishedLoadingGAsync2),
            index,
            cocos2d::kCCTexture2DPixelFormat_RGBA8888
        );
    }
    cocos2d::CCTexture2D* loadIcon(int id, int type, int requestID) = win 0x181d50, imac 0x381a10, m1 0x309668;
    void loadIconAsync(int id, int type, int requestID, cocos2d::CCObject* delegate) = imac 0x380c60, m1 0x3089ac;
    void loadMiddleground(int index) = win 0x182a40, m1 0x30ac78;
    void loadMiddlegroundAsync(int index) = win inline, imac 0x383130 {
        index = std::clamp(index, 0, 3);
        if (m_loadingG1 || m_loadedMG == index) return;
        m_loadingG1 = true;
        m_finishedLoadingMG1 = false;
        m_finishedLoadingMG2 = false;
        cocos2d::CCTextureCache::sharedTextureCache()->addImageAsync(
            cocos2d::CCString::createWithFormat("fg_%02d_001.png", index)->getCString(),
            this,
            callfuncO_selector(GameManager::finishedLoadingMGAsync1),
            index,
            cocos2d::kCCTexture2DPixelFormat_RGBA8888
        );
        cocos2d::CCTextureCache::sharedTextureCache()->addImageAsync(
            cocos2d::CCString::createWithFormat("fg_%02d_2_001.png", index)->getCString(),
            this,
            callfuncO_selector(GameManager::finishedLoadingMGAsync2),
            index,
            cocos2d::kCCTexture2DPixelFormat_RGBA8888
        );
    }
    void loadVideoSettings() = win inline, imac 0x388b90, m1 0x30fc9c {
        auto application = cocos2d::CCApplication::sharedApplication();
        application->toggleVerticalSync(this->getGameVariable("0030"));
        application->setForceTimer(this->getGameVariable("0032"));
        application->setSmoothFix(this->getGameVariable("0023"));
    }
    void lockColor(int id, UnlockType type) = win inline, imac 0x378250, m1 0x301594 {
        m_valueKeeper->removeObjectForKey(this->colorKey(id, type));
    }
    void lockIcon(int id, IconType type) = win inline, m1 0x301170 {
        m_valueKeeper->removeObjectForKey(this->iconKey(id, type));
    }
    void logLoadedIconInfo() = imac 0x382a90, m1 0x123e8c;
    void openEditorGuide() = win inline, m1 0x308590 {
        m_showedEditorGuide = true;
        cocos2d::CCApplication::sharedApplication()->openURL("https://www.boomlings.com/GDEditor");
    }
    void playMenuMusic() = win 0x17b870, imac 0x376b60, m1 0x300228;
    int playSFXTrigger(SFXTriggerGameObject* object) = win 0x17bd00, imac 0x377050;
    void prepareDPadSettings() = win 0x186a30, imac 0x388440;
    void printGJLog() = win inline, m1 0x29da34 {}
    void queueReloadMenu() = win inline, imac 0x38be50, m1 0x312cd0 {
        m_pActionManager->addAction(cocos2d::CCSequence::create(
            cocos2d::CCDelayTime::create(.1f),
            cocos2d::CCCallFunc::create(this, callfunc_selector(GameManager::reloadMenu)),
            nullptr
        ), this, false);
    }
    void rateGame() = win inline, m1 0x30825c {
        if (GameToolbox::doWeHaveInternet()) {
            GameToolbox::openAppPage();
            m_ratedGame = true;
            m_hasRatedGame = true;
        }
    }
    void recountUserStats(gd::string str) = imac 0x385190;
    void reloadAll(bool switchingModes, bool toFullscreen, bool unused) {
        return this->reloadAll(switchingModes, toFullscreen, false, false, unused);
    }
    void reloadAll(bool switchingModes, bool toFullscreen, bool borderless, bool fix, bool unused) = win 0x18a450, imac 0x38bf80, m1 0x312e18;
    void reloadAllStep2() = win 0x18a500;
    void reloadAllStep3() = win 0x18a660;
    void reloadAllStep4() = win 0x18a770, m1 0x313030;
    void reloadAllStep5() = win 0x18a810, imac 0x38c220, m1 0x31309c;
    void reloadMenu() = win 0x18a420, m1 0x312d44;
    void removeCustomObject(int key) = win inline, imac 0x384890, m1 0x30c578 {
        m_customObjectDict->removeObjectForKey(cocos2d::CCString::createWithFormat("%i", key)->getCString());
    }
    void removeIconDelegate(int requestID) = win inline, imac 0x3826f0, m1 0x30a31c {
        for (auto it = m_iconDelegates.begin(); it != m_iconDelegates.end(); it++) {
            auto& delegates = it->second;
            for (int i = 0; i < delegates.size();) {
                if (static_cast<SimplePlayer*>(delegates[i])->m_iconRequestID == requestID) {
                    delegates.erase(delegates.begin() + i);
                }
                else i++;
            }
        }
    }
    int reorderKey(int index, bool up) = win 0x183b00, m1 0x1b5a60;
    void reportAchievementWithID(char const* key, int percent, bool dontNotify) = win 0x17e030, m1 0x302d78;
    void reportPercentageForLevel(int levelID, int percentage, bool isPlatformer) = win 0x17d650, imac 0x378f40, m1 0x3023f0;
    void resetAchievement(gd::string key) = win 0x17d3f0, m1 0x302250;
    void resetAdTimer() = win inline, imac 0x37fbc0, m1 0x307b5c, ios inline {
        m_adTimer = 0.0;
    }
    void resetAllIcons() = win 0x183ee0;
    void resetCoinUnlocks() = win 0x180bb0, imac 0x37e100, m1 0x30605c;
    void resetDPadSettings(bool dual) = win inline, imac 0x388830, m1 0x1c2610 {
        if (dual) {
            m_dpad2.reset();
            m_dpad3.reset();
            m_dpad4.resetOneBtn();
            m_dpad5.resetOneBtn();
        }
        else m_dpad1.reset();
    }
    cocos2d::CCSize resolutionForKey(int key) = win 0x18a850, imac 0x38c260, m1 0x3130f0;
    void resumeAudio() = win inline, m1 0x307d8c, ios inline {
        auto engine = FMODAudioEngine::sharedEngine();
        engine->resumeAudio();
        engine->resumeAllAudio();
        AppDelegate::get()->resumeSound();
        engine->m_system->update();
    }
    void resumeAudioDelayed() = win inline, imac 0x37fdb0, m1 0x307d08, ios inline {
        auto action = cocos2d::CCSequence::create(
            cocos2d::CCDelayTime::create(.05f),
            cocos2d::CCCallFunc::create(this, callfunc_selector(GameManager::resumeAudio)),
            nullptr
        );
        action->setTag(11);
        m_pActionManager->addAction(action, this, false);
    }
    void returnToLastScene(GJGameLevel* level) = win 0x189ff0, imac 0x38ba80;
    void rewardedVideoAdFinished(int unused) = m1 0x307e24;
    void rewardedVideoHidden();
    void rewardedVideoHiddenDelayed() = imac 0x37ff60, m1 0x307ee4;
    // partially inlined on windows
    bool safePopScene() = win 0x18a3a0;
    void saveAdTimer() = m1 0xa8668;
    void saveDPadLayout(int index, bool dual) = win 0x185e60, m1 0x30ddfc;
    void setGameVariable(char const* key, bool value) = win 0x182ef0, imac 0x383770, m1 0x30b3e4;
    void setHasRatingPower(int hasRP) {
        m_hasRP = hasRP;
    }
    void setIntGameVariable(char const* key, int value) = win 0x183650, imac 0x383d60, m1 0x30ba80;
    void setPlayerBall(int id) {
        m_playerBall = id;
    }
    void setPlayerBird(int id) {
        m_playerBird = id;
    }
    void setPlayerColor(int id) {
        m_playerColor = id;
    }
    void setPlayerColor2(int id) {
        m_playerColor2 = id;
    }
    void setPlayerColor3(int id) {
        m_playerGlowColor = id;
    }
    void setPlayerDart(int id) {
        m_playerDart = id;
    }
    void setPlayerDeathEffect(int id) {
        m_playerDeathEffect = id;
    }
    void setPlayerFrame(int id) {
        m_playerFrame = id;
    }
    void setPlayerGlow(bool v) {
        m_playerGlow = v;
    }
    void setPlayerJetpack(int id) {
        m_playerJetpack = id;
    }
    void setPlayerRobot(int id) {
        m_playerRobot = id;
    }
    void setPlayerShip(int id) {
        m_playerShip = id;
    }
    void setPlayerShipStreak(int id) {
        m_playerShipFire = id;
    }
    void setPlayerSpider(int id) {
        m_playerSpider = id;
    }
    void setPlayerStreak(int id) {
        m_playerStreak = id;
    }
    void setPlayerSwing(int id) {
        m_playerSwing = id;
    }
    void setPlayerUserID(int id) {
        m_playerUserID = id;
    }
    void setUGV(char const* key, bool value) = win 0x183380, m1 0x30b738;
    void setupGameAnimations() = win 0x1ab830, imac 0x25f180, m1 0x20316c;
    gd::string sheetNameForIcon(int id, int type) = win 0x1824d0, imac 0x380f30, m1 0x308c74;
    void shortenAdTimer(float time) = win inline, imac 0x37fbe0, m1 0x307b64, ios inline {
        m_adTimer -= time;
    }
    bool shouldShowInterstitial(int unk1, int unk2, int unk3) = win inline, imac 0x37fc60, m1 0x307bd4, ios inline { return false; }
    bool showInterstitial() = win inline, imac 0x37fc70, m1 0x307bdc, ios inline { return true; }
    bool showInterstitialForced() = win inline, m1 0x307c88, ios inline { return false; }
    bool showMainMenuAd() = win inline, imac 0x37fbb0, m1 0x307b54, ios inline { return false; }
    void startUpdate() = win inline, m1 0x2fff04 {
        cocos2d::CCDirector::sharedDirector()->getScheduler()->scheduleSelector(
            schedule_selector(GameManager::update), this, 0.f, kCCRepeatForever, 0.f, false);
    }
    gd::string stringForCustomObject(int customObjectID) = win 0x1839b0, m1 0x30c094;
    void subYouTube() = win inline, m1 0x308390 {
        if (GameToolbox::doWeHaveInternet()) {
            cocos2d::CCApplication::sharedApplication()->openURL("https://www.youtube.com/user/RobTopGames");
            m_clickedYouTube = true;
            __timeb64 current;
            _ftime64_s(&current);
            m_socialsDuration = ((current.time & 0xfffff) * 1000 + current.millitm) / 1000.0;
        }
    }
    void switchCustomObjects(int key1, int key2) = win 0x183c00, imac 0x384520, m1 0x30c268;
    void switchScreenMode(bool fullscreen, bool borderless, bool fix, bool unused) = win inline, imac 0x38bee0, m1 0x312d74, ios inline {
        this->reloadAll(true, fullscreen, borderless, fix, unused);
    }
    void syncPlatformAchievements() = win inline {}
    bool toggleGameVariable(char const* key) = win 0x1832d0, imac 0x3839e0, m1 0x30b654;
    void tryCacheAd() = m1 0x307be4;
    void tryShowInterstitial(int unk1, int unk2, int unk3) = win inline, imac 0x37fc50, m1 0x307bd0, ios inline {}
    void unloadBackground() = win inline {
        if (m_loadedBgID == 0) return;
        cocos2d::CCTextureCache::sharedTextureCache()->removeTextureForKey(
            cocos2d::CCString::createWithFormat("game_bg_%02d_001.png", m_loadedBgID)->getCString());
        m_loadedBgID = 0;
        auto fileUtils = cocos2d::CCFileUtils::sharedFileUtils();
        for (int i = 1; i < 60; i++) {
            fileUtils->removeFullPath(cocos2d::CCString::createWithFormat("game_bg_%02d_001.png", i)->getCString());
        }
    }
    void unloadIcon(int id, int type, int requestID) = win 0x1820b0, m1 0x309cbc;
    void unloadIcons(int requestID) = win 0x182370;
    void unlockColor(int id, UnlockType type) = win inline {
        m_valueKeeper->setObject(cocos2d::CCString::create("1"), this->colorKey(id, type));
    }
    void unlockedPremium() = win inline, m1 0x307658, ios inline {}
    void unlockIcon(int id, IconType type) = win inline {
        m_valueKeeper->setObject(cocos2d::CCString::create("1"), this->iconKey(id, type));
    }
    IconType unlockTypeToIconType(int type) = win 0x17c740, m1 0x3010a0;
    void updateCustomFPS() = win 0x18ac80, imac 0x38c530, m1 0x3133a4;
    void updateMusic() = win inline, m1 0x308218 {
        auto engine = FMODAudioEngine::sharedEngine();
        engine->setBackgroundMusicVolume(m_bgVolume);
        engine->setEffectsVolume(m_sfxVolume);
        engine->m_musicOffset = m_timeOffset;
    }
    void verifyAchievementUnlocks() = win inline, m1 0x302fbc {
        auto achievementManager = AchievementManager::sharedState();
        auto allAchievements = achievementManager->getAllAchievements();
        for (int i = 0; i < allAchievements->count(); i++) {
            auto achievement = static_cast<cocos2d::CCDictionary*>(allAchievements->objectAtIndex(i));
            auto key = static_cast<cocos2d::CCString*>(achievement->objectForKey("identifier"))->getCString();
            if (achievementManager->isAchievementEarned(key)) this->completedAchievement(key);
        }
    }
    void verifyCoinUnlocks() = win 0x17e5e0, imac 0x379e00, m1 0x3031c8;
    void verifyStarUnlocks() = win inline, imac 0x379da0, m1 0x303168 {
        auto glm = GameLevelManager::sharedState();
        auto gsm = GameStatsManager::sharedState();
        for (int i = 1; i < 23; i++) {
            auto level = glm->getMainLevel(i, false);
            if (gsm->hasCompletedLevel(level)) gsm->completedStarLevel(level);
        }
    }
    void verifySyncedCoins() = win inline, imac 0x37f2c0, m1 0x3072e0, ios inline {
        auto coins = 0;
        auto glm = GameLevelManager::sharedState();
        auto gsm = GameStatsManager::sharedState();
        for (int i = 1; i < 23; i++) {
            auto level = glm->getMainLevel(i, false);
            if (gsm->hasCompletedLevel(level)) {
                if (gsm->hasSecretCoin(level->getCoinKey(1))) coins++;
                if (gsm->hasSecretCoin(level->getCoinKey(2))) coins++;
                if (gsm->hasSecretCoin(level->getCoinKey(3))) coins++;
            }
        }
        for (int i = 5001; i < 5005; i++) {
            auto level = glm->getMainLevel(i, false);
            if (gsm->hasCompletedLevel(level)) {
                if (gsm->hasSecretCoin(level->getCoinKey(1))) coins++;
                if (gsm->hasSecretCoin(level->getCoinKey(2))) coins++;
                if (gsm->hasSecretCoin(level->getCoinKey(3))) coins++;
            }
        }
        if (gsm->hasSecretCoin("secret04")) coins++;
        if (gsm->hasSecretCoin("secret06")) coins++;
        if (gsm->hasSecretCoin("secretB03")) coins++;
        gsm->setStatIfHigher("8", coins);
    }
    void videoAdHidden() = win inline, ios inline {
        if (m_musicPaused) FMODAudioEngine::sharedEngine()->resumeAllMusic();
        m_musicPaused = false;
    }
    void videoAdShowed() = win inline, m1 0x307c90, ios inline {
        auto engine = FMODAudioEngine::sharedEngine();
        if (engine->isMusicPlaying(0)) {
            engine->pauseAllMusic(true);
            m_musicPaused = true;
        }
        else m_musicPaused = false;
    }

    cocos2d::CCDictionary* m_mainFramesForAnimation;
    cocos2d::CCDictionary* m_detailFramesForAnimation;
    cocos2d::CCDictionary* m_frameTimeForAnimation;
    cocos2d::CCDictionary* m_framesForAnimation;
    cocos2d::CCDictionary* m_defaultFrames;
    bool m_switchModes;
    bool m_toFullscreen;
    bool m_reloading;
    bool m_fix;
    bool m_reloadTextures;
    bool m_unkBool2;
    bool m_vsyncEnabled;
    cocos2d::CCDictionary* m_valueKeeper;
    cocos2d::CCDictionary* m_unlockValueKeeper;
    cocos2d::CCDictionary* m_customObjectDict;
    double m_adTimer;
    double m_adCache;
    bool m_unkBool3;
    int m_unkSize4_1;
    double m_unkDouble2;
    int m_unkSize4_2;
    int m_unkSize4_3;
    bool m_loaded;
    bool m_googlePlaySignedIn;
    gd::string m_editorClipboard;
    int m_copiedObjectCount;
    PlayLayer* m_playLayer;
    LevelEditorLayer* m_levelEditorLayer;
    GJBaseGameLayer* m_gameLayer;
    LevelSelectLayer* m_levelSelectLayer;
    MenuLayer* m_menuLayer;
    bool m_inMenuLayer;
    void* m_premiumPopup;
    bool m_firstSetup;
    bool m_showedMenu;
    bool m_unknownBool4;
    bool m_unknownBool5;
    gd::string m_playerUDID;
    gd::string m_playerName;
    bool m_scoreUpdated; //playerScoreValid
    geode::SeedValueRSV m_playerUserID;
    float m_bgVolume;
    float m_sfxVolume;
    float m_timeOffset;
    bool m_ratedGame;
    bool m_clickedFacebook;
    bool m_clickedTwitter;
    bool m_clickedYouTube;
    bool m_clickedTwitch;
    bool m_clickedDiscord;
    bool m_clickedReddit;
    double m_socialsDuration;
    bool m_musicPaused; //didPauseBGMusic
    bool m_isParticleObject;
    bool m_editorEnabled;
    int m_sceneEnum;
    bool m_searchObjectBool;
    geode::SeedValueRSV m_playerFrame;
    geode::SeedValueRSV m_playerShip;
    geode::SeedValueRSV m_playerBall;
    geode::SeedValueRSV m_playerBird;
    geode::SeedValueRSV m_playerDart;
    geode::SeedValueRSV m_playerRobot;
    geode::SeedValueRSV m_playerSpider;
    geode::SeedValueRSV m_playerSwing;
    geode::SeedValueRSV m_playerColor;
    geode::SeedValueRSV m_playerColor2;
    geode::SeedValueRSV m_playerGlowColor;
    geode::SeedValueRSV m_playerStreak;
    geode::SeedValueRSV m_playerShipFire;
    geode::SeedValueRSV m_playerDeathEffect;
    geode::SeedValueRSV m_playerJetpack;
    geode::SeedValueRS m_chk;
    geode::SeedValueSR m_secretNumber;
    bool m_playerGlow;
    IconType m_playerIconType;
    bool m_everyPlaySetup;
    bool m_showSongMarkers;
    bool m_showBPMMarkers;
    bool m_recordGameplay;
    bool m_showProgressBar;
    bool m_performanceMode;
    bool m_addGlow;
    bool m_clickedGarage;
    bool m_clickedEditor;
    bool m_clickedName;
    bool m_clickedPractice;
    bool m_showedEditorGuide;
    bool m_showedRateDiffDialog;
    bool m_showedRateStarDialog;
    bool m_showedLowDetailDialog;
    GameRateDelegate* m_gameRateDelegate1;
    GameRateDelegate* m_gameRateDelegate2;
    cocos2d::ccColor3B m_copiedColor;
    int m_currentLevelID;
    int m_currentColorChannel;
    int m_currentGroupID;
    int m_loadedBgID;
    int m_loadedGroundID;
    int m_loadedMG;
    int m_loadedFont;
    int m_loadedDeathEffect;
    bool m_loadingBG;
    bool m_loadingG;
    bool m_loadingG1;
    bool m_finishedLoadingG1;
    bool m_finishedLoadingG2;
    bool m_finishedLoadingMG1;
    bool m_finishedLoadingMG2;
    int m_sessionAttempts;
    int m_sessionAttempts2;
    int m_sessionNormalAttempts;
    int m_bootups;
    bool m_hasRatedGame;
    bool m_unkBool6;
    bool m_shouldLoadUnlockValueKeeper;
    bool m_unkBool7;
    bool m_unkBool8;
    geode::SeedValueRSV m_hasRP;
    bool m_canGetLevelSaveData;
    int m_resolution;
    int m_texQuality;
    bool m_somethingInMenuLayer;
    DailyLevelPage* m_dailyLevelPage;
    bool m_ropeGarageEnter;
    int m_currentGauntlet;
    int m_unkSize4_13;
    bool m_unkBool10;
    int m_unkSize4_14;
    bool m_disableThumbstick;
    float m_customFPSTarget;
    bool m_loadingLevel;
    int m_customMenuSongID;
    int m_customPracticeSongID;
    gd::map<int, int> m_iconLoadCounts;
    gd::map<int, gd::map<int, int>> m_iconRequests;
    gd::map<int, bool> m_isIconBeingLoaded;
    gd::vector<int> m_keyStartForIcon;
    gd::map<int, gd::vector<cocos2d::CCObject*>> m_iconDelegates;
    int m_iconRequestID;
    cocos2d::CCArray* m_gjLog;
    RewardedVideoDelegate* m_rewardedVideoDelegate;
    SearchType m_localSearchType;
    SearchType m_savedSearchType;
    int m_levelSearchType;
    UIButtonConfig m_dpad1;
    UIButtonConfig m_dpad2;
    UIButtonConfig m_dpad3;
    UIButtonConfig m_dpad4;
    UIButtonConfig m_dpad5;
    gd::string m_dpadLayout1;
    gd::string m_dpadLayout2;
    gd::string m_dpadLayout3;
    gd::string m_dpadLayoutDual1;
    gd::string m_dpadLayoutDual2;
    gd::string m_dpadLayoutDual3;
    int m_leaderboardLevelID;
    int m_leaderboardLevelTime;
    int m_leaderboardLevelPoints;
    bool m_shouldResetShader;
    cocos2d::CCPoint m_practicePos;
    float m_practiceOpacity;
}

[[link(android)]]
class GameObject : CCSpritePlus {
    GameObject() = win 0x137820, m1 0x1a1fc8;
    ~GameObject() = win 0x18b6f0, m1 0x4e5a5c;

    static GameObject* createWithFrame(char const* name) = win 0x18dc60, imac 0x5a1a20, m1 0x4e5ffc;
    static GameObject* createWithKey(int key) = win 0x18b810, imac 0x59cec0, m1 0x4e5b34;
    static bool isBasicEnterEffect(int id) = win inline, imac 0x5cb790, m1 0x4fa5e4 {
        return (id > 21 && id < 29) || (id > 54 || id < 60) || id == 1915;
    }
    static GameObject* objectFromVector(gd::vector<gd::string>& propValues, gd::vector<void*>& propIsPresent, GJBaseGameLayer* gameLayer, bool lowDetail) = win 0x19d220, imac 0x5bf740, m1 0x4f0af0;
    static void resetMID() = win inline, imac 0x59cd90, m1 0x4e5a4c {
        *reinterpret_cast<int*>(geode::base::get() + 0x69c158) = 10;
    }

    virtual void update(float dt) = win inline, imac 0x5a9e80, m1 0x4e8140 {}
    virtual void setScaleX(float scaleX) = win 0x198290, m1 0x4ed0cc, imac 0x5bbc50;
    virtual void setScaleY(float scaleY) = win 0x198370, m1 0x4ed164, imac 0x5bbce0;
    virtual void setScale(float scale) = win 0x198460, m1 0x4ed1fc, imac 0x5bbd70;
    virtual void setPosition(cocos2d::CCPoint const& position) = win 0x197ba0, m1 0x4ecb2c, imac 0x5bb710;
    virtual void setVisible(bool visible) = win 0x198c90, m1 0x4ed834, imac 0x5bc460;
    virtual void setRotation(float rotation) = win 0x197e40, imac 0x5bb980, m1 0x4ecdb0;
    virtual void setRotationX(float rotationX) = win 0x197f90, m1 0x4ece98, imac 0x5bba50;
    virtual void setRotationY(float rotationY) = win 0x1980e0, m1 0x4ecf74, imac 0x5bbb10;
    virtual void setOpacity(unsigned char opacity) = win 0x198840, m1 0x4ed518, imac 0x5bc0c0;
    virtual bool initWithTexture(cocos2d::CCTexture2D* texture) = win 0x18dcf0, m1 0x4e6240, imac 0x5a1c50;
    virtual void setChildColor(cocos2d::ccColor3B const& color) = win 0x1a0e00, m1 0x4f8010, imac 0x5c8ad0;
    virtual void setFlipX(bool flipX) = win 0x198200, m1 0x4ed034, imac 0x5bbbd0;
    virtual void setFlipY(bool flipY) = win 0x198240, m1 0x4ed080, imac 0x5bbc10;
    virtual void firstSetup() {}
    virtual void customSetup() = win 0x190e60, imac 0x5a9e90, m1 0x4e8144;
    virtual void setupCustomSprites(gd::string frameName) = win 0x1aef40, m1 0x3b5628, imac 0x443f10;
    virtual void addMainSpriteToParent(bool reorder) = win 0x19bd90, m1 0x4eed84, imac 0x5bd870;
    virtual void resetObject() = win 0x190710, imac 0x5a9350, m1 0x4e7754;
    virtual void triggerObject(GJBaseGameLayer* layer, int uniqueID, gd::vector<int> const* remapKeys) {}
    virtual void activateObject() = win 0x190b20, m1 0x4e7c18, imac 0x5a9980;
    virtual void deactivateObject(bool deactivate) = win 0x190bd0, imac 0x5a9ce0, m1 0x4e7f8c;
    virtual void transferObjectRect(cocos2d::CCRect& rect) = win 0x197690, m1 0x4ec4fc, imac 0x5bb030;
    virtual cocos2d::CCRect const& getObjectRect() = win 0x1976e0, imac 0x5bb0a0, m1 0x4ec57c;
    virtual cocos2d::CCRect getObjectRect(float width, float height) = win 0x197700, imac 0x5bb0d0, m1 0x4ec590;
    virtual cocos2d::CCRect const& getObjectRect2(float width, float height) = win 0x197890, m1 0x4ec778, imac 0x5bb300;
    virtual cocos2d::CCRect const& getObjectTextureRect() = win 0x197930, imac 0x5bb3d0, m1 0x4ec84c;
    virtual cocos2d::CCPoint getRealPosition() = win 0x197b60, imac 0x5bb650, m1 0x4eca9c;
    virtual void setStartPos(cocos2d::CCPoint position) = win 0x190590, m1 0x4e7644, imac 0x5a9240;
    virtual void updateStartValues() = win 0x190960, m1 0x4e7aa8, imac 0x5a97b0;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) {}
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x19ed10, m1 0x4f2344, imac 0x5c15f0;
    virtual void claimParticle() = win 0x198db0, imac 0x5bc5c0, m1 0x4ed980;
    virtual void unclaimParticle() = win 0x1992e0, m1 0x4edf58, imac 0x5bcbd0;
    virtual void particleWasActivated() = win inline, imac 0x5bcc40, m1 0x4edfc8 {}
    virtual bool isFlipX() = win 0x1981e0, m1 0x4ed024, imac 0x5bbbb0;
    virtual bool isFlipY() = win 0x1981f0, m1 0x4ed02c, imac 0x5bbbc0;
    virtual void setRScaleX(float scaleX) = win 0x198550, imac 0x5bbe00, m1 0x4ed294;
    virtual void setRScaleY(float scaleY) = win 0x198590, imac 0x5bbe40, m1 0x4ed2c8;
    virtual void setRScale(float scale) = win 0x1985d0, imac 0x5bbe80, m1 0x4ed2fc;
    virtual float getRScaleX() = win 0x198610, imac 0x5bbf00, m1 0x4ed380;
    virtual float getRScaleY() = win 0x198650, imac 0x5bbf30, m1 0x4ed3b8;
    virtual void setRRotation(float rotation) = win 0x197db0, m1 0x4ecd20, imac 0x5bb900;
    virtual void triggerActivated(float xPosition) {}
    virtual void setObjectColor(cocos2d::ccColor3B const& color) = win 0x1a0ac0, imac 0x5c87f0, m1 0x4f7ccc;
    virtual void setGlowColor(cocos2d::ccColor3B const& color) = win 0x1a0db0, m1 0x4f7fbc, imac 0x5c8a80;
    virtual void restoreObject() = win 0x1993d0, imac 0x5bcc80, m1 0x4edfe8;
    virtual void animationTriggered() {}
    virtual void selectObject(cocos2d::ccColor3B color) = win 0x1a0e80, imac 0x5c8b40, m1 0x4f8094;
    virtual void activatedByPlayer(PlayerObject* player) {}
    virtual bool hasBeenActivatedByPlayer(PlayerObject* player) { return false; }
    virtual bool hasBeenActivated() { return false; }
    virtual OBB2D* getOrientedBox() = win 0x1a1550, m1 0x4f8898, imac 0x5c9570;
    virtual void updateOrientedBox() = win 0x1a15b0, m1 0x4f8930, imac 0x5c95f0;
    virtual float getObjectRotation() = win 0x1a1530, imac 0x5d1ef0, m1 0x4fe524;
    virtual void updateMainColor(cocos2d::ccColor3B const& color) = win 0x1a1fb0, imac 0x5ca170, m1 0x4f9348;
    virtual void updateSecondaryColor(cocos2d::ccColor3B const& color) = win 0x1a1fc0, m1 0x4f984c, imac 0x5ca660;
    virtual int addToGroup(int id) = win 0x19c7d0, m1 0x4ef46c, imac 0x5bdf50;
    virtual void removeFromGroup(int id) = win 0x19c8f0, m1 0x4ef53c, imac 0x5be000;
    virtual void saveActiveColors() = win 0x1a0910, imac 0x5c8630, m1 0x4f7b08;
    virtual float spawnXPosition() = win 0x137c60, imac 0x1f3690, m1 0x1a19f0;
    virtual bool canAllowMultiActivate() { return false; }
    virtual void blendModeChanged() {}
    virtual void updateParticleColor(cocos2d::ccColor3B const& color) = win 0x1a0ca0, m1 0x4f7ef4, imac 0x5c89c0;
    virtual void updateParticleOpacity(unsigned char opacity) = win 0x198ae0, m1 0x4ed7ac, imac 0x5bc3d0;
    virtual void updateMainParticleOpacity(unsigned char opacity) {}
    virtual void updateSecondaryParticleOpacity(unsigned char opacity) {}
    virtual bool canReverse() { return false; }
    virtual bool isSpecialSpawnObject() { return false; }
    virtual bool canBeOrdered() { return false; }
    virtual cocos2d::CCLabelBMFont* getObjectLabel() = m1 0x8b574, imac 0x6b30 { return nullptr; }
    virtual void setObjectLabel(cocos2d::CCLabelBMFont* label) {}
    virtual bool shouldDrawEditorHitbox() = win inline, m1 0x4fa620, imac 0x5cb7c0 { return true; }
    virtual bool getHasSyncedAnimation() { return false; }
    virtual bool getHasRotateAction() { return false; }
    virtual bool canMultiActivate(bool multiActivate) { return false; }
    virtual void updateTextKerning(int kerning) {}
    virtual int getTextKerning() { return false; }
    virtual bool getObjectRectDirty() const = win 0x137c80, imac 0x1f36b0, m1 0x1a1a10;
    virtual void setObjectRectDirty(bool dirty) = win 0x137c90, imac 0x1f36c0, m1 0x1a1a18;
    virtual bool getOrientedRectDirty() const = win 0x137ca0, imac 0x1f36d0, m1 0x1a1a20;
    virtual void setOrientedRectDirty(bool dirty) = win 0x137cb0, imac 0x1f36e0, m1 0x1a1a28;
    virtual GameObjectType getType() const = win 0x137cc0, imac 0x1f36f0, m1 0x1a1a30;
    virtual void setType(GameObjectType type) = win 0x137cd0, imac 0x1f3700, m1 0x1a1a38;
    virtual cocos2d::CCPoint getStartPos() const = win 0x137ce0, imac 0x1f3710, m1 0x1a1a40;

    void addColorSprite(gd::string frame) = win 0x18e7f0, imac 0x5a43f0, m1 0x4e6b94;
    void addColorSpriteToParent(bool reorder) = win 0x19c000;
    void addColorSpriteToSelf() = win 0x19c200, imac 0x5bd9e0, m1 0x4eef10;
    cocos2d::CCSprite* addCustomBlackChild(gd::string frame, float opacity, bool color) = win inline, imac 0x5baa70, m1 0x4ebedc, ios inline {
        if (color) {
            return this->addCustomColorChild(frame);
        }
        else {
            auto ret = this->addCustomChild(frame, { 0.f, 0.f }, -2);
            ret->setColor({ 0, 0, 0 });
            m_blackChildOpacity = opacity;
            ret->setOpacity(opacity * 255);
            m_blackChildOpacityLocked = true;
            return ret;
        }
    }
    cocos2d::CCSprite* addCustomChild(gd::string frame, cocos2d::CCPoint offset, int zOrder) = win 0x1972f0, imac 0x124480, m1 0x4ec0c4;
    cocos2d::CCSprite* addCustomColorChild(gd::string frame) = win 0x1973b0, imac 0x5bacb0, m1 0x4ec16c;
    void addEmptyGlow() = win 0x18e6a0, imac 0x5a4280, m1 0x4e6a3c;
    void addGlow(gd::string frame) = win 0x18df20;
    cocos2d::CCSprite* addInternalChild(cocos2d::CCSprite* parent, gd::string frame, cocos2d::CCPoint offset, int zOrder) = win inline, imac 0x5bae50, m1 0x4ec308, ios inline {
        auto spr = cocos2d::CCSprite::createWithSpriteFrameName(frame.c_str());
        spr->setPosition(parent->convertToNodeSpace({0.f, 0.f}) + offset);
        parent->addChild(spr, zOrder);
        return spr;
    }
    cocos2d::CCSprite* addInternalCustomColorChild(gd::string frame, cocos2d::CCPoint offset, int zOrder) = win 0x1974f0, imac 0x5bada0, m1 0x4ec244;
    cocos2d::CCSprite* addInternalGlowChild(gd::string frame, cocos2d::CCPoint offset) = win 0x1975c0, imac 0x5baee0, m1 0x4ec3ac;
    void addNewSlope01(bool dontDraw) = win inline, m1 0x4fa044 {
        if (dontDraw) this->setDontDraw(true);
        auto sprite = this->addCustomChild("blockOutline_14new_001.png", { 0.f, 0.f }, 2);
        sprite->setRotation(-45.f);
    }
    void addNewSlope01Glow(bool dontDraw) = win inline, m1 0x4fa14c {
        if (!m_glowSprite) return;
        if (dontDraw) m_glowSprite->setDontDraw(true);
        auto sprite = cocos2d::CCSprite::createWithSpriteFrameName(this->getGlowFrame("blockOutline_14new_001.png").c_str());
        sprite->setRotation(-45.f);
        m_glowSprite->addChild(sprite);
        sprite->setPosition(m_glowSprite->convertToNodeSpace({ 0.f, 0.f }));
    }
    void addNewSlope02(bool dontDraw) = win inline, m1 0x4fa290 {
        if (dontDraw) this->setDontDraw(true);
        auto sprite = this->addCustomChild("blockOutline_15new_001.png", { 0.f, 0.f }, 2);
        sprite->setRotation(-26.5f);
    }
    void addNewSlope02Glow(bool dontDraw) = win inline, m1 0x4fa398 {
        if (!m_glowSprite) return;
        if (dontDraw) m_glowSprite->setDontDraw(true);
        auto sprite = cocos2d::CCSprite::createWithSpriteFrameName(this->getGlowFrame("blockOutline_15new_001.png").c_str());
        sprite->setRotation(-26.5f);
        m_glowSprite->addChild(sprite);
        sprite->setPosition(m_glowSprite->convertToNodeSpace({ 0.f, 0.f }));
    }
    void addRotation(float rotation) = win 0x197d10, imac 0x5bb820, m1 0x4ecc28;
    void addRotation(float rotationX, float rotationY) = win inline, imac 0x5bb8a0, m1 0x4eccb4, ios inline {
        this->setRotationX(this->getRotationX() + rotationX);
        this->setRotationY(this->getRotationY() + rotationY);
    }
    void addToColorGroup(int group) = win 0x19ca10;
    void addToCustomScaleX(float scale) = win inline, imac 0x5bbf60, m1 0x4ed3f0 {
        m_isDirty = true;
        m_isObjectRectDirty = true;
        m_scaleXOffset += scale;
        m_scaleX += scale;
    }
    void addToCustomScaleY(float scale) = win inline, imac 0x5bbfa0, m1 0x4ed418 {
        m_isDirty = true;
        m_isObjectRectDirty = true;
        m_scaleYOffset += scale;
        m_scaleY += scale;
    }
    void addToOpacityGroup(int group) = win inline {
        if (m_opacityGroupCount < 10 && group > 0 && group < 10000) {
            this->createOpacityGroupContainer(10);
            if (m_opacityGroupCount > 0) {
                for (int i = 0; i < m_opacityGroupCount; i++) {
                    if ((*m_opacityGroups)[i] == group) return;
                }
            }
            (*m_opacityGroups)[m_opacityGroupCount] = group;
            m_opacityGroupCount++;
        }
    }
    void addToTempOffset(double offsetX, double offsetY) = win inline {
        if (!m_tempOffsetXRelated) m_positionX += offsetX;
        m_positionY += offsetY;
    }
    void assignUniqueID() = win inline, imac 0x5a1d40, m1 0x4e632c {
        auto uniqueID = reinterpret_cast<int*>(geode::base::get() + 0x69c158);
        m_uniqueID = *uniqueID;
        m_unknown5 = *uniqueID;
        (*uniqueID)++;
    }
    bool belongsToGroup(int group) = win inline {
        if (m_groupCount > 0) {
            for (int i = 0; i < m_groupCount; i++) {
                if ((*m_groups)[i] == group) return true;
            }
        }
        return false;
    }
    void calculateOrientedBox() = win inline, imac 0x5c95c0, m1 0x3e7c2c {
        m_shouldUseOuterOb = true;
        this->updateOrientedBox();
        this->getObjectRect();
    }
    bool canChangeCustomColor() = win inline, imac 0x5c9ab0, m1 0x4f8dc0 {
        return this->canChangeMainColor() || this->canChangeSecondaryColor();
    }
    bool canChangeMainColor() = win inline, imac 0x5c9ae0, m1 0x4f8df4 {
        return m_baseColor->m_defaultColorID != 0;
    }
    bool canChangeSecondaryColor() = win inline, m1 0x4f8e08 {
        return m_detailColor && m_detailColor->m_defaultColorID != 0;
    }
    bool canRotateFree() = win inline, imac 0x5bde90, m1 0x173e70 {
        auto type = m_objectType;
        return (
            type != GameObjectType::Solid
            && type != GameObjectType::Breakable
            && type != GameObjectType::Slope
        ) || m_isNoTouch;
    }
    const cocos2d::ccColor3B& colorForMode(int id, bool mainColor) = win 0x1a1fd0, imac 0x5ca280, m1 0x4f944c;
    void commonInteractiveSetup() = win 0x196dc0;
    void commonSetup() = win 0x18dd30, m1 0x4e60c8;
    void copyGroups(GameObject* object) = win 0x19c980;
    cocos2d::CCParticleSystemQuad* createAndAddParticle(int objectType, char const* plistName, int tag, cocos2d::tCCPositionType positionType) = win 0x198b60, imac 0x555a0;
    void createColorGroupContainer(int size) = win inline, ios inline {
        if (!m_colorGroups) {
            m_colorGroups = new std::array<short, 10>();
            for (int i = 0; i < size; i++) {
                (*m_colorGroups)[i] = 0;
            }
        }
    }
    void createGlow(gd::string frame) = win 0x18e710, imac 0x5a41e0, m1 0x4e69a8;
    void createGroupContainer(int size) = win 0x19c700, ios inline {
        if (!m_groups) {
            m_groups = new std::array<short, 10>();
            for (int i = 0; i < size; i++) {
                (*m_groups)[i] = 0;
            }
        }
    }
    void createOpacityGroupContainer(int size) = win inline, ios inline {
        if (!m_opacityGroups) {
            m_opacityGroups = new std::array<short, 10>();
            for (int i = 0; i < size; i++) {
                (*m_opacityGroups)[i] = 0;
            }
        }
    }
    void createSpriteColor(int type) = win inline, imac 0x5a1c80, m1 0x4e6274 {
        if (type == 2) {
            if (!m_detailColor) m_detailColor = new GJSpriteColor();
        }
        else {
            if (!m_baseColor) m_baseColor = new GJSpriteColor();
        }
    }
    void deselectObject() = win inline, imac 0x5c8f50, m1 0x4f8560 {
        m_isSelected = false;
        this->updateObjectEditorColor();
    }
    void destroyObject() = win inline, imac 0x5bcc50, m1 0x4edfcc {
        m_isDisabled = true;
        m_isDisabled2 = true;
        this->setOpacity(0);
    }
    void determineSlopeDirection() = win 0x19c300, imac 0x5bdae0, m1 0x4ef004;
    bool didScaleXChange() = win inline, imac 0x5bbfe0, m1 0x4ed440, ios inline {
        return (int)(m_scaleX * 10000) != (int)(m_customScaleX * 10000);
    }
    bool didScaleYChange() = win inline, imac 0x5bc010, m1 0x4ed470, ios inline {
        return (int)(m_scaleY * 10000) != (int)(m_customScaleY * 10000);
    }
    void dirtifyObjectPos() = win inline, imac 0x5bb020, m1 0x4ec4ec {
        m_isObjectPosDirty = true;
        m_isUnmodifiedPosDirty = true;
    }
    void dirtifyObjectRect() = win inline, imac 0x5bb010, m1 0x4ec4e0 {
        m_isObjectRectDirty = true;
        m_isOrientedBoxDirty = true;
    }
    void disableObject() = win inline, imac 0x5bcd10, m1 0x4ee034 {
        m_isDisabled = true;
        m_isDisabled2 = true;
        this->setOpacity(0);
        this->triggerActivated(0.f);
    }
    bool dontCountTowardsLimit() = win inline, imac 0x5b5650, ios inline {
        return m_objectID == 31;
    }
    void duplicateAttributes(GameObject* object) = win 0x1a1cc0, m1 0x4f9010;
    void duplicateColorMode(GameObject* object) = win 0x1a1be0, imac 0x5c9ce0;
    void duplicateValues(GameObject* object) = win 0x1a1e00, imac 0x5c9e70, m1 0x4f90b4;
    cocos2d::ccColor3B editorColorForCustomMode(int id) = win inline, m1 0x4f8428 {
        auto index = (id < 5 ? id : id - 5) % 12;
        switch (index) {
            case 0: return { 210, 255, 167 };
            case 1: return { 167, 255, 167 };
            case 2: return { 165, 255, 209 };
            case 3: return { 167, 255, 255 };
            case 4: return { 166, 209, 255 };
            case 5: return { 167, 167, 255 };
            case 6: return { 209, 166, 255 };
            case 7: return { 255, 167, 255 };
            case 8: return { 255, 166, 209 };
            case 9: return { 255, 167, 167 };
            case 10: return { 255, 209, 166 };
            case 11: return { 255, 255, 167 };
            default: return { 255, 255, 255 };
        }
    }
    cocos2d::ccColor3B editorColorForMode(int id) = win 0x1a1060, imac 0x5c8d20;
    void fastRotateObject(float rotation) = win inline, imac 0x5c9890, m1 0x4f8b80 {
        m_rotationXOffset += rotation;
        m_rotationYOffset += rotation;
        this->addRotation(rotation);
        if (m_objectType != GameObjectType::Decoration && !m_shouldUseOuterOb) {
            this->calculateOrientedBox();
        }
    }
    cocos2d::ccColor3B const& getActiveColorForMode(int id, bool mainColor) = win 0x1a2100;
    const char* getBallFrame(int index) = win inline, imac 0x5c8600, m1 0x4f7ad0 {
        return cocos2d::CCString::createWithFormat("rod_ball_%02d_001.png", std::clamp(index, 0, 3))->getCString();
    }
    cocos2d::CCRect getBoundingRect() = win inline, imac 0x5bafa0, m1 0x4ec47c, ios inline {
        return cocos2d::CCRectApplyAffineTransform({ 0.f, 0.f, m_width, m_height }, this->nodeToParentTransform());
    }
    cocos2d::CCPoint const& getBoxOffset() = win 0x1a1810, imac 0x5bb200, m1 0x4ec688;
    gd::string getColorFrame(gd::string frame);
    int getColorIndex() = win inline, imac 0x5cb070, m1 0x4f9e8c {
        switch (m_objectID) {
            case 29: return 1000;
            case 30: return 1001;
            case 105: return 1004;
            case 744: return 1003;
            case 899: return m_targetColor;
            case 900: return 1009;
            case 915: return 1002;
            default: return 0;
        }
    }
    gd::string getColorKey(bool isMainColor, bool colorGroups) = win 0x19cd70, m1 0x4f0168;
    ZLayer getCustomZLayer() = win inline, imac 0x5bdec0 {
        return m_zLayer;
    }
    gd::string getGlowFrame(gd::string frame) = win 0x1904d0;
    bool getGroupDisabled() = win inline, imac 0x5be3b0, m1 0x4ef8ec {
        return m_isGroupDisabled;
    }
    int getGroupID(int index) = win inline, imac 0x5be090, m1 0x4ef5d0 {
        if (index < 10 && m_groups) {
            return (*m_groups)[index];
        }
        return 0;
    }
    gd::string getGroupString() = win inline {
        fmt::memory_buffer buffer;
        auto first = true;
        for (int i = 0; i < 10; i++) {
            auto group = (*m_groups)[i];
            if (group > 0) {
                if (!first) fmt::format_to(std::back_inserter(buffer), ".");
                fmt::format_to(std::back_inserter(buffer), "{}", group);
                first = false;
            }
        }
        return fmt::to_string(buffer);
    }
    cocos2d::CCPoint const& getLastPosition() = win inline, imac 0x5caa90, m1 0x4f9c3c {
        return m_lastPosition;
    }
    GJSpriteColor* getMainColor() = win inline, imac 0x5c9a90, m1 0x4f8db0 {
        return m_baseColor;
    }
    int getMainColorMode() = win inline {
        if (auto color = this->getMainColor()) return color->getColorMode();
        return 0;
    }
    int getObjectDirection() = win 0x19c560, m1 0x4ef258;
    float getObjectRadius() = win inline, m1 0x4f9fa0 {
        return m_scaleX == 1.f && m_scaleY == 1.f ? m_objectRadius : m_objectRadius * std::max(m_scaleX, m_scaleY);
    }
    cocos2d::CCRect* getObjectRectPointer() = win inline {
        if (m_isObjectRectDirty) this->getObjectRect();
        return &m_objectRect;
    }
    ZLayer getObjectZLayer() = win inline, imac 0x5a9ab0, m1 0x4e7d50 {
        return m_zLayer != ZLayer::Default ? m_zLayer : m_defaultZLayer;
    }
    int getObjectZOrder() = win inline, imac 0x5bd9c0, m1 0x4eeef8 {
        return m_zOrder != 0 ? m_zOrder : m_defaultZOrder;
    }
    cocos2d::CCRect getOuterObjectRect() = win inline, ios inline {
        if (m_isOrientedBoxDirty) this->updateOrientedBox();
        return m_orientedBox->getBoundingRect();
    }
    int getParentMode() = win 0x19ab70, imac 0x5bcb60;
    GJSpriteColor* getRelativeSpriteColor(int type) = win 0x1a1af0;
    cocos2d::CCPoint getScalePosDelta() = win 0x19c5e0, m1 0x4ef2a4;
    GJSpriteColor* getSecondaryColor() = win inline, imac 0x5c9aa0, m1 0x4f8db8 {
        return m_detailColor;
    }
    int getSecondaryColorMode() = win inline {
        if (auto color = this->getSecondaryColor()) return color->getColorMode();
        return 0;
    }
    float getSlopeAngle() = win inline, imac 0x5bdd00, m1 0x4ef220 {
        cocos2d::CCRect rect = getObjectRect();
        return atanf(rect.size.height / rect.size.width);
    }
    cocos2d::CCPoint getUnmodifiedPosition() = win inline, imac 0x5bb5c0, m1 0x4eca3c {
        return { (float)(m_positionX - m_positionXOffset), (float)(m_positionY - m_positionYOffset) };
    }
    cocos2d::ccColor3B const& groupColor(cocos2d::ccColor3B const& color, bool mainColor) = win inline, imac 0x5ca9a0, m1 0x4f9b64 {
        m_groupColor = color;
        if (m_groupCount > 0) {
            for (int i = 0; i < m_groupCount; i++) {
                m_groupColor = m_goEffectManager->colorForGroupID((*m_groups)[i], color, mainColor);
            }
        }
        return m_groupColor;
    }
    float groupOpacityMod() = win 0x19ccf0, imac 0x5be9e0, m1 0x4effe0;
    void groupWasDisabled() = win inline, imac 0x5be3e0, m1 0x4ef910 {
        m_enabledGroupsCounter--;
        m_isGroupDisabled = m_enabledGroupsCounter < 1;
    }
    void groupWasEnabled() = win inline, imac 0x5be3c0, m1 0x4ef8f4 {
        m_enabledGroupsCounter++;
        m_isGroupDisabled = m_enabledGroupsCounter < 1;
    }
    bool hasSecondaryColor() = win inline, imac 0x5c9cc0 {
        return m_colorSprite;
    }
    bool ignoreEditorDuration() = win 0x1a3140, imac 0x5b5d10, m1 0x4eb6e0;
    bool ignoreEnter() = win inline, imac 0x5baf90, m1 0x4ec474 {
        return m_ignoreEnter;
    }
    bool ignoreFade() = win inline, imac 0x5baf80, m1 0x4ec46c {
        return m_ignoreFade;
    }
    bool init(char const* frame) = win inline {
        if (!CCSpritePlus::initWithSpriteFrameName(frame)) return false;
        this->commonSetup();
        m_bUnkBool2 = true;
        return true;
    }
    bool isBasicTrigger() = win 0x1a3630, imac 0x5cb6b0, m1 0x4fa4f4;
    bool isColorObject() = win inline {
        if (m_customColorType == 0) {
            if (m_maybeNotColorable) return false;
        }
        else if (m_customColorType == 1) return false;
        if (this->hasSecondaryColor()) return false;
        auto defaultColorID = m_baseColor->m_defaultColorID;
        return defaultColorID != 1004 && defaultColorID != 0;
    }
    bool isColorTrigger() = win inline, imac 0x5cb020, m1 0x4f9e38 {
        return m_objectID == 29 || m_objectID == 30 || m_objectID == 105 || m_objectID == 744 || m_objectID == 899 || m_objectID == 900 || m_objectID == 915;
    }
    bool isConfigurablePortal() = win inline, imac 0x5cb720, m1 0x4fa568 {
        auto id = m_objectID;
        return id == 12 || id == 13 || id == 47 || id == 111 || id == 286 || id == 287 || id == 660 || id == 745 || id == 1331 || id == 1933;
    }
    bool isEditorSpawnableTrigger() = win inline, imac 0x5b6860 {
        auto id = m_objectID;
        return id == 29 || id == 30 || id == 105 || id == 744 || id == 899 || id == 900 || id == 901 || id == 915 || id == 1006 || id == 1007 || id == 1049 || id == 1268 || id == 1346 ||
            id == 1347 || id == 1585 || id == 1595 || id == 1611 || id == 1612 || id == 1613 || id == 1616 || id == 1811 || id == 1814 || id == 1815 || id == 1817 || id == 1912 ||
            id == 1913 || id == 1914 || id == 1916 || id == 1917 || id == 1932 || id == 1934 || id == 1935 || id == 2015 || id == 2062 || id == 2066 || id == 2067 || id == 2068 ||
            id == 2899 || id == 2900 || id == 2901 || id == 2903 || id == 2904 || id == 2905 || id == 2907 || id == 2909 || id == 2910 || id == 2911 || id == 2912 || id == 2913 ||
            id == 2914 || id == 2915 || id == 2916 || id == 2917 || id == 2919 || id == 2920 || id == 2921 || id == 2922 || id == 2923 || id == 2924 || id == 2925 || id == 2999 ||
            id == 3006 || id == 3007 || id == 3008 || id == 3009 || id == 3010 || id == 3011 || id == 3012 || id == 3013 || id == 3014 || id == 3015 || id == 3016 || id == 3022 ||
            id == 3024 || id == 3029 || id == 3030 || id == 3031 || id == 3033 || id == 3602 || id == 3603 || id == 3604 || id == 3605 || id == 3606 || id == 3607 || id == 3608 ||
            id == 3609 || id == 3612 || id == 3613 || id == 3614 || id == 3615 || id == 3617 || id == 3618 || id == 3619 || id == 3620 || id == 3640 || id == 3641 || id == 3655 ||
            id == 3660 || id == 3661 || id == 3662;
    }
    bool isFacingDown() = win 0x1a1950, imac 0x5c9970, m1 0x4f8c70;
    bool isFacingLeft() = win 0x1a1a10, m1 0x4f8d00;
    bool isSettingsObject() = win inline, imac 0x5cb690, m1 0x4fa4dc {
        return m_objectID == 3662 || m_objectID == 3613;
    }
    bool isSpawnableTrigger() = win 0x1a26f0, imac 0x5caac0;
    bool isSpecialObject() = win 0x1a2b00, imac 0x5cb1c0, m1 0x4f9fcc;
    bool isSpeedObject() = win inline, imac 0x5cb0f0, m1 0x4f9f18 {
        auto id = m_objectID;
        return id == 200 || id == 201 || id == 202 || id == 203 || id == 1334 || id == 1917 || id == 1934 || id == 1935 || id == 2900 || id == 2902 || id == 3022 || id == 3027;
    }
    bool isStoppableTrigger() = win inline, imac 0x5b5bd0, m1 0x4eb584 {
        auto id = m_objectID;
        return id == 29 || id == 30 || id == 105 || id == 744 || id == 899 || id == 900 || id == 901 || id == 915 || id == 1006 || id == 1007 || id == 1268 || id == 1346 || id == 1347 ||
            id == 1595 || id == 1611 || id == 1615 || id == 1812 || id == 1814 || id == 1815 || id == 1913 || id == 1916 || id == 2015 || id == 2067 || id == 2903 || id == 2999 ||
            id == 3006 || id == 3007 || id == 3008 || id == 3009 || id == 3010 || id == 3016 || id == 3033 || id == 3602 || id == 3604 || id == 3614 || id == 3615;
    }
    bool isTrigger() = win 0x1a2280, imac 0x5b5660;
    void loadGroupsFromString(gd::string groupList) = win 0x19cb10;
    void makeInvisible() = win inline, imac 0x5bccb0, m1 0x4ee000 {
        m_isDisabled2 = true;
        m_isInvisible = true;
        this->setOpacity(0);
    }
    void makeVisible() = win inline, imac 0x5bcce0, m1 0x4ee01c {
        m_isDisabled2 = false;
        m_isInvisible = false;
        this->setOpacity(255);
    }
    float opacityModForMode(int id, bool mainColor) = win inline, m1 0x4182dc {
        auto ret = 1.f;
        if (id > 0) {
            auto actionSprite = mainColor ? m_mainActionSprite : m_detailActionSprite;
            uint8_t opacity = actionSprite->m_opacity;
            if (opacity < 250) ret = opacity / 255.f;
        }
        if (m_opacityGroupCount > 0) ret *= this->groupOpacityMod();
        return ret;
    }
    cocos2d::CCNode* parentForZLayer(int zLayer, bool blending, int parentMode) = win 0x19bf20, imac 0x5a9a50, m1 0x10b648;
    gd::string perspectiveColorFrame(char const* prefix, int index) = win 0x1aef10, imac 0x443ea0, m1 0x3b55ac;
    gd::string perspectiveFrame(char const* prefix, int index) = win 0x1aedd0, m1 0x3b52b4;
    void playDestroyObjectAnim(GJBaseGameLayer* layer) = win 0x1aa4e0;
    void playPickupAnimation(cocos2d::CCSprite* target, float offset, float duration, float randomValue1, float randomValue2) = win 0x1a9f10, imac 0x25dc00, m1 0x201c38, ios inline {
        this->playPickupAnimation(target, offset * 50.f, offset * 60.f, offset * 90.f, offset * 180.f, offset * 20.f, duration * .75f, duration * .5f, duration * .25f, false, randomValue1, randomValue2);
    }
    void playPickupAnimation(cocos2d::CCSprite* target, float xOffset, float yOffset, float controlYOffset1, float controlYOffset2, float endYOffset, float duration, float fadeDelay, float fadeDuration, bool rotate, float randomValue1, float randomValue2) = win 0x1aa000, imac 0x25dc90, m1 0x201cc0;
    void playShineEffect() = win 0x1993f0, imac 0x5bcd50, m1 0x4ee07c;
    void quickUpdatePosition() = win inline, imac 0x5bb680, m1 0x4ecab4 {
        auto pos = ccp(m_positionX, m_positionY);
        cocos2d::CCSprite::setPosition(pos);
        if (m_colorSprite && !m_colorSpriteLocked) m_colorSprite->setPosition(pos);
    }
    void quickUpdatePosition2() = win inline, imac 0x5bb6f0, m1 0x4ecb1c, ios inline {
        m_obPosition.x = m_positionX;
        m_obPosition.y = m_positionY;
    }
    void removeColorSprite() = win inline, m1 0x4e6b68, ios inline {
        if (m_colorSprite) {
            m_colorSprite->release();
            m_colorSprite = nullptr;
        }
    }
    void removeGlow() = win inline, imac 0x5a4380, m1 0x4e6b2c {
        if (m_glowSprite) {
            m_glowSprite->removeMeAndCleanup();
            m_glowSprite = nullptr;
        }
    }
    void reorderColorSprite() = win inline, imac 0x5bdad0, m1 0x4ef000, ios inline {}
    void resetColorGroups() = win inline, m1 0x4ef7ac {
        if (m_colorGroupCount > 0) {
            for (int i = 0; i < m_colorGroupCount; i++) {
                (*m_colorGroups)[i] = 0;
            }
        }
        m_colorGroupCount = 0;
    }
    void resetGroupDisabled() = win inline, imac 0x5a9690, m1 0x4e79dc {
        m_enabledGroupsCounter = 0;
        m_isGroupDisabled = false;
    }
    void resetGroups() = win inline, imac 0x5be080, m1 0x4ef5c8 {
        m_groupCount = 0;
    }
    void resetMainColorMode() = win inline, m1 0x4f8f20, ios inline {
        if (auto color = this->getMainColor()) {
            color->m_defaultColorID = std::clamp(color->m_defaultColorID, 0, 1101);
            color->m_colorID = 0;
        }
    }
    void resetMoveOffset() = win inline, imac 0x5a9960, m1 0x4e7c08 {
        m_positionX = m_startPosition.x;
        m_positionY = m_startPosition.y;
    }
    void resetRScaleForced() = win inline, m1 0x4ed340, ios inline {
        m_fScaleX = 0.f;
        m_fScaleY = 0.f;
        this->setRScaleX(1.f);
        this->setRScaleY(1.f);
    }
    void resetSecondaryColorMode() = win inline, m1 0x4f8f44, ios inline {
        if (auto color = this->getSecondaryColor()) {
            color->m_defaultColorID = std::clamp(color->m_defaultColorID, 0, 1101);
            color->m_colorID = 0;
        }
    }
    void setAreaOpacity(float step, float value, int index) = win 0x1987b0, imac 0x5bc040, m1 0x4ed4a0;
    void setCustomZLayer(int zLayer) = win inline {
        if (m_zFixedZLayer) return;
        m_zLayer = static_cast<ZLayer>(zLayer);
    }
    void setDefaultMainColorMode(int id) = win inline {
        if (auto color = this->getMainColor()) {
            color->m_defaultColorID = std::clamp(id, 0, 1101);
            color->m_colorID = 0;
        }
    }
    void setDefaultSecondaryColorMode(int id) = win inline, m1 0x4e7508 {
        if (auto color = this->getSecondaryColor()) {
            color->m_defaultColorID = std::clamp(id, 0, 1101);
            color->m_colorID = 0;
        }
    }
    void setGlowOpacity(unsigned char opacity) = win inline {
        if (m_glowSprite) {
            auto glowOpacity = opacity * m_opacityMod;
            m_glowSprite->setOpacity(glowOpacity);
            m_glowSprite->setChildOpacity(glowOpacity);
        }
    }
    void setLastPosition(cocos2d::CCPoint const& position) = win inline, imac 0x5caaa0, m1 0x4f9c44 {
        m_lastPosition = position;
    }
    void setMainColorMode(int id) = win inline, m1 0x4f8ee0 {
        if (auto color = this->getMainColor()) {
            color->m_colorID = std::clamp(id, 0, 1101);
        }
    }
    void setSecondaryColorMode(int id) = win inline, m1 0x4f8f00, ios inline {
        if (auto color = this->getSecondaryColor()) {
            color->m_colorID = std::clamp(id, 0, 1101);
        }
    }
    void setupColorSprite(int id, bool mainColor) = win inline, m1 0x4f7c90, ios inline {
        if (mainColor) m_mainActionSprite = m_goEffectManager->getColorSprite(id);
        else m_detailActionSprite = m_goEffectManager->getColorSprite(id);
    }
    void setupPixelScale() = win 0x1c3340, imac 0x469b20, m1 0x3d4438;
    void setupSpriteSize() = win 0x1a36e0, imac 0x5b6bc0, m1 0x4ebaa4;
    bool shouldBlendColor(GJSpriteColor* color, bool mainColor) = win 0x190cc0;
    bool shouldLockX() = win 0x196e80, imac 0x5b5020;
    bool shouldNotHideAnimFreeze() = win inline, imac 0x25db90, m1 0x201be0, ios inline {
        return m_objectID == 1855;
    }
    bool shouldShowPickupEffects() = win inline {
        if (!m_hasNoEffects && !m_isInvisible) {
            if (this->getOpacity() != 0) return true;
            if (m_colorSprite && m_colorSprite->getOpacity() != 0) return true;
        }
        return false;
    }
    bool slopeFloorTop() = win inline, m1 0x4f8664 {
        return m_slopeDirection == 1 || m_slopeDirection == 3 || m_slopeDirection == 5 || m_slopeDirection == 6;
    }
    bool slopeWallLeft() = win inline, m1 0x4f8648 {
        return m_slopeDirection == 2 || m_slopeDirection == 3 || m_slopeDirection == 4 || m_slopeDirection == 6;
    }
    double slopeYPos(GameObject* object) = win inline, imac 0x5c9380, m1 0x4f8680, ios inline {
        return this->slopeYPos(object->getObjectRect());
    }
    double slopeYPos(cocos2d::CCRect rect) = win inline, imac 0x5c93f0, m1 0x4f8720 {
        auto floorTop = this->slopeFloorTop();
        if (m_slopeUphill) {
            return this->slopeYPos(floorTop ? rect.getMaxX() : rect.getMinX());
        }
        else {
            return this->slopeYPos(floorTop ? rect.getMinX() : rect.getMaxX());
        }
    }
    double slopeYPos(float x) = win 0x1a13f0, imac 0x5c9440, m1 0x4f8790;
    void spawnDefaultPickupParticle(GJBaseGameLayer* layer) = win 0x1aa2a0, imac 0x1153b0;
    void updateBlendMode() = win inline {
        auto shouldBlend = this->shouldBlendColor(m_baseColor, true);
        m_shouldBlendBase = shouldBlend;
        if (!m_colorSprite) {
            m_shouldBlendDetail = false;
            return;
        }
        m_shouldBlendDetail = m_detailColor->getColorMode() != 1012 ? this->shouldBlendColor(m_detailColor, false) : shouldBlend;
    }
    void updateCustomColorType(short type) = win inline, imac 0x5caa30, ios inline {
        m_customColorType = type;
        m_customSpriteColor = this->getRelativeSpriteColor(1) == nullptr;
    }
    void updateCustomScaleX(float scaleX) = imac 0x5a96b0, m1 0x4e79e8;
    void updateCustomScaleY(float scaleY) = imac 0x5a9730, m1 0x4e7a48;
    void updateHSVState() = win inline, imac 0x5bea70, m1 0x4f0078 {
        if (auto color = m_baseColor) {
            color->m_usesHSV = color->m_hsv.h != 0.f || color->m_hsv.s != 1.f || color->m_hsv.v != 1.f || color->m_hsv.absoluteSaturation || color->m_hsv.absoluteBrightness;
        }
        if (auto color = m_detailColor) {
            color->m_usesHSV = color->m_hsv.h != 0.f || color->m_hsv.s != 1.f || color->m_hsv.v != 1.f || color->m_hsv.absoluteSaturation || color->m_hsv.absoluteBrightness;
        }
    }
    void updateIsOriented() = win 0x1a1770, imac 0x5c9790, m1 0x4f8ab4;
    void updateMainColor() = win inline, imac 0x5ca190, m1 0x4f9354 {
        this->updateMainColor(this->colorForMode(m_activeMainColorID, true));
        this->updateMainOpacity();
    }
    void updateMainColorOnly() = win inline, ios inline {
        if (m_activeMainColorID != 0 && m_colorGroupCount != 0 && m_opacityGroupCount != 0) {
            this->updateMainColor(this->colorForMode(m_activeMainColorID, true));
        }
    }
    void updateMainOpacity() = win inline, ios inline {
        m_baseColor->m_opacity = this->opacityModForMode(m_activeMainColorID, true);
    }
    void updateObjectEditorColor() = win 0x1a1330, m1 0x1f20f0;
    void updateSecondaryColor() = win inline {
        if (this->hasSecondaryColor() && m_activeDetailColorID != 0 && m_groupCount != 0) {
            this->updateSecondaryColor(this->colorForMode(m_activeDetailColorID, false));
            this->updateSecondaryOpacity();
        }
    }
    void updateSecondaryColorOnly() = win inline, ios inline {
        if (this->hasSecondaryColor() && m_activeDetailColorID != 0 && m_groupCount != 0) {
            this->updateSecondaryColor(this->colorForMode(m_activeDetailColorID, false));
        }
    }
    void updateSecondaryOpacity() = win inline, ios inline {
        m_detailColor->m_opacity = this->opacityModForMode(m_activeDetailColorID, false);
    }
    void updateStartPos() = win 0x190630, imac 0x5a92c0, m1 0x4e76b4;
    void updateUnmodifiedPositions() = win inline, ios inline {
        if (m_isDisabled) {
            m_isDisabled = false;
            m_unmodifiedPositionX = m_positionX - m_positionXOffset;
            m_unmodifiedPositionY = m_positionY - m_positionYOffset;
        }
    }
    bool usesFreezeAnimation() = win inline, imac 0x25d7f0 {
        auto id = m_objectID;
        return id == 921 || id == 1519 || id == 1618 || id == 1851 || id == 1852 || id == 1854 || id == 1855 || id == 1856 || id == 1860 || id == 2020 || id == 2021 || id == 2022 ||
            id == 2024 || id == 2025 || id == 2026 || id == 2027 || id == 2028 || id == 2029 || id == 2030 || id == 2031 || id == 2033 || id == 2035 || id == 2036 || id == 2037 ||
            id == 2038 || id == 2039 || id == 2040 || id == 2043 || id == 2044 || id == 2045 || id == 2046 || id == 2047 || id == 2048 || id == 2049 || id == 2050 || id == 2051 ||
            id == 2052 || id == 2053 || id == 2054 || id == 2055 || id == 2867 || id == 2868 || id == 2869 || id == 2870 || id == 2871 || id == 2872 || id == 2875 || id == 2876 ||
            id == 2877 || id == 2878 || id == 2880 || id == 2882 || id == 2883 || id == 2885 || id == 2886 || id == 2887;
    }
    bool usesSpecialAnimation() = win inline, imac 0x25dbb0, m1 0x201bf0 {
        auto id = m_objectID;
        return id == 1591 || id == 1593 || id == 1839 || id == 1840 || id == 1841 || id == 1842 || id == 2892 || id == 2893;
    }

    int m_someOtherIndex;
    int m_innerSectionIndex;
    int m_outerSectionIndex;
    int m_middleSectionIndex;
    // property 511
    bool m_hasExtendedCollision;
    cocos2d::ccColor3B m_groupColor;
    bool m_isColorSpriteBlack;
    bool m_isObjectBlack;
    float m_blackChildOpacity;
    bool m_blackChildOpacityLocked;
    bool m_editorEnabled;
    bool m_isGroupDisabled;
    bool m_unk28B;
    bool m_unk28c;
    // somehow related to property 155 and 156 if anyone wants to reverse engineer
    int m_activeMainColorID;
    int m_activeDetailColorID;
    bool m_baseUsesHSV;
    bool m_detailUsesHSV;
    float m_positionXOffset;
    float m_positionYOffset;
    float m_rotationXOffset;
    float m_unk2A8;
    float m_rotationYOffset;
    float m_unk2B0;
    float m_scaleXOffset;
    float m_scaleYOffset;
    float m_unk2BC;
    float m_unk2C0;
    bool m_tempOffsetXRelated;
    bool m_isFlipX;
    bool m_isFlipY;
    cocos2d::CCPoint m_customBoxOffset;
    bool m_boxOffsetCalculated;
    cocos2d::CCPoint m_boxOffset;
    OBB2D* m_orientedBox;
    bool m_shouldUseOuterOb;
    cocos2d::CCSprite* m_glowSprite;
    bool m_isRingPoweredOn;
    float m_width;
    float m_height;
    bool m_addToNodeContainer;
    bool m_isActivated;
    bool m_isDisabled2;
    cocos2d::CCParticleSystemQuad* m_particle;
    gd::string m_particleString;
    bool m_hasParticles;
    // property 146
    bool m_particleUseObjectColor;
    bool m_hasColorSprite;
    cocos2d::CCPoint m_particleOffset;
    bool m_isParticleSpriteLocked;
    cocos2d::CCRect m_textureRect;
    bool m_isDirty;
    bool m_isObjectPosDirty;
    bool m_isUnmodifiedPosDirty;
    float m_fadeMargin;
    cocos2d::CCRect m_objectRect;
    bool m_isObjectRectDirty;
    bool m_isOrientedBoxDirty;
    bool m_colorSpriteLocked;
    bool m_unk353;
    bool m_canRotateFree;
    bool m_isMirroredByScale;
    // property 108
    int m_linkedGroup;
    int m_unk35C;
    short m_colorType;
    short m_childColorType;
    bool m_shouldBlendBase;
    bool m_shouldBlendDetail;
    bool m_hasCustomChild;
    bool m_unk367;
    cocos2d::CCSprite* m_colorSprite;
    bool m_unk370;
    float m_objectRadius;
    bool m_isRotationAligned;
    float m_spriteWidthScale;
    float m_spriteHeightScale;
    int m_uniqueID;
    GameObjectType m_objectType;
    // used in PlayerObject::gameEventTriggered
    GameObjectType m_savedObjectType;
    int m_unk390;
    float m_unmodifiedPositionX;
    float m_unmodifiedPositionY;
    double m_positionX;
    double m_positionY;
    cocos2d::CCPoint m_startPosition;
    bool m_usesAudioScale;
    // property 372
    bool m_hasNoAudioScale;
    bool m_isDisabled;
    float m_startRotationX;
    float m_startRotationY;
    float m_startScaleX;
    float m_startScaleY;
    float m_customScaleX;
    float m_customScaleY;
    bool m_startFlipX;
    bool m_startFlipY;
    bool m_unk3ee;
    bool m_isInvisible;
    int m_unk3D8;
    short m_varianceIndex;
    bool m_unk3DE;
    short m_enterType;
    short m_exitType;
    // property 343
    short m_enterChannel;
    // property 446
    short m_objectMaterial;
    bool m_unk3E8;
    short m_parentMode;
    // property 96
    bool m_hasNoGlow;
    // property 23
    int m_targetColor;
    // property 1
    int m_objectID;
    bool m_unk3F8;
    bool m_intrinsicDontFade;
    bool m_ignoreEnter;
    bool m_ignoreFade;
    // true for object IDs 207-213 and 693-694
    bool m_isSolidColorBlock;
    bool m_unk3FD;
    bool m_customSpriteColor;
    // property 497
    short m_customColorType;
    // property 67
    bool m_isDontEnter;
    // property 64
    bool m_isDontFade;
    // property 116
    bool m_hasNoEffects;
    // property 507
    bool m_hasNoParticles;
    int m_defaultZOrder;
    bool m_unk40C;
    bool m_colorZLayerRelated;
    bool m_customAudioScale;
    float m_minAudioScale;
    float m_maxAudioScale;
    bool m_particleLocked;
    // property 53
    int m_property53;
    bool m_isInvisibleBlock;
    bool m_glowColorIsLBG;
    bool m_customGlowColor;
    bool m_cantColorGlow;
    float m_opacityMod;
    bool m_slopeUphill;
    int m_slopeDirection;
    bool m_slopeIsHazard;
    float m_opacityMod2;
    // property 21, also used with 41 and 43
    GJSpriteColor* m_baseColor;
    // property 22, also used with 42 and 44
    GJSpriteColor* m_detailColor;
    bool m_baseOrDetailBlending;
    ZLayer m_defaultZLayer;
    bool m_zFixedZLayer;
    // property 24
    ZLayer m_zLayer;
    // property 25
    int m_zOrder;
    bool m_wasSelected;
    bool m_isSelected;
    float m_unk460;
    cocos2d::CCPoint m_unk464;
    bool m_updateParents;
    bool m_updateEditorColor;
    // property 34
    bool m_hasGroupParent;
    // property 279
    bool m_hasAreaParent;
    // property 128
    float m_scaleX;
    // property 129
    float m_scaleY;
    // property 57, short array of size either 10 or m_groupCount
    std::array<short, 10>* m_groups;
    // used with property 57
    short m_groupCount;
    // used with property 274
    bool m_hasGroupParentsString;
    std::array<short, 10>* m_colorGroups;
    short m_colorGroupCount;
    std::array<short, 10>* m_opacityGroups;
    short m_opacityGroupCount;
    // property 20
    short m_editorLayer;
    // property 61
    short m_editorLayer2;
    int m_enabledGroupsCounter;
    bool m_updateCustomContentSize;
    bool m_hasContentSize;
    // property 121
    bool m_isNoTouch;
    cocos2d::CCSize m_lastSize;
    cocos2d::CCPoint m_lastPosition;
    int m_unk4C0;
    int m_unk4C4;
    int m_unk4C8;
    int m_unk4CC;
    GameObjectClassType m_classType;
    bool m_isTrigger;
    bool m_isSpawnOrderTrigger;
    bool m_isColorTrigger;
    bool m_dontIgnoreDuration;
    bool m_canBeControlled;
    bool m_activateTriggerInEditor;
    bool m_isStartPos;
    // property 103
    bool m_isHighDetail;
    ColorActionSprite* m_mainActionSprite;
    ColorActionSprite* m_detailActionSprite;
    GJEffectManager* m_goEffectManager;
    bool m_unk4F8;
    bool m_isDecoration;
    bool m_isDecoration2;
    bool m_unk4fb;
    bool m_maybeNotColorable;
    // property 134
    bool m_isPassable;
    // property 135
    bool m_isHide;
    // property 136
    bool m_isNonStickX;
    // property 289
    bool m_isNonStickY;
    // property 137
    bool m_isIceBlock;
    // property 193
    bool m_isGripSlope;
    // property 356
    bool m_isScaleStick;
    // property 495
    bool m_isExtraSticky;
    // property 496
    bool m_isDontBoostY;
    // property 509
    bool m_isDontBoostX;
    bool m_unk507;
    bool m_unk508;
    float m_unk50C;
    float m_pixelScaleX;
    float m_pixelScaleY;
    // property 155
    int m_mainColorKeyIndex;
    // property 156
    int m_detailColorKeyIndex;
    uint8_t m_areaOpacityRelated;
    float m_areaOpacityValue;
    int m_areaOpacityIndex;
    int m_unk52C;
    bool m_unk530;
    bool m_isUIObject;
    bool m_greenDebugDraw;
}

[[link(android)]]
class GameObjectCopy : cocos2d::CCObject {
    // virtual ~GameObjectCopy();

    static GameObjectCopy* create(GameObject* object) = win 0x2e87a0, imac 0xe3220, m1 0xc8a08;

    bool init(GameObject* object) = win inline, imac 0x100890, m1 0xdfa04 {
        m_object = object;
        object->retain();
        m_position = m_object->getPosition();
        m_rotationX = m_object->getRotationX();
        m_rotationY = m_object->getRotationY();
        m_isFlipX = m_object->isFlipX();
        m_isFlipY = m_object->isFlipY();
        m_customScaleX = m_object->m_scaleX;
        m_customScaleY = m_object->m_scaleY;
        return true;
    }
    void resetObject() = win 0x2e88a0, imac 0xe3340;

    GameObject* m_object;
    cocos2d::CCPoint m_position;
    float m_rotationX;
    float m_rotationY;
    bool m_isFlipX;
    bool m_isFlipY;
    float m_customScaleX;
    float m_customScaleY;
}

[[link(android)]]
class GameObjectEditorState {
    void loadValues(GameObject* obj) = win inline, imac 0x8cd0, m1 0x7abc {
        m_position = obj->getPosition();
        m_scaleX = obj->m_scaleX / obj->m_pixelScaleX;
        m_scaleY = obj->m_scaleY / obj->m_pixelScaleY;
        m_rotationX = obj->getRotationX();
        m_rotationY = obj->getRotationY();
    }

    cocos2d::CCPoint m_position;
    float m_scaleX;
    float m_scaleY;
    float m_rotationX;
    float m_rotationY;
}

[[link(android)]]
class GameOptionsLayer : GJOptionsLayer {
    // virtual ~GameOptionsLayer();
    GameOptionsLayer() {
        m_practiceDialogIndex = 0;
    }

    static GameOptionsLayer* create(GJBaseGameLayer* baseGameLayer) = win inline, imac 0x2b09c0, m1 0x24ebe8 {
        auto ret = new GameOptionsLayer();
        if (ret->init(baseGameLayer)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void setupOptions() = win 0x29eda0, m1 0x24edf0, imac 0x2b0c90;
    virtual void didToggle(int tag) = win 0x2a03c0, imac 0x2b1a30, m1 0x24fb30;

    bool init(GJBaseGameLayer* baseGameLayer) = win inline, imac 0x2b0c40 {
        m_baseGameLayer = baseGameLayer;
        m_gap = 40.f;
        m_maxLabelScale = .4f;
        if (!GJOptionsLayer::init(2)) return false;
        this->preSetup();
        this->postSetup();
        return true;
    }
    void onPracticeMusicSync(cocos2d::CCObject* sender) = win 0x2a00d0, m1 0x24f4b4;
    void onUIOptions(cocos2d::CCObject* sender) = m1 0x24f528;
    void onUIPOptions(cocos2d::CCObject* sender) = win 0x2a0270, m1 0x24f548;
    void showPracticeMusicSyncUnlockInfo() = win 0x29f870, imac 0x2b1490, m1 0x24f5b4;

    GJBaseGameLayer* m_baseGameLayer;
    int m_practiceDialogIndex;
}

[[link(android)]]
class GameOptionsTrigger : EffectGameObject {
    // virtual ~GameOptionsTrigger();
    GameOptionsTrigger() {
        m_streakAdditive = GameOptionsSetting::Disabled;
        m_unlinkDualGravity = GameOptionsSetting::Disabled;
        m_hideGround = GameOptionsSetting::Disabled;
        m_hideP1 = GameOptionsSetting::Disabled;
        m_hideP2 = GameOptionsSetting::Disabled;
        m_disableP1Controls = GameOptionsSetting::Disabled;
        m_disableP2Controls = GameOptionsSetting::Disabled;
        m_hideMG = GameOptionsSetting::Disabled;
        m_hideAttempts = GameOptionsSetting::Disabled;
        m_editRespawnTime = GameOptionsSetting::Disabled;
        m_respawnTime = 0.f;
        m_audioOnDeath = GameOptionsSetting::Disabled;
        m_noDeathSFX = GameOptionsSetting::Disabled;
        m_boostSlide = GameOptionsSetting::Disabled;
    }

    static GameOptionsTrigger* create(char const* frame) = win inline, m1 0x1692f8 {
        auto ret = new GameOptionsTrigger();
        if (ret->init(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x49f0e0, m1 0x16abd4, imac 0x1b0480;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x49e970, m1 0x169414, imac 0x1ae530;

    bool init(char const* frame) = win inline, ios inline {
        return EffectGameObject::init(frame);
    }

    // property 159
    GameOptionsSetting m_streakAdditive;
    // property 160
    GameOptionsSetting m_unlinkDualGravity;
    // property 161
    GameOptionsSetting m_hideGround;
    // property 162
    GameOptionsSetting m_hideP1;
    // property 163
    GameOptionsSetting m_hideP2;
    // property 165
    GameOptionsSetting m_disableP1Controls;
    // property 199
    GameOptionsSetting m_disableP2Controls;
    // property 195
    GameOptionsSetting m_hideMG;
    // property 532
    GameOptionsSetting m_hideAttempts;
    // property 573
    GameOptionsSetting m_editRespawnTime;
    // property 574
    float m_respawnTime;
    // property 575
    GameOptionsSetting m_audioOnDeath;
    // property 576
    GameOptionsSetting m_noDeathSFX;
    // property 593
    GameOptionsSetting m_boostSlide;
}

[[link(android)]]
class GameRateDelegate {
    virtual void updateRate() {}
}

[[link(android)]]
class GameStatsManager : cocos2d::CCNode {
    static GameStatsManager* get() {
        return GameStatsManager::sharedState();
    }
    // virtual ~GameStatsManager();
    // GameStatsManager() = win 0x1d0b20;
    static GameStatsManager* sharedState() = win 0x1d0f30, m1 0x4d72c;

    virtual bool init() = win 0x1d1150, imac 0x5a4a0, m1 0x4da70;

    int accountIDForIcon(int id, UnlockType type) = win inline {
        if (auto it = m_accountIDForIcon.find({ id, type }); it != m_accountIDForIcon.end()) {
            return it->second;
        }
        return 0;
    }
    void addSimpleSpecialChestReward(gd::string key, UnlockType type, int id, bool unused) = win 0x1ea0e0, imac 0x77e10, m1 0x695a0;
    void addSpecialRewardDescription(gd::string key, gd::string description) = win 0x1ea2f0, imac 0x77dd0, ios inline {
        m_specialRewardDescriptions[key] = description;
    }
    void addStoreItem(int index, int id, int unlockType, int price, ShopType shopType) = win 0x1d4010, m1 0x5863c;
    bool areChallengesLoaded() = win inline, imac 0x72de0, m1 0x64708 {
        return m_challengeTime > 0;
    }
    bool areRewardsLoaded() = win inline, m1 0x63bb4 {
        return m_rewardItems->objectForKey(1) != nullptr;
    }
    void awardCurrencyForLevel(GJGameLevel* level) = win 0x1e09a0, m1 0x6292c;
    void awardDiamondsForLevel(GJGameLevel* level) = win 0x1e1180, imac 0x71820, m1 0x630c8;
    bool awardSecretKey() = win 0x1f1a30, m1 0x7e0b0;
    bool canItemBeUnlocked(int id, UnlockType type) = win inline, imac 0x77890, m1 0x473cc, ios inline { return true; }
    void checkAchievement(char const* statKey) = win 0x1d5480;
    void checkCoinAchievement(GJGameLevel* level) = win 0x1dd840, imac 0x6ce00;
    void checkCoinsForLevel(GJGameLevel* level) = win inline, imac 0x6fe50, m1 0x61574 {
        if (level->m_coins > 0 && level->m_coinsVerified.value() == 1) {
            for (int i = 1; i < 4; i++) {
                auto coinKey = level->getCoinKey(i);
                if (this->hasPendingUserCoin(coinKey)) {
                    if (!this->hasUserCoin(coinKey)) {
                        this->storeUserCoin(coinKey);
                        this->incrementStat("12");
                    }
                    m_pendingUserCoins->removeObjectForKey(coinKey);
                }
            }
        }
    }
    bool claimListReward(GJLevelList* list) = win inline, m1 0x656ac {
        if (list->m_diamonds > 0 && list->m_levelsToClaim > 0 && list->completedLevels() >= list->m_levelsToClaim && !this->hasClaimedListReward(list)) {
            m_completedLists->setObject(cocos2d::CCString::createWithFormat("%i", list->m_diamonds), this->getListRewardKey(list));
            return true;
        }
        return false;
    }
    void collectReward(GJRewardType type, GJRewardItem* item) = win inline, imac 0x72620, m1 0x63e84 {
        if (!item || this->hasRewardBeenCollected(type, item->m_chestID)) return;
        this->registerRewardsFromItem(item);
        m_dailyChests->setObject(item, this->getRewardKey(type, item->m_chestID));
    }
    void collectVideoReward(int orbs) = m1 0x7e154;
    void completedChallenge(GJChallengeItem* item) = win inline {
        if (item->m_canClaim && !this->hasCompletedChallenge(item)) {
            auto reward = item->m_reward.value();
            m_challengeDiamonds->setObject(cocos2d::CCString::createWithFormat("%i", reward), this->getChallengeKey(item));
            this->incrementStat("13", reward);
        }
    }
    GJRewardItem* completedDailyLevel(GJGameLevel* level) = win 0x1e2e20, m1 0x65b30;
    void completedDemonLevel(GJGameLevel* level) = win 0x1de540, m1 0x5f594;
    void completedLevel(GJGameLevel* level) = win 0x1de3f0, imac 0x6dbc0, m1 0x5f438;
    void completedMapPack(GJMapPack* pack) = win 0x1dee40, imac 0x6e6d0, m1 0x5ff7c;
    void completedStarLevel(GJGameLevel* level) = win 0x1de7b0, m1 0x5f72c;
    int countSecretChests(GJRewardType rewardType) = win inline, m1 0x7df50 {
        if (!m_allTreasureRoomChests) {
            return 0;
        }

        if (rewardType == GJRewardType::Unknown) {
            return m_allTreasureRoomChests->count();
        }

        int count = 0;
        cocos2d::CCDictElement* obj;
        cocos2d::CCDictElement* temp;
        HASH_ITER(hh, m_allTreasureRoomChests->m_pElements, obj, temp) {
            auto chest = static_cast<GJRewardItem*>(obj->getObject());
            if (chest->m_rewardType == rewardType) count++;
        }
        return count;
    }
    int countUnlockedSecretChests(GJRewardType rewardType) = win inline, m1 0x7df94 {
        if (!m_treasureRoomChests) {
            return 0;
        }

        if (rewardType == GJRewardType::Unknown) {
            return m_treasureRoomChests->count();
        }

        int count = 0;
        cocos2d::CCDictElement* obj;
        cocos2d::CCDictElement* temp;
        HASH_ITER(hh, m_treasureRoomChests->m_pElements, obj, temp) {
            auto chest = static_cast<GJRewardItem*>(obj->getObject());
            if (chest->m_rewardType == rewardType) count++;
        }
        return count;
    }
    GJRewardItem* createReward(GJRewardType type, int id, gd::string str) = win 0x1e1630, imac 0x71cd0, m1 0x6358c;
    void createSecretChestItems() = win inline, imac 0x5cbe0, m1 0x4fa54 {
        if (m_allTreasureRoomChestItems) return;
        m_allTreasureRoomChestItems = cocos2d::CCDictionary::create();
        m_allTreasureRoomChestItems->retain();
        m_allTreasureRoomChests = cocos2d::CCDictionary::create();
        m_allTreasureRoomChests->retain();
        this->createSecretChestRewards();
        cocos2d::CCDictElement* element;
        cocos2d::CCDictElement* temp;
        HASH_ITER(hh, m_allTreasureRoomChests->m_pElements, element, temp) {
            if (auto rewardItem = static_cast<GJRewardItem*>(element->getObject())) {
                auto rewardObjects = rewardItem->m_rewardObjects;
                for (int i = 0; i < rewardObjects->count(); i++) {
                    auto rewardObject = static_cast<GJRewardObject*>(rewardObjects->objectAtIndex(i));
                    auto rewardKey = this->getItemKey(rewardObject->m_itemID, (int)rewardObject->m_unlockType);
                    m_allTreasureRoomChestItems->setObject(cocos2d::CCString::createWithFormat("%i", rewardItem->m_chestID), rewardKey);
                }
            }
        }
    }
    void createSecretChestRewards() = win 0x1eab30, m1 0x6a58c;
    void createSpecialChestItems() = win 0x1e5ca0, imac 0x5cd30;
    void createStoreItems() = win 0x1d1840;
    void dataLoaded(DS_Dictionary* dict) = win 0x1f24e0, imac 0x653a20, m1 0x5918c;
    void encodeDataTo(DS_Dictionary* dict) = m1 0x7e8f8;
    void firstSetup() = win 0x1f1af0, m1 0x7e2c8;
    void generateItemUnlockableData() = win 0x1d1350, m1 0x57a18;
    int getAwardedCurrencyForLevel(GJGameLevel* level) = win 0x1e0760, m1 0x6273c;
    int getAwardedDiamondsForLevel(GJGameLevel* level) = win 0x1e0f50, imac 0x71660, m1 0x62ec4;
    int getBaseCurrency(int stars, bool mainLevel, int levelID) = win inline, m1 0x62498 {
        if (mainLevel) {
            return levelID == 14 || levelID == 18 || levelID == 20 ? 400 : (stars + 1) * 20;
        }
        else {
            switch (stars) {
                case 2: return 40;
                case 3: return 60;
                case 4: return 100;
                case 5: return 140;
                case 6: return 180;
                case 7: return 220;
                case 8: return 280;
                case 9: return 340;
                case 10: return 400;
                default: return 0;
            }
        }
    }
    int getBaseCurrencyForLevel(GJGameLevel* level) = win 0x1e04c0, imac 0x70cf0, m1 0x624f8;
    int getBaseDiamonds(int stars) = win inline, imac 0x71600, m1 0x62e7c {
        return stars > 2 && stars < 11 ? stars + 2 : 0;
    }
    int getBonusDiamonds(int stars) = win inline, imac 0x71620, m1 0x62e90 {
        return stars > 2 && stars < 11 ? stars == 10 ? 20 : this->getBaseDiamonds(stars) / 2.f : 0;
    }
    GJChallengeItem* getChallenge(int id) = win 0x1e1e80;
    gd::string getChallengeKey(GJChallengeItem* chal) = win inline, imac 0x73740, m1 0x65124 {
        return cocos2d::CCString::createWithFormat("c%i%i", chal->m_position, chal->m_timeLeft)->getCString();
    }
    int getCollectedCoinsForLevel(GJGameLevel* level) = win 0x1ddbe0, imac 0x6d270, m1 0x5ea48;
    cocos2d::CCArray* getCompletedMapPacks() = win 0x1df190, m1 0x6045c;
    gd::string getCurrencyKey(GJGameLevel* level) = win inline, imac 0x70bd0 {
        auto dailyID = level->m_dailyID.value();
        return cocos2d::CCString::createWithFormat("%i", dailyID > 0 ? dailyID : level->m_levelID.value())->getCString();
    }
    gd::string getDailyLevelKey(int dailyID) = win inline {
        return cocos2d::CCString::createWithFormat("d%i", dailyID)->getCString();
    }
    const char* getDemonLevelKey(GJGameLevel* level) = win inline {
        auto dailyID = level->m_dailyID.value();
        if (dailyID > 0) return cocos2d::CCString::createWithFormat("ddemon_%i", dailyID)->getCString();
        auto levelID = level->m_levelID.value();
        if (level->m_gauntletLevel) return cocos2d::CCString::createWithFormat("gdemon_%i", levelID)->getCString();
        return cocos2d::CCString::createWithFormat("demon_%i", levelID)->getCString();
    }
    gd::string getEventRewardKey(int id) = win inline, imac 0x789f0, m1 0x6a230, ios inline {
        return fmt::format("o_event_{}", id);
    }
    gd::string getGauntletRewardKey(int id) = win 0x1ea210, imac 0x77bf0, m1 0x693b0;
    gd::string getItemKey(int id, int type) = win 0x1e19c0;
    int getItemUnlockState(int itemID, UnlockType unlockType) = win 0x1e5b40, imac 0x77510, m1 0x68c10;
    int getItemUnlockStateLite(int id, UnlockType type) = imac 0x775d0, m1 0x68d0c;
    gd::string getLevelKey(GJGameLevel* level) = win inline, imac 0x6d3f0, m1 0x5ebc8 {
        return getLevelKey(level->m_levelID, level->m_levelType != GJLevelType::Main, level->m_dailyID > 0, level->m_gauntletLevel, level->m_dailyID > 200000);
    }
    gd::string getLevelKey(int levelID, bool isOnline, bool isDaily, bool isGauntlet, bool isEvent) = win 0x1ddd60, imac 0x6d460, m1 0x5ec0c;
    gd::string getListRewardKey(GJLevelList* list) = win inline, imac 0x73ae0, m1 0x654e0 {
        return cocos2d::CCString::createWithFormat("lr_%i", list->m_listID)->getCString();
    }
    const char* getMapPackKey(int id) = win inline, m1 0x5ff54, ios inline {
        return cocos2d::CCString::createWithFormat("pack_%i", id)->getCString();
    }
    int getNextGoldChestID() = win inline, imac 0x8bec0, m1 0x7da64 {
        for (int i = 6001; i < 6021; i++) {
            if (!this->isSecretChestUnlocked(i)) return i;
        }
        return 0;
    }
    gd::string getNextVideoAdReward() = imac 0x781b0, m1 0x69960;
    gd::string getPathRewardKey(int id) = win 0x1ea700, imac 0x6c9a0, m1 0x5e170;
    GJChallengeItem* getQueuedChallenge(int id);
    GJRewardItem* getRewardForSecretChest(int id) = win inline, m1 0x7dde0, ios inline {
        return static_cast<GJRewardItem*>(m_allTreasureRoomChests->objectForKey(id));
    }
    GJRewardItem* getRewardForSpecialChest(gd::string key) = win inline, m1 0x69c50 {
        return static_cast<GJRewardItem*>(m_allSpecialChests->objectForKey(key));
    }
    GJRewardItem* getRewardItem(GJRewardType type) = win inline, imac 0x722e0, m1 0x63ba8 {
        return static_cast<GJRewardItem*>(m_rewardItems->objectForKey((int)type));
    }
    gd::string getRewardKey(GJRewardType type, int id) = win 0x1e19c0;
    GJChallengeItem* getSecondaryQueuedChallenge(int id) = win 0x1e2020;
    int getSecretChestForItem(int id, UnlockType type) = win inline, imac 0x66450, m1 0x58318 {
        return m_allTreasureRoomChestItems->valueForKey(this->getItemKey(id, (int)type))->intValue();
    }
    const char* getSecretCoinKey(char const* key) = win inline, m1 0x61c6c, ios inline {
        return cocos2d::CCString::createWithFormat("unique_%s", key)->getCString();
    }
    gd::string getSecretOnlineRewardKey(int id) = win inline, imac 0x78be0, m1 0x6a3dc {
        return fmt::format("o_secret_{}", id);
    }
    cocos2d::CCString* getSpecialChestKeyForItem(int id, UnlockType type) = win inline, imac 0x664c0 {
        return static_cast<cocos2d::CCString*>(m_allSpecialChestItems->objectForKey(this->getItemKey(id, (int)type)));
    }
    gd::string getSpecialRewardDescription(gd::string key, bool unused) = win inline, imac 0x78030, m1 0x697b4 {
        if (auto it = m_specialRewardDescriptions.find(key); it != m_specialRewardDescriptions.end()) {
            return it->second;
        }
        return "";
    }
    gd::string getSpecialUnlockDescription(int id, UnlockType type, bool unused) = win 0x1ea380, imac 0x78090, m1 0x6981c;
    char const* getStarLevelKey(GJGameLevel* level) = win inline {
        int dailyID = level->m_dailyID.value();
        if (dailyID > 0) return cocos2d::CCString::createWithFormat("dstar_%i",dailyID)->getCString();
        int levelID = level->m_levelID.value();
        if (level->m_gauntletLevel) return cocos2d::CCString::createWithFormat("gstar_%i",levelID)->getCString();
        return cocos2d::CCString::createWithFormat("star_%i",levelID)->getCString();
    }
    int getStat(char const* key) = win 0x1d51f0;
    int getStatFromKey(StatKey key) = win inline {
        return this->getStat(GameToolbox::intToString((int)key).c_str());
    }
    GJStoreItem* getStoreItem(int index) = win inline, m1 0x58850 {
        return static_cast<GJStoreItem*>(m_storeItems->objectForKey(index));
    }
    GJStoreItem* getStoreItem(int id, int type) = win inline, imac 0x663e0 {
        return static_cast<GJStoreItem*>(m_allStoreItems->objectForKey(this->getItemKey(id, type)));
    }
    int getTotalCollectedCurrency() = win 0x1e38c0, imac 0x74910, m1 0x66304;
    int getTotalCollectedDiamonds() = win 0x1e4190, imac 0x75670, m1 0x66f04;
    bool hasClaimedListReward(GJLevelList* list) = win 0x1e2c40, imac 0x73ba0, m1 0x655a4;
    bool hasCompletedChallenge(GJChallengeItem* item) = win 0x1e2880, m1 0x651ec;
    bool hasCompletedDailyLevel(int dailyID) = win 0x1e2d20;
    bool hasCompletedDemonLevel(GJGameLevel* level) = win inline {
        return m_completedLevels->objectForKey(this->getDemonLevelKey(level)) != nullptr;
    }
    bool hasCompletedGauntletLevel(int id) = imac 0x6d8e0;
    bool hasCompletedLevel(GJGameLevel* level) = win 0x1ddfc0, imac 0x6d7b0, m1 0x5ef94;
    bool hasCompletedMainLevel(int levelID) = win 0x1dde90, imac 0x6d730;
    bool hasCompletedMapPack(int id);
    bool hasCompletedOnlineLevel(int id) = imac 0x6d860;
    bool hasCompletedStarLevel(GJGameLevel* level) = win 0x1de2e0;
    bool hasPendingUserCoin(char const* key) = win 0x1dfea0;
    bool hasRewardBeenCollected(GJRewardType type, int id) = win 0x1e1ab0;
    bool hasSecretCoin(char const* key) = win 0x1dff60;
    bool hasUserCoin(char const* key) = win 0x1dfd20;
    void incrementActivePath(int amount) = win inline, imac 0x6b910, m1 0x5cef8 {
        this->trySelectActivePath();
        if (m_activePath < 30 || m_activePath > 39) return;
        this->incrementStat(GameToolbox::intToString(m_activePath).c_str(), amount);
    }
    void incrementChallenge(GJChallengeType type, int amount) = win 0x1e2100, imac 0x6b6c0;
    void incrementStat(char const* key) = win inline, imac 0x67030, m1 0x58eb8 {
        this->incrementStat(key, 1);
    }
    void incrementStat(char const* key, int amount) = win 0x1d4510, imac 0x67040, m1 0x58ec0;
    bool isGauntletChestUnlocked(int id) = win inline {
        return this->isSpecialChestUnlocked(this->getGauntletRewardKey(id));
    }
    bool isItemEnabled(UnlockType type, int id) = win inline, imac 0x778a0, m1 0x69000 {
        return this->isItemUnlocked(type, id) && m_enabledItems->valueForKey(this->getItemKey(id, (int)type))->boolValue();
    }
    bool isItemUnlocked(UnlockType type, int id) = win 0x1e5860, imac 0x6b9b0, m1 0x5cfcc;
    bool isPathChestUnlocked(int path) = win inline {
        return this->isSpecialChestUnlocked(this->getPathRewardKey(path));
    }
    bool isPathUnlocked(StatKey key) = win inline, imac 0x6b990, m1 0x5cfa4, ios inline {
        return this->isItemUnlocked(UnlockType::GJItem, (int)key - 24);
    }
    bool isSecretChestUnlocked(int id) = win 0x1ea8a0;
    bool isSecretCoin(gd::string key) = win inline, imac 0x70660, m1 0x61da4, ios inline {
        return key.starts_with("unique_");
    }
    bool isSecretCoinValid(gd::string key) = win 0x1e0100, imac 0x70690, m1 0x61dd4;
    bool isSpecialChestLiteUnlockable(gd::string key) = win inline, ios inline {
        return m_specialChestsLite && m_specialChestsLite->objectForKey(key) != nullptr;
    }
    bool isSpecialChestUnlocked(gd::string key) = win 0x1ea530, imac 0x77420, m1 0x68b10;
    bool isStoreItemUnlocked(int index);
    int keyCostForSecretChest(int id) = win inline, imac 0x76f40, m1 0x68618 {
        if (id < 1001) return 1;
        if (id < 2001) return 5;
        if (id < 3001) return 10;
        if (id < 4001) return 25;
        if (id < 5001) return 50;
        if (id < 6001) return 100;
        return 1;
    }
    void linkSpecialChestUnlocks(GJRewardItem* item, gd::string key) = win 0x1e9fd0, imac 0x77f00, m1 0x6969c;
    void logCoins() = m1 0x80344;
    void markLevelAsCompletedAndClaimed(GJGameLevel* level) = win 0x1de950, imac 0x6e080, m1 0x5f908;
    void postLoadGameStats();
    void preProcessReward(GJRewardItem* item) = win 0x1e1b10, imac 0x727b0, m1 0x6402c;
    void preSaveGameStats() = m1 0x7eb8c;
    void processChallengeQueue(int position) = win 0x1e2960, m1 0x65448;
    void processOnlineChests() = win 0x1f3630, m1 0x1044d4;
    bool purchaseItem(int index) = win 0x1d42f0, imac 0x66ad0;
    void recountSpecialStats() = win 0x1e4490, m1 0x287e8;
    void recountUserCoins(bool force) = win 0x1df400, imac 0x6f250, m1 0x60b6c;
    void registerRewardsFromItem(GJRewardItem* item) = win 0x1f1540, imac 0x726f0, m1 0x63f6c;
    void removeChallenge(int position) = win inline {
        m_activeChallenges->removeObjectForKey(cocos2d::CCString::createWithFormat("%i", position)->getCString());
    }
    void removeErrorFromSpecialChests() = win 0x1f3820;
    void removeQueuedChallenge(int position) = win inline {
        m_upcomingChallenges->removeObjectForKey(cocos2d::CCString::createWithFormat("%i", position)->getCString());
    }
    void removeQueuedSecondaryChallenge(int position) = win inline {
        m_upcomingChallenges->removeObjectForKey(cocos2d::CCString::createWithFormat("%i", position + 100)->getCString());
    }
    void resetChallengeTimer() = win inline, imac 0x72dc0, m1 0x64700 {
        m_challengeTime = 0;
    }
    void resetPreSync() = win inline, imac 0x8ec40, m1 0x8033c, ios inline {}
    void resetSpecialChest(gd::string key) = win inline, m1 0x5e31c, ios inline {
        m_miscChests->removeObjectForKey(key);
    }
    void resetSpecialStatAchievements() = win 0x1e52f0, m1 0x6866c;
    void resetUserCoins() = win inline, m1 0x60b34, ios inline {
        this->setStat("12", 0);
        m_verifiedUserCoins->removeAllObjects();
        m_pendingUserCoins->removeAllObjects();
    }
    void restorePostSync() = win inline, imac 0x8ec50, m1 0x80340, ios inline {}
    void setAwardedBonusKeys(int keys) {
        m_bonusKey = keys;
    }
    void setStarsForMapPack(int id, int stars) = win 0x1df0a0, m1 0x60220;
    void setStat(char const* key, int value) = win 0x1d5310, imac 0x66e50;
    void setStatIfHigher(char const* key, int value) = win inline, ios inline {
        if (value > this->getStat(key)) this->setStat(key, value);
    }
    void setupIconCredits() = win 0x1c4150, imac 0x32b290, m1 0x2b7e98;
    ShopType shopTypeForItemID(int index) = win inline, m1 0x58e94, ios inline {
        if (auto item = this->getStoreItem(index)) {
            return item->m_shopType;
        }
        return ShopType::Normal;
    }
    bool shouldAwardSecretKey() = win inline, m1 0x7e05c, ios inline {
        return m_bonusKey.value() < this->getStat("22") / 500.f;
    }
    int starsForMapPack(int id) = win inline {
        return m_completedMappacks->valueForKey(this->getMapPackKey(id))->intValue();
    }
    void storeChallenge(int position, GJChallengeItem* challenge) = win inline {
        m_activeChallenges->setObject(challenge, cocos2d::CCString::createWithFormat("%i", position)->getCString());
    }
    void storeChallengeTime(int remaining) = win inline, imac 0x72d60, m1 0x6469c {
        __timeb64 current;
        _ftime64_s(&current);
        m_challengeTime = ((current.time & 0xfffff) * 1000 + current.millitm) / 1000.0;
    }
    void storeEventChest(int eventID, GJRewardItem* item) = win inline, imac 0x73e40, m1 0x6582c {
        if (item) m_eventChest->setObject(item, this->getDailyLevelKey(eventID));
    }
    void storeOnlineChest(gd::string key, GJRewardItem* item) = win inline, m1 0x661a8 {
        if (item) m_allSpecialChests->setObject(item, key);
    }
    void storePendingUserCoin(char const* key) = win inline {
        m_pendingUserCoins->setObject(m_trueString, key);
    }
    void storeQueuedChallenge(int position, GJChallengeItem* challenge) = win 0x1e1da0;
    void storeRewardState(GJRewardType type, int id, int remaining, gd::string str) = win 0x1e1920, imac 0x72100, m1 0x639b4;
    void storeSecondaryQueuedChallenge(int position, GJChallengeItem* challenge) = win inline, m1 0x64b50 {
        m_upcomingChallenges->setObject(challenge, cocos2d::CCString::createWithFormat("%i", position + 100)->getCString());
    }
    void storeSecretCoin(char const* key) = m1 0x61c94;
    void storeUserCoin(char const* key) = win 0x1dfde0;
    void tempClear() = win inline, imac 0x70bc0, ios inline {}
    void toggleEnableItem(UnlockType type, int id, bool enabled) = win 0x1e5c10, imac 0x77930, m1 0x690a8;
    void tryFixPathBug() = win 0x1d4820;
    void trySelectActivePath() = win 0x1d46a0, imac 0x6bbe0, m1 0x5d248;
    void uncompleteLevel(GJGameLevel* level) = win 0x1debd0, imac 0x427b60, m1 0x5fc3c;
    GJRewardItem* unlockGauntletChest(int id) = win inline, m1 0x69f30 {
        if (auto reward = this->unlockSpecialChest(this->getGauntletRewardKey(id))) {
            this->incrementStat("40");
            return reward;
        }
        return nullptr;
    }
    GJRewardItem* unlockGoldChest(int id) = win inline, m1 0x7ddec {
        if (!this->isSecretChestUnlocked(id)) {
            if (auto reward = this->getRewardForSecretChest(id)) {
                auto keys = this->getStat("43");
                if (keys > 0) {
                    this->setStat("43", keys - 1);
                    this->preProcessReward(reward);
                    this->registerRewardsFromItem(reward);
                    m_treasureRoomChests->setObject(reward, cocos2d::CCString::createWithFormat("%i", id)->getCString());
                    return reward;
                }
            }
        }
        return nullptr;
    }
    GJRewardItem* unlockOnlineChest(gd::string key) = win 0x1ea7e0, imac 0x74800, m1 0x661c4;
    GJRewardItem* unlockPathChest(int id) = win inline {
        return this->unlockSpecialChest(this->getPathRewardKey(id));
    }
    GJRewardItem* unlockSecretChest(int id) = win 0x1ea970, m1 0x7dc14;
    GJRewardItem* unlockSpecialChest(gd::string key) = win 0x1ea620, imac 0x784d0, m1 0x69c58;
    void updateActivePath(StatKey key) = win inline, imac 0x6bbc0, m1 0x5d234 {
        m_activePath = key >= StatKey::FirePath && key <= StatKey::SoulPath ? (int)key : 0;
    }
    gd::string usernameForAccountID(int id) = win inline, m1 0x2b7e28 {
        if (auto it = m_usernameForAccountID.find(id); it != m_usernameForAccountID.end()) {
            return it->second;
        }
        return "";
    }
    void verifyPathAchievements() = win 0x1d4f90, imac 0x6cbb0, m1 0x5e324;
    void verifyUserCoins() = win 0x1dfc40, m1 0x610ac;

    bool m_usePlayerStatsCCDictionary;
    cocos2d::CCString* m_trueString;
    cocos2d::CCDictionary* m_allStoreItems;
    cocos2d::CCDictionary* m_storeItems;
    cocos2d::CCDictionary* m_allTreasureRoomChests;
    cocos2d::CCDictionary* m_allTreasureRoomChestItems;
    cocos2d::CCDictionary* m_allSpecialChests;
    cocos2d::CCDictionary* m_allSpecialChestItems;
    gd::unordered_map<gd::string, gd::string> m_specialRewardDescriptions;
    gd::unordered_map<gd::string, gd::string> m_createSpecialChestItemsMap;
    cocos2d::CCDictionary* m_specialChestsLite;
    cocos2d::CCArray* m_storeItemArray;
    cocos2d::CCDictionary* m_rewardItems;
    cocos2d::CCDictionary* m_dailyChests;
    cocos2d::CCDictionary* m_worldAdvertChests;
    cocos2d::CCDictionary* m_activeChallenges;
    cocos2d::CCDictionary* m_upcomingChallenges;
    double m_challengeTime;
    cocos2d::CCDictionary* m_playerStats;
    gd::unordered_map<int, int> m_playerStatsRandMap;
    gd::unordered_map<int, int> m_playerStatsSeedMap;
    cocos2d::CCDictionary* m_completedLevels;
    cocos2d::CCDictionary* m_verifiedUserCoins;
    cocos2d::CCDictionary* m_pendingUserCoins;
    cocos2d::CCDictionary* m_purchasedItems;
    cocos2d::CCDictionary* m_onlineCurrencyScores;
    cocos2d::CCDictionary* m_mainCurrencyScores;
    cocos2d::CCDictionary* m_gauntletCurrencyScores;
    cocos2d::CCDictionary* m_timelyCurrencyScores;
    cocos2d::CCDictionary* m_onlineStars;
    cocos2d::CCDictionary* m_timelyStars;
    cocos2d::CCDictionary* m_gauntletDiamondScores;
    cocos2d::CCDictionary* m_timelyDiamondScores;
    cocos2d::CCDictionary* m_unusedCurrencyAwardDict;
    cocos2d::CCDictionary* m_challengeDiamonds;
    cocos2d::CCDictionary* m_completedMappacks;
    cocos2d::CCDictionary* m_completedLists;
    cocos2d::CCDictionary* m_weeklyChest;
    cocos2d::CCDictionary* m_eventChest;
    cocos2d::CCDictionary* m_treasureRoomChests;
    geode::SeedValueRSV m_bonusKey;
    cocos2d::CCDictionary* m_miscChests;
    cocos2d::CCDictionary* m_enabledItems;
    cocos2d::CCDictionary* m_wraithChests;
    bool m_skipIncrementChallenge;
    cocos2d::CCDictionary* m_unk390;
    cocos2d::CCDictionary* m_unkDict;
    cocos2d::CCDictionary* m_unlockedItems;
    gd::map<std::pair<int, UnlockType>, int> m_accountIDForIcon;
    gd::map<int, gd::string> m_usernameForAccountID;
    gd::set<std::pair<UnlockType, int>> m_wraithIcons;
    bool m_pathBugFixed;
    bool m_tryFixPathBug;
    int m_activePath;
}

[[link(android)]]
class GameToolbox {
    static void addBackButton(cocos2d::CCLayer* parent, cocos2d::CCMenuItem* menuItem) = win 0x65060, imac 0x4ef220, m1 0x4490a8;
    static void addRThumbScrollButton(cocos2d::CCLayer* parent) = win 0x65140, m1 0x449190;
    static void alignItemsHorisontally(cocos2d::CCArray* items, float gap, cocos2d::CCPoint position, bool skipSize) = win 0x64160, imac 0x4edd20, m1 0x447c7c;
    static void alignItemsVertically(cocos2d::CCArray* items, float gap, cocos2d::CCPoint position) = win inline, imac 0x4ee050, m1 0x2afd64 {
        auto y = -gap;
        for (auto obj : geode::cocos::CCArrayExt<cocos2d::CCObject*, false>(items)) {
            auto node = static_cast<cocos2d::CCNode*>(obj);
            y += node->getScaleY() * node->getContentSize().height + gap;
        }

        y = -y / 2.f;
        for (auto obj : geode::cocos::CCArrayExt<cocos2d::CCObject*, false>(items)) {
            auto node = static_cast<cocos2d::CCNode*>(obj);
            auto size = node->getContentSize();
            auto scale = node->getScaleY();
            node->setPosition({ 0.f, scale * size.height / 2.f + y });
            node->setPosition(node->getPosition() + position);
            y += scale * size.height + gap;
        }
    }
    static float bounceTime(float time) = win 0x68ae0, m1 0x44f384;
    static cocos2d::ccColor3B colorToSepia(cocos2d::ccColor3B color, float factor) = win inline, imac 0x72b30, m1 0x4495f0, ios inline {
        cocos2d::ccColor3B sepia;
        sepia.r = std::min<uint8_t>(255, color.r * 0.393 + color.g * 0.769 + color.b * 0.189);
        sepia.g = std::min<uint8_t>(255, color.r * 0.349 + color.g * 0.686 + color.b * 0.168);
        sepia.b = std::min<uint8_t>(255, color.r * 0.272 + color.g * 0.534 + color.b * 0.131);
        return factor < 1.f ? GameToolbox::multipliedColorValue(color, sepia, factor) : sepia;
    }
    static void contentScaleClipRect(cocos2d::CCRect& rect) = win inline, imac 0x4ee6a0, m1 0x448578, ios inline {}
    static gd::string createHashString(gd::string const& str, int length) = win inline, imac 0x4f0eb0, m1 0x44acc8, ios inline {
        std::string ret;
        if (length > 0) {
            auto strSize = str.size();
            if (length > strSize) ret = str;
            else {
                int increment = (float)strSize / (float)length;
                for (int i = 0; i < length; i += increment) {
                    ret += str[i];
                }
            }
        }
        return ret;
    }
    static CCMenuItemToggler* createToggleButton(gd::string label, cocos2d::SEL_MenuHandler selector, bool state, cocos2d::CCMenu* menu, cocos2d::CCPoint position, cocos2d::CCNode* parent, cocos2d::CCNode* labelParent, cocos2d::CCArray* container) = win inline, imac 0x4ee700, m1 0x4485bc {
        return GameToolbox::createToggleButton(label, selector, state, menu, position, parent, labelParent, .7f, .5f, 80.f, { 8.f, 0.f }, "bigFont.fnt", false, 0, container);
    }
    static CCMenuItemToggler* createToggleButton(gd::string label, cocos2d::SEL_MenuHandler selector, bool state, cocos2d::CCMenu* menu, cocos2d::CCPoint position, cocos2d::CCNode* parent, cocos2d::CCNode* labelParent, float buttonScale, float maxLabelScale, float maxLabelWidth, cocos2d::CCPoint labelOffset, char const* font, bool labelTop, int labelTag, cocos2d::CCArray* container) = win 0x646c0, imac 0x4ee830, m1 0x4486f8;
    static bool doWeHaveInternet() = win inline, m1 0x4480c4 {
        return true;
    }
    static gd::string easeToText(int easingType) = win 0x685c0, imac 0x4f5f90, m1 0x44f070;
    static uint64_t fast_rand() = win inline, imac 0x4f13a0, m1 0x44b1c8, ios inline {
        auto value = GameToolbox::getfast_srand() * 214013 + 2531011;
        GameToolbox::fast_srand(value);
        return value >> 16 & 32767;
    }
    static float fast_rand_0_1() = win inline, imac 0x4f13d0, m1 0x44b1f0 {
        return GameToolbox::fast_rand() / 32767.f;
    }
    static float fast_rand_minus1_1() = win inline, imac 0x4f1410, m1 0x44b22c {
        return GameToolbox::fast_rand_0_1() * 2.f - 1.f;
    }
    static void fast_srand(uint64_t seed) = win inline, imac 0x4f1380, m1 0x44b1b0 {
        *reinterpret_cast<uint64_t*>(geode::base::get() + 0x6a4e20) = seed;
    }
    static gd::string gen_random(int length) = win 0x66090, imac 0x4f1230, m1 0x44b030;
    static cocos2d::CCSequence* getDropActionWDelay(float delay, float duration, float scale, cocos2d::CCNode* target, cocos2d::SEL_CallFunc selector) = win inline, ios inline {
        auto scaleAndFade = cocos2d::CCSpawn::create(
            cocos2d::CCEaseExponentialIn::create(cocos2d::CCScaleTo::create(duration, scale)),
            cocos2d::CCEaseExponentialIn::create(cocos2d::CCFadeIn::create(duration)),
            nullptr
        );
        auto delayTime = cocos2d::CCDelayTime::create(delay);
        if (target) {
            return cocos2d::CCSequence::create(delayTime, scaleAndFade, cocos2d::CCCallFunc::create(target, selector), nullptr);
        }
        else {
            return cocos2d::CCSequence::create(delayTime, scaleAndFade, nullptr);
        }
    }
    static cocos2d::CCSequence* getDropActionWEnd(float delay, float duration, float scale, cocos2d::CCAction* action, float actionDelay) = win inline, imac 0x4edc80, m1 0x447bdc, ios inline {
        return cocos2d::CCSequence::create(
            GameToolbox::getDropActionWDelay(delay, duration, scale, nullptr, nullptr),
            cocos2d::CCDelayTime::create(actionDelay),
            action,
            nullptr
        );
    }
    static cocos2d::CCActionInterval* getEasedAction(cocos2d::CCActionInterval* action, int easingType, float easingRate) = win inline, m1 0x44af74, ios inline {
        if (easingType == 0) return action;
        if (easingRate <= 0.f) easingRate = 2.f;
        switch (easingType) {
            case 1: return cocos2d::CCEaseInOut::create(action, easingRate);
            case 2: return cocos2d::CCEaseIn::create(action, easingRate);
            case 3: return cocos2d::CCEaseOut::create(action, easingRate);
            case 4: return cocos2d::CCEaseElasticInOut::create(action, easingRate);
            case 5: return cocos2d::CCEaseElasticIn::create(action, easingRate);
            case 6: return cocos2d::CCEaseElasticOut::create(action, easingRate);
            case 7: return cocos2d::CCEaseBounceInOut::create(action);
            case 8: return cocos2d::CCEaseBounceIn::create(action);
            case 9: return cocos2d::CCEaseBounceOut::create(action);
            case 10: return cocos2d::CCEaseExponentialInOut::create(action);
            case 11: return cocos2d::CCEaseExponentialIn::create(action);
            case 12: return cocos2d::CCEaseExponentialOut::create(action);
            case 13: return cocos2d::CCEaseSineInOut::create(action);
            case 14: return cocos2d::CCEaseSineIn::create(action);
            case 15: return cocos2d::CCEaseSineOut::create(action);
            case 16: return cocos2d::CCEaseBackInOut::create(action);
            case 17: return cocos2d::CCEaseBackIn::create(action);
            case 18: return cocos2d::CCEaseBackOut::create(action);
            default: return action;
        }
    }
    static float getEasedValue(float value, int easingType, float easingRate) = win 0x68b90, m1 0x44f46c;
    static uint64_t getfast_srand() = win inline, imac 0x4f1390, m1 0x44b1bc, ios inline {
        return *reinterpret_cast<uint64_t*>(geode::base::get() + GEODE_WINDOWS(0x6a4e20) GEODE_IOS(0x85d890));
    }
    static int getInvertedEasing(int easingType) = win inline, m1 0x44aff4, ios inline {
        switch (easingType) {
            case 2: return 3;
            case 3: return 2;
            case 5: return 6;
            case 6: return 5;
            case 8: return 9;
            case 9: return 8;
            case 11: return 12;
            case 12: return 11;
            case 14: return 15;
            case 15: return 14;
            case 17: return 18;
            case 18: return 17;
            default: return easingType;
        }
    }
    static cocos2d::CCDictionary* getLargestMergedIntDicts(cocos2d::CCDictionary* dict1, cocos2d::CCDictionary* dict2) = win inline, m1 0x448b94, ios inline {
        if (dict2->count() > dict1->count()) {
            GameToolbox::mergeDictsSaveLargestInt(dict2, dict1);
            return dict2;
        }
        else {
            GameToolbox::mergeDictsSaveLargestInt(dict1, dict2);
            return dict1;
        }
    }
    static cocos2d::ccHSVValue getMultipliedHSV(cocos2d::ccHSVValue const& value, float factor) = win inline, imac 0x4ef910, m1 0x44977c {
        cocos2d::ccHSVValue ret;
        ret.h = value.h * factor;
        ret.s = value.absoluteSaturation ? value.s * factor : value.s * factor + (1.f - factor);
        ret.v = value.absoluteBrightness ? value.v * factor : value.v * factor + (1.f - factor);
        ret.absoluteSaturation = value.absoluteSaturation;
        ret.absoluteBrightness = value.absoluteBrightness;
        return ret;
    }
    static cocos2d::CCPoint getRelativeOffset(GameObject* object, cocos2d::CCPoint offset) = win 0x649c0, imac 0x4eea90, m1 0x44899c;
    static gd::string getResponse(cocos2d::extension::CCHttpResponse* response) = win 0x64360, imac 0x4ee490, m1 0x448348;
    static gd::string getTimeString(int seconds, bool noSeconds) = win 0x65e70, imac 0x4f0f70, m1 0x44ad98;
    static cocos2d::ccHSVValue hsvFromString(gd::string const& str, char const* delim) = win 0x65530, imac 0x4ef9b0, m1 0x4497e8; // on windows, 2nd param is ignored and assumed to be "a"
    static gd::string intToShortString(int value) = win 0x69170, imac 0x4f6d30, m1 0x44fec4;
    static gd::string intToString(int value) = win 0x690b0, imac 0x4f6a00, m1 0x44fb98;
    static bool isIOS() = win inline, imac 0x4ee360, m1 0x448224, ios inline {
        #ifdef GEODE_IS_IOS
        return true;
        #else
        return false;
        #endif
    }
    static bool isRateEasing(int easingType) = win inline, imac 0x4f1220, m1 0x44b020 {
        return easingType > 0 && easingType < 7;
    }
    static void mergeDictsSaveLargestInt(cocos2d::CCDictionary* toDict, cocos2d::CCDictionary* fromDict) = win 0x64bc0;
    static void mergeDictsSkipConflict(cocos2d::CCDictionary* toDict, cocos2d::CCDictionary* fromDict) = win 0x64e20;
    static gd::string msToTimeString(int milliseconds, int formattingMode) = win 0x69680, imac 0x4f73b0, m1 0x4504f8;
    static cocos2d::ccColor3B multipliedColorValue(cocos2d::ccColor3B minColor, cocos2d::ccColor3B maxColor, float factor) = win inline, imac 0x4ef6b0, m1 0x44951c {
        if (factor < 1.f) {
            if (factor > 0.f) {
                cocos2d::ccColor3B ret;
                ret.r = (maxColor.r - minColor.r) * factor + minColor.r;
                ret.g = (maxColor.g - minColor.g) * factor + minColor.g;
                ret.b = (maxColor.b - minColor.b) * factor + minColor.b;
                return ret;
            }
            else return minColor;
        }
        else return maxColor;
    }
    static void openAppPage() = win inline, m1 0x448324 {
        cocos2d::CCApplication::sharedApplication()->openURL("https://store.steampowered.com/recommended/recommendgame/322170");
    }
    static void openRateURL(gd::string str1, gd::string str2) = imac 0x4ee370, m1 0x44822c;
    static cocos2d::CCParticleSystemQuad* particleFromString(gd::string const& str, cocos2d::CCParticleSystemQuad* system, bool dontUpdate) = win inline, imac 0x4f5970, m1 0x44eac8 {
        cocos2d::ParticleStruct ret;
        GameToolbox::particleStringToStruct(str, ret);
        return GameToolbox::particleFromStruct(ret, system, dontUpdate);
    }
    static cocos2d::CCParticleSystemQuad* particleFromStruct(cocos2d::ParticleStruct const& particleStruct, cocos2d::CCParticleSystemQuad* system, bool dontUpdate) = win 0x68050, imac 0x4f5a80, m1 0x44ebb4;
    static void particleStringToStruct(gd::string const& str, cocos2d::ParticleStruct& particleStruct) = win 0x67590, imac 0x4f4a20, m1 0x44dc90;
    static gd::string pointsToString(int points) = win 0x697b0, m1 0x2725b4;
    static void postClipVisit() = win inline, m1 0x4485b4 {
        glDisable(GL_SCISSOR_TEST);
    }
    static void preVisitWithClippingRect(cocos2d::CCNode* node, cocos2d::CCRect rect) = win 0x64610, imac 0x41b810, m1 0x4484cc;
    static void preVisitWithClipRect(cocos2d::CCRect rect) = win inline, imac 0x4ee6b0, m1 0x44857c {
        glEnable(GL_SCISSOR_TEST);
        GameToolbox::contentScaleClipRect(rect);
        cocos2d::CCDirector::sharedDirector()->getOpenGLView()->setScissorInPoints(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);
    }
    static gd::string saveParticleToString(cocos2d::CCParticleSystemQuad* system) = win 0x66320, imac 0x4f1450, m1 0x44b274;
    static bool saveStringToFile(gd::string const& path, gd::string const& content) = win inline, imac 0x4f6be0, m1 0x44fd38, ios inline {
        #ifdef GEODE_IS_WINDOWS
        FILE* file = nullptr;
        fopen_s(&file, (cocos2d::CCFileUtils::sharedFileUtils()->getWritablePath() + path).c_str(), "w");
        #else
        auto file = fopen((cocos2d::CCFileUtils::sharedFileUtils()->getWritablePath() + path).c_str(), "w");
        #endif
        if (!file) return false;
        auto result = fwrite(content.c_str(), 1, content.size(), file);
        fclose(file);
        return result == content.size();
    }
    static gd::string stringFromHSV(cocos2d::ccHSVValue value, char const* separator) = win 0x65740, imac 0x4efed0, m1 0x449d80;
    static cocos2d::CCDictionary* stringSetupToDict(gd::string const& str, char const* separator) = win 0x65c80, imac 0x1b9120, m1 0x44a60c;
    static void stringSetupToMap(gd::string const& str, char const* separator, gd::map<gd::string, gd::string>& setup) = win 0x658e0, imac 0x5797e0, m1 0x44a26c;
    static cocos2d::ccColor3B strongColor(cocos2d::ccColor3B color) = win inline, imac 0x4f0e10, m1 0x44ac30 {
        if (color.r != 255 && color.b != 255 && color.g != 255) {
            auto factor = std::min(1.5f, 255.f / std::max({ color.r, color.g, color.b }));
            color.r *= factor;
            color.g *= factor;
            color.b *= factor;
        }
        return color;
    }
    static gd::string timestampToHumanReadable(time_t timestamp) = win 0x69310, imac 0x4f7190, m1 0x450298;
    static cocos2d::ccColor3B transformColor(cocos2d::ccColor3B const& color, cocos2d::ccHSVValue hsv) = win 0x652e0, m1 0x449360;
    static cocos2d::ccColor3B transformColor(cocos2d::ccColor3B const& color, float h, float s, float v) = win inline, imac 0x4ef480, m1 0x449344 {
        return GameToolbox::transformColor(color, { h, s, v, true, true });
    }
}

[[link(android)]]
class GauntletLayer : cocos2d::CCLayer, LevelManagerDelegate {
    GauntletLayer() {
        m_levels = nullptr;
        m_loadingCircle = nullptr;
        m_backgroundSprite = nullptr;
        m_unkPtr = nullptr;
        m_activeItemButton = nullptr;
        m_activeObjects = nullptr;
        m_tryAgainText = nullptr;
    }
    ~GauntletLayer() = win inline, m1 0x3183e4 {
        auto glm = GameLevelManager::sharedState();
        if (glm->m_levelManagerDelegate == this) glm->m_levelManagerDelegate = nullptr;
        CC_SAFE_RELEASE(m_activeObjects);
    }

    static GauntletLayer* create(GauntletType type) = win inline, imac 0x392520, m1 0x3187a8 {
        auto ret = new GauntletLayer();
        if (ret->init(type)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static cocos2d::CCScene* scene(GauntletType type) = win 0x1f5e30, m1 0x3186c0;

    virtual void keyBackClicked() = win 0x1f84a0, m1 0x31a8f8, imac 0x394780;
    virtual void loadLevelsFinished(cocos2d::CCArray* levels, char const* key, int type) = win 0x1f6970, m1 0x319de0, imac 0x393d30;
    virtual void loadLevelsFailed(char const* key, int type) = win 0x1f6b80, m1 0x319f74, imac 0x393ed0;

    bool init(GauntletType type) = win 0x1f6180, m1 0x318870;
    void onBack(cocos2d::CCObject* sender) = m1 0x318ecc;
    void onLevel(cocos2d::CCObject* sender) = win 0x1f7dd0, imac 0x394140, m1 0x85f28;
    void setupGauntlet(cocos2d::CCArray* levels) = imac 0x392cb0, m1 0x318f14;
    void unlockActiveItem() = win 0x1f7e40, imac 0x394180, m1 0x31a274;

    cocos2d::CCArray* m_levels;
    LoadingCircle* m_loadingCircle;
    GauntletType m_gauntletType;
    cocos2d::CCSprite* m_backgroundSprite;
    void* m_unkPtr;
    CCMenuItemSpriteExtra* m_activeItemButton;
    cocos2d::CCArray* m_activeObjects;
    TextArea* m_tryAgainText;
}

[[link(android)]]
class GauntletNode : cocos2d::CCNode {
    // virtual ~GauntletNode();
    GauntletNode() {
        m_gauntletInfoNode = nullptr;
        m_rewardNode = nullptr;
        m_gauntlet = nullptr;
        m_locked = false;
    }

    static GauntletNode* create(GJMapPack* gauntlet) = win inline {
        auto ret = new GauntletNode();
        if (ret->init(gauntlet)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static gd::string frameForType(GauntletType type) = win 0x1fde40;
    static gd::string nameForType(GauntletType type);

    bool init(GJMapPack* gauntlet) = win 0x1fc280, imac 0x249310;
    void onClaimReward() = win 0x1fde00, imac 0x572ca0;

    cocos2d::CCNode* m_gauntletInfoNode;
    cocos2d::CCNode* m_rewardNode;
    cocos2d::ccColor3B m_labelColor;
    cocos2d::ccColor3B m_backgroundColor;
    GJMapPack* m_gauntlet;
    bool m_locked;
}

[[link(android)]]
class GauntletSelectLayer : cocos2d::CCLayer, BoomScrollLayerDelegate, LevelManagerDelegate, RewardedVideoDelegate {
    GauntletSelectLayer() {
        m_backgroundSprite = nullptr;
        m_scrollLayer = nullptr;
        m_refreshButton = nullptr;
        m_exiting = false;
        m_playing = false;
        m_tryAgainText = nullptr;
        m_loadingCircle = nullptr;
        m_gauntlets = nullptr;
        m_playBlocked = false;
        m_gauntletID = 0;
        m_videoPlaying = false;
        m_locked = false;
    }
    ~GauntletSelectLayer() = win inline {
        auto glm = GameLevelManager::sharedState();
        if (glm->m_levelManagerDelegate == this) glm->m_levelManagerDelegate = nullptr;
        CC_SAFE_RELEASE(m_gauntlets);
    }

    static GauntletSelectLayer* create(int unused) = win inline {
        auto ret = new GauntletSelectLayer();
        if (ret->init(unused)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static cocos2d::CCScene* scene(int unused) = win 0x1f8b20;

    virtual void onExit() = win 0x1fb070, m1 0x4c0e64, imac 0x573250;
    virtual void keyBackClicked() = win 0x1fa7a0, m1 0x4c0758, imac 0x572bb0;
    virtual void scrollLayerWillScrollToPage(BoomScrollLayer* layer, int page) = win 0x1fa6a0, m1 0x4c0884, imac 0x572ce0;
    virtual void scrollLayerScrolledToPage(BoomScrollLayer* layer, int page) = win 0x1fa6a0, imac 0x572b10, m1 0x4c06b8;
    virtual void loadLevelsFinished(cocos2d::CCArray* gauntlets, char const* key, int type) = win 0x1f9a30, imac 0x572a70, m1 0x4c0618;
    virtual void loadLevelsFailed(char const* key, int type) = win 0x1f9bf0, m1 0x4bfbe8, imac 0x571fa0;

    void goToPage(int page, bool instant) = win 0x1fa530, m1 0x4c051c;
    bool init(int unused) = win 0x1f8c70;
    void onBack(cocos2d::CCObject* sender);
    void onInfo(cocos2d::CCObject* sender) = win 0x1f97d0, imac 0x571950, m1 0x4bf5dc;
    void onNext(cocos2d::CCObject* sender) = win 0x1fa4f0, imac 0x5718c0;
    void onPlay(cocos2d::CCObject* sender) = win 0x1fa7b0;
    void onPrev(cocos2d::CCObject* sender) = win 0x1fa510, imac 0x5718a0, m1 0x4bf540;
    void onRefresh(cocos2d::CCObject* sender) = win 0x1f9910, imac 0x571a00, m1 0x4bf698;
    void setupGauntlets() = win 0x1f9d70;
    void unblockPlay() = imac 0x572a60;
    void updateArrows() = win inline, imac 0x571f50, m1 0x4bfb98, ios inline {
        m_leftButton->setVisible(m_scrollLayer != nullptr);
        m_rightButton->setVisible(m_scrollLayer != nullptr);
    }

    cocos2d::CCSprite* m_backgroundSprite;
    BoomScrollLayer* m_scrollLayer;
    CCMenuItemSpriteExtra* m_leftButton;
    CCMenuItemSpriteExtra* m_rightButton;
    CCMenuItemSpriteExtra* m_refreshButton;
    bool m_exiting;
    bool m_playing;
    TextArea* m_tryAgainText;
    LoadingCircle* m_loadingCircle;
    cocos2d::CCDictionary* m_gauntlets;
    bool m_playBlocked;
    int m_gauntletID;
    bool m_videoPlaying;
    bool m_locked;
}

[[link(android)]]
class GauntletSprite : cocos2d::CCNode {
    // virtual ~GauntletSprite();
    GauntletSprite() {}

    static GauntletSprite* create(GauntletType type, bool locked) = win inline, imac 0x394070, m1 0x31a10c {
        auto ret = new GauntletSprite();
        if (ret->init(type, locked)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    void addLockedSprite() = win 0xc9650, m1 0x31ab1c;
    void addNormalSprite() = win inline, imac 0x3948b0, m1 0x31aa20 {
        auto normalSprite = cocos2d::CCSprite::createWithSpriteFrameName(GauntletNode::frameForType(m_gauntletType).c_str());
        this->addChild(normalSprite);
        normalSprite->setPosition(this->getContentSize() / 2);
    }
    cocos2d::ccColor3B colorForType(GauntletType type) = win inline, ios inline {
        switch (type) {
            case GauntletType::Fire: return { 255, 200, 200 };
            case GauntletType::Lava: return { 200, 200, 200 };
            case GauntletType::Bonus: return { 225, 225, 100 };
            case GauntletType::Monster: return { 200, 200, 200 };
            case GauntletType::Doom: return { 200, 200, 200 };
            default: return { 225, 225, 225 };
        }
    }
    bool init(GauntletType type, bool locked) = win inline {
        if (!CCNode::init()) return false;

        m_gauntletType = type;
        this->setContentSize({ 60.0f, 60.0f });
        this->toggleLockedSprite(locked);

        return true;
    }
    float luminanceForType(GauntletType type) = win inline {
        switch (type) {
            case GauntletType::Fire: return 1.1f;
            case GauntletType::Ice: return 0.9f;
            case GauntletType::Shadow: return 1.6f;
            case GauntletType::Lava: return 1.3f;
            case GauntletType::Bonus: return 0.9f;
            case GauntletType::Chaos: return 1.5f;
            case GauntletType::Spike: return 0.8f;
            default: return 1.0f;
        }
    }
    void toggleLockedSprite(bool locked) = win 0x1f8830, imac 0x394750, m1 0x31a8b8;

    GauntletType m_gauntletType;
}

[[link(android)]]
class GhostTrailEffect : cocos2d::CCNode {
    // virtual ~GhostTrailEffect();
    //GhostTrailEffect() = ios 0x305d20;

    static GhostTrailEffect* create() = win 0x6a020, imac 0x5f9500, m1 0x5220a8;

    virtual bool init() = win 0x6a100, imac 0x5f95d0, m1 0x522178;
    virtual void draw() = win inline, m1 0x5226e0, imac 0x5f9b80 {}

    void doBlendAdditive() = win inline, imac 0x5f9b60, m1 0x5226d0 {
        m_blendFunc.src = GL_SRC_ALPHA;
        m_blendFunc.dst = GL_ONE;
    }
    void runWithTarget(cocos2d::CCSprite* sprite, float snapshotInterval, float fadeInterval, float duration, float ghostScale, bool scaleTwice) = win inline, imac 0x5f9630, m1 0x5221d4 {
        m_iconSprite = sprite;
        m_snapshotInterval = snapshotInterval;
        m_fadeInterval = fadeInterval;
        if (ghostScale <= .1f) ghostScale = .1f;
        m_scaleTwice = scaleTwice;
        m_ghostScale = ghostScale;
        this->schedule(schedule_selector(GhostTrailEffect::trailSnapshot), snapshotInterval);
        if (duration > 0.f) this->runAction(cocos2d::CCSequence::create(
            cocos2d::CCDelayTime::create(duration),
            cocos2d::CCCallFunc::create(this, callfunc_selector(GhostTrailEffect::stopTrail)),
            nullptr
        ));
    }
    void stopTrail() = win inline, m1 0x522680 {
        this->unscheduleAllSelectors();
        this->stopAllActions();
        this->removeMeAndCleanup();
    }
    void trailSnapshot(float dt) = win 0x6a160, imac 0x8ea80, m1 0x522288;

    float m_snapshotInterval;
    float m_fadeInterval;
    float m_ghostScale;
    bool m_scaleTwice;
    float m_playerScale;
    cocos2d::ccBlendFunc m_blendFunc;
    cocos2d::CCSprite* m_iconSprite;
    PlayerObject* m_playerObject;
    cocos2d::CCLayer* m_objectLayer;
    float m_opacity;
    void* m_delegate;
    cocos2d::ccColor3B m_color;
    cocos2d::CCPoint m_position;
    bool m_unk194;
}

[[link(android)]]
class GJAccountBackupDelegate {
    virtual void backupAccountFinished() {}
    virtual void backupAccountFailed(BackupAccountError errorType, int response) {}
}

[[link(android)]]
class GJAccountDelegate {
    virtual void accountStatusChanged() {}
}

[[link(android)]]
class GJAccountLoginDelegate {
    virtual void loginAccountFinished(int accountID, int userID) {}
    virtual void loginAccountFailed(AccountError errorType) {}
}

[[link(android)]]
class GJAccountManager : cocos2d::CCNode {
    // virtual ~GJAccountManager();
    // GJAccountManager();

    static GJAccountManager* get() {
        return GJAccountManager::sharedState();
    }
    static GJAccountManager* sharedState() = win 0x200010, imac 0xcf140, m1 0xb6528;

    virtual bool init() = win 0x2005d0, m1 0xb8b0c, imac 0xd1bb0;

    void addDLToActive(char const* tag) = win inline, ios inline {
        this->addDLToActive(tag, cocos2d::CCNode::create());
    }
    void addDLToActive(char const* tag, cocos2d::CCObject* object) = win inline {
        m_activeDownloads->setObject(object, tag);
    }
    bool backupAccount(gd::string url) = win 0x2019b0, m1 0xb9cc0;
    void dataLoaded(DS_Dictionary* dict) = win inline, imac 0xd3fa0, m1 0xbad94 {
        m_username = dict->getStringForKey("GJA_001");
        m_accountID = dict->getIntegerForKey("GJA_003");
        m_password = dict->getStringForKey("GJA_002");
        m_GJP2 = dict->getStringForKey("GJA_005");
        if (!m_password.empty() && m_GJP2.empty()) {
            m_GJP2 = this->getShaPassword(m_password);
        }
    }
    void encodeDataTo(DS_Dictionary* dict) = win inline, imac 0xd3f40 {
        dict->setStringForKey("GJA_001", m_username);
        dict->setIntegerForKey("GJA_003", m_accountID);
        dict->setStringForKey("GJA_005", m_GJP2);
    }
    void firstSetup() = win inline, imac 0xd3f30 {}
    bool getAccountBackupURL() = win 0x201390;
    bool getAccountSyncURL() = win 0x2022f0;
    cocos2d::CCObject* getDLObject(char const* tag) = win inline {
        return m_activeDownloads->objectForKey(tag);
    }
    gd::string getShaPassword(gd::string password) = win 0x2040a0, imac 0xd4160, m1 0xbaf68;
    void handleIt(bool success, gd::string response, gd::string tag, GJHttpType type) = win 0x200380, imac 0xcf570, m1 0xb6918;
    void handleItDelayed(bool success, gd::string response, gd::string tag, GJHttpType type) = win inline, ios inline {
        auto result = GJHttpResult::create(true, response, tag, type);
        result->retain();
        m_pActionManager->addAction(cocos2d::CCSequence::create(
            cocos2d::CCDelayTime::create(.1f),
            cocos2d::CCCallFuncND::create(this, callfuncND_selector(GJMultiplayerManager::handleItND), result),
            nullptr
        ), this, false);
    }
    void handleItND(cocos2d::CCNode* node, void* data) = win inline, ios inline {
        auto result = static_cast<GJHttpResult*>(data);
        this->handleIt(result->m_success, result->m_response, result->m_requestTag, result->m_httpType);
        result->release();
    }
    bool isDLActive(char const* tag) = win inline, ios inline {
        return this->getDLObject(tag) != nullptr;
    }
    void linkToAccount(gd::string username, gd::string gjp2, int accountID, int userID) = win 0x2038e0, imac 0xd3850, m1 0xba73c;
    void loginAccount(gd::string username, gd::string gjp2) = win 0x200b40, m1 0xb9124;
    void onBackupAccountCompleted(gd::string response, gd::string tag) = win 0x201ee0, imac 0xd0440, m1 0xb765c;
    void onGetAccountBackupURLCompleted(gd::string response, gd::string tag) = m1 0xb860c;
    void onGetAccountSyncURLCompleted(gd::string response, gd::string tag) = m1 0xb8834;
    void onLoginAccountCompleted(gd::string response, gd::string tag) = win 0x200fa0, imac 0xd00a0, m1 0xb7300;
    void onProcessHttpRequestCompleted(cocos2d::extension::CCHttpClient* client, cocos2d::extension::CCHttpResponse* response);
    void onRegisterAccountCompleted(gd::string response, gd::string tag) = win 0x2009b0, imac 0xcffe0, m1 0xb7224;
    void onSyncAccountCompleted(gd::string response, gd::string tag) = win 0x202b70, imac 0xd0710, m1 0xb7908;
    void onUpdateAccountSettingsCompleted(gd::string response, gd::string tag) = win 0x203f40;
    void ProcessHttpRequest(gd::string url, gd::string params, gd::string tag, GJHttpType type) = win 0x200130, m1 0xb65d4;
    void registerAccount(gd::string response, gd::string tag, gd::string data) = win 0x2006e0, imac 0xd1ef0, m1 0xb8e8c;
    void removeDLFromActive(char const* tag) = win inline {
        m_activeDownloads->removeObjectForKey(tag);
    }
    bool syncAccount(gd::string url) = win 0x202900, m1 0xba48c;
    void unlinkFromAccount() = win inline, imac 0xd3980 {
        m_GJP2 = "";
        m_password = "";
        m_username = "";
        m_accountID = 0;
        auto gameManager = GameManager::sharedState();
        gameManager->m_shouldLoadUnlockValueKeeper = true;
        gameManager->firstLoad();
        gameManager->m_shouldLoadUnlockValueKeeper = false;
        LocalLevelManager::sharedState()->firstLoad();
        if (m_accountDelegate) m_accountDelegate->accountStatusChanged();
        gameManager->accountStatusChanged();
    }
    void updateAccountSettings(int messageStatus, int friendRequestStatus, int commentStatus, gd::string youtube, gd::string twitter, gd::string twitch);

    cocos2d::CCDictionary* m_activeDownloads;
    gd::string m_username;
    int m_accountID;
    int m_unkInt1; // likely VRS for account ID but unimplemented
    int m_unkInt2; // likely VRS for account ID but unimplemented
    gd::string m_GJP2;
    GJAccountRegisterDelegate* m_accountRegisterDelegate;
    GJAccountLoginDelegate* m_accountLoginDelegate;
    GJAccountDelegate* m_accountDelegate;
    GJAccountBackupDelegate* m_backupDelegate;
    GJAccountSyncDelegate* m_syncDelegate;
    GJAccountSettingsDelegate* m_accountSettingsDelegate;
    int m_gameManagerSize;
    int m_localLevelsSize;
    gd::string m_password;
}

[[link(android)]]
class GJAccountRegisterDelegate {
    virtual void registerAccountFinished() {}
    virtual void registerAccountFailed(AccountError errorType) {}
}

[[link(android)]]
class GJAccountSettingsDelegate {
    virtual void updateSettingsFinished() {}
    virtual void updateSettingsFailed() {}
}

[[link(android)]]
class GJAccountSettingsLayer : FLAlertLayer, TextInputDelegate {
    GJAccountSettingsLayer() {
        m_accountID = 0;
        m_messageStatus = 0;
        m_friendStatus = 0;
        m_commentHistoryStatus = 0;
        m_inputs = nullptr;
        m_messageSettings = nullptr;
        m_friendRequestSettings = nullptr;
        m_commentSettings = nullptr;
    }
    ~GJAccountSettingsLayer() = win inline, m1 0x23e1c8 {
        CC_SAFE_RELEASE(m_inputs);
        CC_SAFE_RELEASE(m_messageSettings);
        CC_SAFE_RELEASE(m_friendRequestSettings);
        CC_SAFE_RELEASE(m_commentSettings);
    }

    static GJAccountSettingsLayer* create(int accountID) = win inline {
        auto ret = new GJAccountSettingsLayer();
        if (ret->init(accountID)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyBackClicked() = win 0x294390, imac 0x2a2a40, m1 0x241b6c;
    virtual void textInputShouldOffset(CCTextInputNode* node, float yOffset) = win 0x7b620, m1 0x240c94, imac 0x2a1a20;
    virtual void textInputReturn(CCTextInputNode* node) = win 0x7b680, m1 0x240d64, imac 0x2a1ae0;

    CCMenuItemToggler* createToggleButton(gd::string label, cocos2d::SEL_MenuHandler selector, bool toggled, cocos2d::CCMenu* menu, cocos2d::CCPoint position, float width, float scale) = imac 0x2a0db0, m1 0x2400d4;
    bool init(int accountID) = win 0x292040;
    void onClose(cocos2d::CCObject* sender);
    void onCommentSetting(cocos2d::CCObject* sender);
    void onFriendRequests(cocos2d::CCObject* sender);
    void onMessageSetting(cocos2d::CCObject* sender);
    void onUpdate(cocos2d::CCObject* sender) = win 0x293ed0;
    void updateScoreValues() = win 0x2940b0;

    int m_accountID;
    int m_messageStatus;
    int m_friendStatus;
    int m_commentHistoryStatus;
    cocos2d::CCArray* m_inputs;
    gd::map<int, gd::string> m_links;
    cocos2d::CCArray* m_messageSettings;
    cocos2d::CCArray* m_friendRequestSettings;
    cocos2d::CCArray* m_commentSettings;
}

[[link(android)]]
class GJAccountSyncDelegate {
    virtual void syncAccountFinished() {}
    virtual void syncAccountFailed(BackupAccountError errorType, int response) {}
}

[[link(android)]]
class GJActionManager : cocos2d::CCNode {
    GJActionManager() {
        m_internalActions = nullptr;
    }
    ~GJActionManager() = win inline, m1 0x52f3fc {
        CC_SAFE_RELEASE(m_internalActions);
    }

    static GJActionManager* create() = win inline, m1 0x52f4b4 {
        auto ret = new GJActionManager();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x2005d0, m1 0x52f548, imac 0x609140;

    cocos2d::CCAction* getInternalAction(int id) = win inline, m1 0x52f5bc, ios inline {
        return static_cast<cocos2d::CCAction*>(m_internalActions->objectForKey(id));
    }
    void runInternalAction(cocos2d::CCAction* action, cocos2d::CCNode* target) = win inline, imac 0x609180, m1 0x52f580 {
        m_internalActions->setObject(action, action->getTag());
        action->startWithTarget(target);
    }
    void stopAllInternalActions() = win inline, m1 0x52f618 {
        this->updateInternalActions(0.f, true);
    }
    void stopInternalAction(int id) = win inline, imac 0x6091d0, m1 0x52f5c8 {
        if (auto action = static_cast<cocos2d::CCAction*>(m_internalActions->objectForKey(id))) {
            action->stop();
            m_internalActions->removeObjectForKey(id);
        }
    }
    void updateInternalActions(float dt, bool remove) = win inline, imac 0x6092c0, m1 0x52f6b8 {
        auto keys = m_internalActions->allKeys();
        for (auto obj : geode::cocos::CCArrayExt<cocos2d::CCObject*, false>(keys)) {
            auto key = static_cast<cocos2d::CCInteger*>(obj)->getValue();
            auto action = static_cast<cocos2d::CCAction*>(m_internalActions->objectForKey(key));
            if (action->isDone() || remove) {
                action->stop();
                m_internalActions->removeObjectForKey(key);
            }
            else {
                action->step(dt);
            }
        }
    }

    cocos2d::CCDictionary* m_internalActions;
}

[[link(android)]]
class GJAssetDownloadAction {
    int m_id;
    GJAssetType m_assetType;
    int m_status;
}

[[link(android), depends(GJGameState), depends(PlayerButtonCommand)]]
class GJBaseGameLayer : cocos2d::CCLayer, TriggerEffectDelegate {
    GJBaseGameLayer() = win 0x2cfd50, m1 0xac9fc;
    ~GJBaseGameLayer() = win 0x2057e0, m1 0xea500;

    static float convertToClosestDirection(float angle, float bound) = win 0x22e8e0, imac 0x1381c0, m1 0x10d618;
    static gd::string gameEventToString(GJGameEvent event) = win 0x232560, imac 0x14b110, m1 0x11dac8;
    // GJBaseGameLayer() = ios 0x1256b4;
    static GJBaseGameLayer* get() {
        return GameManager::get()->m_gameLayer;
    }

    virtual void update(float dt) = win 0x237690, m1 0x1225f0, imac 0x150ef0;
    virtual bool init() = win 0x206f70, imac 0x10f980, m1 0xeb1f4;
    virtual void visit() = win 0x246cf0, imac 0x1633d0, m1 0x130f14;
    virtual void postUpdate(float dt) {}
    virtual void checkForEnd() {}
    virtual void testTime() {}
    virtual void updateVerifyDamage() {}
    virtual void updateAttemptTime(float attemptTime) {}
    virtual void updateVisibility(float dt) {}
    virtual void playerTookDamage(PlayerObject* player) {}
    virtual float opacityForObject(GameObject* object) = win 0x237270, imac 0x150ca0, m1 0x1223f0;
    virtual void addToSpeedObjects(EffectGameObject* object) {}
    virtual void objectsCollided(int blockAID, int blockBID) = win 0x2191a0, m1 0x103768, imac 0x12b710;
    virtual void updateColor(cocos2d::ccColor3B& color, float fadeTime, int colorID, bool blending, float opacity, cocos2d::ccHSVValue& copyHSV, int colorIDToCopy, bool copyOpacity, EffectGameObject* callerObject, int unk1, int unk2) = win 0x2239a0, imac 0x13c670, m1 0x1114b0;
    virtual void toggleGroupTriggered(int group, bool activate, gd::vector<int> const& remapKeys, int triggerID, int controlID) = win 0x223b80, imac 0x13c810, m1 0x111618;
    virtual void spawnGroup(int group, bool ordered, double delay, gd::vector<int> const& remapKeys, int triggerID, int controlID) = win 0x21abb0, imac 0x12c890, m1 0x1047a0;
    virtual void spawnObject(GameObject* object, double delay, gd::vector<int> const& remapKeys) = win 0x21b060, imac 0x12cd10, m1 0x104c24;
    virtual void activateEndTrigger(int targetID, bool reverse, bool lockPlayerY) {}
    virtual void activatePlatformerEndTrigger(EndTriggerGameObject* object, gd::vector<int> const& remapKeys) {}
    virtual void toggleGlitter(bool visible) {}
    virtual void destroyPlayer(PlayerObject* player, GameObject* object) {}
    virtual void updateDebugDraw() = win 0x210840, imac 0x121720, m1 0xfa648;
    virtual void addToSection(GameObject* object) = win 0x226530, m1 0x1133a8, imac 0x13e890;
    virtual void addToGroup(GameObject* object, int groupID, bool triggerGroup) = win 0x224000, imac 0x13cd90, m1 0x111b2c;
    virtual void removeFromGroup(GameObject* object, int groupID) = win 0x224180, m1 0x111d88, imac 0x13cfe0;
    virtual void updateObjectSection(GameObject* object) = win 0x227f80, m1 0x11494c, imac 0x140410;
    virtual void updateDisabledObjectsLastPos(cocos2d::CCArray* objects) {}
    virtual void toggleGroundVisibility(bool visible) = win inline, imac 0x14e660, m1 0x1205b4 {}
    virtual void toggleMGVisibility(bool visible) = win inline, imac 0x14e670, m1 0x1205b8 {}
    virtual void toggleHideAttempts(bool hide) = win inline, imac 0x14e680, m1 0x1205bc {}
    virtual float timeForPos(cocos2d::CCPoint position, int order, int channel, bool songTriggers, int id) { return 0.f; }
    virtual cocos2d::CCPoint posForTime(float time) { return { 0.f, 0.f }; }
    virtual void resetSPTriggered() {}
    virtual void updateScreenRotation(float rotation, bool add, bool convert, float duration, int easingType, float easingRate, int uniqueID, int controlID) = win 0x235cc0, m1 0x1206fc, imac 0x14e820;
    virtual void reverseDirection(EffectGameObject* object) = win 0x218190, m1 0x1027cc, imac 0x12a660;
    virtual void rotateGameplay(RotateGameplayGameObject* object) = win 0x2181f0, m1 0x102814, imac 0x12a6a0;
    virtual void didRotateGameplay() {}
    virtual void updateTimeWarp(float timeWarp) = win 0x235f90, imac 0x14ef60, m1 0x120d14;
    virtual void updateTimeWarp(GameObject* object, float timeWarp) = win 0x235f90, m1 0x120d58, imac 0x14efb0;
    virtual void applyTimeWarp(float timeWarp) = win 0x235fe0, m1 0x120d58, imac 0x14efb0;
    virtual void playGravityEffect(bool flip) {}
    virtual void manualUpdateObjectColors(GameObject* object) {}
    virtual cocos2d::CCParticleSystemQuad* createCustomParticle(gd::string const& key, cocos2d::ParticleStruct const& particleStruct, int minimum, bool dontAdd) = win 0x240b90, m1 0x12c7dc, imac 0x15d980;
    virtual cocos2d::CCParticleSystemQuad* claimCustomParticle(gd::string const& key, cocos2d::ParticleStruct const& particleStruct, int zLayer, int zOrder, int uiObject, bool dontAdd) = win 0x240e90, imac 0x15dcf0, m1 0x12cb64;
    virtual void unclaimCustomParticle(gd::string const& key, cocos2d::CCParticleSystemQuad* particle) = win 0x241090, imac 0x15def0, m1 0x12cda4;
    virtual void activatedAudioTrigger(SFXTriggerGameObject* object) = win 0x242c40, imac 0x15ee30, m1 0x12dae0;
    virtual void checkpointActivated(CheckpointGameObject* object) = win 0x2468d0, imac 0x1630f0, m1 0x130c70;
    virtual void flipArt(bool flip) = win inline, m1 0x130c6c, imac 0x1630e0 {}
    virtual void addKeyframe(KeyframeGameObject* object) = win 0x2339c0, imac 0x14b300, m1 0x11dc74;
    virtual void updateTimeLabel(int seconds, int centiseconds, bool decimals) {}
    virtual void checkSnapshot() {}
    virtual void toggleProgressbar() {}
    virtual void toggleInfoLabel() {}
    virtual void removeAllCheckpoints() {}
    virtual void toggleMusicInPractice() {}

    void activateCustomRing(RingObject* object) = win inline, m1 0x10aeac {
        if (object->m_isSpawnOnly) this->spawnGroup(object->m_targetGroupID, false, 0.0, {}, object->m_uniqueID, object->m_controlID);
        else this->toggleGroupTriggered(object->m_targetGroupID, object->m_activateGroup, {}, object->m_uniqueID, object->m_controlID);
    }
    void activatedAudioTrigger(SFXTriggerGameObject* object, float levelTime) = win 0x242c60;
    void activateEventTrigger(EventLinkTrigger* object, gd::vector<int> const& remapKeys) = win 0x231f50;
    void activateItemCompareTrigger(ItemTriggerGameObject* object, gd::vector<int> const& remapKeys) = win 0x234470;
    void activateItemEditTrigger(ItemTriggerGameObject* object) = win 0x234090, m1 0x11e73c;
    void activateObjectControlTrigger(ObjectControlGameObject* object) = win inline, m1 0x101fe8 {}
    void activatePersistentItemTrigger(ItemTriggerGameObject* object) = win 0x234880;
    void activatePlayerControlTrigger(PlayerControlGameObject* object) = win 0x217510;
    void activateResetTrigger(EffectGameObject* object) = win inline, imac 0x14b4f0, m1 0x11de34 {
        auto group = this->getGroup(object->m_targetGroupID);
        if (group && group->count() != 0) {
            for (auto obj : geode::cocos::CCArrayExt<cocos2d::CCObject*, false>(group)) {
                auto gameObject = static_cast<GameObject*>(obj);
                if (gameObject->m_objectID == 2063) {
                    m_effectManager->removeTriggeredID(gameObject->m_uniqueID, m_player1->m_uniqueID);
                    m_effectManager->removeTriggeredID(gameObject->m_uniqueID, m_player2->m_uniqueID);
                    gameObject->restoreObject();
                }
                else if (gameObject->getType() == GameObjectType::Collectible || gameObject->getType() == GameObjectType::Breakable) {
                    m_effectManager->removeTriggeredID(gameObject->m_uniqueID, 0);
                    gameObject->restoreObject();
                }
            }
        }
    }
    void activateSFXEditTrigger(SFXTriggerGameObject* object) = win 0x241c60;
    void activateSFXTrigger(SFXTriggerGameObject* object) = win 0x241a60;
    void activateSongEditTrigger(SongTriggerGameObject* object) = win 0x241750;
    void activateSongTrigger(SongTriggerGameObject* object) = win 0x2413d0;
    void activateTimerTrigger(TimerTriggerGameObject* object, gd::vector<int> const& remapKeys) = win 0x234ca0, imac 0x14d2d0;
    void addAreaEffect(EnterEffectObject* object, gd::vector<EnterEffectInstance>* instances, GJAreaActionType type) = win 0x2274b0, imac 0x27bb40;
    void addCustomEnterEffect(EnterEffectObject* object, bool enter) = win 0x20e440, m1 0xf70ec;
    bool addGuideArt(GameObject* object) = win 0x245ce0, imac 0x1fa2b0;
    void addObjectCounter(LabelGameObject* object) = win inline {
        auto id = object->m_itemID;
        if (object->m_shownSpecial < 0) id = object->m_shownSpecial;
        auto& objects = object->m_isTimeCounter ? m_timeLabelObjects[id] : m_labelObjects[id];
        objects.push_back(object);
    }
    void addPickupTrigger(CountTriggerGameObject* object) = win inline, imac 0x14bbf0, m1 0x11e404 {
        auto itemID = object->m_itemID;
        if (object->m_pickupTriggerMode == 1) {
            m_effectManager->updateCountForItem(itemID, m_effectManager->countForItem(itemID) * object->m_pickupTriggerMultiplier);
        }
        else if (object->m_pickupTriggerMode == 2) {
            if (object->m_pickupTriggerMultiplier != 0.f) {
                m_effectManager->updateCountForItem(itemID, m_effectManager->countForItem(itemID) / object->m_pickupTriggerMultiplier);
            }
        }
        else if (object->m_isOverride) {
            m_effectManager->updateCountForItem(itemID, object->m_pickupCount);
        }
        else {
            m_effectManager->addCountToItem(itemID, object->m_pickupCount);
        }
        this->updateCounters(itemID, m_effectManager->countForItem(itemID));
    }
    void addPoints(int points) = win inline, imac 0x1560c0 {
        m_gameState.m_unkBool32 = true;
        m_gameState.m_points += points;
    }
    void addProximityVolumeEffect(int channelID, int targetType, SFXTriggerGameObject* object) = win 0x242240, m1 0x12d14c;
    void addRemapTargets(gd::set<int>& targets) = win 0x20dc10, imac 0x116890;
    void addToGroupParents(GameObject* object) = win inline {
        if (object->m_hasGroupParentsString) {
            if (auto groupIDs = static_cast<cocos2d::CCArray*>(m_removedParentGroupIDs->objectForKey(object->m_uniqueID))) {
                object->m_hasGroupParentsString = false;
                for (int i = 0; i < groupIDs->count(); i++) {
                    auto groupID = static_cast<cocos2d::CCInteger*>(groupIDs->objectAtIndex(i))->getValue();
                    if (m_parentGroupsDict->objectForKey(groupID)) {
                        this->setGroupParent(object, groupID);
                    }
                }
                m_removedParentGroupIDs->removeObjectForKey(object->m_uniqueID);
            }
        }
    }
    void addToGroups(GameObject* object, bool duplicateTrigger) = win 0x223f70;
    void addToObjectsToShow(GameObject* object) {
        if (m_activeObjectsCount < m_activeObjectsIndex) {
            m_activeObjects[m_activeObjectsIndex] = object;
        }
        else {
            m_activeObjects.push_back(object);
            m_activeObjectsIndex++;
        }
        m_activeObjectsCount++;
    }
    void addUIObject(GameObject* object) = win 0x225f80;
    void animateInDualGroundNew(GameObject* object, float height, bool instant, float duration) = win 0x2133b0;
    void animateInGroundNew(bool unk1, float unk2, bool unk3) = win inline, imac 0x125340, ios inline {}
    void animateOutGroundNew(bool instant) = win inline, imac 0x124e00, m1 0xfd948 {
        m_gameState.m_unkBool7 = false;
        if (m_gameState.m_unkBool1) {
            this->resetStaticCamera(false, true);
        }
        m_gameState.tweenValue(m_gameState.m_unkFloat9, 0.f, 25, m_gameState.m_isDualMode ? .32f : .4f, 1, 1.5f, -1, -1);
    }
    void animatePortalY(float fromY, float toY, float duration, float easingRate) = win inline, imac 0x15bbc0, ios inline {
        m_gameState.m_portalY = fromY;
        if (fromY != toY) {
            m_gameState.tweenValue(fromY, toY, 9, duration, 1, easingRate, -1, -1);
            if (m_gameState.m_cameraZoom != m_gameState.m_targetCameraZoom) {
                m_gameState.m_unkBool6 = true;
            }
        }
    }
    void applyLevelSettings(GameObject* object) = win inline, imac 0x158990 {
        object->m_canRotateFree = m_allowStaticRotate || object->canRotateFree();
        if (m_fixNegativeScale != object->m_isMirroredByScale) object->m_isObjectRectDirty = true;
        object->m_isMirroredByScale = m_fixNegativeScale;
    }
    void applyRemap(EffectGameObject* object, gd::vector<int> const& remapKeys, gd::unordered_map<int, int>& remap) = win 0x21b1f0;
    void applySFXEditTrigger(int channelID, int targetType, SFXTriggerGameObject* object) = win 0x241f40, imac 0x15e190, m1 0x12d030;
    void applyShake(cocos2d::CCPoint& point) = win inline, imac 0x15ad20 {
        if (m_gameState.m_unkUint64_1 < 0.0 || m_gameState.m_unkUint16 <= 0.f && m_gameState.m_unkUint16 < m_gameState.m_totalTime - m_gameState.m_unkUint64_1) {
            m_gameState.m_unkUint64_1 = m_gameState.m_totalTime;
            auto xFactor = 0.f;
            auto yFactor = 0.f;
            if (m_staticCameraShake) {
                xFactor = ((float)rand() / (float)RAND_MAX) > .5f ? 1.f : -1.f;
                yFactor = ((float)rand() / (float)RAND_MAX) > .5f ? 1.f : -1.f;
            }
            else {
                xFactor = ((float)rand() / (float)RAND_MAX) * 2.f - 1.f;
                yFactor = ((float)rand() / (float)RAND_MAX) * 2.f - 1.f;
            }
            m_gameState.m_unkPoint34.x = xFactor * m_gameState.m_unkUint15;
            m_gameState.m_unkPoint34.y = yFactor * m_gameState.m_unkUint15;
        }

        point.x += m_gameState.m_unkPoint34.x;
        point.y += m_gameState.m_unkPoint34.y;
    }
    void assignNewStickyGroups(cocos2d::CCArray* objects) = win 0x224d70, imac 0x13de50, m1 0x112b00;
    void asyncBGLoaded(int background) = win inline, imac 0x1143e0, m1 0xef2b4 {
        this->createBackground(background);
        this->updateLevelColors();
    }
    void asyncGLoaded(int ground) = win inline, imac 0x1146f0, m1 0xef574 {
        this->createGroundLayer(ground, 0);
        this->updateLevelColors();
    }
    void asyncMGLoaded(int middleground) = win inline, imac 0x1149c0, m1 0xef808 {
        this->createMiddleground(middleground);
        this->updateLevelColors();
    }
    int atlasValue(int atlas) = win inline, imac 0x11ddf0, m1 0xf6c90, ios inline {
        if (atlas < 30) return 0;
        return (int)std::min(atlas * 1.1f, 9999.f);
    }
    void bumpPlayer(PlayerObject* player, EffectGameObject* object) = win 0x217a00, m1 0x4cfa4;
    int buttonIDToButton(int id) = win inline, ios inline {
        switch (id) {
            case 2: case 7: return 2;
            case 3: case 8: return 3;
            case 4: case 9: return 4;
            case 5: case 10: return 5;
            default: return 1;
        }
    }
    void calculateColorGroups() = m1 0xf6988;
    void cameraMoveX(float value, float duration, float rate, bool unused) = win inline, imac 0x15b850, ios inline {
        float x = m_gameState.m_cameraPosition.x;
        m_gameState.m_unkBool4 = true;
        m_gameState.tweenValue(x, value, 1, duration, 1, rate, -1, -1);
    }
    void cameraMoveY(float value, float duration, float rate, bool force) = win inline, ios inline {
        if (!m_gameState.m_unkBool5 || m_gameState.m_unkInt13 != value || force) {
            float y = m_gameState.m_cameraPosition.y;
            m_gameState.m_unkBool5 = true;
            m_gameState.m_unkInt13 = value;
            m_gameState.tweenValue(y, value, 2, duration, 1, rate, -1, -1);
        }
    }
    bool canBeActivatedByPlayer(PlayerObject* player, EffectGameObject* object) = win 0x2178f0, imac 0xc4170, m1 0xfff48;
    bool canProcessSFX(SFXTriggerState& state, gd::unordered_map<int, int>& stateIndices, gd::unordered_map<int, float>& times, gd::vector<SFXTriggerState>& states) = win 0x242fb0, imac 0x15f340, m1 0x12dec4;
    bool canTouchObject(GameObject* object) = win inline, imac 0x127aa0, m1 0xfff18, ios inline {
        if (m_gameState.m_currentChannel == 0 || object->m_classType != GameObjectClassType::Effect) return true;
        auto effectObject = static_cast<EffectGameObject*>(object);
        return effectObject->m_channelValue == 0 || effectObject->m_channelValue == m_gameState.m_currentChannel;
    }
    void checkCameraLimitAfterTeleport(PlayerObject* player, float yOffset) = win 0x2399e0;
    bool checkCollision(int blockAID, int blockBID) = win 0x2190c0, imac 0x12b6e0, m1 0x103738;
    void checkCollisionBlocks(EffectGameObject* object, gd::vector<EffectGameObject*>* blocks, int blockCount) = win 0x218ef0, imac 0x12b550, m1 0x103594;
    int checkCollisions(PlayerObject* object, float dt, bool ignoreDamage) = win 0x213830;
    void checkRepellPlayer() = win 0x239710;
    void checkSpawnObjects() = win 0x21a920;
    cocos2d::CCPoint claimMoveAction(int groupID, bool ignoreStaticGroups) = win 0x22dc10, imac 0x146ef0, m1 0x11a510;
    cocos2d::CCParticleSystemQuad* claimParticle(gd::string key, int zLayer) = win 0x2407e0;
    void claimRotationAction(int targetID, int centerID, float& rotation, float& offset, bool ignoreStaticGroups, bool unused) = win 0x22d9d0, imac 0x146d80, m1 0x11a3a8;
    void clearActivatedAudioTriggers() = win inline {
        m_gameState.m_songChannelStates.clear();
        m_gameState.m_songTriggerStateVectors.clear();
    }
    void clearPickedUpItems() = win inline, m1 0x101868, ios inline {
        m_collectedItems->removeAllObjects();
    }
    void collectedObject(EffectGameObject* object) = win inline, m1 0x11e018 {
        m_effectManager->addCountToItem(object->m_itemID, object->m_subtractCount ? -1 : 1);
        this->updateCounters(object->m_itemID, m_effectManager->countForItem(object->m_itemID));
    }
    void collisionCheckObjects(PlayerObject* object, gd::vector<GameObject*>* objects, int objectCount, float dt) = win 0x214990;
    void controlAdvancedFollowCommand(AdvancedFollowTriggerObject* object, int controlID, GJActionCommand command) = win inline {
        for (auto& inst : m_gameState.m_advanceFollowInstances) {
            if ((controlID == -1 && inst.m_gameObject == object) || inst.m_controlId == controlID) {
                switch (command) {
                    case GJActionCommand::Stop:
                        inst.m_started = true;
                        inst.m_finished = false;
                        inst.m_doStart = false;
                        break;
                    case GJActionCommand::Pause:
                        inst.m_finished = true;
                        inst.m_doStart = true;
                        break;
                    case GJActionCommand::Resume:
                        inst.m_finished = false;
                        inst.m_doStart = false;
                        break;
                }
            }
        }
    }
    void controlAreaEffect(EnterEffectObject* object, gd::vector<EnterEffectInstance>* instances, GJActionCommand command) = win 0x227a20;
    void controlAreaEffectWithID(int uniqueID, int controlID, GJActionCommand command) = win 0x227820, imac 0x137040;
    void controlDynamicCommand(EffectGameObject* object, int controlID, gd::vector<DynamicObjectAction>& actions, GJActionCommand command) = win inline, imac 0x138750 {
        for (auto& action : actions) {
            if ((controlID == -1 && action.m_gameObject1 == object) || action.m_controlID == controlID) {
                switch (command) {
                    case GJActionCommand::Stop:
                        action.m_unkBool2 = true;
                        break;
                    case GJActionCommand::Pause:
                        action.m_unkBool3 = true;
                        action.m_unkBool4 = true;
                        break;
                    case GJActionCommand::Resume:
                        action.m_unkBool3 = false;
                        action.m_unkBool4 = false;
                        break;
                }
            }
        }
    }
    void controlDynamicMoveCommand(EffectGameObject* object, int controlID, GJActionCommand command) = win inline, ios inline {
        this->controlDynamicCommand(object, controlID, m_gameState.m_dynamicMoveActions, command);
    }
    void controlDynamicRotateCommand(EffectGameObject* object, int controlID, GJActionCommand command) = win inline, ios inline {
        this->controlDynamicCommand(object, controlID, m_gameState.m_dynamicRotateActions, command);
    }
    void controlEventLink(int uniqueID, int controlID, GJActionCommand command) = win 0x2321c0, m1 0x10b9f8;
    void controlGradientTrigger(GradientTriggerObject* object, GJActionCommand command) = win inline, m1 0x10bbd4 {
        if (command == GJActionCommand::Resume) {
            this->triggerGradientCommand(object);
        }
        else {
            if (auto gradientLayer = static_cast<GJGradientLayer*>(m_gradientLayers->objectForKey(std::min(object->m_gradientID, 999)))) {
                gradientLayer->removeFromParentAndCleanup(false);
                gradientLayer->m_triggerObject = nullptr;
            }
        }
    }
    void controlTriggersInGroup(int group, GJActionCommand command) = win 0x21e1c0, imac 0x135c10;
    void controlTriggersWithControlID(int controlID, GJActionCommand command) = win 0x21e750, m1 0x2df8a8;
    void createBackground(int background) = win 0x20b860, imac 0x114190, m1 0xef068;
    void createGroundLayer(int ground, int line) = win 0x20bca0, imac 0x114710, m1 0xef59c;
    void createMiddleground(int middleground) = win 0x20bb20, imac 0x114920, m1 0xef780;
    cocos2d::CCArray* createNewKeyframeAnim() = win inline, m1 0x11dc20 {
        auto group = cocos2d::CCArray::create();
        group->setTag(m_keyframeGroup);
        m_keyframeGroups->setObject(group, m_keyframeGroup++);
        return group;
    }
    cocos2d::CCParticleSystemQuad* createParticle(int objectType, char const* plistName, int tag, cocos2d::tCCPositionType positionType) = win 0x240400, m1 0x12bd14;
    void createPlayer();
    void createPlayerCollisionBlock() = win 0x2183a0, m1 0x1029a0;
    void createTextLayers() = win 0x20ecd0, m1 0xf8140;
    cocos2d::CCArray* damagingObjectsInRect(cocos2d::CCRect rect, bool enabledGroups) = win 0x211660, m1 0xfb454;
    void destroyObject(GameObject* object) = win 0x2160c0, imac 0x128730, m1 0x100aa4;
    void enterDualMode(GameObject* object, bool unused) = win inline {
        if (!object) return;
        m_player1->m_lastPortalPos = object->getPosition();
        m_player1->m_lastActivatedPortal = object;
        m_gameState.m_lastActivatedPortal1 = object;
    }
    void exitStaticCamera(bool exitX, bool exitY, float time, int easingType, float easingRate, bool smoothVelocity, float smoothVelocityMod, bool exitInstant) = win 0x23f480, imac 0x15c1f0, m1 0x12b284;
    void flipFinished() = win inline {
        m_player1->levelFlipFinished();
        if (m_gameState.m_isDualMode) m_player2->levelFlipFinished();
        m_gameState.m_unkBool11 = false;
        m_gameState.m_unkBool12 = false;
    }
    void flipGravity(PlayerObject* object, bool flip, bool noEffects) = win 0x212b40;
    void flipObjects() = win 0x246810, imac 0x163030, m1 0x130bb4;
    void gameEventTriggered(GJGameEvent event, int material, int playerID) = win 0x231e30, m1 0xfa310;
    int generateEnterEasingBuffer(int easingType, float easingRate) = win 0x20ea80;
    void generateEnterEasingBuffers(EnterEffectObject* object) = win inline, imac 0x11ef20, m1 0xf7a68 {
        object->m_easingInBuffer = this->generateEnterEasingBuffer((int)object->m_easingInType, object->m_easingInRate);
        object->m_easingOutBuffer = this->generateEnterEasingBuffer((int)object->m_easingOutType, object->m_easingOutRate);
    }
    void generatePickupAnimRandVal(GameObject* object, float& randomValue1, float& randomValue2) = win inline, imac 0xedb30, m1 0x1011f8 {
        std::pair<int, int> key = { (int)object->getPosition().x, (int)object->getPosition().y };
        if (m_destroyObjectValues.count(key) != 0) {
            m_destroyObjectValues[key] = { ((float)rand() / (float)RAND_MAX) * 2.f - 1.f, (float)rand() / (float)RAND_MAX };
        }
        randomValue1 = m_destroyObjectValues[key].first;;
        randomValue2 = m_destroyObjectValues[key].second;
    }
    void generateSpawnRemap() = win 0x21dfe0, imac 0x117220, m1 0xf1bc4;
    void generateTargetGroups() = imac 0x11a520, m1 0xf41d4;
    void generateVisibilityGroups() = win 0x2315c0;
    cocos2d::CCArray* getActiveOrderSpawnObjects() = win inline, imac 0x12c820, m1 0x104750 {
        if (auto objects = static_cast<cocos2d::CCArray*>(m_spawnObjects->objectForKey(m_gameState.m_currentChannel))) return objects;
        return cocos2d::CCArray::create();
    }
    float getAreaObjectValue(EnterEffectInstance* instance, GameObject* object, cocos2d::CCPoint& position, bool& show) = win 0x2280a0, imac 0x143650, m1 0x117584 {
        auto realPosition = object->getRealPosition();
        float value;
        switch (instance->m_gameObject->m_directionType) {
            case 1: {
                value = realPosition.x - position.x + (instance->m_offsetVariance != 0.f ? instance->m_offsetVariance * m_varianceValues[object->m_varianceIndex + 1] : 0.f);
                value *= value > 0.f ? instance->m_modFront : instance->m_modBack;
                show = instance->m_reversed ? position.x >= realPosition.x : position.x <= realPosition.x;
                break;
            }
            case 2: {
                value = realPosition.y - position.y + (instance->m_offsetVariance != 0.f ? instance->m_offsetVariance * m_varianceValues[object->m_varianceIndex + 1] : 0.f);
                value *= value > 0.f ? instance->m_modFront : instance->m_modBack;
                show = instance->m_reversed ? position.y >= realPosition.y : position.y <= realPosition.y;
                break;
            }
            default: {
                value = cocos2d::ccpDistance(realPosition, position + cocos2d::CCPoint {
                    instance->m_offsetVariance != 0.f ? instance->m_offsetVariance * m_varianceValues[object->m_varianceIndex + 1] : 0.f,
                    instance->m_offsetYVariance != 0.f ? instance->m_offsetYVariance * m_varianceValues[object->m_varianceIndex + 2] : 0.f
                });
                show = instance->m_reversed ? position.x >= realPosition.x : position.x <= realPosition.y;
                break;
            }
        }
        auto deadzone = instance->m_deadzone;
        auto result = value / (instance->m_length + (instance->m_lengthVariance != 0.f ? instance->m_lengthVariance * m_varianceValues[object->m_varianceIndex] : 0.f));
        result = std::clamp(deadzone != 0.f ? (result - deadzone) / (1.f - deadzone) : result, 0.f, 1.f);
        return instance->m_gameObject->m_inbound ? 1.f - result : result;
    }
    float getBumpMod(PlayerObject* player, int type) = win inline, imac 0x129f00 {
        if (static_cast<GameObjectType>(type) == GameObjectType::PinkJumpPad) {
            if (player->m_isShip) return .35f;
            if (player->m_isBird) return .4f;
            if (player->m_isBall || player->m_isSpider) return .7f;
            return .65f;
        }
        if (static_cast<GameObjectType>(type) == GameObjectType::RedJumpPad) {
            if (player->m_isShip) return (player->m_vehicleSize < 1.f) ? .95f : .63f;
            if (player->m_isBird) return (player->m_vehicleSize < 1.f) ? .98f : .6f;
            return 1.25f;
        }
        return 1.f;
    }
    float getCameraEdgeValue(int type) = win inline, imac 0x14eca0, m1 0x120aac {
        switch (type - 1) {
            case 0: {
                if (auto mainObject = this->tryGetMainObject(m_gameState.m_cameraEdgeValue0)) {
                    return mainObject->getRealPosition().x;
                }
                return 0.f;
            }
            case 1: {
                if (auto mainObject = this->tryGetMainObject(m_gameState.m_cameraEdgeValue1)) {
                    return mainObject->getRealPosition().x;
                }
                return 0.f;
            }
            case 2: {
                if (auto mainObject = this->tryGetMainObject(m_gameState.m_cameraEdgeValue2)) {
                    return mainObject->getRealPosition().y;
                }
                return 0.f;
            }
            case 3: {
                if (auto mainObject = this->tryGetMainObject(m_gameState.m_cameraEdgeValue3)) {
                    return mainObject->getRealPosition().y;
                }
                return 0.f;
            }
            default: {
                return 0.f;
            }
        }
    }
    gd::string getCapacityString() = win inline, imac 0x11f390, m1 0xf7e34 {
        fmt::memory_buffer buffer;
        auto first = true;
        auto index = 0;
        for (auto obj : geode::cocos::CCArrayExt<cocos2d::CCObject*, false>(m_batchNodes)) {
            auto capacity = static_cast<cocos2d::CCSpriteBatchNode*>(obj)->getUsedAtlasCapacity();
            if (capacity > 200) {
                if (!first) fmt::format_to(std::back_inserter(buffer), ",");
                fmt::format_to(std::back_inserter(buffer), "{},{}", capacity, index++);
                first = false;
            }
        }
        return fmt::to_string(buffer);
    }
    GameObject* getCenterGroupObject(int groupID, int defaultID) = win inline, imac 0x13d310, m1 0x1120dc, ios inline {
        if (groupID < 1) groupID = defaultID;
        auto group = this->getGroup(groupID);
        if (group && group->count() == 1) return static_cast<GameObject*>(group->objectAtIndex(0));
        else return this->getGroupParent(groupID);
    }
    gd::vector<EnterEffectInstance>* getCustomEnterEffects(int id, bool enter) = win inline, imac 0x11ee00, m1 0xf794c {
        if (id > 100) return nullptr;
        return enter ? &m_gameState.m_enterEffectInstanceVectors[id] : &m_gameState.m_exitEffectInstanceVectors[id];
    }
    float getEasedAreaValue(GameObject* object, EnterEffectInstance* instance, float value, bool show, int index) = win 0x228290, imac 0x143880, ios inline {
        auto enterObject = instance->m_gameObject;
        if (enterObject->m_easeOutEnabled) {
            if (value > .01f && value < .99f) {
                auto index = instance->m_easeIndex;
                auto& indices = instance->m_easeIndices;
                if (indices[index] == index - 2) {
                    indices[index] = index;
                    show = false;
                }
                else if (indices[index] == index - 1) {
                    indices[index] = index + 1;
                    show = true;
                }
            }
            if (!show) return this->getEnterEasingValue(value, (int)enterObject->m_easingOutType, enterObject->m_easingOutRate, enterObject->m_easingOutBuffer);
        }
        return this->getEnterEasingValue(value, (int)enterObject->m_easingInType, enterObject->m_easingInRate, enterObject->m_easingInBuffer);
    }
    int getEnterEasingKey(int easingType, float easingRate) = win inline, ios inline {
        switch (easingType) {
            case 0: return -1;
            case 3: case 7: case 8: case 9: return -2;
            default: return easingType * 10000 + easingRate * 100.f;
        }
    }
    float getEnterEasingValue(float value, int easingType, float easingRate, int easingBuffer) = win inline, m1 0xf7dd4 {
        if (easingBuffer == -1) return value;
        if (easingBuffer == -2) return GameToolbox::getEasedValue(value, easingType, easingRate);
        auto easeIndex = (int)(value * 100.f) + easingBuffer;
        return (value - (int)(value * 100.f) / 100.f) * (m_enterEasingValues[easeIndex + 1] - m_enterEasingValues[easeIndex]) * 100.f + m_enterEasingValues[easeIndex];
    }
    cocos2d::CCPoint getFollowSpeedVal(GameObject* object, int startSpeedRef, int startDirRef, float startDir, float startSpeed) = win 0x22e980, imac 0x147a00, m1 0x11adf8;
    float getGroundHeight(PlayerObject* player, int type) = win inline, imac 0x122e10 {
        if (m_gameState.m_isDualMode) {
            auto height1 = this->getGroundHeightForMode(type);
            if (height1 == 240.f) height1 = 270.f;
            auto otherPlayer = this->getOtherPlayer(player);
            auto height2 = this->getGroundHeightForMode(otherPlayer->isFlying() ? 5 : otherPlayer->m_isBall ? 16 : 6);
            return std::max(height1, height2);
        }
        return this->getGroundHeightForMode(type);
    }
    float getGroundHeightForMode(int type) = win 0x211d90, m1 0xfbaf8, ios inline {
        while (true) {
            switch (type) {
                case 5: case 19: case 26: case 41: {
                    return 300.f;
                }
                case 16: {
                    return 240.f;
                }
                case 23: case 24: {
                    type = m_gameState.m_dualRelated;
                    if (type == 23 || type == 24) {
                        return 270.f;
                    }
                    break;
                }
            }
        }
        return 270.f;
    }
    cocos2d::CCArray* getGroup(int id) = win 0x2242b0;
    GameObject* getGroupParent(int groupId) = win inline, m1 0x111eec {
        return static_cast<GameObject*>(m_parentGroupsDict->objectForKey(groupId));
    }
    gd::string getGroupParentsString(GameObject* object) = win inline, imac 0x13d760, m1 0x1124f4 {
        auto groupParents = static_cast<cocos2d::CCArray*>(m_parentGroupIDs->objectForKey(object->m_uniqueID));
        if (!groupParents || groupParents->count() == 0) return "";
        fmt::memory_buffer buffer;
        auto first = true;
        for (auto i = 0; i < groupParents->count(); i++) {
            auto groupID = static_cast<cocos2d::CCInteger*>(groupParents->objectAtIndex(i))->getValue();
            if (!first) fmt::format_to(std::back_inserter(buffer), ".");
            fmt::format_to(std::back_inserter(buffer), "{}", groupID);
            first = false;
        }
        return fmt::to_string(buffer);
    }
    double getItemValue(int type, int id) = win 0x234000, imac 0x36e090;
    float getMaxPortalY() = win 0x2137b0;
    float getMinDistance(cocos2d::CCPoint position, cocos2d::CCArray* objects, float minNear, int mode) = win 0x2427d0, imac 0x15e940, m1 0x12d6f8;
    float getMinPortalY() = win 0x2136d0, imac 0x125470;
    float getModifiedDelta(float dt) = win 0x2375f0, imac 0x150e40, m1 0x122560;
    cocos2d::CCPoint getMoveTargetDelta(EffectGameObject* object, bool mainObject) = win inline, imac 0x12b730, m1 0x103770 {
        auto targetID = object->m_targetModCenterID;
        if (targetID < 1) targetID = object->m_targetGroupID;
        auto object1 = mainObject ? this->tryGetMainObject(targetID) : this->tryGetObject(targetID);
        GameObject* object2;
        if (!object->m_targetPlayer1) {
            if (!object->m_targetPlayer2) object2 = mainObject ? this->tryGetMainObject(object->m_centerGroupID) : this->tryGetObject(object->m_centerGroupID);
            else if (m_gameState.m_isDualMode) object2 = m_player2;
            else object2 = m_player1;
        }
        else object2 = m_player1;
        if (object1 && object2 && object1->m_uniqueID != object2->m_uniqueID) {
            return object2->getRealPosition() - object1->getRealPosition();
        }
        else return { 0.f, 0.f };
    }
    cocos2d::CCArray* getOptimizedGroup(int groupID) = win inline {
        groupID = std::clamp(groupID, 0, 9999);
        auto group = m_optimizedGroups[groupID];
        if (group) return group;
        group = cocos2d::CCArray::create();
        m_optimizedGroupDict->setObject(group, groupID);
        m_optimizedGroups[groupID] = group;
        return group;
    }
    PlayerObject* getOtherPlayer(PlayerObject* player) = win inline, imac 0x122f20 {
        return player->m_uniqueID != m_player1->m_uniqueID ? m_player1 : m_player2;
    }
    gd::string getParticleKey(int objectType, char const* plistName, int tag, cocos2d::tCCPositionType positionType) = win 0x2401d0, imac 0x15c9e0, m1 0x12b8d8;
    gd::string getParticleKey2(gd::string key) = win 0x240350, imac 0x15cdd0, m1 0x12bc40;
    int getPlayerButtonID(int button, bool player2) = win inline, ios inline {
        if (button < 2 || button > 5) return player2 ? 6 : 1;
        return player2 ? button + 5 : button;
    }
    int getPlayTimerFullSeconds() = win inline, imac 0x1560b0, ios inline {
        return m_timePlayed;
    }
    int getPlayTimerMilli() = win inline, imac 0x156090, m1 0x126474 {
        return m_timePlayed * 1000.0;
    }
    TeleportPortalObject* getPortalTarget(TeleportPortalObject* object) = win inline, imac 0x120fa0 {
        auto target = object->m_orangePortal;
        if (target) return target;
        if (object->m_targetGroupID > 0) {
            auto group = this->getGroup(object->m_targetGroupID);
            auto count = group->count();
            if (count > 0) {
                if (count == 1) return static_cast<TeleportPortalObject*>(group->objectAtIndex(0));
                else {
                    auto seed = reinterpret_cast<uint64_t*>(geode::base::get() + 0x6a4e88);
                    *seed = *seed * 214013 + 2531011;
                    auto num = ((*seed >> 16) & 32767) / 32767.f;
                    if (num == 1.f) num = 0.f;
                    return static_cast<TeleportPortalObject*>(group->objectAtIndex(num * count));
                }
            }
        }
        return nullptr;
    }
    cocos2d::CCPoint getPortalTargetPos(TeleportPortalObject* object, GameObject* target, PlayerObject* player) = win inline, imac 0x1210b0, m1 0xfa020 {
        if (target && object->m_objectID != 747) return target->getRealPosition();
        else return { player->getPosition().x, object->getRealPosition().y + object->m_teleportYOffset };
    }
    gd::string getRecordString();
    void getRotateCommandTargets(EnhancedTriggerObject* object, GameObject*& centerObject, GameObject*& targetObject, GameObject*& rotateObject) = win inline, imac 0x137dc0, m1 0x10d194 {
        auto centerID = object->m_centerGroupID;
        if (centerID == 0) centerID = object->m_targetGroupID;
        centerObject = this->tryGetObject(centerID);
        targetObject = this->tryGetObject(object->m_targetGroupID);
        if (!object->m_targetPlayer1) {
            if (!object->m_targetPlayer2) rotateObject = this->tryGetObject(object->m_rotationTargetID);
            else if (m_gameState.m_isDualMode) rotateObject = m_player2;
            else rotateObject = m_player1;
        }
        else rotateObject = m_player1;
    }
    cocos2d::CCPoint getSavedPosition(int groupID, float delay) = win 0x2192d0;
    float getScaledGroundHeight(float height) = win inline, imac 0x12a830, m1 0x102978, ios inline {
        if (m_gameState.m_targetCameraZoom != 1.f) return floorf((height / m_gameState.m_targetCameraZoom) / 30.f) * 30.f;
        return height;
    }
    GameObject* getSingleGroupObject(int groupID) = win inline, imac 0x13d220 {
        if (groupID < 1) return nullptr;
        auto group = this->getGroup(groupID);
        if (group && group->count() == 1) return static_cast<GameObject*>(group->objectAtIndex(0));
        return nullptr;
    }
    int getSpecialKey(int groupID, bool ignoreGroupParent, bool ignoreLinkedObjects) = win inline, imac 0x11ec60, m1 0xf7210, ios inline {
        return groupID + (int)ignoreGroupParent * 1000000 + (int)ignoreLinkedObjects * 10000000 + 10000000;
    }
    cocos2d::CCArray* getStaticGroup(int groupID) = win inline {
        groupID = std::clamp(groupID, 0, 9999);
        auto group = m_staticGroups[groupID];
        if (group) return group;
        group = cocos2d::CCArray::create();
        m_staticGroupDict->setObject(group, groupID);
        m_staticGroups[groupID] = group;
        return group;
    }
    cocos2d::CCArray* getStickyGroup(int group) = win inline, m1 0x112934 {
        return static_cast<cocos2d::CCArray*>(m_linkedGroupDict->objectForKey(group));
    }
    float getTargetFlyCameraY(GameObject* object) = win inline {
        if (m_gameState.m_isDualMode) {
            if (m_gameState.m_lastActivatedPortal2) return m_gameState.m_lastActivatedPortal2->getStartPos().y;
            if (m_startPosObject) return m_startPosObject->getStartPos().y;
            if (object) return object->getStartPos().y;
        }
        else {
            if (object) return object->getStartPos().y;
            if (m_startPosObject) return m_startPosObject->getStartPos().y;
        }
        return 0.f;
    }
    cocos2d::CCArray* getTargetGroup(int index, int uniqueID) = win inline, imac 0x13e2c0, m1 0x112eb8, ios inline {
        return static_cast<cocos2d::CCArray*>(static_cast<cocos2d::CCDictionary*>(m_targetGroupsArray->objectAtIndex(index + 1))->objectForKey(uniqueID));
    }
    cocos2d::CCArray* getTargetGroupOrigin(int index, int uniqueID) = win inline, imac 0x13e2f0, m1 0x112ee4, ios inline {
        return static_cast<cocos2d::CCArray*>(static_cast<cocos2d::CCDictionary*>(m_targetGroupsArray->objectAtIndex(index + 2))->objectForKey(uniqueID));
    }
    void gravBumpPlayer(PlayerObject* player, EffectGameObject* object) = win inline, m1 0x4b86c0 {
        auto flip = player->m_isSideways ? !object->isFacingLeft() : !object->isFacingDown();
        if (player->m_isUpsideDown != flip && this->canBeActivatedByPlayer(player, object)) {
            if (object->m_isReverse) player->reversePlayer(object);
            if (!object->m_hasNoEffects) this->playGravityEffect(flip);
            player->m_lastPortalPos = object->getPosition() - cocos2d::CCPoint { 0.f, 10.f };
            object->activatedByPlayer(player);
            player->m_lastActivatedPortal = object;
            player->propellPlayer(.8f, object->m_hasNoEffects, 10);
            this->flipGravity(player, flip, true);
            player->m_padRingRelated = true;
            this->gameEventTriggered(GJGameEvent::GravityPad, 0, 0);
        }
    }
    void groupStickyObjects(cocos2d::CCArray* objects) = win 0x224b90, m1 0x112940;
    void handleButton(bool down, int button, bool isPlayer1) = win 0x233720;
    bool hasItem(int id) = win inline {
        return m_collectedItems->objectForKey(cocos2d::CCString::createWithFormat("%i", id)->getCString()) != nullptr;
    }
    bool hasUniqueCoin(EffectGameObject* object) = win 0x216730, imac 0x128800, m1 0x100b88;
    void increaseBatchNodeCapacity() = win 0x20cc60, m1 0xeffbc;
    bool isFlipping() = win inline, imac 0x156020, m1 0x12641c {
        return m_gameState.m_levelFlipping != 0.f && m_gameState.m_levelFlipping != 1.f;
    }
    bool isPlayer2Button(int button) = win inline, imac 0x1564a0, ios inline {
        return button > 5;
    }
    void lightningFlash(cocos2d::CCPoint to, cocos2d::ccColor3B color) = win inline, imac 0x163230, m1 0x130d88 {
        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        auto x = ((float)rand() / (float)RAND_MAX) * 150.f + (to.x - 50.f);
        auto y = m_gameState.m_cameraPosition.y + (winSize.height + 50.f) / m_objectLayer->getScale();
        this->lightningFlash({ x, y }, to, color, 5.f, .5f, 0, true, 1.f);
    }
    void lightningFlash(cocos2d::CCPoint from, cocos2d::CCPoint to, cocos2d::ccColor3B color, float lineWidth, float duration, int displacement, bool flash, float opacity) = win 0x246b10, imac 0x121130, m1 0xfa0c4;
    void loadGroupParentsFromString(GameObject* object, gd::string groupList) = win 0x224890, imac 0x13da80;
    void loadLevelSettings() = win 0x23ab40, imac 0x1587f0, m1 0x12832c;
    void loadStartPosObject() = win 0x2355a0;
    void loadUpToPosition(float position, int order, int channel) = win 0x235740;
    int maxZOrderForShaderZ(int zLayer) = win 0x2237e0;
    int minZOrderForShaderZ(int zLayer) = win 0x223730, m1 0x111330;
    void modifyGroupPhysics(AdvancedFollowEditObject* object, cocos2d::CCArray* group) = win 0x22ee30, m1 0xc490c;
    void modifyObjectPhysics(AdvancedFollowEditObject* object, GameObjectPhysics& physics) = win inline, imac 0x1484c0, m1 0x11b6c8 {
        physics.m_unkPoint1.x = GameToolbox::fast_rand_0_1() * object->m_modXVariance + object->m_modX;
        physics.m_unkPoint1.y = GameToolbox::fast_rand_0_1() * object->m_modYVariance + object->m_modY;
        auto speed = GameToolbox::fast_rand_0_1() * object->m_startSpeedVariance + object->m_startSpeed;
        if (speed != 0.f) {
            auto speedVal = this->getFollowSpeedVal(physics.m_gameObject, object->m_startSpeedReference, object->m_startDirectionReference,
                GameToolbox::fast_rand_0_1() * object->m_startDirectionVariance + object->m_startDirection, speed);
            if (!object->m_xOnly) physics.m_unkPoint1.y += speedVal.y;
            if (!object->m_yOnly) physics.m_unkPoint1.x += speedVal.x;
        }
    }
    void moveAreaObject(GameObject* object, float dx, float dy) = win 0x22aae0 {
        auto result = this->resetAreaObjectValues(object, true);
        if (dx == 0.f && dy == 0.f && !result) return;
        if (dy != 0.f) {
            object->m_positionY += dy;
            object->m_positionYOffset += dy;
            object->dirtifyObjectPos();
            object->dirtifyObjectRect();
        }
        if (dx != 0.f && !object->m_tempOffsetXRelated) {
            object->m_positionX += dx;
            object->m_positionXOffset += dx;
            object->dirtifyObjectPos();
            object->dirtifyObjectRect();
        }
        this->updateObjectSection(object);
    }
    void moveCameraToPos(cocos2d::CCPoint pos) = win inline, imac 0x15b6f0, ios inline {
        this->cameraMoveX(pos.x, 1.2f, 1.8f, false);
        this->cameraMoveY(pos.y, 1.2f, 1.8f, false);
    }
    void moveObject(GameObject* object, double dx, double dy, bool lockPlayerY) = win inline, imac 0x1479a0, m1 0x11ada0 {
        m_objectsToMove->addObject(object);
        this->moveObjects(m_objectsToMove, dx, dy, lockPlayerY);
        m_objectsToMove->removeObjectAtIndex(0);
    }
    void moveObjects(cocos2d::CCArray* objects, double dx, double dy, bool lockPlayerY) = win 0x22dd80, imac 0x147680, m1 0x11ab2c;
    void moveObjectsSilent(int groupId, double dx, double dy) = win inline, imac 0x137a80, m1 0x10ced4 {
        auto group = this->getGroup(groupId);
        for (auto object : geode::cocos::CCArrayExt<cocos2d::CCObject*, false>(group)) {
            auto obj = static_cast<GameObject*>(object);

            if (!obj->m_tempOffsetXRelated) {
                obj->m_positionX += dx;
            }
            obj->m_positionY += dy;
            obj->dirtifyObjectRect();
            obj->dirtifyObjectPos();
            this->updateObjectSection(obj);
            obj->m_lastPosition.x = obj->m_positionX;
            obj->m_lastPosition.y = obj->m_positionY;
        }

        m_effectManager->saveCompletedMove(groupId, dx, dy);
    }
    void moveObjectToStaticGroup(GameObject* object) = win 0x231440, m1 0xd62f0;
    bool objectIntersectsCircle(GameObject* object, GameObject* circle) = win inline, imac 0x123080, m1 0xfbdf4 {
        auto objectRect = object->getObjectRect();
        auto circleRadius = circle->getObjectRadius();
        auto circlePosition = circle->getRealPosition();
        auto minX = objectRect.getMinX();
        auto maxX = objectRect.getMaxX();
        auto minY = objectRect.getMinY();
        auto maxY = objectRect.getMaxY();
        if (objectRect.containsPoint(circlePosition)) return true;
        if (circleRadius > std::abs(cocos2d::ccpDistance({ maxX, maxY }, circlePosition))) return true;
        if (circleRadius > std::abs(cocos2d::ccpDistance({ maxX, minY }, circlePosition))) return true;
        if (circleRadius > std::abs(cocos2d::ccpDistance({ minX, minY }, circlePosition))) return true;
        if (circleRadius > std::abs(cocos2d::ccpDistance({ minX, maxY }, circlePosition))) return true;
        return false;
    }
    GJGameEvent objectTypeToGameEvent(int type) = win 0x2323a0;
    void optimizeMoveGroups() = imac 0xaee70, m1 0xf2104;
    void orderSpawnObjects() = win 0x245b80, m1 0x12fd08;
    cocos2d::CCNode* parentForZLayer(int zLayer, bool blending, int parentMode, int uiObject) = win 0x20f1a0, imac 0x11fbe0;
    void pauseAudio() = win 0x2372f0, m1 0x122490;
    double performMathOperation(double operand1, double operand2, int operation) = win inline, m1 0x11e698, ios inline {
        switch (operation) {
            case 0:
                return operand1 + operand2;
            case 1:
                return operand1 - operand2;
            case 2:
                return operand1 * operand2;
            case 3:
                return operand2 != 0.0 ? operand1 / operand2 : 0.0;
            default:
                return 0.0;
        }
    }
    double performMathRounding(double value, int type) = win inline, m1 0x11e6e8, ios inline {
        switch (type) {
            case 1: return round(value);
            case 2: return floor(value);
            case 3: return ceil(value);
            default: return value;
        }
    }
    void pickupItem(EffectGameObject* object) = win 0x2161e0;
    void playAnimationCommand(int id, int groupID) = win inline, m1 0x69b6cc {
        if (groupID <= 0) return;
        auto group = this->getGroup(groupID);
        for (int i = 0; i < group->count(); i++) {
            auto object = static_cast<AnimatedGameObject*>(group->objectAtIndex(i));
            if (object->m_classType == GameObjectClassType::Animated) object->playAnimation(id);
            else object->animationTriggered();
        }
    }
    bool playerCircleCollision(PlayerObject* player, GameObject* object) = win 0x211e30;
    bool playerIntersectsCircle(PlayerObject* player, GameObject* object) = win inline, imac 0x122ff0, m1 0xfbd50 {
        return cocos2d::ccpDistance(object->getPosition(), player->getRealPosition()) <= player->getObjectRect().size.width * .5f + object->getObjectRadius();
    }
    void playerTouchedObject(PlayerObject* player, GameObject* object) = win inline, imac 0x129e10, m1 0x102044, ios inline {
        m_gameState.m_unkMapPairIntIntInt[{ object->m_uniqueID, player->m_uniqueID }] = m_gameState.m_unkUint2;
    }
    void playerTouchedRing(PlayerObject* player, RingObject* object) = win 0x217e70, imac 0x1283f0;
    void playerTouchedTrigger(PlayerObject* player, EffectGameObject* object) = win 0x217f80, m1 0x100844;
    bool playerWasTouchingObject(PlayerObject* player, GameObject* object) = win inline, m1 0x101fec, ios inline {
        return m_gameState.m_unkMapPairIntIntInt.find({ object->m_uniqueID, player->m_uniqueID }) != m_gameState.m_unkMapPairIntIntInt.end();
    }
    void playerWillSwitchMode(PlayerObject* player, GameObject* object) = win 0x212f30, m1 0xfd40c;
    void playExitDualEffect(PlayerObject* player) = win 0x216eb0, m1 0x1018ec;
    void playFlashEffect(float duration, int flashes, float unknown) = win inline, imac 0x163330, m1 0x130e74, ios inline {
        m_unk31f8 = unknown;
        m_flashNode->setVisible(true);
        auto action = flashes > 1 ? cocos2d::CCSequence::create(
            cocos2d::CCBlink::create(duration, flashes - 1), cocos2d::CCHide::create(), nullptr
        ) : cocos2d::CCSequence::create(
            cocos2d::CCDelayTime::create(duration), cocos2d::CCHide::create(), nullptr
        );
        action->setTag(15);
        m_flashNode->runAction(action);
    }
    void playKeyframeAnimation(KeyframeAnimTriggerObject* object, gd::vector<int> const& remapKeys) = win 0x217bf0, imac 0x12a090, m1 0x42fa0;
    void playSpeedParticle(float timeMod) = win inline, m1 0x12b748 {
        if (GameManager::sharedState()->m_performanceMode || m_skipArtReload) return;
        const char* particleFile;
        if (timeMod == .7f) particleFile = "speedEffect_slow.plist";
        else if (timeMod == 1.1f) particleFile = "speedEffect_fast.plist";
        else if (timeMod == 1.3f) particleFile = "speedEffect_vfast.plist";
        else if (timeMod == 1.6f) particleFile = "speedEffect_vvfast.plist";
        else particleFile = "speedEffect_normal.plist";
        auto director = cocos2d::CCDirector::sharedDirector();
        auto winSize = director->getWinSize();
        auto particle = cocos2d::CCParticleSystemQuad::create(particleFile, false);
        particle->setPositionType(cocos2d::tCCPositionType::kCCPositionTypeGrouped);
        particle->setAutoRemoveOnFinish(true);
        this->addChild(particle, 100);
        particle->setPosition({ director->getScreenRight() + 10.f, winSize.height / 2.f });
        particle->setPosVar({ 10.f, director->getScreenScaleFactorH() * 160.f });
        particle->resetSystem();
    }
    cocos2d::CCPoint positionForShaderTarget(int groupID) = win 0x223580;
    void positionUIObjects() = win 0x2260a0, m1 0x23731c;
    void prepareSavePositionObjects() = win 0x2197e0;
    void prepareTransformParent(bool rotateNode) = win inline, m1 0x117da8 {
        m_areaTransformNode2->retain();
        m_areaTransformNode2->removeFromParentAndCleanup(false);

        auto node = rotateNode ? m_areaRotateNode : m_areaTransformNode;
        node->addChild(m_areaTransformNode2);
        m_areaTransformNode2->release();
    }
    void preResumeGame() = win inline, imac 0x150d30, m1 0x122484 {
        m_resumeTimer = 2;
    }
    void preUpdateVisibility(float dt) = win 0x236040, m1 0x120dac;
    void processActivatedAudioTriggers(float levelTime) = win 0x243780, imac 0x15ff30;
    void processAdvancedFollowAction(AdvancedFollowInstance& instance, bool started, float dt) = win 0x22f330;
    void processAdvancedFollowActions(float dt) = win 0x22f110, imac 0x146700;
    void processAreaActions(float dt, bool visibleFrame) = win 0x228ff0;
    void processAreaEffects(gd::vector<EnterEffectInstance>* effects, GJAreaActionType type, float dt, bool visibleFrame) = win 0x228410, m1 0x3fcca0;
    void processAreaFadeGroupAction(cocos2d::CCArray* objects, EnterEffectInstance* instance, cocos2d::CCPoint position, bool targetGroups) = win inline, imac 0x142630, m1 0x1166a8 {
        auto fromOpacity = instance->m_fromOpacity;;
        auto toOpacity = instance->m_toOpacity;
        m_areaColorCount += objects->count();
        auto colorCount = 0;
        auto totalCount = 0;
        for (auto obj : geode::cocos::CCArrayExt<cocos2d::CCObject*, false>(objects)) {
            auto object = static_cast<GameObject*>(obj);
            if (!object->m_isActivated) continue;
            totalCount++;
            auto show = false;
            auto rawOpacity = this->getAreaObjectValue(instance, object, position, show);
            auto opacity = rawOpacity * (toOpacity - fromOpacity) + fromOpacity;
            if (targetGroups) {
                auto targetGroup = this->getTargetGroup(instance->m_targetGroupIndex, object->m_uniqueID);
                colorCount += targetGroup->count() - 1;
                for (auto targetObj : geode::cocos::CCArrayExt<cocos2d::CCObject*, false>(targetGroup)) {
                    static_cast<GameObject*>(targetObj)->setAreaOpacity(opacity, rawOpacity, m_gameState.m_unkUint2);
                }
            }
            else {
                object->setAreaOpacity(opacity, rawOpacity, m_gameState.m_unkUint2);
            }
        }
        m_areaColorCount += colorCount;
        m_areaColorCountTotal += colorCount + totalCount;
    }
    void processAreaMoveGroupAction(cocos2d::CCArray* objects, EnterEffectInstance* instance, cocos2d::CCPoint position, int outerMin, int outerMax, int middleMin, int middleMax, int startIndex, bool targetGroups, bool reset) = win 0x22a500;
    void processAreaRotateGroupAction(cocos2d::CCArray* objects, EnterEffectInstance* instance, cocos2d::CCPoint position, int outerMin, int outerMax, int middleMin, int middleMax, int startIndex, bool targetGroups, bool reset) = win 0x229dc0;
    void processAreaTintGroupAction(cocos2d::CCArray* objects, EnterEffectInstance* instance, cocos2d::CCPoint position, bool targetGroups) = win 0x22abd0;
    void processAreaTransformGroupAction(cocos2d::CCArray* objects, EnterEffectInstance* instance, cocos2d::CCPoint position, int outerMin, int outerMax, int middleMin, int middleMax, int startIndex, bool targetGroups, bool reset) = win 0x229250, imac 0x1416a0;
    void processAreaVisualActions(float dt) = win inline, imac 0x143600, m1 0x117538 {
        this->processAreaEffects(&m_gameState.m_fadeEffectInstances, GJAreaActionType::Fade, dt, true);
        this->processAreaEffects(&m_gameState.m_tintEffectInstances, GJAreaActionType::Tint, dt, true);
    }
    GameObject* processCameraObject(GameObject* object, PlayerObject* player) = win inline, imac 0x123200, m1 0xfbf54 {
        if (object) {
            player->m_lastPortalPos = object->getPosition();
            player->m_lastActivatedPortal = object;
        }
        auto ret = object;
        if (m_gameState.m_isDualMode && m_gameState.m_lastActivatedPortal2) ret = m_gameState.m_lastActivatedPortal2;
        if (object) m_gameState.m_lastActivatedPortal1 = object;
        return ret;
    }
    void processCommands(float dt) = win 0x239aa0;
    void processDynamicObjectActions(int type, float dt) = win 0x22e2b0, m1 0xa4b80;
    void processFollowActions() = win 0x2305b0, imac 0x1468f0, m1 0x11a018;
    void processItems() = win 0x2162c0, m1 0x101650;
    void processMoveActions() = win 0x22d5e0, m1 0x119a88;
    void processMoveActionsStep(float dt, bool visibleFrame) = win 0x22b600, imac 0x1443b0;
    void processOptionsTrigger(GameOptionsTrigger* object) = win 0x223d80, imac 0x13ca30, m1 0x85e7c;
    void processPlayerFollowActions(float dt) = win 0x22df00, imac 0x146430, m1 0x119c14;
    void processQueuedAudioTriggers() = win 0x23b8f0, imac 0x159e30;
    void processQueuedButtons();
    void processRotationActions() = win 0x22b820, m1 0x1192ec;
    void processSFXObjects() = win 0x241820, imac 0x11d910, m1 0xf6768;
    void processSFXState(SFXTriggerState* state1, SFXTriggerState* state2, int type, float levelTime) = win 0x244c20;
    bool processSongState(int musicID, float spawnDelay, float levelTime, int songOffset, float volume, float speed, gd::vector<SongTriggerState>* states, SongTriggerGameObject* object) = win 0x245160, m1 0x12f8a4;
    void processStateObjects() = win inline, imac 0x12a5b0, m1 0x102734 {
        for (auto it = m_gameState.m_stateObjects.begin(); it != m_gameState.m_stateObjects.end();) {
            auto obj = it->second;
            obj->updateState(m_gameState.m_unkUint2);
            if (obj->m_isRingPoweredOn) ++it;
            else {
                obj->stateSensitiveOff(this);
                it = m_gameState.m_stateObjects.erase(it);
            }
        }
    }
    void processTransformActions(bool visibleFrame) = win 0x22c6b0;
    void queueButton(int button, bool push, bool isPlayer2) = win inline {
        if (button <= 0 || button > 3) {
            return;
        }
        PlayerButtonCommand command = {};
        command.m_button = (PlayerButton) button;
        command.m_isPush = push;
        command.m_isPlayer2 = isPlayer2;
        m_queuedButtons.push_back(command);
    }
    void reAddToStickyGroup(GameObject* object) = win inline {
        auto uniqueID = object->m_uniqueID;
        if (m_stickyGroups.count(uniqueID) != 0 && object->m_linkedGroup == 0) {
            auto groupID = m_stickyGroups[uniqueID];
            if (auto stickyGroup = this->getStickyGroup(groupID)) {
                stickyGroup->addObject(object);
                object->m_linkedGroup = groupID;
                m_stickyGroups.erase(uniqueID);
            }
        }
    }
    void recordAction(int button, bool down, bool player2) = win inline {
        if (m_recordInputs && !m_useReplay) {
            PlayerButtonCommand command;
            command.m_button = (PlayerButton)button;
            command.m_isPush = down;
            command.m_isPlayer2 = player2;
            command.m_step = 0;
            m_queuedRecordedButtons.push_back(command);
        }
    }
    bool rectIntersectsCircle(cocos2d::CCRect rect, cocos2d::CCPoint center, float radius) = win inline, imac 0x122c00, m1 0xfb964 {
        auto minX = rect.getMinX();
        auto maxX = rect.getMaxX();
        auto minY = rect.getMinY();
        auto maxY = rect.getMaxY();
        if (rect.containsPoint(center)) return true;
        if (radius > std::abs(cocos2d::ccpDistance({ maxX, maxY }, center))) return true;
        if (radius > std::abs(cocos2d::ccpDistance({ maxX, minY }, center))) return true;
        if (radius > std::abs(cocos2d::ccpDistance({ minX, minY }, center))) return true;
        if (radius > std::abs(cocos2d::ccpDistance({ minX, maxY }, center))) return true;
        if (radius >= cocos2d::ccpDistance({ std::clamp(center.x, minX, maxX), std::clamp(center.y, minY, maxY) }, center)) return true;
        return false;
    }
    void refreshCounterLabels() = win 0x2353f0, imac 0x14b740, m1 0x11fc70;
    void refreshKeyframeAnims() = win 0x233b20, m1 0xf6598;
    void regenerateEnterEasingBuffers() = win inline, imac 0x1173b0, m1 0xf1d24 {
        m_enterEasingValues.clear();
        m_enterEasingIndices.clear();
        m_enterEasingValuesIndex = 0;
        for (auto obj : geode::cocos::CCArrayExt<cocos2d::CCObject*, false>(m_objects)) {
            auto object = static_cast<EnterEffectObject*>(obj);
            if (object->m_objectID >= 3006 && object->m_objectID <= 3021 && object->m_objectID != 3016) {
                this->generateEnterEasingBuffers(object);
            }
        }
    }
    int registerSpawnRemap(gd::vector<ChanceObject>& spawnRemap) = win inline, imac 0x135a10, m1 0x10ad80 {
        std::unordered_map<int, int> remap;
        m_spawnRemapTriggers.push_back(remap);
        for (auto& obj : spawnRemap) {
            m_spawnRemapTriggers.back()[obj.m_groupID] = obj.m_chance;
        }
        return m_spawnRemapTriggers.size() - 1;
    }
    void registerStateObject(EffectGameObject* object) = win inline {
        m_gameState.m_stateObjects[object->m_uniqueID] = object;
    }
    void removeBackground() = win inline, imac 0x114350, m1 0xef210 {
        if (m_background) {
            m_background->removeFromParent();
            m_background = nullptr;
        }
    }
    void removeCustomEnterEffects(int id, bool enter) = win inline, m1 0xf7434, ios inline {
        if (id > 100) return;
        if (enter) m_gameState.m_enterEffectInstanceVectors.erase(id);
        else m_gameState.m_exitEffectInstanceVectors.erase(id);
    }
    void removeFromGroupParents(GameObject* object) = win inline {
        if (object->m_hasGroupParentsString) {
            if (auto groupIDs = static_cast<cocos2d::CCArray*>(m_removedParentGroupIDs->objectForKey(object->m_uniqueID))) {
                for (int i = 0; i < groupIDs->count(); i++) {
                    m_parentGroupsDict->removeObjectForKey(static_cast<cocos2d::CCInteger*>(groupIDs->objectAtIndex(i))->getValue());
                }
                m_removedParentGroupIDs->removeObjectForKey(object->m_uniqueID);
                m_parentGroupIDs->removeObjectForKey(object->m_uniqueID);
            }
        }
    }
    void removeFromGroups(GameObject* object) = win 0x2240f0;
    void removeFromStickyGroup(GameObject* object) = win inline, imac 0x13df60, m1 0x112c08 {
        if (object->m_linkedGroup != 0) {
            if (auto stickyGroup = this->getStickyGroup(object->m_linkedGroup)) stickyGroup->removeObject(object);
            m_stickyGroups[object->m_uniqueID] = object->m_linkedGroup;
            object->m_linkedGroup = 0;
        }
    }
    void removeGroundLayer() = win inline, imac 0x114a80, m1 0xef8c0 {
        if (m_groundLayer) {
            m_groundLayer->removeFromParent();
            m_groundLayer = nullptr;
            m_groundLayer2->removeFromParent();
            m_groundLayer2 = nullptr;
        }
    }
    void removeGroupParent(int groupID) = win 0x2247c0, imac 0x13d140, m1 0x111ef8;
    void removeKeyframe(KeyframeGameObject* object) = win inline, imac 0x14b4a0, m1 0x11dde4 {
        if (auto keyframeGroup = static_cast<cocos2d::CCArray*>(m_keyframeGroups->objectForKey(object->m_keyframeGroup))) {
            keyframeGroup->removeObject(object);
            this->updateKeyframeOrder(object->m_keyframeGroup);
        }
    }
    void removeMiddleground() = win inline, imac 0x114a50, m1 0xef88c {
        if (m_middleground) {
            m_middleground->removeFromParent();
            m_middleground = nullptr;
        }
    }
    void removeObjectFromSection(GameObject* object) = win 0x226d90;
    void removePlayer2() = win inline, imac 0x129ac0, m1 0x101d6c {
        m_player2->removeFromParentAndCleanup(true);
        m_player2->setOpacity(0);
        m_player2->releaseAllButtons();
        m_player2->removeAllParticles();
        m_player2->deactivateStreak(true);
    }
    void removeTemporaryParticles() = win inline, m1 0x12910c {
        for (int i = 0; i < m_temporaryParticles->count();) {
            auto particle = static_cast<cocos2d::CCParticleSystem*>(m_temporaryParticles->objectAtIndex(i));
            if (particle->isAutoRemoveOnFinish()) {
                particle->removeMeAndCleanup();
                m_customParticlesUIDs.erase(particle->m_uID);
                m_temporaryParticles->fastRemoveObjectAtIndex(i);
            }
            else i++;
        }
    }
    void reorderObjectSection(GameObject* object) = win inline {
        this->removeObjectFromSection(object);
        this->addToSection(object);
    }
    void reparentObject(cocos2d::CCNode* node, cocos2d::CCNode* parent) = win inline, imac 0x13c470, m1 0x111284 {
        if (parent == node->getParent() || node->getTag() == -9999) return;
        node->retain();
        node->removeFromParentAndCleanup(false);
        parent->addChild(node, node->getZOrder());
        node->release();
    }
    void resetActiveEnterEffects() = win 0x20e3d0;
    bool resetAreaObjectValues(GameObject* object, bool update) = win 0x227c60 {
        if (m_gameState.m_unkUint2 <= object->m_unk4C8) return false;
        if (update) this->updateAreaObjectLastValues(object);
        auto result = false;
        if (object->m_positionXOffset != 0.f) {
            object->m_positionX -= object->m_positionXOffset;
            object->m_positionXOffset = 0.f;
            object->m_isUnmodifiedPosDirty = true;
            result = true;
        }
        if (object->m_positionYOffset != 0.f) {
            object->m_positionY -= object->m_positionYOffset;
            object->m_positionYOffset = 0.f;
            object->m_isUnmodifiedPosDirty = true;
            result = true;
        }
        if (object->m_unk2BC != 0.f || object->m_unk2C0 != 0.f) {
            object->m_scaleXOffset -= object->m_unk2BC;
            object->m_scaleX -= object->m_unk2BC;
            object->m_scaleYOffset -= object->m_unk2C0;
            object->m_scaleY -= object->m_unk2C0;
            object->m_unk2BC = 0.f;
            object->m_unk2C0 = 0.f;
            if (!update) object->setRScale(1.f);
        }
        if (object->m_unk2A8 != 0.f || object->m_unk2B0 != 0.f) {
            object->m_rotationXOffset -= object->m_unk2A8;
            object->m_rotationYOffset -= object->m_unk2B0;
            object->m_unk2A8 = 0.f;
            object->m_unk2B0 = 0.f;
            if (!update) object->setRRotation(0.f);
        }
        object->m_unk4C8 = m_gameState.m_unkUint2;
        if (update) {
            if (m_areaObjectsCount < m_areaObjectsIndex) {
                m_areaObjects[m_areaObjectsCount++] = object;
            }
            else {
                m_areaObjects.push_back(object);
                m_areaObjectsIndex++;
                m_areaObjectsCount++;
            }
        }
        else this->updateAreaObjectLastValues(object);
        return result;
    }
    void resetAudio() = win 0x237550, m1 0x1224e4;
    void resetCamera() = win 0x23f910, imac 0x1599c0;
    void resetGradientLayers() = win 0x220fd0;
    void resetGroupCounters(bool reset) = win inline, imac 0x14de60, m1 0x11ff00 {
        for (auto& pair : m_labelObjects) {
            for (auto label : pair.second) {
                if (reset) label->updateLabel("0");
                else label->updatePreviewLabel();
            }
        }

        for (auto& pair : m_timeLabelObjects) {
            for (auto label : pair.second) {
                if (reset) label->updateLabel(label->m_showSecondsOnly ? "0" : "0.00");
                else label->updatePreviewLabel();
            }
        }
    }
    void resetLevelVariables() = win 0x23ae80, imac 0x158c40, m1 0x128768;
    void resetMoveOptimizedValue() = win inline, m1 0x11ceac {
        for (auto obj : geode::cocos::CCArrayExt<cocos2d::CCObject*, false>(m_objects)) {
            auto object = static_cast<GameObject*>(obj);
            object->m_isDecoration2 = object->m_isDecoration;
        }
    }
    void resetPlayer() = win 0x2120f0;
    void resetSongTriggerValues() = win inline, ios inline {
        m_gameState.m_proximityVolumeRelated.clear();
        m_gameState.m_levelTime = 0.0;
    }
    void resetSpawnChannelIndex() = win 0x245c30, imac 0x159d40;
    void resetStaticCamera(bool resetX, bool resetY) = win 0x23fbf0, imac 0x125350;
    void resetStoppedAreaObjects() = win inline {
        if (m_areaObjectsCount > 0) {
            for (size_t i = 0; i < m_areaObjectsCount; i++) {
                auto object = m_areaObjects[i];
                object->m_isDirty = true;
                object->m_isObjectRectDirty = true;
                object->m_isOrientedBoxDirty = true;
                if (this->resetAreaObjectValues(object, false)) {
                    this->updateObjectSection(object);
                }
                object->setRRotation(0.f);
                object->setRScale(1.f);
            }
        }
    }
    void restoreAllUIObjects() = win inline, imac 0x4e070 {
        for (auto obj : geode::cocos::CCArrayExt<cocos2d::CCObject*, false>(m_uiObjects)) {
            auto object = static_cast<GameObject*>(obj);
            object->setStartPos(m_uiObjectPositions[object->m_uniqueID]);
            object->deactivateObject(true);
            object->m_outerSectionIndex = 0;
            object->m_isUIObject = false;
            this->addToSection(object);
            m_objectsToDeactivate->setObject(object, object->m_uniqueID);
            object->m_unk3ee = true;
        }
        m_uiObjects->removeAllObjects();
        m_uiObjectPositions.clear();
        m_calcCollisionBlockObjects2.clear();
        m_calcCollisionBlockObjects2Size = 0;
    }
    void restoreDefaultGameplayOffsetX() = win inline, imac 0x14edd0, m1 0x120c04, ios inline {
        this->updateGameplayOffsetX(75, false);
    }
    void restoreDefaultGameplayOffsetY() = win inline, imac 0x14ee10, m1 0x120c20, ios inline {
        this->updateGameplayOffsetY(75, false);
    }
    void restoreRemap(EffectGameObject* object, gd::unordered_map<int, int>& remap) = win 0x21cfd0, imac 0x1335d0, m1 0x1091b4;
    void resumeAudio() = win 0x237440, m1 0x1224bc;
    void rotateAreaObjects(GameObject* object, cocos2d::CCArray* objects, float rotation, bool reset) = win 0x22a130, imac 0x143f80, m1 0x117e0c;
    void rotateObject(GameObject* object, float rotation) = win 0x22c130, imac 0x147140;
    void rotateObjects(cocos2d::CCArray* objects, float rotation, cocos2d::CCPoint position, cocos2d::CCPoint offset, bool finished, bool unused) = win 0x22c1d0, imac 0x1471c0, m1 0x11a6ec;
    void setGroupParent(GameObject* object, int groupID) = win 0x2246b0, m1 0x11223c;
    void setStartPosObject(StartPosObject* startPos) = win inline, m1 0xfc248 {
        if (startPos != m_startPosObject) {
            if (startPos) {
                startPos->retain();
            }
            if (m_startPosObject) {
                m_startPosObject->release();
            }
            m_startPosObject = startPos;
        }
    }
    void setupLayers() = win 0x208ae0, imac 0x111480, m1 0xec5c0;
    void setupLevelStart(LevelSettingsObject* settings) = win 0x212260, imac 0x123580, m1 0xfc290;
    void setupReplay(gd::string inputs);
    void shakeCamera(float duration, float strength, float interval) = win 0x23ba60, m1 0x12a098;
    bool shouldExitHackedLevel() = win 0x20b090, m1 0xeead4;
    void sortAllGroupsX() = win inline, imac 0x13d2b0 {
        for (int i = 0; i < 10000; i++) {
            if (auto group = m_groups[i]) {
                qsort(group->data->arr, group->data->num, sizeof(GameObject*), [](const void* a, const void* b) {
                    auto objA = *static_cast<GameObject* const*>(a);
                    auto objB = *static_cast<GameObject* const*>(b);
                    return (int)objA->getPosition().x - (int)objB->getPosition().x;
                });
            }
        }
    }
    void sortGroups() = win 0x224320, imac 0x1174f0;
    void sortSectionVector() = win 0x226fd0, m1 0x113ed4;
    void sortStickyGroups() = win 0x224a30;
    void spawnGroupTriggered(int targetID, float delay, bool spawnOrdered, gd::vector<int> const& remapKeys, int uniqueID, int controlID) = win inline, imac 0x12c850, m1 0x10477c {
        if (delay > 0.f) m_effectManager->spawnGroup(targetID, delay, spawnOrdered, remapKeys, uniqueID, controlID);
        else this->spawnGroup(targetID, spawnOrdered, -delay, remapKeys, uniqueID, controlID);
    }
    void spawnObjectsInOrder(cocos2d::CCArray* objects, double delay, gd::vector<int> const& remapKeys, int uniqueID, int controlID) = win 0x21ae30, imac 0x12cbb0, m1 0x104ad0;
    cocos2d::CCParticleSystemQuad* spawnParticle(char const* plist, int zOrder, cocos2d::tCCPositionType positionType, cocos2d::CCPoint position) = win 0x2400f0, imac 0x15c7b0;
    void spawnParticleTrigger(SpawnParticleGameObject* object) = win inline, imac 0x15c5d0, m1 0x12b50c {
        auto rotation = object->m_rotation + (((float)rand() / (float)RAND_MAX) * 2.f - 1.f) * object->m_rotationVariance;
        auto scale = object->m_scale + (((float)rand() / (float)RAND_MAX) * 2.f - 1.f) * object->m_scaleVariance;
        auto position = this->getPosition();
        auto centerID = object->m_centerGroupID;
        if (centerID > 0) {
            if (auto groupObject = this->tryGetObject(centerID)) {
                position = groupObject->getPosition();
                if (object->m_matchRotation) rotation += groupObject->getRotation();
            }
        }
        position.x += object->m_offset.x + (((float)rand() / (float)RAND_MAX) * 2.f - 1.f) * object->m_offsetVariance.x;
        position.y += object->m_offset.y + (((float)rand() / (float)RAND_MAX) * 2.f - 1.f) * object->m_offsetVariance.y;
        this->spawnParticleTrigger(object->m_targetGroupID, position, rotation, scale);
    }
    void spawnParticleTrigger(int particleID, cocos2d::CCPoint position, float rotation, float scale) = win 0x23fcc0, imac 0x128a10, m1 0x100dd0;
    void spawnPlayer2() = win inline, imac 0x1295d0, m1 0x101870 {
        auto parent = m_player2->getParent();
        if (!parent) {
            m_player1->getParent()->addChild(m_player2, 59);
            if (!m_isEditor) m_player2->addAllParticles();
        }
        m_player2->spawnFromPlayer(m_player1, m_gameState.m_unkBool31);
    }
    cocos2d::CCPoint speedForShaderTarget(int groupID) = win 0x223630;
    cocos2d::CCArray* staticObjectsInRect(cocos2d::CCRect rect, bool enabledGroups) = win 0x2112a0, imac 0xe0c60;
    void stopAllGroundActions() = win inline, m1 0xfde60, ios inline {
        m_groundLayer->deactivateGround();
        m_groundLayer2->deactivateGround();
    }
    void stopCameraShake() = win inline, imac 0x15ab90 {
        m_gameState.m_cameraShakeEnabled = false;
        m_gameState.m_cameraShakeFactor = 0.f;
    }
    void stopCustomEnterEffect(EnterEffectObject* object) = win inline {
        auto enterType = object->m_enterType;
        if (enterType == 0 || enterType == 1) this->stopCustomEnterEffect(object, true);
        if (enterType == 0 || enterType == 2) this->stopCustomEnterEffect(object, false);
    }
    void stopCustomEnterEffect(EnterEffectObject* object, bool enter) = win 0x20e7a0;
    void stopSFXTrigger(SFXTriggerGameObject* object) = win inline {
        if (object->m_objectID != 3602) return;
        auto engine = FMODAudioEngine::sharedEngine();
        for (auto& channel : m_gameState.m_unkUMap8[object->m_uniqueID]) {
            engine->stopChannel(channel);
            m_gameState.m_proximityVolumeRelated.erase({ channel, 0 });
        }
        m_gameState.m_unkUMap8[object->m_uniqueID].clear();
    }
    void swapBackground(int background) = win inline, imac 0x114380 {
        m_gameState.m_background = background;
        if (m_skipArtReload) return;
        auto gameManager = GameManager::sharedState();
        if (background != gameManager->m_loadedBgID) gameManager->loadBackgroundAsync(background);
        else this->asyncBGLoaded(background);
    }
    void swapGround(int ground) = win inline, imac 0x1146b0 {
        m_gameState.m_ground = ground;
        if (m_skipArtReload) return;
        auto gameManager = GameManager::sharedState();
        if (ground != gameManager->m_loadedGroundID) gameManager->loadGroundAsync(ground);
    }
    void swapMiddleground(int middleground) = win inline, imac 0x114800 {
        m_gameState.m_middleground = middleground;
        if (m_skipArtReload) return;
        auto gameManager = GameManager::sharedState();
        if (middleground == gameManager->m_loadedMG && (middleground < 1 || !m_middleground)) return;
        if (middleground == 0) this->createMiddleground(0);
        else {
            if (middleground != gameManager->m_loadedMG) gameManager->loadMiddlegroundAsync(middleground);
            else this->asyncMGLoaded(middleground);
        }
    }
    void switchToFlyMode(PlayerObject* player, GameObject* object, bool noPortal, int type) = win inline, imac 0x124130, m1 0xfcd3c {
        player->switchedToMode((GameObjectType)type);
        auto cameraObject = this->processCameraObject(object, player);
        auto noEffects = cameraObject && cameraObject->m_hasNoEffects;
        switch (type) {
            case 5:
                player->toggleFlyMode(true, noEffects);
                break;
            case 19:
                player->toggleBirdMode(true, noEffects);
                break;
            case 26:
                player->toggleDartMode(true, noEffects);
                break;
            case 41:
                player->toggleSwingMode(true, noEffects);
                break;
        }
        this->toggleGlitter(true);
    }
    void switchToRobotMode(PlayerObject* player, GameObject* object, bool noPortal) = win 0x212c60, imac 0x124320;
    void switchToRollMode(PlayerObject* player, GameObject* object, bool noPortal) = win 0x212e40, imac 0x124270;
    void switchToSpiderMode(PlayerObject* player, GameObject* object, bool noPortal) = win 0x212d50, imac 0x1243d0, m1 0xfcfe0;
    void syncBGTextures() = win 0x23ade0, imac 0x158b30, m1 0x128650;
    void teleportPlayer(TeleportPortalObject* object, PlayerObject* player) = win 0x20fdf0, imac 0x4fa60;
    void testInstantCountTrigger(int itemID, int compareCount, int groupID, bool activateGroup, int triggerMode, gd::vector<int> const& remapKeys, int uniqueID, int controlID) = win inline, imac 0x14b650, m1 0x11df58 {
        auto itemCount = m_effectManager->countForItem(itemID);
        switch (triggerMode) {
            case 0:
                if (itemCount != compareCount) return;
                break;
            case 1:
                if (itemCount <= compareCount) return;
                break;
            case 2:
                if (itemCount >= compareCount) return;
                break;
        }
        this->toggleGroupTriggered(groupID, activateGroup, remapKeys, uniqueID, controlID);
    }
    void toggleAudioVisualizer(bool visible) = win 0x2488f0, m1 0xec45c;
    void toggleDualMode(GameObject* object, bool dual, PlayerObject* player, bool noEffects) = win 0x216900, imac 0x123db0;
    void toggleFlipped(bool flip, bool noEffects) = win 0x2465e0, imac 0x127d30, m1 0x104c24;
    void toggleGroup(int id, bool activate) = win 0x223bf0, m1 0x111698;
    void toggleLockPlayer(bool disable, bool player2) = win inline, imac 0x13ccd0, m1 0x111a8c, ios inline {
        auto player = player2 ? m_player2 : m_player1;
        if (disable) player->disablePlayerControls();
        else player->enablePlayerControls();
    }
    void togglePlayerStreakBlend(bool blend) = win inline {
        if (blend != m_gameState.m_playerStreakBlend) {
            m_gameState.m_playerStreakBlend = blend;
            m_player1->updateStreakBlend(blend);
            m_player2->updateStreakBlend(blend);
        }
    }
    void togglePlayerVisibility(bool visible) = win inline {
        this->togglePlayerVisibility(visible, true);
        this->togglePlayerVisibility(visible, false);
    }
    void togglePlayerVisibility(bool visible, bool player1) = win inline, ios inline {
        if (player1)
            this->m_player1->toggleVisibility(visible);
        else
            this->m_player2->toggleVisibility(visible);
    }
    void transformAreaObjects(GameObject* object, cocos2d::CCArray* objects, float scaleX, float scaleY, bool reset) = win 0x229750, imac 0x143990, m1 0x1178bc;
    void triggerAdvancedFollowCommand(AdvancedFollowTriggerObject* object) = win inline {
        auto targetID = object->m_centerGroupID;
        if (object->m_targetPlayer1) targetID = -1;
        else if (object->m_targetPlayer2) targetID = -2;
        else if (object->m_followCPP) targetID = -3;
        auto exists = false;
        for (auto& inst : m_gameState.m_advanceFollowInstances) {
            if (inst.m_gameObject != object || inst.m_group != object->m_targetGroupID || inst.m_objectKey != targetID || inst.m_controlId != object->m_controlID) continue;
            inst.m_finished = false;
            inst.m_doStart = false;
            inst.m_relatedToGJGameStateUnkUint7 = ++m_gameState.m_unkUint7;
            exists = true;
        }
        if (!exists) {
            m_gameState.m_advanceFollowInstances.emplace_back(object, object->m_targetGroupID, targetID, 0, ++m_gameState.m_unkUint7, object->m_controlID);
        }
    }
    void triggerAdvancedFollowEditCommand(AdvancedFollowEditObject* object) = win 0x22eaf0;
    void triggerAreaEffect(EnterEffectObject* object) = win 0x2271f0, imac 0x13fa10;
    void triggerAreaEffectAnimation(EnterEffectObject* object) = win inline, imac 0x13ff20 {
        auto targetID = object->m_targetGroupID;
        if (object->m_useEffectID) {
            for (int i = 0; i < 5; i++) {
                std::vector<EnterEffectInstance>* instances;
                switch (i) {
                    case 0: instances = &m_gameState.m_moveEffectInstances; break;
                    case 1: instances = &m_gameState.m_rotateEffectInstances; break;
                    case 2: instances = &m_gameState.m_scaleEffectInstances; break;
                    case 3: instances = &m_gameState.m_fadeEffectInstances; break;
                    case 4: instances = &m_gameState.m_tintEffectInstances; break;
                    default: continue;
                }
                for (auto& inst : *instances) {
                    if (inst.m_gameObject->m_effectID == targetID) {
                        inst.loadTransitions(object, m_gameState.m_totalTime);
                        if (targetID > 0) break;
                    }
                    else break;
                }
            }
        }
        else {
            auto group = this->getGroup(targetID);
            for (auto obj : geode::cocos::CCArrayExt<cocos2d::CCObject*, false>(group)) {
                auto groupObject = static_cast<GameObject*>(obj);
                if (groupObject->m_unk390 != 45) continue;
                std::vector<EnterEffectInstance>* instances;
                switch (groupObject->m_objectID) {
                    case 3006: instances = &m_gameState.m_moveEffectInstances; break;
                    case 3007: instances = &m_gameState.m_rotateEffectInstances; break;
                    case 3008: instances = &m_gameState.m_scaleEffectInstances; break;
                    case 3009: instances = &m_gameState.m_fadeEffectInstances; break;
                    case 3010: instances = &m_gameState.m_tintEffectInstances; break;
                    default: continue;
                }
                for (auto& inst : *instances) {
                    if (inst.m_gameObject == groupObject) {
                        inst.loadTransitions(object, m_gameState.m_totalTime);
                    }
                }
            }
        }
    }
    void triggerDynamicMoveCommand(EffectGameObject* object) = win inline {
        auto targetID = object->m_targetModCenterID;
        if (targetID < 1) targetID = object->m_targetGroupID;
        auto object1 = this->tryGetObject(targetID);
        GameObject* object2;
        if (!object->m_targetPlayer1) {
            if (!object->m_targetPlayer2) object2 = this->tryGetObject(object->m_centerGroupID);
            else if (m_gameState.m_isDualMode) object2 = m_player2;
            else object2 = m_player1;
        }
        else object2 = m_player1;
        if (object1 && object2) {
            m_gameState.m_dynamicMoveActions.emplace_back(object, object1, object2);
        }
    }
    void triggerDynamicRotateCommand(EnhancedTriggerObject* object) = win 0x21f2d0;
    void triggerGradientCommand(GradientTriggerObject* object) = win 0x21f780, m1 0x26c304;
    void triggerGravityChange(EffectGameObject* object, int playerID) = win inline {
        if (object->m_followCPP) {
            if (playerID == 1) m_player1->m_gravityMod = object->m_gravityValue;
            else if (playerID == 2) m_player2->m_gravityMod = object->m_gravityValue;
        }
        else {
            if (object->m_targetPlayer1) m_player1->m_gravityMod = object->m_gravityValue;
            else if (object->m_targetPlayer2) m_player2->m_gravityMod = object->m_gravityValue;
        }
    }
    void triggerMoveCommand(EffectGameObject* object) = win 0x21ea70;
    void triggerRotateCommand(EnhancedTriggerObject* object) = win inline, imac 0x138240, m1 0x10d674 {
        if (object->m_isDynamicMode && object->m_duration != 0.f) {
            if (object->m_useMoveTarget || object->m_isDirectionFollowSnap360) {
                this->triggerDynamicRotateCommand(object);
            }
        }
        else {
            auto rotation = object->m_times360 * 360.f + object->m_rotationDegrees;
            if (object->m_useMoveTarget || object->m_isDirectionFollowSnap360) {
                GameObject* centerObject;
                GameObject* targetObject;
                GameObject* rotateObject;
                this->getRotateCommandTargets(object, centerObject, targetObject, rotateObject);
                if (centerObject && targetObject && rotateObject) {
                    auto minXObject = this->tryGetObject(object->m_minXID);
                    auto minYObject = this->tryGetObject(object->m_minYID);
                    auto maxXObject = this->tryGetObject(object->m_maxXID);
                    auto maxYObject = this->tryGetObject(object->m_maxYID);
                    auto centerPosition = centerObject->getRealPosition();
                    auto targetPosition = targetObject->getRealPosition();
                    auto rotatePosition = rotateObject->getRealPosition();
                    if (centerObject == targetObject) {
                        rotation = centerObject->getRotation();
                    }
                    else {
                        auto difference = targetPosition - centerPosition;
                        if (sqrtf(difference.x * difference.x + difference.y * difference.y) < .01f) {
                            rotation = centerObject->getRotation();
                        }
                        else {
                            rotation = 90.f - atan2f(difference.y, difference.x) * (180.f / M_PI);
                        }
                    }
                    auto distance = 0.f;
                    if (centerObject != targetObject) {
                        if (object->m_useMoveTarget) {
                            if (minXObject) {
                                auto minX = minXObject->getRealPosition().x;
                                if (rotatePosition.x < minX) rotatePosition.x = minX;
                            }
                            if (maxXObject) {
                                auto maxX = maxXObject->getRealPosition().x;
                                if (rotatePosition.x > maxX) rotatePosition.x = maxX;
                            }
                            if (minYObject) {
                                auto minY = minYObject->getRealPosition().y;
                                if (rotatePosition.y < minY) rotatePosition.y = minY;
                            }
                            if (maxYObject) {
                                auto maxY = maxYObject->getRealPosition().y;
                                if (rotatePosition.y > maxY) rotatePosition.y = maxY;
                            }
                            auto difference = rotatePosition - centerPosition;
                            if (sqrtf(difference.x * difference.x + difference.y * difference.y) >= .01f) {
                                distance = 90.f - atan2f(difference.y, difference.x) * (180.f / M_PI);
                            }
                        }
                        else {
                            distance = rotateObject->getRotation();
                        }
                    }
                    rotation = convertToClosestDirection(distance - rotation + object->m_rotationOffset, 180.f);
                }
                m_effectManager->createRotateCommand(rotation, object->m_duration, object->m_targetGroupID, object->m_centerGroupID,
                    (int)object->m_easingType, object->m_easingRate, object->m_lockObjectRotation, false, false, object->m_uniqueID, object->m_controlID);
            }
        }
    }
    void triggerShaderCommand(ShaderGameObject* object) = win 0x221060, imac 0x1b1930;
    void triggerTransformCommand(TransformTriggerGameObject* object) = win 0x21f4f0;
    GameObject* tryGetGroupParent(int groupID) = win inline, imac 0x13d3b0, m1 0x112178, ios inline {
        if (auto groupParent = static_cast<GameObject*>(m_parentGroupsDict->objectForKey(groupID))) return groupParent;
        auto group = this->getGroup(groupID);
        for (auto obj : geode::cocos::CCArrayExt<cocos2d::CCObject*, false>(group)) {
            auto object = static_cast<GameObject*>(obj);
            if (object->m_hasGroupParent) return object;
        }
        return nullptr;
    }
    GameObject* tryGetMainObject(int groupID) = win 0x224550, imac 0x12a4b0, m1 0x102628;
    GameObject* tryGetObject(int groupID) = win 0x2245c0, imac 0x1233f0, m1 0xfc108;
    void tryResumeAudio() = win inline {
        if (m_resumeTimer < 1 && m_audioPaused) {
            this->resumeAudio();
            m_audioPaused = false;
        }
    }
    void unclaimParticle(char const* key, cocos2d::CCParticleSystemQuad* particle) = win 0x2409f0, imac 0x15d690, m1 0x12c504;
    void ungroupStickyObjects(cocos2d::CCArray* objects) = win 0x224cb0, imac 0x13dd90, m1 0x112a58;
    void unlinkAllEvents() = win inline, ios inline {
        m_gameState.m_unkMapPairGJGameEventIntVectorEventTriggerInstance.clear();
    }
    void updateActiveEnterEffect(EnterEffectObject* object) = win inline {
        auto id = -2;
        switch (object->m_objectID) {
            case 23: id = -6; break;
            case 24: id = -5; break;
            case 25: id = -7; break;
            case 26: id = -8; break;
            case 27: id = -3; break;
            case 28: id = -4; break;
            case 55: id = -11; break;
            case 56: id = -10; break;
            case 57: id = -9; break;
            case 58: id = -12; break;
            case 59: id = -13; break;
            case 1915: id = -14; break;
            case 3017: case 3018: case 3019: case 3020: case 3021: id = -15; break;
        }
        auto enterType = object->m_enterType;
        if (enterType == 0 || enterType == 1) {
            m_gameState.m_enterChannelMap[object->m_enterChannel] = id;
            if (id == -15) this->addCustomEnterEffect(object, true);
            else this->removeCustomEnterEffects(id, true);
        }
        if (enterType == 0 || enterType == 2) {
            m_gameState.m_exitChannelMap[object->m_enterChannel] = id;
            if (id == -15) this->addCustomEnterEffect(object, false);
            else this->removeCustomEnterEffects(id, false);
        }
    }
    void updateAllObjectSection() = win inline {
        for (auto obj : geode::cocos::CCArrayExt<cocos2d::CCObject*, false>(m_objects)) {
            this->updateObjectSection(static_cast<GameObject*>(obj));
        }
    }
    void updateAreaObjectLastValues(GameObject* object) = win 0x227ee0 {
        if (object->m_isDecoration2) return;
        if (object->m_unk4C4 != m_gameState.m_unkUint2) {
            object->m_lastPosition.x = object->m_positionX;
            object->m_lastPosition.y = object->m_positionY;
            object->m_unk4C4 = m_gameState.m_unkUint2;
            object->dirtifyObjectRect();
        }
        if (object->m_unk4CC != m_gameState.m_unkUint2) {
            object->m_customScaleX = object->m_scaleX;
            object->m_customScaleY = object->m_scaleY;
            object->m_unk4CC = m_gameState.m_unkUint2;
            object->dirtifyObjectRect();
        }
    }
    void updateAudioVisualizer() = win 0x248690;
    void updateBGArtSpeed(float modX, float modY) = win inline, imac 0x159760, m1 0x128fec {
        m_gameState.m_unkFloat5 = modX;
        m_gameState.m_unkFloat6 = modY;
    }
    void updateCamera(float dt) = win 0x23bb00;
    void updateCameraBGArt(cocos2d::CCPoint position, float zoom) = win 0x23e260, imac 0x15ae40, m1 0x2918b4;
    void updateCameraEdge(int direction, int value) = win inline {
        switch (direction) {
            case 1:
                m_gameState.m_cameraEdgeValue0 = value;
                break;
            case 2:
                m_gameState.m_cameraEdgeValue1 = value;
                break;
            case 3:
                m_gameState.m_cameraEdgeValue2 = value;
                break;
            case 4:
                m_gameState.m_cameraEdgeValue3 = value;
                break;
        }
    }
    void updateCameraMode(EffectGameObject* obj, bool updateDual) = win inline, imac 0x1247a0 {
        auto cameraFree = obj->m_cameraIsFreeMode;
        auto freeMode = m_gameState.m_unkBool8;
        m_gameState.m_unkBool8 = cameraFree;
        m_gameState.m_unkBool9 = obj->m_cameraDisableGridSnap;
        if (obj->m_cameraEditCameraSettings) {
            m_gameState.m_unkFloat3 = std::clamp(obj->m_cameraEasingValue, 1.f, 40.f);
            m_gameState.m_unkFloat2 = std::clamp(obj->m_cameraPaddingValue, 0.f, 1.f);
        }
        if (cameraFree != freeMode && updateDual) this->updateDualGround(m_player1, m_gameState.m_dualRelated, false, 0.f);
    }
    void updateCameraOffsetX(float offsetX, float duration, int easingType, float easingRate, int uniqueID, int controlID) = win 0x235db0;
    void updateCameraOffsetY(float offsetY, float duration, int easingType, float easingRate, int uniqueID, int controlID) = win 0x235e50;
    void updateCollisionBlocks() = win 0x218800;
    void updateCounters(int itemId, int value) = win 0x233d00;
    void updateDualGround(PlayerObject* object, int mode, bool instant, float duration) = win 0x2131c0, m1 0xfd08c;
    void updateEnterEffects(float dt) = win 0x20e9a0, imac 0x11ee60, m1 0xf79c0;
    void updateExtendedCollision(GameObject* object, bool extendedCollision) = win inline {
        if (object->m_hasExtendedCollision != extendedCollision) {
            this->removeObjectFromSection(object);
            object->m_hasExtendedCollision = extendedCollision;
            this->addToSection(object);
        }
    }
    void updateExtraGameLayers() = win 0x223880, imac 0x13c510, m1 0x111354;
    void updateGameplayOffsetX(int offsetX, bool staticOffset) = win inline, imac 0x14edf0, m1 0x120c14 {
        m_gameState.m_unkInt1 = offsetX;
        m_gameState.m_unkBool2 = staticOffset;
    }
    void updateGameplayOffsetY(int offsetY, bool staticOffset) = win inline, imac 0x14ee30, m1 0x120c30 {
        m_gameState.m_unkInt2 = offsetY;
        m_gameState.m_unkBool3 = staticOffset;
    }
    void updateGradientLayers() = win 0x21fc10;
    void updateGroundShadows() = win 0x20bda0, imac 0x38d7f0;
    void updateGuideArt() = win 0x2464d0;
    void updateInternalCamOffsetX(float offsetX, float duration, float easingRate) = win inline, imac 0x15b9e0, ios inline {
        m_gameState.m_unkPoint27.x = offsetX;
        if (duration > 0.f) {
            m_gameState.tweenValue(m_gameState.m_unkPoint26.x, offsetX, 18, duration, 1, easingRate, -1, -1);
        }
        else {
            m_gameState.stopTweenAction(18);
            m_gameState.m_unkPoint26.x = m_gameState.m_unkPoint27.x;
        }
    }
    void updateInternalCamOffsetY(float offsetY, float duration, float easingRate) = win inline, imac 0x15bad0, ios inline {
        m_gameState.m_unkPoint27.y = offsetY;
        if (duration > 0.f) {
            m_gameState.tweenValue(m_gameState.m_unkPoint26.y, offsetY, 19, duration, 1, easingRate, -1, -1);
        }
        else {
            m_gameState.stopTweenAction(10);
            m_gameState.m_unkPoint26.y = m_gameState.m_unkPoint27.y;
        }
    }
    void updateKeyframeOrder(int keyframeGroup) = win 0x233a50, imac 0x14b390, m1 0x11dd14;
    void updateLayerCapacity(gd::string capacityString) = win 0x20cd40, m1 0x2ec058;
    void updateLegacyLayerCapacity(int front, int frontBlend, int back, int backBlend) = win inline, imac 0x1152b0, m1 0xf0058 {
        if (front < 100) front = 100;
        if (frontBlend < 100) frontBlend = 100;
        if (back < 100) back = 100;
        if (backBlend < 100) backBlend = 100;
        m_gameLayerT1->increaseAtlasCapacity(front);
        m_gameBlendingLayerT1->increaseAtlasCapacity(frontBlend);
        m_game2LayerT1->increaseAtlasCapacity(20);
        m_game2BlendingLayerT1->increaseAtlasCapacity(20);
        m_game2LayerB1->increaseAtlasCapacity(20);
        m_gameLayerB1->increaseAtlasCapacity(back);
        m_gameBlendingLayerB1->increaseAtlasCapacity(backBlend);
        m_gameLayerB2->increaseAtlasCapacity(back);
        m_gameBlendingLayerB2->increaseAtlasCapacity(backBlend);
        m_glowLayerT1->increaseAtlasCapacity(frontBlend / 2);
        m_glowLayerB1->increaseAtlasCapacity(backBlend / 2);
        m_glowLayerB2->increaseAtlasCapacity(backBlend / 2);
    }
    void updateLevelColors() = win 0x20c4d0, imac 0x114400, m1 0xef2d8;
    void updateMaxGameplayY() = win 0x23ad00, imac 0x1589e0, m1 0x1284ec;
    void updateMGArtSpeed(float modX, float modY) = win inline, imac 0x1597a0, m1 0x129020 {
        m_gameState.m_unkFloat7 = modX;
        m_gameState.m_unkFloat8 = modY;
    }
    void updateMGOffsetY(float offsetY, float duration, int easingType, float easingRate, int uniqueID, int controlID) = win 0x235ef0;
    void updateOBB2(cocos2d::CCRect rect) = win inline, imac 0x122b80, m1 0xfb900 {
        m_obb2->calculateWithCenter(rect.size * .5f, rect.size.width, rect.size.height, 0.f);
    }
    void updateParticles(float dt) = win 0x241150, imac 0x15dfa0, m1 0x12ce5c;
    void updatePlatformerTime() = win 0x239500, imac 0x1560e0;
    void updatePlayerCollisionBlocks() = win 0x2185d0, imac 0x12ab50, m1 0x102c4c;
    void updateProximityVolumeEffects() = win 0x242130, imac 0x155f60, m1 0x126358;
    void updateQueuedLabels() = win inline, imac 0x14da50, m1 0x11fbd4 {
        for (auto& pair : m_labelObjects) {
            for (auto label : pair.second) {
                if (label->m_isActivated) label->updateLabelIfDirty();
            }
        }
        for (auto& pair : m_timeLabelObjects) {
            for (auto label : pair.second) {
                if (label->m_isActivated) label->updateLabelIfDirty();
            }
        }
    }
    void updateReplay() = win inline {
        if (!m_useReplay) return;
        for (auto it = m_queuedReplayButtons.begin(); it != m_queuedReplayButtons.end() && it->m_step <= m_gameState.m_unkUint2;) {
            this->handleButton(it->m_isPush, (int)it->m_button, it->m_isPlayer2);
            it = m_queuedReplayButtons.erase(it);
        }
    }
    void updateSavePositionObjects() = win inline, imac 0x12beb0, m1 0x103dcc {
        if (m_gameState.m_unkUint4 != 0 && m_gameState.m_unkUint4 + 1000 > m_gameState.m_unkUint5) return;
        m_gameState.m_unkUint4 = m_gameState.m_unkUint5;
        m_gameState.m_unkUint11++;
        for (auto& pair : m_savePositionValues) {
            cocos2d::CCPoint position;
            auto type = pair.first;
            auto value = pair.second;
            auto offset = 0;
            if (type < 1) {
                switch (type) {
                    case -1:
                        offset = m_player1->m_unk52C;
                        position = m_player1->m_lastPosition;
                        break;
                    case -2:
                        offset = m_player2->m_unk52C;
                        position = m_player2->m_lastPosition;
                        break;
                    case -3:
                        offset = m_gameState.m_unkUint12;
                        position = m_gameState.m_cameraPosition2;
                        break;
                }
            }
            else {
                auto object = m_savePositionObjects[type];
                offset = object->m_unk52C;
                position = object->m_lastPosition;
            }
            auto index = (m_gameState.m_unkUint11 % value + offset) * 2;
            m_gameState.m_unkVecFloat1[index] = position.x;
            m_gameState.m_unkVecFloat1[index + 1] = position.y;
        }
    }
    void updateShaderLayer(float dt) = win 0x2222e0, imac 0x3fcab0, m1 0x343a38;
    void updateSpecialGroupData() = imac 0x1171b0, m1 0xf1b58, win 0x20df70;
    void updateSpecialLabels() = win 0x239220, imac 0x155a10, m1 0x125f34;
    void updateStaticCameraPos(cocos2d::CCPoint pos, bool staticX, bool staticY, bool followOrSmoothEase, float time, int easingType, float easingRate) = win 0x23f040, imac 0x124fb0, m1 0xfdaf0;
    void updateStaticCameraPosToGroup(int centerID, bool updateX, bool updateY, bool followObject, float followEase, float duration, int easingType, float easingRate, bool smoothVelocity, float velocityMod) = win 0x23ec50, imac 0x15bca0, m1 0x12af14;
    void updateTimeMod(float speed, bool players, bool noEffects) = win inline, imac 0x124620 {
        if (players) {
            m_gameState.m_timeModRelated = 0;
            m_gameState.m_timeModRelated2 = false;
            m_player1->updateTimeMod(speed, noEffects);
            if (m_gameState.m_isDualMode) m_player2->updateTimeMod(speed, noEffects);
        }
        else {
            m_gameState.m_timeModRelated = speed;
            m_gameState.m_timeModRelated2 = noEffects;
        }
    }
    void updateTimerLabels() = win 0x235080, imac 0x14db10, m1 0x11f6ec;
    void updateZoom(float zoom, float duration, int easing, float rate, int uniqueID, int controlID) = win 0x235b30, imac 0x14e690;
    void visitWithColorFlash() = win 0x2480d0, imac 0x164b50, m1 0x1323c4;
    float volumeForProximityEffect(SFXTriggerInstance& instance) = win 0x242400;

    PAD = win 0x8, android32 0x8, android64 0x8, imac 0x8, m1 0x8, ios 0x8;
    GJGameState m_gameState;
    GJGameLevel* m_level;
    PlaybackMode m_playbackMode;
    bool m_lowDetailMode;
    bool m_extraLDM;
    bool m_ignoreDamage;
    bool m_enable22Changes;
    bool m_allowStaticRotate;
    bool m_fixNegativeScale;
    bool m_startingFromBeginning;
    gd::vector<SFXTriggerGameObject*> m_activeSfxTriggers;
    gd::vector<void*> m_unk8a0;
    cocos2d::CCNode* m_hoverNode;
    cocos2d::CCNode* m_areaTransformNode;
    cocos2d::CCNode* m_areaSkewNode;
    cocos2d::CCNode* m_areaScaleNode;
    cocos2d::CCNode* m_areaRotateNode;
    cocos2d::CCNode* m_areaTransformNode2;
    OBB2D* m_obb2;
    gd::vector<gd::unordered_map<int,int>> m_spawnRemapTriggers;
    gd::unordered_map<int, cocos2d::CCPoint> m_uiObjectPositions;
    GJEffectManager* m_effectManager;
    cocos2d::CCSpriteBatchNode* m_gameBlendingLayerT5;
    cocos2d::CCSpriteBatchNode* m_fireBlendingLayerT5;
    cocos2d::CCSpriteBatchNode* m_pixelBlendingLayerT5;
    cocos2d::CCSpriteBatchNode* m_particleBlendingLayerT5;
    cocos2d::CCSpriteBatchNode* m_game2BlendingLayerT5;
    cocos2d::CCSpriteBatchNode* m_gameLayerT4;
    cocos2d::CCSpriteBatchNode* m_gameBlendingLayerT4;
    cocos2d::CCSpriteBatchNode* m_glowLayerT4;
    CCNodeContainer* m_specialLayerT4;
    cocos2d::CCSpriteBatchNode* m_textLayerT4;
    cocos2d::CCSpriteBatchNode* m_textBlendingLayerT4;
    cocos2d::CCSpriteBatchNode* m_fireLayerT4;
    cocos2d::CCSpriteBatchNode* m_fireBlendingLayerT4;
    cocos2d::CCSpriteBatchNode* m_pixelLayerT4;
    cocos2d::CCSpriteBatchNode* m_pixelBlendingLayerT4;
    cocos2d::CCSpriteBatchNode* m_particleLayerT4;
    cocos2d::CCSpriteBatchNode* m_particleBlendingLayerT4;
    cocos2d::CCSpriteBatchNode* m_game2LayerT4;
    cocos2d::CCSpriteBatchNode* m_game2BlendingLayerT4;
    cocos2d::CCSpriteBatchNode* m_gameLayerT3;
    cocos2d::CCSpriteBatchNode* m_gameBlendingLayerT3;
    cocos2d::CCSpriteBatchNode* m_glowLayerT3;
    CCNodeContainer* m_specialLayerT3;
    cocos2d::CCSpriteBatchNode* m_textLayerT3;
    cocos2d::CCSpriteBatchNode* m_textBlendingLayerT3;
    cocos2d::CCSpriteBatchNode* m_fireLayerT3;
    cocos2d::CCSpriteBatchNode* m_fireBlendingLayerT3;
    cocos2d::CCSpriteBatchNode* m_pixelLayerT3;
    cocos2d::CCSpriteBatchNode* m_pixelBlendingLayerT3;
    cocos2d::CCSpriteBatchNode* m_particleLayerT3;
    cocos2d::CCSpriteBatchNode* m_particleBlendingLayerT3;
    cocos2d::CCSpriteBatchNode* m_game2LayerT3;
    cocos2d::CCSpriteBatchNode* m_game2BlendingLayerT3;
    cocos2d::CCSpriteBatchNode* m_gameLayerT2;
    cocos2d::CCSpriteBatchNode* m_gameBlendingLayerT2;
    cocos2d::CCSpriteBatchNode* m_glowLayerT2;
    CCNodeContainer* m_specialLayerT2;
    cocos2d::CCSpriteBatchNode* m_textLayerT2;
    cocos2d::CCSpriteBatchNode* m_textBlendingLayerT2;
    cocos2d::CCSpriteBatchNode* m_fireLayerT2;
    cocos2d::CCSpriteBatchNode* m_fireBlendingLayerT2;
    cocos2d::CCSpriteBatchNode* m_pixelLayerT2;
    cocos2d::CCSpriteBatchNode* m_pixelBlendingLayerT2;
    cocos2d::CCSpriteBatchNode* m_particleLayerT2;
    cocos2d::CCSpriteBatchNode* m_particleBlendingLayerT2;
    cocos2d::CCSpriteBatchNode* m_game2LayerT2;
    cocos2d::CCSpriteBatchNode* m_game2BlendingLayerT2;
    cocos2d::CCSpriteBatchNode* m_gameLayerT1;
    cocos2d::CCSpriteBatchNode* m_gameBlendingLayerT1;
    cocos2d::CCSpriteBatchNode* m_glowLayerT1;
    CCNodeContainer* m_specialLayerT1;
    cocos2d::CCSpriteBatchNode* m_textLayerT1;
    cocos2d::CCSpriteBatchNode* m_textBlendingLayerT1;
    cocos2d::CCSpriteBatchNode* m_fireLayerT1;
    cocos2d::CCSpriteBatchNode* m_fireBlendingLayerT1;
    cocos2d::CCSpriteBatchNode* m_pixelLayerT1;
    cocos2d::CCSpriteBatchNode* m_pixelBlendingLayerT1;
    cocos2d::CCSpriteBatchNode* m_particleLayerT1;
    cocos2d::CCSpriteBatchNode* m_particleBlendingLayerT1;
    cocos2d::CCSpriteBatchNode* m_game2LayerT1;
    cocos2d::CCSpriteBatchNode* m_game2BlendingLayerT1;
    cocos2d::CCSpriteBatchNode* m_game2LayerB0;
    cocos2d::CCSpriteBatchNode* m_gameBlendingLayerB0;
    cocos2d::CCSpriteBatchNode* m_fireBlendingLayerB0;
    cocos2d::CCSpriteBatchNode* m_pixelBlendingLayerB0;
    cocos2d::CCSpriteBatchNode* m_particleBlendingLayerB0;
    cocos2d::CCSpriteBatchNode* m_game2BlendingLayerB0;
    cocos2d::CCSpriteBatchNode* m_gameLayerB1;
    cocos2d::CCSpriteBatchNode* m_gameBlendingLayerB1;
    cocos2d::CCSpriteBatchNode* m_glowLayerB1;
    CCNodeContainer* m_specialLayerB1;
    cocos2d::CCSpriteBatchNode* m_textLayerB1;
    cocos2d::CCSpriteBatchNode* m_textBlendingLayerB1;
    cocos2d::CCSpriteBatchNode* m_fireLayerB1;
    cocos2d::CCSpriteBatchNode* m_fireBlendingLayerB1;
    cocos2d::CCSpriteBatchNode* m_pixelLayerB1;
    cocos2d::CCSpriteBatchNode* m_pixelBlendingLayerB1;
    cocos2d::CCSpriteBatchNode* m_particleLayerB1;
    cocos2d::CCSpriteBatchNode* m_particleBlendingLayerB1;
    cocos2d::CCSpriteBatchNode* m_game2LayerB1;
    cocos2d::CCSpriteBatchNode* m_game2BlendingLayerB1;
    cocos2d::CCSpriteBatchNode* m_gameLayerB2;
    cocos2d::CCSpriteBatchNode* m_gameBlendingLayerB2;
    cocos2d::CCSpriteBatchNode* m_glowLayerB2;
    CCNodeContainer* m_specialLayerB2;
    cocos2d::CCSpriteBatchNode* m_textLayerB2;
    cocos2d::CCSpriteBatchNode* m_textBlendingLayerB2;
    cocos2d::CCSpriteBatchNode* m_fireLayerB2;
    cocos2d::CCSpriteBatchNode* m_fireBlendingLayerB2;
    cocos2d::CCSpriteBatchNode* m_pixelLayerB2;
    cocos2d::CCSpriteBatchNode* m_pixelBlendingLayerB2;
    cocos2d::CCSpriteBatchNode* m_particleLayerB2;
    cocos2d::CCSpriteBatchNode* m_particleBlendingLayerB2;
    cocos2d::CCSpriteBatchNode* m_game2LayerB2;
    cocos2d::CCSpriteBatchNode* m_game2BlendingLayerB2;
    cocos2d::CCSpriteBatchNode* m_gameLayerB3;
    cocos2d::CCSpriteBatchNode* m_gameBlendingLayerB3;
    cocos2d::CCSpriteBatchNode* m_glowLayerB3;
    CCNodeContainer* m_specialLayerB3;
    cocos2d::CCSpriteBatchNode* m_textLayerB3;
    cocos2d::CCSpriteBatchNode* m_textBlendingLayerB3;
    cocos2d::CCSpriteBatchNode* m_fireLayerB3;
    cocos2d::CCSpriteBatchNode* m_fireBlendingLayerB3;
    cocos2d::CCSpriteBatchNode* m_pixelLayerB3;
    cocos2d::CCSpriteBatchNode* m_pixelBlendingLayerB3;
    cocos2d::CCSpriteBatchNode* m_particleLayerB3;
    cocos2d::CCSpriteBatchNode* m_particleBlendingLayerB3;
    cocos2d::CCSpriteBatchNode* m_game2LayerB3;
    cocos2d::CCSpriteBatchNode* m_game2BlendingLayerB3;
    cocos2d::CCSpriteBatchNode* m_gameLayerB4;
    cocos2d::CCSpriteBatchNode* m_gameBlendingLayerB4;
    cocos2d::CCSpriteBatchNode* m_glowLayerB4;
    CCNodeContainer* m_specialLayerB4;
    cocos2d::CCSpriteBatchNode* m_textLayerB4;
    cocos2d::CCSpriteBatchNode* m_textBlendingLayerB4;
    cocos2d::CCSpriteBatchNode* m_fireLayerB4;
    cocos2d::CCSpriteBatchNode* m_fireBlendingLayerB4;
    cocos2d::CCSpriteBatchNode* m_pixelLayerB4;
    cocos2d::CCSpriteBatchNode* m_pixelBlendingLayerB4;
    cocos2d::CCSpriteBatchNode* m_particleLayerB4;
    cocos2d::CCSpriteBatchNode* m_particleBlendingLayerB4;
    cocos2d::CCSpriteBatchNode* m_game2LayerB4;
    cocos2d::CCSpriteBatchNode* m_game2BlendingLayerB4;
    cocos2d::CCSpriteBatchNode* m_gameLayerB5;
    cocos2d::CCSpriteBatchNode* m_gameBlendingLayerB5;
    cocos2d::CCSpriteBatchNode* m_glowLayerB5;
    CCNodeContainer* m_specialLayerB5;
    cocos2d::CCSpriteBatchNode* m_textLayerB5;
    cocos2d::CCSpriteBatchNode* m_textBlendingLayerB5;
    cocos2d::CCSpriteBatchNode* m_fireLayerB5;
    cocos2d::CCSpriteBatchNode* m_fireBlendingLayerB5;
    cocos2d::CCSpriteBatchNode* m_pixelLayerB5;
    cocos2d::CCSpriteBatchNode* m_pixelBlendingLayerB5;
    cocos2d::CCSpriteBatchNode* m_particleLayerB5;
    cocos2d::CCSpriteBatchNode* m_particleBlendingLayerB5;
    cocos2d::CCSpriteBatchNode* m_game2LayerB5;
    cocos2d::CCSpriteBatchNode* m_game2BlendingLayerB5;
    PlayerObject* m_player1;
    PlayerObject* m_player2;
    LevelSettingsObject* m_levelSettings;
    cocos2d::CCArray* m_objects;
    cocos2d::CCArray* m_collisionBlocks;
    cocos2d::CCArray* m_spawnObjectsArray;
    cocos2d::CCDictionary* m_spawnObjects;
    cocos2d::CCNode* m_unkdd0;
    gd::vector<GameObject*> m_unkdd8;
    gd::vector<GameObject*> m_disabledObjects;
    gd::vector<GameObject*> m_unke08;
    gd::vector<GameObject*> m_areaObjects;
    gd::vector<GameObject*> m_processedAreaObjects;
    gd::unordered_map<int, gd::vector<GameObject*>> m_visibilityGroups;
    gd::vector<GameObject*> m_visibleObjects;
    int m_visibleObjectsCount;
    int m_visibleObjectsIndex;
    gd::vector<GameObject*> m_visibleObjects2;
    int m_visibleObjects2Count;
    int m_visibleObjects2Index;
    int m_unked0;
    int m_disabledObjectsCount;
    int m_unked8;
    int m_areaObjectsCount;
    int m_processedAreaObjectsCount;
    int m_unkee4;
    int m_disabledObjectsIndex;
    int m_unkeec;
    int m_areaObjectsIndex;
    int m_processedAreaObjectsIndex;
    cocos2d::CCDictionary* m_groupDict;
    cocos2d::CCDictionary* m_staticGroupDict;
    cocos2d::CCDictionary* m_optimizedGroupDict;
    gd::vector<cocos2d::CCArray*> m_groups;
    gd::vector<cocos2d::CCArray*> m_staticGroups;
    gd::vector<cocos2d::CCArray*> m_optimizedGroups;
    cocos2d::CCDictionary* m_parentGroupsDict;
    cocos2d::CCDictionary* m_parentGroupIDs;
    cocos2d::CCDictionary* m_removedParentGroupIDs;
    cocos2d::CCArray* m_targetGroupsArray;
    gd::unordered_map<int, std::pair<int, int>> m_targetGroups;
    cocos2d::CCDictionary* m_linkedGroupDict;
    int m_lastUsedLinkedID;
    cocos2d::CCNode* m_objectParent;
    cocos2d::CCNode* m_inShaderParent;
    cocos2d::CCNode* m_aboveShaderParent;
    cocos2d::CCLayer* m_objectLayer;
    cocos2d::CCLayer* m_inShaderObjectLayer;
    cocos2d::CCLayer* m_aboveShaderObjectLayer;
    cocos2d::CCSprite* m_background;
    void* m_unk1000;
    GJGroundLayer* m_groundLayer;
    GJGroundLayer* m_groundLayer2;
    GJMGLayer* m_middleground;
    cocos2d::CCArray* m_batchNodes;
    cocos2d::CCDictionary* m_objectsToDeactivate;
    gd::unordered_map<int, gd::vector<LabelGameObject*>> m_labelObjects;
    gd::unordered_map<int, gd::vector<LabelGameObject*>> m_timeLabelObjects;
    gd::set<std::tuple<int, int, int>> m_spawnTuples;
    bool m_increasedLayerCapacity;
    std::array<float, 2000> m_varianceValues;
    gd::map<std::pair<int, int>, std::pair<float, float>> m_destroyObjectValues;
    gd::vector<float> m_enterEasingValues;
    gd::unordered_map<int, int> m_enterEasingIndices;
    int m_enterEasingValuesIndex;
    bool m_dualTouchTrigger;
    int m_clicks;
    int m_attempts;
    bool m_jumping;
    int m_leftSectionIndex;
    int m_rightSectionIndex;
    int m_bottomSectionIndex;
    int m_topSectionIndex;
    bool m_isEditor;
    bool m_blending;
    bool m_isPlatformer;
    GameObject* m_player1CollisionBlock;
    GameObject* m_player2CollisionBlock;
    int m_particleCount;
    int m_customParticleCount;
    int m_particleSystemLimit;
    cocos2d::CCDictionary* m_particlesDict;
    cocos2d::CCDictionary* m_customParticles;
    cocos2d::CCArray* m_unclaimedParticles;
    gd::unordered_map<int, gd::string> m_particleCountToParticleString;
    cocos2d::CCDictionary* m_claimedParticles;
    cocos2d::CCArray* m_temporaryParticles;
    gd::unordered_set<int> m_customParticlesUIDs;
    cocos2d::CCDictionary* m_gradientLayers;
    int m_activeGradients;
    ShaderLayer* m_shaderLayer;
    bool m_objectsDeactivated;
    bool m_areaObjectsUpdated;
    StartPosObject* m_startPosObject;
    bool m_useReplay;
    bool m_unk3189;
    int m_solidCollisionObjectsCount;
    int m_solidCollisionObjectsIndex;
    gd::vector<GameObject*> m_solidCollisionObjects;
    int m_hazardCollisionObjectsCount;
    int m_hazardCollisionObjectsIndex;
    gd::vector<GameObject*> m_hazardCollisionObjects;
    gd::vector<SequenceTriggerGameObject*> m_sequenceTriggers;
    bool m_isPracticeMode;
    bool m_practiceMusicSync;
    float m_loadingProgress;
    cocos2d::CCNode* m_flashNode;
    float m_unk31f8;
    float m_cameraFlip;
    float m_cameraWidthOffset;
    float m_cameraHeightOffset;
    bool m_updateGroundShadows;
    cocos2d::CCDictionary* m_collectedItems;
    float m_levelLength;
    bool m_resetActiveObjects;
    bool m_skipArtReload;
    EndPortalObject* m_endPortal;
    bool m_isTestMode;
    bool m_freezeStartCamera;
    bool m_unk322a;
    float m_cameraUnzoomedHeightOffset;
    float m_targetCameraHeightOffset;
    bool m_calculateTargetHeightOffset;
    cocos2d::CCParticleSystemQuad* m_glitterParticles;
    bool m_staticCameraShake;
    bool m_skipCameraShake;
    bool m_playerDied;
    double m_extraDelta;
    bool m_started;
    bool m_unk3251;
    float m_cameraWidth;
    float m_cameraHeight;
    float m_cameraUnzoomedX;
    float m_halfCameraWidth;
    AudioEffectsLayer* m_audioEffectsLayer;
    OBB2D* m_cameraObb2;
    gd::vector<GameObject*> m_activeObjects;
    int m_activeObjectsCount;
    int m_activeObjectsIndex;
    cocos2d::ccColor3B m_lightBGColor;
    int m_resumeTimer;
    bool m_recordInputs;
    bool m_unk32a1;
    bool m_unk32a2;
    bool m_unk32a3;
    bool m_unk32a4;
    gd::string m_recordString;
    cocos2d::CCObject* m_unk32c8;
    int m_unk32d0;
    bool m_unk32d4;
    double m_queueInterval;
    uint64_t m_coinsCollected;
    int m_replayRandSeed;
    int m_unk32ec;
    int m_currentStep;
    gd::vector<PlayerButtonCommand> m_queuedButtons;
    gd::vector<PlayerButtonCommand> m_queuedRecordedButtons;
    gd::vector<PlayerButtonCommand> m_queuedReplayButtons;
    gd::vector<void*> m_unk3340;
    gd::vector<void*> m_unk3358;
    PAD = win 0x88, mac 0x88;
    int m_queuedRecordedButtonsSize;
    bool m_portalIndicators;
    bool m_orbIndicators;
    cocos2d::CCArray* m_indicatorSprites;
    float m_unk3380;
    gd::vector<int> m_unk3388;
    gd::vector<int> m_unk33a0;
    PAD = win 0x48, mac 0x48;
    bool m_hideGround;
    cocos2d::CCArray* m_unk33c0;
    cocos2d::CCArray* m_objectsToMove;
    gd::unordered_map<int, GameObject*> m_savePositionObjects;
    gd::unordered_map<int, int> m_savePositionValues;
    bool m_keepGroupParents;
    cocos2d::CCDictionary* m_keyframeGroups;
    int m_keyframeGroup;
    UILayer* m_uiLayer;
    cocos2d::CCArray* m_uiObjects;
    cocos2d::CCDictionary* m_uiObjectLayers;
    cocos2d::CCNode* m_uiTriggerUI;
    double m_timePlayed;
    int m_unk3568;
    int m_unk356c;
    bool m_levelEndAnimationStarted;
    int m_points;
    gd::string m_pointsString;
    gd::vector<gd::vector<gd::vector<GameObject*>*>*> m_sections;
    gd::vector<gd::vector<gd::vector<GameObject*>*>*> m_nonEffectObjects;
    gd::vector<gd::vector<GameObject*>*> m_collisionBlockSections;
    gd::vector<GameObject*> m_calcNonEffectObjects;
    int m_calcNonEffectObjectsSize;
    gd::vector<GameObject*> m_calcCollisionBlockObjects;
    int m_calcCollisionBlockObjectsSize;
    gd::vector<GameObject*> m_calcCollisionBlockObjects2;
    int m_calcCollisionBlockObjects2Size;
    gd::vector<gd::vector<int>*> m_sectionSizes;
    gd::vector<gd::vector<int>*> m_nonEffectObjectsSizes;
    gd::vector<gd::vector<int>*> m_collisionBlockSectionSizes;
    gd::vector<gd::vector<bool>*> m_nonEffectObjectsFlags;
    float m_sectionXFactor;
    float m_sectionYFactor;
    float m_maxGameplayY;
    float m_songTriggerInterval;
    gd::unordered_map<int, int> m_stickyGroups;
    FMODLevelVisualizer* m_audioVisualizerBG;
    FMODLevelVisualizer* m_audioVisualizerSFX;
    bool m_showAudioVisualizer;
    int m_areaMovedCount;
    int m_areaScaledCount;
    int m_areaRotatedCount;
    int m_areaColorCount;
    int m_areaMovedCountTotal;
    int m_areaScaledCountTotal;
    int m_areaRotatedCountTotal;
    int m_areaColorCountTotal;
    int m_movedCount;
    int m_scaledCount;
    int m_rotatedCount;
    int m_followedCount;
    int m_areaMovedCountDisplay;
    int m_areaScaledCountDisplay;
    int m_areaRotatedCountDisplay;
    int m_areaColorCountDisplay;
    int m_areaMovedCountTotalDisplay;
    int m_areaScaledCountTotalDisplay;
    int m_areaRotatedCountTotalDisplay;
    int m_areaColorCountTotalDisplay;
    int m_movedCountDisplay;
    int m_scaledCountDisplay;
    int m_rotatedCountDisplay;
    int m_followedCountDisplay;
    bool m_loadingStartPosition;
    bool m_processingAudioTriggers;
    bool m_audioPaused;
    bool m_startOptimization;
    GJGameLoadingLayer* m_loadingLayer;
    cocos2d::CCDrawNode* m_debugDrawNode;
    std::array<cocos2d::CCPoint, 400>* m_debugDrawPoints;
    bool m_isDebugDrawEnabled;
    bool m_disablePlayerHitbox;
    bool m_hitboxesOnDeath;
    GameObject* m_anticheatSpike;
    double m_timestamp;
    bool m_isBetweenSteps;
    bool m_clickBetweenSteps;
    bool m_clickOnSteps;
}

[[link(android)]]
class GJBigSprite : cocos2d::CCNode {
    // virtual ~GJBigSprite();

    static GJBigSprite* create() = imac 0x268250, m1 0x20bb34;

    virtual bool init() = m1 0x20d0f8, imac 0x269a10;

    void finishedLoadingSpriteAsync(cocos2d::CCObject* obj) = imac 0x269fa0, m1 0x20d598;
    void loadSpriteAsync(gd::string filename, int index) = m1 0x20d508;
    void unloadAll() = imac 0x268d50, m1 0x20c5a8;
    void unloadSprite(gd::string filename, int index) = m1 0x20d4a0;
    void updateSpriteVisibility() = imac 0x2682d0;

    gd::vector<bool> m_spritesLoaded;
    cocos2d::CCArray* m_spriteNodes;
    float m_scaleX;
    float m_scaleY;
    bool m_loadSprites;
    bool m_unloadingAll;
}

[[link(android)]]
class GJBigSpriteNode : cocos2d::CCNode {
    // virtual ~GJBigSpriteNode();

    static GJBigSpriteNode* create() = imac 0x269930;

    virtual bool init() = m1 0x20d0f4, imac 0x269a00;

    gd::string m_spriteName;
    cocos2d::CCSprite* m_sprite;
    cocos2d::CCRect m_spriteRect;
    bool m_spriteVisible;
}

[[link(android)]]
class GJChallengeDelegate {
    virtual void challengeStatusFinished() {}
    virtual void challengeStatusFailed() {}
}

[[link(android)]]
class GJChallengeItem : cocos2d::CCObject {
    // virtual ~GJChallengeItem();

    static GJChallengeItem* create() = win inline, imac 0x8f7d0, m1 0x80e78 {
        return create(GJChallengeType::Unknown, 0, 0, 0, "");
    }
    static GJChallengeItem* create(GJChallengeType challengeType, int goal, int reward, int timeLeft, gd::string questName) = win 0x1f4a30, m1 0x80d28;
    static GJChallengeItem* createFromString(gd::string string) = win 0x1f47d0, imac 0x8f460, m1 0x80b28;
    static GJChallengeItem* createWithCoder(DS_Dictionary* dsdict) = win inline, imac 0x8f890, m1 0x80f3c {
        auto ret = GJChallengeItem::create();
        ret->dataLoaded(dsdict);
        return ret;
    }

    virtual void encodeWithCoder(DS_Dictionary* dsdict) = win 0x1f4bb0, imac 0x8fa30, m1 0x810e4;
    virtual bool canEncode() = win inline, imac 0x8fb00, m1 0x811c0 { return true; }

    void dataLoaded(DS_Dictionary* dsdict) = win inline, imac 0x8f8d0, m1 0x80f90 {
        m_challengeType = (GJChallengeType)dsdict->getIntegerForKey("1");
        m_timeLeft = dsdict->getIntegerForKey("5");
        m_canClaim = dsdict->getBoolForKey("6");
        m_name = dsdict->getStringForKey("7");
        m_count = dsdict->getIntegerForKey("2");
        m_goal = dsdict->getIntegerForKey("3");
        m_reward = dsdict->getIntegerForKey("4");
        m_position = dsdict->getIntegerForKey("8");
    }
    void incrementCount(int add) = win inline {
        if (m_canClaim) return;
        auto newCount = m_count.value() + add;
        if (m_goal.value() <= newCount) {
            m_canClaim = true;
            m_count = m_goal.value();
        }
        else {
            m_count = newCount;
        }
    }
    bool init(GJChallengeType challengeType, int goal, int reward, int timeLeft, gd::string questName) = win inline, imac 0x8f800, m1 0x80eb0 {
        m_challengeType = challengeType;
        m_goal = goal;
        m_reward = reward;
        m_timeLeft = timeLeft;
        m_name = questName;
        return true;
    }
    void setCount(int value) {
        m_count = value;
    }

    GJChallengeType m_challengeType;
    geode::SeedValueRSV m_count;
    geode::SeedValueRSV m_reward;
    geode::SeedValueRSV m_goal;
    int m_timeLeft;
    bool m_canClaim;
    int m_position;
    gd::string m_name;
}

[[link(android)]]
class GJChestSprite : cocos2d::CCSprite {
    // virtual ~GJChestSprite();

    static GJChestSprite* create(int chestType) = win 0x3d1270, imac 0x21c850, m1 0x1c77c8;

    virtual void setOpacity(unsigned char opacity) = win 0x3d1400, m1 0x1ca2c4, imac 0x21f560;
    virtual void setColor(cocos2d::ccColor3B const& color) = win 0x3d1340, imac 0x21f470, m1 0x1ca1ec;

    bool init(int chestType) = win inline {
        if (!cocos2d::CCSprite::init()) return false;
        m_chestType = chestType;
        this->setContentSize({ 0, 0 });
        this->switchToState(ChestSpriteState::Closed, false);
        return true;
    }
    void switchToState(ChestSpriteState state, bool noGlow) = win 0x3d1470, imac 0x21de70, m1 0x1c8bd4;

    int m_chestType;
    ChestSpriteState m_spriteState;
    bool m_dark;
}

[[link(android)]]
class GJColorSetupLayer : FLAlertLayer, ColorSelectDelegate, FLAlertLayerProtocol {
    // virtual ~GJColorSetupLayer();

    static GJColorSetupLayer* create(LevelSettingsObject* object) = win 0x255d60, imac 0x20afa0, m1 0x1b6ce8;

    virtual void keyBackClicked() = win 0x256b80, imac 0x20bcc0, m1 0x1b7940;
    virtual void colorSelectClosed(cocos2d::CCNode* popup) = win 0x256ab0, imac 0x20bc90, m1 0x1b7934;

    bool init(LevelSettingsObject* object) = win 0x255ea0, imac 0x20b130;
    void onClose(cocos2d::CCObject* sender) = win 0x256b30, imac 0x20bb30, m1 0x1b77c8;
    void onColor(cocos2d::CCObject* sender) = win 0x2569e0, imac 0x20b840, m1 0x1b74d0;
    void onPage(cocos2d::CCObject* sender) = win 0x256990, imac 0x20ba90, m1 0x1b7730;
    void showPage(int page) = win 0x256ac0, imac 0x20bb80, m1 0x1b7828;
    void updateSpriteColor(ColorChannelSprite* sprite, cocos2d::CCLabelBMFont* label, int id) = win 0x256820, imac 0x20bbf0, m1 0x1b788c;
    void updateSpriteColors() = win 0x256700, imac 0x20b900, m1 0x1b7598;

    LevelSettingsObject* m_settingsObject;
    cocos2d::CCDictionary* m_unk290;
    cocos2d::CCDictionary* m_unk298;
    cocos2d::CCArray* m_colorLabels;
    cocos2d::CCArray* m_colorSprites;
    int m_page;
    int m_colorsPerPage;
    int m_totalPages;
    CCMenuItemSpriteExtra* m_prevButton;
    CCMenuItemSpriteExtra* m_nextButton;
    bool m_closeOnSelect;
    ColorSetupDelegate* m_delegate;
    int m_colorID;
}

[[link(android)]]
class GJComment : cocos2d::CCNode {
    GJComment() {
        m_commentID = 0;
        m_userID = 0;
        m_likeCount = 0;
        m_levelID = 0;
        m_isSpam = false;
        m_accountID = 0;
        m_commentDeleted = false;
        m_percentage = 0;
        m_modBadge = 0;
        m_color.r = 255;
        m_color.g = 255;
        m_color.b = 255;
        m_hasLevelID = false;
        m_unkMultiplayerBool = false;
        m_canDelete = false;
        m_userScore = nullptr;
    }
    ~GJComment() = win inline, m1 0x4b03d8 {
        CC_SAFE_RELEASE(m_userScore);
    }

    static GJComment* create() = win inline, m1 0x4b047c {
        auto ret = new GJComment();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static GJComment* create(cocos2d::CCDictionary* dict) = win 0x1752e0, imac 0x550470, m1 0xa14b4;

    virtual bool init() = win 0x175e80, imac 0x561420, m1 0x4b0534;

    gd::string m_commentString;
    gd::string m_userName;
    int m_commentID;
    int m_userID;
    int m_likeCount;
    int m_levelID;
    bool m_isSpam;
    int m_accountID;
    gd::string m_uploadDate;
    bool m_commentDeleted;
    int m_percentage;
    int m_modBadge;
    cocos2d::ccColor3B m_color;
    bool m_hasLevelID;
    bool m_unkMultiplayerBool;
    bool m_canDelete;
    GJUserScore* m_userScore;
}

[[link(android)]]
class GJCommentListLayer : cocos2d::CCLayerColor {
    // virtual ~GJCommentListLayer();

    static GJCommentListLayer* create(BoomListView* listView, char const* title, cocos2d::ccColor4B color, float width, float height, bool blueBorder) = win 0x291b10, imac 0x29e370, m1 0x23da50;

    bool init(BoomListView* listView, char const* title, cocos2d::ccColor4B color, float width, float height, bool blueBorder) = win 0x291c30, m1 0x23db48;

    BoomListView* m_list;
}

[[link(android)]]
class GJDailyLevelDelegate {
    virtual void dailyStatusFinished(GJTimedLevelType type) {}
    virtual void dailyStatusFailed(GJTimedLevelType type, GJErrorCode errorType) {}
}

[[link(android)]]
class GJDifficultySprite : cocos2d::CCSprite {
    // virtual ~GJDifficultySprite();

    static GJDifficultySprite* create(int difficulty, GJDifficultyName name) = win 0x2a4df0, imac 0x2b65c0, m1 0x253f4c;
    static gd::string getDifficultyFrame(int difficulty, GJDifficultyName name) = win 0x2a4ed0, m1 0x2540f8;

    bool init(int difficulty, GJDifficultyName name) = win inline, imac 0x2b66a0, m1 0x254060 {
        return cocos2d::CCSprite::initWithSpriteFrameName(GJDifficultySprite::getDifficultyFrame(difficulty, name).c_str());
    }
    void updateDifficultyFrame(int difficulty, GJDifficultyName name) = win 0x2a4fb0, imac 0x2b6840, m1 0x254238;
    void updateFeatureState(GJFeatureState state) = win 0x2a50d0, imac 0x2b69c0, m1 0x2543b4;
    void updateFeatureStateFromLevel(GJGameLevel* level) = win inline {
        if (!level) return;

        GJFeatureState featureState;

        if (level->m_isEpic >= 3) {
            featureState = GJFeatureState::Mythic;
        } else if (level->m_isEpic == 2) {
            featureState = GJFeatureState::Legendary;
        } else if (level->m_isEpic == 1) {
            featureState = GJFeatureState::Epic;
        } else if (level->m_featured >= 1) {
            featureState = GJFeatureState::Featured;
        } else {
            featureState = GJFeatureState::None;
        }

        this->updateFeatureState(featureState);
    }

    GJFeatureState m_featureState;
}

[[link(android)]]
class GJDropDownLayer : cocos2d::CCLayerColor {
    GJDropDownLayer() = win 0x7d250 {
        m_buttonMenu = nullptr;
        m_listLayer = nullptr;
        m_mainLayer = nullptr;
        m_closeOnHide = false;
        m_delegate = nullptr;
        m_fastMenu = false;
    }
    ~GJDropDownLayer() = win 0x256be0, m1 0x511c50;

    static GJDropDownLayer* create(const char* title) = win inline, imac 0x5e7ee0, m1 0x5123d0, ios inline {
        return create(title, 220.0f, false);
    }
    static GJDropDownLayer* create(const char* title, float height, bool noBack) = win inline, imac 0x5e79a0, m1 0x511eb0, ios inline {
        auto ret = new GJDropDownLayer();
        if (ret->init(title, height, noBack)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void draw() = win 0x42780, m1 0x51276c, imac 0x5e82d0;
    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline, m1 0x5127a8, imac 0x5e8300 { return true; }
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline, m1 0x5127c8, imac 0x5e8360 {}
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline, m1 0x5127b8, imac 0x5e8320 {}
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline, m1 0x5127c0, imac 0x5e8340 {}
    virtual void registerWithTouchDispatcher() = win 0x42660, m1 0x512454, imac 0x5e7fa0;
    virtual void keyBackClicked() = win 0x257110, imac 0x5e7fe0, m1 0x51248c;
    virtual void customSetup() = win inline, m1 0x5123f0, imac 0x5e7f20 {}
    virtual void enterLayer() = win 0x42630, m1 0x51241c, imac 0x5e7f70;
    virtual void exitLayer(cocos2d::CCObject* sender) = win 0x257130, imac 0x5e8020, m1 0x5124b0;
    virtual void showLayer(bool instant) = win 0x257170, m1 0x5124fc, imac 0x5e8060;
    virtual void hideLayer(bool instant) = win 0x2572c0, m1 0x512600, imac 0x5e8160;
    virtual void layerVisible() = win 0x42730, m1 0x512708, imac 0x5e8270;
    virtual void layerHidden() = win 0x257410, m1 0x512718, imac 0x5e8290;
    virtual void enterAnimFinished() = win inline, m1 0x512704, imac 0x5e8260 {}
    virtual void disableUI() = win 0x2570d0, m1 0x5123f4, imac 0x5e7f30;
    virtual void enableUI() = win 0x2570f0, m1 0x512408, imac 0x5e7f50;

    bool init(char const* title) = win inline, imac 0x5e7f00, m1 0x5123e0 {
        return init(title, 220.0f, false);
    }
    bool init(char const* title, float height, bool noBack) = win 0x256c90, imac 0x5e7ae0, m1 0x511fd4;

    cocos2d::CCPoint m_endPosition;
    cocos2d::CCPoint m_startPosition;
    cocos2d::CCMenu* m_buttonMenu;
    GJListLayer* m_listLayer;
    cocos2d::CCLayer* m_mainLayer;
    bool m_closeOnHide;
    GJDropDownLayerDelegate* m_delegate;
    bool m_fastMenu;
}

[[link(android)]]
class GJDropDownLayerDelegate {
    virtual void dropDownLayerWillClose(GJDropDownLayer* layer) {}
}

[[link(android), depends(DynamicMoveCalculation), depends(PulseEffectAction), depends(TouchToggleAction), depends(CollisionTriggerAction), depends(ToggleTriggerAction), depends(SpawnTriggerAction), depends(GroupCommandObject2), depends(OpacityEffectAction), depends(CountTriggerAction), depends(TimerItem), depends(TimerTriggerAction)]]
class GJEffectManager : cocos2d::CCNode {
    // virtual ~GJEffectManager();
    // GJEffectManager();

    static GJEffectManager* create();
    static cocos2d::ccColor3B getMixedColor(cocos2d::ccColor3B color1, cocos2d::ccColor3B color2, float ratio) = win inline, imac 0x2ed890 {
        auto r = color1.r * ratio + color2.r * (1.f - ratio);
        auto g = color1.g * ratio + color2.g * (1.f - ratio);
        auto b = color1.b * ratio + color2.b * (1.f - ratio);
        return { std::clamp<uint8_t>(r, 0, 255), std::clamp<uint8_t>(g, 0, 255), std::clamp<uint8_t>(b, 0, 255) };
    }

    virtual bool init() = win 0x25aaf0, m1 0x277140, imac 0x2dd010;

    cocos2d::ccColor3B activeColorForIndex(int index) = win inline, m1 0x277ca4 {
        if (index == 1010) return { 0, 0, 0 };
        else if (index == 0 || index == 1011) return { 255, 255, 255 };
        else {
            if (auto sprite = this->getColorSprite(index)) return sprite->m_color;
            else return { 255, 255, 255 };
        }
    }
    float activeOpacityForIndex(int index) = win inline, imac 0x2de0e0, m1 0x277e0c {
        if (auto sprite = this->getColorSprite(index)) return sprite->m_opacity;
        else return 1.f;
    }
    void addAllInheritedColorActions(cocos2d::CCArray* actions) = win inline, ios inline {
        cocos2d::CCDictElement* element;
        cocos2d::CCDictElement* temp;
        HASH_ITER(hh, m_unkObject148->m_pElements, element, temp) {
            auto action = static_cast<ColorAction*>(element->getObject());
            if (action->m_copyID > 0) {
                if (!actions) actions = cocos2d::CCArray::create();
                actions->addObject(action);
            }
        }
    }
    void addCountToItem(int itemId, int value) = win inline, imac 0x2e9d70, m1 0x281740 {
        itemId = std::clamp(itemId, 0, 9999);
        this->updateCountForItem(itemId, value + m_itemCountMap[itemId]);
    }
    void addMoveCalculation(CCMoveCNode* node, cocos2d::CCPoint offset, GameObject* object) = win inline, imac 0x2e7070 {
        node->m_unk0d1 = true;
        m_unkVector708.push_back({
            .m_moveNode = node,
            .m_offset = offset,
            .m_gameObject = object
        });
    }
    void calculateBaseActiveColors() = win 0x25b270;
    void calculateInheritedColor(int id, ColorAction* action) = win 0x25b650, m1 0x278840;
    void calculateLightBGColor(cocos2d::ccColor3B color) = win 0x263800, imac 0x2ed700, m1 0x284134;
    bool checkCollision(int const& blockAID, int const& blockBID) = win inline, m1 0x279634 {
        auto key = std::min(blockAID, blockBID) * 10000 + std::max(blockAID, blockBID) + 10000000;
        return m_unkMap288.count(key) != 0;
    }
    void colorActionChanged(ColorAction* action) = win inline, imac 0x2df1a0, m1 0x278d30 {
        if (action->m_copyID > 0) m_colorActionDict->setObject(action, action->m_colorID);
        else m_colorActionDict->removeObjectForKey(action->m_colorID);
    }
    bool colorExists(int col) = win inline, imac 0x2df170, m1 0x278d0c {
        return m_colorActionVector[std::clamp(col, 0, 1101)] != nullptr;
    }
    cocos2d::ccColor3B colorForEffect(cocos2d::ccColor3B color, cocos2d::ccHSVValue hsv) = win inline, imac 0x2dfbb0, m1 0x2795a0 {
        return GameToolbox::transformColor(color, hsv);
    }
    cocos2d::ccColor3B colorForGroupID(int id, cocos2d::ccColor3B const& color, bool mainColor) = win 0x261920, imac 0x2e8a20, m1 0x280690;
    cocos2d::ccColor3B colorForIndex(int index) = win inline, ios inline {
        if (auto colorAction = this->getColorAction(index)) return colorAction->m_toColor;
        else return { 255, 255, 255 };
    }
    cocos2d::ccColor3B colorForPulseEffect(cocos2d::ccColor3B const& color, PulseEffectAction* action) = win 0x261570;
    void controlActionsForControlID(int id, GJActionCommand command) = win 0x25d860, m1 0x27b448;
    void controlActionsForTrigger(EffectGameObject* object, GJActionCommand command) = win 0x25e1c0, imac 0x54ee30, m1 0x27c0a0;
    int countForItem(int id) = win 0x262200, m1 0x281648;
    void createFollowCommand(float xMod, float yMod, float duration, int targetID, int centerID, int uniqueID, int controlID) = win 0x25c8f0, imac 0x2e0820, m1 0x27a074;
    GroupCommandObject2* createKeyframeCommand(int targetID, cocos2d::CCArray* group, GameObject* object, int uniqueID, int controlID, bool temporary, float posXMod, float posYMod, float rotMod, float scaleXMod, float scaleYMod, float timeMod, gd::vector<int> const& remapKeys) = win 0x25cb20;
    void createMoveCommand(cocos2d::CCPoint pt, int groupID, float duration, int easingType, float easingRate, bool lockPlayerX, bool lockPlayerY, bool lockCameraX, bool lockCameraY, float moveModX, float moveModY, int uniqueID, int controlID) = win 0x25c510, imac 0x2e0470, m1 0x279d18;
    void createPlayerFollowCommand(float delay, float speed, int offset, float maxSpeed, float duration, int targetID, int uniqueID, int controlID) = imac 0x2e0900, m1 0x27a138, win 0x25ca00;
    void createRotateCommand(float offset, float duration, int targetID, int centerID, int easingType, float easingRate, bool lockRotation, bool player1, bool player2, int uniqueID, int controlID) = win 0x25c7c0, imac 0x2e05d0, m1 0x279e6c;
    void createTransformCommand(double scaleX, double scaleY, double property450, double property451, bool onlyMove, float duration, int targetID, int centerID, int easingType, float easingRate, bool, bool relativeRotation, int uniqueID, int controlID) = win inline, imac 0x2e06e0, m1 0x279f60 {
        auto& command = m_unkVector560.emplace_back();
        command.m_targetScaleX = scaleX;
        command.m_targetScaleY = scaleY;
        command.m_transformTriggerProperty450 = property450;
        command.m_transformTriggerProperty451 = property451;
        command.m_onlyMove = onlyMove;
        command.m_targetGroupID = targetID;
        command.m_centerGroupID = centerID;
        command.m_transformRelatedFalse = p10;
        command.m_relativeRotation = relativeRotation;
        command.m_triggerUniqueID = uniqueID;
        command.m_controlID = controlID;
        command.runTransformCommand(duration, easingType, easingRate);
    }
    cocos2d::CCArray* getAllColorActions() = win 0x25b0e0, m1 0x277a54;
    cocos2d::CCArray* getAllColorSprites() = win inline, m1 0x277aa4, ios inline {
        auto arr = cocos2d::CCArray::create();
        cocos2d::CCDictElement* element;
        cocos2d::CCDictElement* temp;
        HASH_ITER(hh, m_unkDict150->m_pElements, element, temp) {
            arr->addObject(element->getObject());
        }
        return arr;
    }
    ColorAction* getColorAction(int index) = win 0x25ba10;
    ColorActionSprite* getColorSprite(int index) = win 0x25bad0, m1 0x277b60;
    void getLoadedMoveOffset(gd::unordered_map<int, std::pair<double, double>>& offsets) = win 0x260760, imac 0x2e7800;
    CCMoveCNode* getMoveCommandNode(GroupCommandObject2* command) = win 0x25ede0, imac 0x2e1fc0, m1 0x27b238;
    CCMoveCNode* getMoveCommandObject() = win 0x25ece0, imac 0x2e4240, m1 0x27ce84;
    OpacityEffectAction* getOpacityActionForGroup(int id) = win inline {
        if (auto it = m_opacityEffectMap.find(id); it != m_opacityEffectMap.end()) {
            return &it->second;
        }
        return nullptr;
    }
    gd::string getSaveString() = win inline, imac 0x2edae0, m1 0x2844a4 {
        cocos2d::CCDictElement* element;
        cocos2d::CCDictElement* temp;
        fmt::memory_buffer out;
        HASH_ITER(hh, m_unkDict150->m_pElements, element, temp) {
            auto action = static_cast<ColorAction*>(element->getObject());
            if (
                action->m_colorID < 1000 && action->m_fromColor.r == 255 && action->m_fromColor.g == 255 && action->m_fromColor.b == 255 &&
                !action->m_blending && action->m_fromOpacity == 1.f && action->m_copyID == 0 && action->m_playerColor < 1
            ) {
                continue;
            }

            fmt::format_to(std::back_inserter(out), "1_{}_2_{}_3_{}_", action->m_fromColor.r, action->m_fromColor.g, action->m_fromColor.b);
            if (action->m_paused) {
                fmt::format_to(std::back_inserter(out), "19_1_");
            }
            if (action->m_toColor.r != 0 || action->m_toColor.g != 0 || action->m_toColor.b != 0) {
                fmt::format_to(std::back_inserter(out), "11_{}_12_{}_13_{}_", action->m_toColor.r, action->m_toColor.g, action->m_toColor.b);
            }
            if (action->m_playerColor != 0) {
                fmt::format_to(std::back_inserter(out), "4_{}_", action->m_playerColor);
            }
            if (action->m_duration != 0.f) {
                fmt::format_to(std::back_inserter(out), "16_{}_", action->m_duration);
            }
            fmt::format_to(std::back_inserter(out), "6_{}_", action->m_colorID);
            if (action->m_blending) {
                fmt::format_to(std::back_inserter(out), "5_1_");
            }
            fmt::format_to(std::back_inserter(out), "7_{}_15_{}_", action->m_fromOpacity, action->m_toOpacity);
            if (action->m_copyOpacity) {
                fmt::format_to(std::back_inserter(out), "17_1_");
            }
            if (action->m_copyID != 0) {
                fmt::format_to(std::back_inserter(out), "9_{}_", action->m_copyID);
            }
            if (
                action->m_copyHSV.h != 0.f || action->m_copyHSV.s != 1.f || action->m_copyHSV.v != 1.f ||
                action->m_copyHSV.absoluteSaturation || action->m_copyHSV.absoluteBrightness
            ) {
                fmt::format_to(std::back_inserter(out), "10_{}_", GameToolbox::stringFromHSV(action->m_copyHSV, "a"));
            }
            if (action->m_deltaTime > 0.f) {
                fmt::format_to(std::back_inserter(out), "14_{}_", action->m_deltaTime);
            }
            fmt::format_to(std::back_inserter(out), "18_{}_8_1|", action->m_uniqueID);
        }
        return fmt::to_string(out);
    }
    GroupCommandObject2* getTempGroupCommand() = win 0x25f080;
    void handleObjectCollision(bool triggerOnExit, int blockAID, int blockBID) = win 0x25c350, imac 0x2e9490;
    bool hasActiveDualTouch() = win inline {
        for (auto& action : m_unkVector1e0) {
            if (action.m_dualMode && !action.m_disabled) return true;
        }
        return false;
    }
    bool hasBeenTriggered(int objectUniqueID, int playerUniqueID) = win inline, m1 0x280e0c {
        auto bound = m_unkMap498.lower_bound(std::make_pair(objectUniqueID, playerUniqueID));
        return bound != m_unkMap498.end() && *bound <= std::make_pair(objectUniqueID, playerUniqueID);
    }
    bool hasPulseEffectForGroupID(int id) = win inline, ios inline {
        if (auto it = m_pulseEffectMap.find(id); it != m_pulseEffectMap.end()) return !it->second.empty();
        return false;
    }
    bool isGroupEnabled(int id) = win inline, m1 0x280e50 {
        return m_unkVector438[std::clamp(id, 0, 9999)];
    }
    const char* keyForGroupIDColor(int id, cocos2d::ccColor3B const& color, bool mainColor) = win inline, imac 0x2e8600, m1 0x280364, ios inline {
        fmt::memory_buffer out;
        fmt::format_to(std::back_inserter(out), "{}_{}{}{}_{}", id, color.r, color.g, color.b, (int)mainColor);
        return out.data();
    }
    void loadFromState(EffectManagerState& state) = win 0x2642b0, m1 0x2852a4;
    void objectsCollided(int blockAID, int blockBID) = win inline, m1 0x279a18 {
        auto key = std::min(blockAID, blockBID) * 10000 + std::max(blockAID, blockBID) + 10000000;
        if (auto it = m_unkMap288.find(key); it != m_unkMap288.end()) {
            it->second = true;
        }
        else {
            this->handleObjectCollision(true, blockAID, blockBID);
            m_unkMap288[key] = true;
        }
    }
    float opacityForIndex(int index) = win inline, imac 0x2ddf70, ios inline {
        if (auto colorAction = this->getColorAction(index)) return colorAction->m_toOpacity;
        else return 1.f;
    }
    float opacityModForGroup(int id) = win 0x260990;
    void pauseTimer(int id) = win inline {
        if (m_timerItemMap.count(id) != 0) m_timerItemMap[id].m_active = false;
    }
    void playerButton(bool down, bool player1) = win 0x261fa0, m1 0xe6648;
    void playerDied() = win inline, m1 0x2812c4 {
        if (m_triggerEffectDelegate) {
            for (int i = 0; i < m_unkVector248.size(); i++) {
                auto& action = m_unkVector248[i];
                if (action.m_disabled) continue;
                m_triggerEffectDelegate->toggleGroupTriggered(action.m_targetGroupID, action.m_activateGroup, action.m_remapKeys, action.m_triggerUniqueID, action.m_controlID);
            }
        }
    }
    void postCollisionCheck() = win 0x25c0f0, imac 0x2dfdd0;
    void postMoveActions() = win 0x260610, m1 0x27f36c;
    void preCollisionCheck() = win inline, m1 0x279750 {
        for (auto& pair : m_unkMap288) {
            pair.second = false;
        }
    }
    void prepareMoveActions(float dt, bool intermediate) = win 0x25f200;
    void processColors() = win 0x25b150, imac 0x2de140, m1 0x11324c;
    void processCopyColorPulseActions() = win 0x261320, imac 0xed7f0;
    void processInheritedColors() = win 0x25b330, imac 0x2de460, m1 0x278118;
    void processMoveCalculations() = win inline, imac 0x2e76d0, m1 0x27f6cc {
        for (auto& calc : m_unkVector708) {
            auto angle = -calc.m_gameObject->m_rotationXOffset * M_PI / 180.f;
            cocos2d::CCPoint position;
            position.x = calc.m_offset.x * cosf(angle) - calc.m_offset.y * sinf(angle);
            position.y = calc.m_offset.x * sinf(angle) + calc.m_offset.y * cosf(angle);
            auto diff = position - calc.m_offset;
            calc.m_moveNode->m_unk038 += diff.x;
            calc.m_moveNode->m_unk040 += diff.y;
            calc.m_moveNode->m_unk090 += diff.x;
            calc.m_moveNode->m_unk098 += diff.y;
            calc.m_moveNode->m_unk0d1 = false;
        }
        m_unkVector708.clear();
    }
    void processPulseActions() = win inline, imac 0x2de390, m1 0xe937c {
        for (int i = 0; i < m_pulseEffectVector.size(); i++) {
            auto& action = m_pulseEffectVector[i];
            auto colorAction = this->getColorAction(action.m_targetGroupID);
            if (action.m_colorIndex == 0 && (!colorAction || colorAction->m_copyID == 0)) {
                colorAction->m_colorSprite->m_copyColor = this->colorForPulseEffect(colorAction->m_colorSprite->m_copyColor, &action);
            }
        }
    }
    void registerCollisionTrigger(int targetID, int blockAID, int blockBID, bool triggerOnExit, bool activateGroup, gd::vector<int> const& remapKeys, int uniqueID, int controlID) = win 0x25c240, imac 0x60fed0, m1 0x279b80;
    void registerRotationCommand(GroupCommandObject2* object, bool clear) = win 0x25ef80;
    void removeAllPulseActions() = win inline, imac 0x1566d0, m1 0x1268d0 {
        m_pulseEffectVector.clear();
        m_unkVector2f0.clear();
    }
    void removeColorAction(int id) = win inline, imac 0x2df110, m1 0x278cc4 {
        id = std::clamp(id, 0, 1101);
        m_unkObject148->removeObjectForKey(id);
        m_colorActionVector[id] = nullptr;
        m_colorActionDict->removeObjectForKey(id);
    }
    void removePersistentFromAllItems() = win inline {
        m_persistentItemCountMap.clear();
    }
    void removePersistentFromAllTimers() = win inline {
        m_persistentTimerItemSet.clear();
    }
    void removeTriggeredID(int objectUniqueID, int playerUniqueID) = win 0x261ef0;
    void reset() = win 0x25aeb0, m1 0x277350;
    void resetEffects() = win 0x25be30, imac 0x2dd3b0, m1 0x277420;
    void resetMoveActions() = win inline {
        m_unkVector560.clear();
        m_unkMap578.clear();
        m_unkMap618.clear();
        m_unkVector6c0.clear();
    }
    void resetTempGroupCommands(bool noRemove) = win 0x25f110;
    void resetToggledGroups() = win inline, imac 0x2dfa00 {
        m_unkVector438.assign(m_unkVector438.size(), true);
        m_unkMap460.clear();
    }
    void resetTriggeredIDs() = win inline, ios inline {
        m_unkMap498.clear();
    }
    void resumeTimer(int id) = win inline {
        if (m_timerItemMap.count(id) != 0) m_timerItemMap[id].m_active = true;
    }
    void runCountTrigger(int id, int targetCount, bool multiActivate, int targetID, bool activateGroup, gd::vector<int> const& remapKeys, int uniqueID, int controlID) = win inline, imac 0x2e9960, m1 0x2813f4 {
        m_countTriggerActions[id].emplace_back(targetID, targetCount, activateGroup, multiActivate, id, this->countForItem(id), remapKeys, uniqueID, controlID);
    }
    void runDeathTrigger(int targetID, bool activateGroup, gd::vector<int> const& remapKeys, int uniqueID, int controlID) = win inline, imac 0x2e9720, m1 0x2811e8 {
        m_unkVector248.emplace_back(targetID, activateGroup, remapKeys, uniqueID, controlID);
    }
    OpacityEffectAction* runOpacityActionOnGroup(int targetID, float duration, float opacity, int uniqueID, int controlID) = win 0x260880, imac 0x2e7ad0, m1 0x27fa24;
    PulseEffectAction* runPulseEffect(int targetID, bool targetGroup, float fadeInDuration, float holdDuration, float fadeOutDuration, PulseEffectType effectType, cocos2d::ccColor3B targetColor, cocos2d::ccHSVValue targetHSV, int copyID, bool mainOnly, bool detailOnly, bool exclusive, bool legacyHSV, int uniqueID, int controlID) = win 0x260a50;
    void runTimerTrigger(int id, double targetTime, bool multiActivate, int targetID, gd::vector<int> const& remapKeys, int uniqueID, int controlID) = win inline, imac 0x2ec960, m1 0x28372c {
        m_unkMap3f8[id].emplace_back(targetID, targetTime, multiActivate, id, remapKeys, uniqueID, controlID);
    }
    void runTouchTriggerCommand(int targetID, bool holdMode, TouchTriggerType touchType, TouchTriggerControl touchControl, bool dualMode, gd::vector<int> const& remapKeys, int uniqueID, int controlID) = win inline, imac 0x2e9340, m1 0x280e7c {
        m_unkVector1e0.emplace_back(targetID, holdMode, touchType, touchControl, dualMode, remapKeys, uniqueID, controlID);
    }
    void saveCompletedMove(int groupId, double dx, double dy) = win inline, imac 0x2e7640, m1 0x27f630 {
        auto& entry = m_unkMap578[groupId];
        entry.first += dx;
        entry.second += dy;
    }
    void saveToState(EffectManagerState& state) = win 0x263c90, imac 0x2ee500;
    void setColorAction(ColorAction* action, int id) = win 0x25bc30, imac 0x2df0a0, m1 0x278c60;
    void setFollowing(int targetID, int targetPosID, bool following) = win inline, imac 0x2ed950, m1 0x284370 {
        auto key = targetID * 2000 + targetPosID;
        if (following) m_unkMap4c8.insert(key);
        else m_unkMap4c8.erase(key);
    }
    void setupFromString(gd::string str) = win 0x263a00, imac 0x8d480, m1 0x284750;
    bool shouldBlend(int id) = win inline, imac 0x2de110 {
        auto action = m_colorActionVector[std::clamp(id, 0, 1101)];
        return action && action->m_blending;
    }
    void spawnGroup(int targetID, float delay, bool spawnOrdered, gd::vector<int> const& remapKeys, int uniqueID, int controlID) = win 0x261ac0;
    void spawnObject(GameObject* object, float delay, gd::vector<int> const& remapKeys, int uniqueID, int controlID) = win inline {
        m_spawnTriggerActions.emplace_back(object, delay, remapKeys, uniqueID, controlID);
    }
    void startTimer(int id, double startTime, double targetTime, bool stopTime, bool active, bool dontOverride, float timeMod, bool ignoreTimewarp, int targetID, gd::vector<int> const& remapKeys, int uniqueID, int controlID) = win 0x262d60;
    void storeTriggeredID(int objectUniqueID, int playerUniqueID) = win 0x261e00, imac 0x2e9110;
    double timeForItem(int id) = win 0x263740;
    bool timerExists(int id) = win 0x262f20;
    void toggleGroup(int id, bool activate) = win inline, imac 0x2e03f0, m1 0x279c98 {
        id = std::clamp(id, 0, 9999);
        if (activate) {
            m_unkVector438[id] = true;
            m_unkMap460.erase(id);
        }
        else {
            m_unkVector438[id] = false;
            m_unkMap460.insert(id);
        }
    }
    void toggleItemPersistent(int id, bool persistent) = win inline {
        if (persistent) m_persistentItemCountMap[id] = m_itemCountMap.count(id) != 0 ? m_itemCountMap[id] : 0;
        else m_persistentItemCountMap.erase(id);
    }
    void toggleTimerPersistent(int id, bool persistent) = win inline, imac 0x2ec120, m1 0x28312c {
        if (persistent) m_persistentTimerItemSet.insert(id);
        else m_persistentTimerItemSet.erase(id);
    }
    void transferPersistentItems() = win 0x262ce0, imac 0x2dfad0;
    void traverseInheritanceChain(InheritanceNode* node) = win inline, imac 0x2dec10, m1 0x2787bc {
        while (node) {
            m_unkArray430->addObject(node);
            node = node->m_inheritanceNode;
        }
        for (auto obj : geode::cocos::CCArrayExt<cocos2d::CCObject*, false>(m_unkArray430)) {
            auto currentNode = static_cast<InheritanceNode*>(obj);
            this->calculateInheritedColor(currentNode->m_colorID, currentNode->m_colorAction);
        }
        m_unkArray430->removeAllObjects();
    }
    CCMoveCNode* tryGetMoveCommandNode(int id) = win inline {
        auto it = m_unkMap618.find(id);
        return it != m_unkMap618.end() ? it->second : nullptr;
    }
    void updateActiveOpacityEffects() = win inline, ios inline {
        for (auto it = m_opacityEffectMap.begin(); it != m_opacityEffectMap.end();) {
            auto& action = it->second;
            if (action.m_finished && action.m_currentValue >= 1.f) it = m_opacityEffectMap.erase(it);
            else ++it;
        }
    }
    void updateColorAction(ColorAction* action) = win inline, m1 0x27f90c {
        if (action->m_copyID == 0) {
            action->m_colorSprite->m_color = action->m_color;
            action->m_colorSprite->m_opacity = action->m_currentOpacity * 255.f;
        }
    }
    void updateColorEffects(float dt) = win inline, m1 0x278e54 {
        cocos2d::CCDictElement* element;
        cocos2d::CCDictElement* temp;
        HASH_ITER(hh, m_unkObject148->m_pElements, element, temp) {
            auto action = static_cast<ColorAction*>(element->getObject());
            action->step(dt);
            if (action->m_copyID == 0) {
                action->m_colorSprite->m_color = action->m_color;
                action->m_colorSprite->m_opacity = action->m_currentOpacity * 255.f;
            }
        }
    }
    void updateColors(cocos2d::ccColor3B color1, cocos2d::ccColor3B color2) = win inline, m1 0x277af4 {
        cocos2d::CCDictElement* element;
        cocos2d::CCDictElement* temp;
        HASH_ITER(hh, m_unkObject148->m_pElements, element, temp) {
            auto action = static_cast<ColorAction*>(element->getObject());
            if (action->m_playerColor == 1) action->m_fromColor = color1;
            else if (action->m_playerColor == 2) action->m_fromColor = color2;
        }
    }
    void updateCountForItem(int id, int count) = win 0x2622c0, imac 0x2e9de0;
    void updateEffects(float dt) = win 0x25bcb0, m1 0x20aa68;
    void updateOpacityAction(OpacityEffectAction* action) = win inline, imac 0x2e7e60, m1 0xce66c {
        if (action->m_finished && action->m_currentValue >= 1.f) m_opacityEffectMap.erase(action->m_targetGroupID);
    }
    void updateOpacityEffects(float dt) = win inline, imac 0x2df810 {
        for (auto it = m_opacityEffectMap.begin(); it != m_opacityEffectMap.end();) {
            auto& action = it->second;
            action.step(dt);
            if (action.m_finished && action.m_currentValue >= 1.f) it = m_opacityEffectMap.erase(it);
            else ++it;
        }
    }
    void updatePulseEffects(float dt) = win 0x260fd0, imac 0x2df4d0, m1 0x278fac;
    void updateSpawnTriggers(float dt) = win 0x261bb0;
    void updateTimer(int id, double time) = win 0x262fc0;
    void updateTimers(float dt, float timeWarp) = win 0x263150;
    bool wasFollowing(int targetID, int targetPosID) = win inline, m1 0x2843b8 {
        return m_unkMap4c8.count(targetID * 2000 + targetPosID) != 0;
    }
    bool wouldCreateLoop(InheritanceNode* node, int id) = win 0x25b9f0, imac 0x2debe0, m1 0x27878c, ios inline {
        while (node) {
            if (node->m_colorID == id) return true;
            node = node->m_inheritanceNode;
        }
        return false;
    }

    TriggerEffectDelegate* m_triggerEffectDelegate;
    cocos2d::CCDictionary* m_unkObject148;
    cocos2d::CCDictionary* m_unkDict150;
    gd::vector<PulseEffectAction> m_pulseEffectVector;
    gd::unordered_map<int, gd::vector<PulseEffectAction>> m_pulseEffectMap;
    gd::unordered_map<int, OpacityEffectAction> m_opacityEffectMap;
    gd::vector<TouchToggleAction> m_unkVector1e0;
    gd::unordered_map<int, gd::vector<CountTriggerAction>> m_countTriggerActions;
    gd::vector<CollisionTriggerAction> m_unkVector230;
    gd::vector<ToggleTriggerAction> m_unkVector248;
    cocos2d::CCDictionary* m_colorActionDict;
    cocos2d::CCDictionary* m_unkDict268;
    gd::vector<InheritanceNode*> m_unkVector270;
    gd::unordered_map<int, bool> m_unkMap288;
    gd::vector<ColorAction*> m_colorActionVector;
    gd::vector<ColorActionSprite*> m_colorActionSpriteVector;
    gd::vector<bool> m_unkVector2f0;
    gd::unordered_map<int, int> m_itemCountMap;
    gd::unordered_map<int, int> m_persistentItemCountMap;
    gd::unordered_set<int> m_persistentTimerItemSet;
    gd::unordered_map<int, TimerItem> m_timerItemMap;
    gd::unordered_map<int, gd::vector<TimerTriggerAction>> m_unkMap3f8;
    cocos2d::CCArray* m_unkArray430;
    gd::vector<bool> m_unkVector438;
    gd::unordered_set<int> m_unkMap460;
    gd::set<std::pair<int, int>> m_unkMap498;
    gd::unordered_set<int> m_unkMap4c8;
    gd::vector<SpawnTriggerAction> m_spawnTriggerActions;
    gd::vector<GroupCommandObject2*> m_unkVector518;
    gd::vector<GroupCommandObject2*> m_unkVector530;
    gd::vector<cocos2d::CCObject*> m_unkVector548;
    gd::vector<GroupCommandObject2> m_unkVector560;
    gd::unordered_map<int, std::pair<double, double>> m_unkMap578;
    gd::vector<GroupCommandObject2*> m_unkVector5b0;
    gd::unordered_map<int, gd::vector<GroupCommandObject2*>> m_unkMap5c8;
    gd::vector<GroupCommandObject2*> m_unkVector600;
    gd::unordered_map<int, CCMoveCNode*> m_unkMap618;
    gd::unordered_map<int, CCMoveCNode*> m_unkMap650;
    gd::unordered_map<int, CCMoveCNode*> m_unkMap688;
    gd::vector<CCMoveCNode*> m_unkVector6c0;
    gd::vector<CCMoveCNode*> m_unkVector6d8;
    gd::vector<CCMoveCNode*> m_unkVector6f0;
    gd::vector<DynamicMoveCalculation> m_unkVector708;
    gd::map<std::pair<int, int>, gd::vector<GroupCommandObject2*>> m_unkMap770;
    float m_unk780;
    float m_unk784;
    float m_unk788;
    float m_unk78C;
    float m_unk790;
    float m_unk794;
    bool m_unk798;
}

[[link(android)]]
class GJFlyGroundLayer : GJGroundLayer {
    // virtual ~GJFlyGroundLayer();

    static GJFlyGroundLayer* create() = m1 0x515528;

    virtual bool init() = m1 0x5155f4, imac 0x5eb670;
}

[[link(android)]]
class GJFollowCommandLayer : SetupTriggerPopup {
    // virtual ~GJFollowCommandLayer();

    static GJFollowCommandLayer* create(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x2703f0, imac 0x2d4be0, m1 0x26f860;

    virtual void determineStartValues() = win 0x271820, m1 0x2712f8, imac 0x2d6840;
    virtual void onClose(cocos2d::CCObject* sender) = win 0x272890, m1 0x271c68, imac 0x2d74b0;
    virtual void textChanged(CCTextInputNode* node) = win 0x271f40, m1 0x271850, imac 0x2d6f00;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x270520, imac 0x2d4e20, m1 0x26f9f0;
    void onUpdateGroupID(cocos2d::CCObject* sender) = win 0x271e80, imac 0x2d6230, m1 0x270cdc;
    void onUpdateGroupID2(cocos2d::CCObject* sender) = win 0x271ee0, imac 0x2d62f0, m1 0x270d98;
    void sliderChanged(cocos2d::CCObject* sender) = win 0x271b30;
    void sliderXModChanged(cocos2d::CCObject* sender) = m1 0x270bbc;
    void sliderYModChanged(cocos2d::CCObject* sender) = m1 0x270c4c;
    void updateDuration();
    void updateDurLabel(bool decimals);
    void updateTargetGroupID();
    void updateTargetGroupID2();
    void updateTextInputLabel();
    void updateTextInputLabel2();
    void updateXMod();
    void updateXModLabel();
    void updateYMod() = m1 0x2716e0;
    void updateYModLabel();

    CCTextInputNode* m_moveTimeInput;
    Slider* m_moveTimeSlider;
    float m_moveTime;
    CCTextInputNode* m_xModInput;
    CCTextInputNode* m_yModInput;
    Slider* m_xModSlider;
    Slider* m_yModSlider;
    float m_xMod;
    float m_yMod;
    CCTextInputNode* m_targetIDInput;
    int m_targetGroupID;
    CCTextInputNode* m_followIDInput;
    int m_followGroupID;
}

[[link(android)]]
class GJFriendRequest : cocos2d::CCNode {
    // virtual ~GJFriendRequest();
    GJFriendRequest() {
        m_requestID = 0;
        m_accountID = 0;
        m_unusedToAccountID = 0;
        m_isRead = false;
    }

    static GJFriendRequest* create() = win inline, imac 0x55ffa0, m1 0x4af45c {
        auto ret = new GJFriendRequest();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static GJFriendRequest* create(cocos2d::CCDictionary* dict) = win 0x172cc0, imac 0x54ca70, m1 0x49d148;

    virtual bool init() = win 0x77e00, m1 0x4af4f4, imac 0x560030;

    int m_requestID;
    int m_accountID;
    int m_unusedToAccountID;
    gd::string m_message;
    gd::string m_uploadDate;
    bool m_isRead;
}

[[link(android)]]
class GJGameLevel : cocos2d::CCNode {
    GJGameLevel() = win 0x1415d0, m1 0x4b26dc {
        m_lastBuildSave = nullptr;
        m_levelID = { 0, 0 };
        m_userID = { 0, 0 };
        m_accountID = { 0, 0 };
        m_difficulty = GJDifficulty::Auto;
        m_audioTrack = 0;
        m_songID = 0;
        m_levelRev = 0;
        m_unlisted = false;
        m_friendsOnly = false;
        m_objectCount = { 0, 0 };
        m_levelIndex = 0;
        m_ratings = 0;
        m_ratingsSum = 0;
        m_downloads = 0;
        m_isEditable = false;
        m_gauntletLevel = false;
        m_gauntletLevel2 = false;
        m_workingTime = 0;
        m_workingTime2 = 0;
        m_lowDetailMode = false;
        m_lowDetailModeToggled = false;
        m_disableShakeToggled = false;
        m_selected = false;
        m_localOrSaved = false;
        m_isVerified = { 0, 0 };
        m_isVerifiedRaw = false;
        m_isUploaded = false;
        m_hasBeenModified = false;
        m_levelVersion = 0;
        m_gameVersion = 0;
        m_attempts = { 0, 0 };
        m_jumps = { 0, 0 };
        m_clicks = { 0, 0 };
        m_attemptTime = { 0, 0 };
        m_isChkValid = false;
        m_isCompletionLegitimate = false;
        m_normalPercent = { 0, 0 };
        m_orbCompletion = { 0, 0 };
        m_newNormalPercent2 = { 0, 0 };
        m_practicePercent = 0;
        m_likes = 0;
        m_dislikes = 0;
        m_levelLength = 0;
        m_featured = 0;
        m_isEpic = 0;
        m_levelFavorited = false;
        m_levelFolder = 0;
        m_dailyID = { 0, 0 };
        m_demon = { 0, 0 };
        m_demonDifficulty = 4;
        m_stars = { 0, 0 };
        m_autoLevel = false;
        m_coins = 0;
        m_coinsVerified = { 0, 0 };
        m_password = { 0, 0 };
        m_originalLevel = { 0, 0 };
        m_twoPlayerMode = false;
        m_failedPasswordAttempts = 0;
        m_firstCoinVerified = { 0, 0 };
        m_secondCoinVerified = { 0, 0 };
        m_thirdCoinVerified = { 0, 0 };
        m_starsRequested = 0;
        m_showedSongWarning = false;
        m_starRatings = 0;
        m_starRatingsSum = 0;
        m_maxStarRatings = 0;
        m_minStarRatings = 0;
        m_demonVotes = 0;
        m_rateStars = 0;
        m_rateFeature = false;
        m_dontSave = false;
        m_levelNotDownloaded = false;
        m_requiredCoins = 0;
        m_isUnlocked = false;
        m_lastEditorZoom = 0.f;
        m_lastBuildTab = 0;
        m_lastBuildPage = 0;
        m_lastBuildGroupID = 0;
        m_levelType = GJLevelType::Default;
        m_M_ID = 0;
        m_highObjectsEnabled = false;
        m_unlimitedObjectsEnabled = false;
        m_timestamp = 0;
        m_listPosition = 0;
        m_54 = 0;
        m_bestTime = 0;
        m_bestPoints = 0;
    }
    ~GJGameLevel() = win inline {
        CC_SAFE_RELEASE(m_lastBuildSave);
    }

    static GJGameLevel* create() = win inline {
	auto ret = new GJGameLevel();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static GJGameLevel* create(cocos2d::CCDictionary* dict, bool download) = win 0x16ae70;
    static GJGameLevel* createWithCoder(DS_Dictionary* dict) = win inline {
        auto level = GJGameLevel::create();
        level->dataLoaded(dict);
        return level;
    }
    static int demonIconForDifficulty(DemonDifficultyType type) = win inline, imac 0x55f160, m1 0x67118 {
        switch (type) {
            case DemonDifficultyType::EasyDemon: return 7;
            case DemonDifficultyType::MediumDemon: return 8;
            case DemonDifficultyType::InsaneDemon: return 9;
            case DemonDifficultyType::ExtremeDemon: return 10;
            default: return 6;
        }
    }
    static int getLengthKey(int length, bool platformer) = win inline, imac 0x55b6b0, m1 0x4ab214 {
        if (platformer) return 5;
        if (length < 10) return 0;
        if (length < 30) return 1;
        if (length < 60) return 2;
        if (length < 120) return 3;
        return 4;
    }
    static gd::string lengthKeyToString(int key) = win 0x16cc10;

    virtual void encodeWithCoder(DS_Dictionary* dict) = win 0x16ef40, m1 0x4adb64, imac 0x55e490;
    virtual bool canEncode() = win inline, imac 0x55f050, m1 0x4ae6a8 { return true; }
    virtual bool init() = win 0x16c6e0, imac 0x55ae20, m1 0x4aab7c;

    bool areCoinsVerified() = win 0x16ff80, imac 0x55f060, m1 0x65b68;
    void copyLevelInfo(GJGameLevel* level) = win 0x16d850, imac 0x55c930, m1 0x4ac488;
    void dataLoaded(DS_Dictionary* dict) = win 0x16df00, imac 0x55d340, m1 0x4acc38;
    gd::string generateSettingsString() = win inline, imac 0x55bc20, m1 0x4ab7c0, ios inline { return ""; }
    gd::string getAudioFileName() = win 0x16cf30, m1 0x4ab5a8;
    int getAverageDifficulty() = win 0x16cd70, m1 0x4ab340;
    char const* getCoinKey(int coinNumber) = win 0x16cde0, imac 0x54bec0, m1 0x49c5f8;
    int getLastBuildPageForTab(int tab);
    GJGameLevel* getListSnapshot() = win 0x16db70;
    int getNormalPercent() = win inline, imac 0x52cc60, m1 0x480e94 {
        return m_normalPercent.value();
    }
    gd::string getSongName() = win 0x16cff0, imac 0x55bb50, m1 0x4ab6d8;
    gd::string getUnpackedLevelDescription();
    void handleStatsConflict(GJGameLevel* level);
    bool isPlatformer() = win inline, imac 0x5366d0, m1 0x48967c {
        return m_levelLength == 5;
    }
    void levelWasAltered() = win inline, imac 0x55b040, m1 0x4aace8 {
        m_hasBeenModified = true;
        m_isVerifiedRaw = false;
        m_isVerified = false;
        this->unverifyCoins();
        m_capacityString = "";
        if (m_isUploaded) {
            m_isUploaded = false;
            m_levelVersion++;
        }
    }
    void levelWasSubmitted() = win inline, imac 0x53e2d0, m1 0x4907f4, ios inline {
        m_isUploaded = true;
    }
    void parseSettingsString(gd::string str) = win inline, imac 0x55ae10, ios inline {}
    void saveNewScore(int value, int type) = win 0x16d270;
    void savePercentage(int percent, bool isPracticeMode, int clicks, int attempts, bool isChkValid) = win 0x16c8f0, m1 0x4aae44;
    void scoreStringToVector(gd::string& str, gd::vector<int>& vec) = win 0x16d6c0, m1 0x399e88;
    gd::string scoreVectorToString(gd::vector<int>& vec, int type) = win inline, imac 0x55c5d0, m1 0x4ac1a0 {
        if (type == 1) std::sort(vec.begin(), vec.end(), std::greater<int>());
        else std::sort(vec.begin(), vec.end(), std::less<int>());
        fmt::memory_buffer out;
        for (int i = 0; i < vec.size(); i++) {
            if (i > 0) fmt::format_to(std::back_inserter(out), ",");
            fmt::format_to(std::back_inserter(out), "{}", vec[i]);
        }
        return fmt::to_string(out);
    }
    void setAccountID(int id) {
        m_accountID = id;
    }
    void setAttempts(int attempts) {
        m_attempts = attempts;
    }
    void setAttemptTime(int time) {
        m_attemptTime = time;
    }
    void setClicks(int clicks) {
        m_clicks = clicks;
    }
    void setCoinsVerified(int coinsVerified) {
        m_coinsVerified = coinsVerified;
    }
    void setDailyID(int id) {
        m_dailyID = id;
    }
    void setDemon(int demon) {
        m_demon = demon;
    }
    void setJumps(int jumps) {
        m_jumps = jumps;
    }
    void setLastBuildPageForTab(int tab, int page) = win inline, m1 0x4ab484 {
        m_lastBuildSave->setObject(cocos2d::CCString::createWithFormat("%i", page), cocos2d::CCString::createWithFormat("%i", tab)->getCString());
    }
    void setLevelID(int levelID) {
        m_levelID = levelID;
    }
    void setNewNormalPercent(int percent) {
        m_orbCompletion = percent;
    }
    void setNewNormalPercent2(int percent) {
        m_newNormalPercent2 = percent;
    }
    void setNormalPercent(int percent) = win inline, imac 0x52e640, m1 0x4825a8, ios inline {
        m_normalPercent = percent;
    }
    void setObjectCount(int count) {
        m_objectCount = count;
    }
    void setOriginalLevel(int id) {
        m_originalLevel = id;
    }
    void setPassword(int password) {
        m_password = password;
    }
    void setStars(int stars) {
        m_stars = stars;
    }
    bool shouldCheatReset() = win inline, imac 0x52e600, m1 0x482560, ios inline {
        return m_stars.value() > 7 && m_jumps.value() < 50 && m_clicks.value() < 50;
    }
    void storeNewLocalScore(int value, int type) = win 0x16d440;
    void unverifyCoins() = win 0x16ffe0;

    cocos2d::CCDictionary* m_lastBuildSave;
    geode::SeedValueRSV m_levelID;
    gd::string m_levelName;
    gd::string m_levelDesc;
    gd::string m_levelString;
    gd::string m_creatorName;
    gd::string m_recordString;
    gd::string m_uploadDate;
    gd::string m_updateDate;
    gd::string m_lockedEditorLayers;
    gd::string m_savedCameraPositions;
    cocos2d::CCPoint m_previewLock;
    geode::SeedValueRSV m_userID;
    geode::SeedValueRSV m_accountID;
    GJDifficulty m_difficulty;
    int m_audioTrack;
    int m_songID;
    int m_levelRev;
    bool m_unlisted;
    bool m_friendsOnly;
    geode::SeedValueRSV m_objectCount;
    int m_levelIndex;
    int m_ratings;
    int m_ratingsSum;
    int m_downloads;
    bool m_isEditable;
    bool m_gauntletLevel;
    bool m_gauntletLevel2;
    int m_workingTime;
    int m_workingTime2;
    bool m_lowDetailMode;
    bool m_lowDetailModeToggled;
    bool m_disableShakeToggled;
    bool m_selected;
    bool m_localOrSaved;
    bool m_disableShake;
    geode::SeedValueRS m_isVerified;
    bool m_isVerifiedRaw;
    bool m_isUploaded;
    bool m_hasBeenModified;
    int m_levelVersion;
    int m_gameVersion;
    geode::SeedValueRSV m_attempts;
    geode::SeedValueRSV m_jumps;
    geode::SeedValueRSV m_clicks;
    geode::SeedValueRSV m_attemptTime;
    int m_chk;
    bool m_isChkValid;
    bool m_isCompletionLegitimate;
    geode::SeedValueVSR m_normalPercent;
    geode::SeedValueRSV m_orbCompletion;
    geode::SeedValueRSV m_newNormalPercent2;
    int m_practicePercent;
    int m_likes;
    int m_dislikes;
    int m_levelLength;
    int m_featured;
    int m_isEpic;
    bool m_levelFavorited;
    int m_levelFolder;
    geode::SeedValueRSV m_dailyID;
    geode::SeedValueRSV m_demon;
    int m_demonDifficulty;
    geode::SeedValueRSV m_stars;
    bool m_autoLevel;
    int m_coins;
    geode::SeedValueRSV m_coinsVerified;
    geode::SeedValueRS m_password;
    geode::SeedValueRSV m_originalLevel;
    bool m_twoPlayerMode;
    int m_failedPasswordAttempts;
    geode::SeedValueRSV m_firstCoinVerified;
    geode::SeedValueRSV m_secondCoinVerified;
    geode::SeedValueRSV m_thirdCoinVerified;
    int m_starsRequested;
    bool m_showedSongWarning;
    int m_starRatings;
    int m_starRatingsSum;
    int m_maxStarRatings;
    int m_minStarRatings;
    int m_demonVotes;
    int m_rateStars;
    bool m_rateFeature;
    gd::string m_rateUser;
    bool m_dontSave;
    bool m_levelNotDownloaded;
    int m_requiredCoins;
    bool m_isUnlocked;
    cocos2d::CCPoint m_lastCameraPos;
    float m_lastEditorZoom;
    int m_lastBuildTab;
    int m_lastBuildPage;
    int m_lastBuildGroupID;
    GJLevelType m_levelType;
    int m_M_ID;
    gd::string m_tempName;
    gd::string m_capacityString;
    bool m_highObjectsEnabled;
    bool m_unlimitedObjectsEnabled;
    gd::string m_personalBests;
    int m_timestamp;
    int m_listPosition;
    gd::string m_songIDs;
    gd::string m_sfxIDs;
    int m_54; //aka k106
    int m_bestTime;
    int m_unk518;
    int m_unk51c;
    int m_unk520;
    gd::string m_inputsTime;
    int m_bestPoints;
    int m_unk54c;
    int m_unk550;
    int m_unk554;
    gd::string m_inputsPoints;
    int m_platformerSeed;
    gd::string m_localBestTimes;
    gd::string m_localBestPoints;
    bool m_savedTime;
    bool m_savedPoints;
}

[[link(android)]]
class GJGameLoadingLayer : cocos2d::CCLayer {
    // virtual ~GJGameLoadingLayer();
    GJGameLoadingLayer() {
        m_level = nullptr;
        m_editor = false;
    }

    static GJGameLoadingLayer* create(GJGameLevel* level, bool editor) = win inline, imac 0x164ef0, m1 0x13274c {
        auto ret = new GJGameLoadingLayer();
        if (ret->init(level, editor)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static GJGameLoadingLayer* transitionToLoadingLayer(GJGameLevel* level, bool editor) = win 0x248c30, m1 0x132640;

    virtual void onEnter() = win 0x52e40, m1 0x132b54, imac 0x1653c0;
    virtual void onEnterTransitionDidFinish() = win 0x248ec0, m1 0x132b50, imac 0x1653b0;

    void gameLayerDidUnload() = win inline, m1 0xeb184 {
        this->runAction(cocos2d::CCSequence::create(
            cocos2d::CCDelayTime::create(.01f),
            cocos2d::CCCallFunc::create(this, callfunc_selector(GJGameLoadingLayer::loadLevel)),
            nullptr
        ));
    }
    bool init(GJGameLevel* level, bool editor) = win inline {
        if (!cocos2d::CCLayer::init()) return false;

        if (level) {
            m_level = level;
            level->retain();
        }
        m_editor = editor;

        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        auto loadingLabel = cocos2d::CCLabelBMFont::create("Loading...", "bigFont.fnt");
        loadingLabel->setScale(.7f);
        this->addChild(loadingLabel, 1);
        loadingLabel->setAnchorPoint({ 1.f, 0.f });
        loadingLabel->setPosition({ winSize.width - 20.f, 20.f });

        return true;
    }
    void loadLevel() = win 0x248e20, imac 0x165350, m1 0x132ae4;

    GJGameLevel* m_level;
    bool m_editor;
}

[[link(android), depends(EventTriggerInstance), depends(SongChannelState), depends(DynamicObjectAction), depends(AdvancedFollowInstance), depends(EnterEffectInstance), depends(GameObjectPhysics), depends(GJValueTween), depends(SFXTriggerInstance), depends(SFXTriggerState), depends(SongTriggerState), depends(EnterEffectAnimValue)]]
class GJGameState {
    // ~GJGameState();
    // GJGameState() = win 0x204510;

    void controlTweenAction(int uniqueID, int controlID, GJActionCommand command) = win 0x2054a0, imac 0x10df20, m1 0xe9d8c;
    GameObjectPhysics& getGameObjectPhysics(GameObject* object) = win 0x2056a0, imac 0x10e5c0, m1 0xea2bc;
    void processStateTriggers() = win 0x205530, imac 0x10e490, m1 0xea1a8;
    void stopTweenAction(int action) = win inline, m1 0xe9d64, ios inline {
        m_tweenActions.erase(action);
    }
    void tweenValue(float from, float to, int action, float duration, int easing, float rate, int uniqueID, int controlID) = win 0x2053e0, imac 0x10de40, m1 0xe9cc8;
    void updateTweenAction(float value, int action) = win inline, imac 0x10e370, m1 0xea0f4 {
        switch (action) {
            case 1: m_cameraPosition.x = value; break;
            case 2: m_cameraPosition.y = value; break;
            case 7: m_levelFlipping = value; break;
            case 9: m_portalY = value; break;
            case 10: m_unkPoint6.x = value; break;
            case 11: m_unkPoint6.y = value; break;
            case 12: m_unkPoint8.x = value; break;
            case 13: m_unkPoint8.y = value; break;
            case 14: m_cameraZoom = value; break;
            case 15: m_cameraOffset.x = value; break;
            case 16: m_cameraOffset.y = value; break;
            case 17: m_cameraAngle = value; break;
            case 18: m_unkPoint26.x = value; break;
            case 19: m_unkPoint26.y = value; break;
            case 20: m_middleGroundOffsetY = value; break;
            case 21: m_unkPoint12.x = value; break;
            case 22: m_unkPoint12.y = value; break;
            case 25: m_unkFloat9 = value; break;
        }
    }
    void updateTweenActions(float tweenValue) = win inline {
        for (auto it = m_tweenActions.begin(); it != m_tweenActions.end();) {
            it->second.step(tweenValue);
            this->updateTweenAction(it->second.m_currentValue, it->first);
            if (it->second.m_finished) it = m_tweenActions.erase(it);
            else ++it;
        }
    }

    float m_cameraZoom;
    float m_targetCameraZoom;
    cocos2d::CCPoint m_cameraOffset;
    cocos2d::CCPoint m_unkPoint1;
    cocos2d::CCPoint m_unkPoint2;
    cocos2d::CCPoint m_unkPoint3;
    cocos2d::CCPoint m_unkPoint4;
    cocos2d::CCPoint m_unkPoint5;
    cocos2d::CCPoint m_unkPoint6;
    cocos2d::CCPoint m_unkPoint7;
    cocos2d::CCPoint m_unkPoint8;
    cocos2d::CCPoint m_unkPoint9;
    cocos2d::CCPoint m_unkPoint10;
    cocos2d::CCPoint m_unkPoint11;
    cocos2d::CCPoint m_unkPoint12;
    cocos2d::CCPoint m_unkPoint13;
    cocos2d::CCPoint m_unkPoint14;
    cocos2d::CCPoint m_unkPoint15;
    cocos2d::CCPoint m_unkPoint16;
    cocos2d::CCPoint m_unkPoint17;
    cocos2d::CCPoint m_unkPoint18;
    cocos2d::CCPoint m_unkPoint19;
    cocos2d::CCPoint m_unkPoint20;
    cocos2d::CCPoint m_unkPoint21;
    cocos2d::CCPoint m_unkPoint22;
    cocos2d::CCPoint m_unkPoint23;
    cocos2d::CCPoint m_unkPoint24;
    cocos2d::CCPoint m_unkPoint25;
    cocos2d::CCPoint m_unkPoint26;
    cocos2d::CCPoint m_unkPoint27;
    cocos2d::CCPoint m_unkPoint28;
    cocos2d::CCPoint m_unkPoint29;
    bool m_unkBool1;
    int m_unkInt1;
    bool m_unkBool2;
    int m_unkInt2;
    bool m_unkBool3;
    cocos2d::CCPoint m_unkPoint30;
    float m_middleGroundOffsetY;
    int m_unkInt3;
    int m_unkInt4;
    bool m_unkBool4;
    bool m_unkBool5;
    float m_unkFloat2;
    float m_unkFloat3;
    int m_unkInt5;
    int m_unkInt6;
    int m_unkInt7;
    int m_unkInt8;
    int m_unkInt9;
    int m_unkInt10;
    int m_unkInt11;
    float m_unkFloat4;
    float m_unkUint1;
    float m_portalY;
    bool m_unkBool6;
    bool m_gravityRelated;
    int m_unkInt12;
    float m_unkInt13;
    int m_unkInt14;
    int m_unkInt15;
    bool m_unkBool7;
    bool m_unkBool8;
    bool m_unkBool9;
    float m_unkFloat5;
    float m_unkFloat6;
    float m_unkFloat7;
    float m_unkFloat8;
    float m_cameraAngle;
    float m_targetCameraAngle;
    bool m_playerStreakBlend;
    float m_timeWarp;
    int m_unk18c; // int/float, size 4
    float m_timeWarpRelated;
    int m_currentChannel;
    int m_rotateChannel;
    gd::unordered_map<int, int> m_spawnChannelRelated0;
    gd::unordered_map<int, bool> m_spawnChannelRelated1;
    double m_totalTime;
    double m_levelTime;
    double m_unkDouble3;
    int m_unkUint2;
    float m_unkUint3;
    int m_currentProgress;
    int m_unkUint4;
    int m_unkUint5;
    int m_unkUint6;
    int m_unkUint7;
    GameObject* m_lastActivatedPortal1;
    GameObject* m_lastActivatedPortal2;
    cocos2d::CCPoint m_cameraPosition;
    bool m_unkBool10;
    float m_levelFlipping;
    bool m_unkBool11;
    bool m_unkBool12;
    bool m_isDualMode;
    float m_unkFloat9;
    gd::unordered_map<int, GJValueTween> m_tweenActions;
    int m_cameraEdgeValue0;
    int m_cameraEdgeValue1;
    int m_cameraEdgeValue2;
    int m_cameraEdgeValue3;
    gd::unordered_map<int, GameObjectPhysics> m_gameObjectPhysics;
    gd::vector<float> m_unkVecFloat1;
    float m_unkUint10;
    int m_unkUint11;
    int m_unkUint12;
    cocos2d::CCPoint m_cameraStepDiff;
    float m_unkFloat10;
    unsigned int m_timeModRelated;
    bool m_timeModRelated2;
    gd::map<std::pair<int, int>, int> m_unkMapPairIntIntInt;
    float m_unkUint13;
    cocos2d::CCPoint m_unkPoint32;
    // same as m_cameraPosition but still updates in the editor when not playtesting?
    cocos2d::CCPoint m_cameraPosition2;
    bool m_unkBool20;
    bool m_unkBool21;
    bool m_unkBool22;
    float m_unkUint14;
    bool m_unkBool26;
    bool m_cameraShakeEnabled;
    float m_cameraShakeFactor;
    float m_unkUint15;
    float m_unkUint16;
    double m_unkUint64_1;
    cocos2d::CCPoint m_unkPoint34;
    unsigned int m_dualRelated;
    gd::unordered_map<int, EnhancedGameObject*> m_stateObjects;
    gd::map<std::pair<GJGameEvent, int>, gd::vector<EventTriggerInstance>> m_unkMapPairGJGameEventIntVectorEventTriggerInstance;
    gd::map<std::pair<GJGameEvent, int>, int> m_unkMapPairGJGameEventIntInt;
    gd::unordered_map<int, gd::vector<EnterEffectInstance>> m_enterEffectInstanceVectors;
    gd::unordered_map<int, gd::vector<EnterEffectInstance>> m_exitEffectInstanceVectors;
    gd::vector<int> m_enterChannelMap;
    gd::vector<int> m_exitChannelMap;
    gd::vector<EnterEffectInstance> m_moveEffectInstances;
    gd::vector<EnterEffectInstance> m_rotateEffectInstances;
    gd::vector<EnterEffectInstance> m_scaleEffectInstances;
    gd::vector<EnterEffectInstance> m_fadeEffectInstances;
    gd::vector<EnterEffectInstance> m_tintEffectInstances;
    gd::unordered_set<int> m_unsortedAreaEffects;
    bool m_unkBool27;
    gd::vector<AdvancedFollowInstance> m_advanceFollowInstances;
    gd::vector<DynamicObjectAction> m_dynamicMoveActions;
    gd::vector<DynamicObjectAction> m_dynamicRotateActions;
    bool m_unkBool28;
    bool m_unkBool29;
    float m_unkUint17;
    gd::unordered_map<int, gd::vector<int>> m_unkUMap8;
    gd::map<std::pair<int,int>, SFXTriggerInstance> m_proximityVolumeRelated;
    gd::unordered_map<int, SongChannelState> m_songChannelStates;
    gd::unordered_map<int, gd::vector<SongTriggerState>> m_songTriggerStateVectors;
    gd::vector<SFXTriggerState> m_sfxTriggerStates;
    bool m_unkBool30;
    int m_background;
    int m_ground;
    int m_middleground;
    bool m_unkBool31;
    int m_points;
    bool m_unkBool32;
    unsigned int m_pauseCounter;
    unsigned int m_pauseBufferTimer;
}

[[link(android)]]
class GJGarageLayer : cocos2d::CCLayer, TextInputDelegate, FLAlertLayerProtocol, GameRateDelegate, ListButtonBarDelegate, DialogDelegate, CharacterColorDelegate, RewardedVideoDelegate {
    GJGarageLayer() {
        m_playerObject = nullptr;
        m_unknown = nullptr;
        m_supporter = nullptr;
        m_hasClosed = false;
        m_cursor2 = nullptr;
        m_currentIcon = nullptr;
        m_iconSelection = nullptr;
        m_iconID = 0;
        m_selectedIconType = IconType::Cube;
        m_videoPlaying = false;
    }
    ~GJGarageLayer() = win inline, m1 0x2f2e04 {
        auto gm = GameManager::sharedState();
        gm->m_gameRateDelegate1 = nullptr;
        CC_SAFE_RELEASE(m_tabButtons);
        CC_SAFE_RELEASE(m_pageButtons);
        if (gm->m_rewardedVideoDelegate == this) gm->m_rewardedVideoDelegate = nullptr;
    }

    static gd::string achievementForUnlock(int id, UnlockType type) = win inline, m1 0x2f925c, ios inline {
        auto achievementManager = AchievementManager::sharedState();
        auto achievement = achievementManager->achievementForUnlock(id, type);
        return achievementManager->isAchievementAvailable(achievement) ? achievement : "";
    }
    static gd::string descriptionForUnlock(int id, UnlockType type) = win 0x278120, m1 0x2f90c8;
    static GJGarageLayer* node() = win inline, m1 0x2f2f44 {
        auto ret = new GJGarageLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static cocos2d::CCScene* scene() = win 0x272ca0, m1 0x2f2f00;
    static gd::string titleForUnlock(int id, UnlockType type) = win inline, m1 0x2f8f3c {
        auto achievementManager = AchievementManager::sharedState();
        return achievementManager->getAchievementsWithID(achievementManager->achievementForUnlock(id, type).c_str())->valueForKey("title")->getCString();
    }

    virtual bool init() = win 0x272e60, m1 0x2f3044, imac 0x368de0;
    virtual void keyBackClicked() = win 0x278fe0, m1 0x2f97e0, imac 0x36f9d0;
    virtual void textInputOpened(CCTextInputNode* node) = win 0x274a80, imac 0x36c290, m1 0x2f63e8;
    virtual void textInputClosed(CCTextInputNode* node) = win 0x274c70, imac 0x36c3c0, m1 0x2f654c;
    virtual void textChanged(CCTextInputNode* node) = win 0xc3da0, m1 0x2f672c, imac 0x36c580;
    virtual void listButtonBarSwitchedPage(ListButtonBar* bar, int page) = win 0xc3e50, imac 0x36e990, m1 0x2f882c;
    virtual void showUnlockPopup(int id, UnlockType type) = win 0x277a10, m1 0x2f898c, imac 0x36eb20;
    virtual void updateRate() = win 0x2786e0, m1 0x2f95c4, imac 0x36f780;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x2782b0, imac 0x36f510, m1 0x2f938c;
    virtual void dialogClosed(DialogLayer* layer) = win 0x278510, m1 0x2f9488, imac 0x36f620;
    virtual void playerColorChanged() = win 0x277860, m1 0x2f8748, imac 0x36e890;
    virtual void rewardedVideoFinished() = win 0x274a70, imac 0x36c270, m1 0x2f63d8;

    cocos2d::CCArray* getItems(IconType type) = win 0x276540, m1 0x2f7a78;
    cocos2d::CCArray* getItems(int count, int page, IconType type, int current) = win 0x276600;
    gd::string getLockFrame(int id, UnlockType type) = win inline, imac 0x36e7f0, m1 0x2f86b0, ios inline {
        return "GJ_lock_001";
    }
    void onArrow(cocos2d::CCObject* sender) = win 0x275c80, imac 0x36c610, m1 0x2f67e0;
    void onBack(cocos2d::CCObject* sender) = win 0x278e40;
    void onInfo(cocos2d::CCObject* sender) = win 0x274880, m1 0x2f5e40;
    void onNavigate(cocos2d::CCObject* sender) = win 0x275d80, imac 0x36cef0, m1 0x2f7068;
    void onPaint(cocos2d::CCObject* sender) = win 0x278c60, m1 0x260804;
    void onRewardedVideo(cocos2d::CCObject* sender) = imac 0x36bec0;
    void onSelect(cocos2d::CCObject* sender) = win 0x276f80, imac 0x36da10, m1 0x8313c;
    void onSelectTab(cocos2d::CCObject* sender) = m1 0x2f67ac;
    void onShards(cocos2d::CCObject* sender) = win 0x278b10, m1 0x2f5dbc;
    void onShop(cocos2d::CCObject* sender) = m1 0x2f5d5c;
    void onSpecial(cocos2d::CCObject* sender) = m1 0x2f7a5c;
    void onToggleItem(cocos2d::CCObject* sender) = win 0x277620, imac 0x36e270, m1 0x2f817c;
    void playRainbowEffect() = win 0x278920, imac 0x36e650, m1 0x2f8514;
    void playShadowEffect() = win inline, imac 0x36f940, m1 0x2f9754, ios inline {
        auto circleWave = CCCircleWave::create(20.f, 60.f, .3f, false);
        circleWave->m_color.r = 0;
        circleWave->m_color.g = 0;
        circleWave->m_color.b = 0;
        circleWave->m_opacityMod = .5f;
        circleWave->m_blendAdditive = false;
        circleWave->setPosition(m_playerObject->getPosition());
        this->addChild(circleWave, -1);
    }
    void selectTab(IconType type) = win 0x275de0, imac 0x36c760, m1 0x2f6918;
    void setupIconSelect() = win 0x275020, m1 0x222560;
    void setupPage(int page, IconType type) = win 0x275ea0;
    void setupSpecialPage() = win 0x2768d0, m1 0x2f510c;
    void showUnlockPopupNew(int id, UnlockType type) = win inline, imac 0x36e9b0, m1 0x2f884c, ios inline {
        ItemInfoPopup::create(id, type)->show();
    }
    void toggleGlow() = win inline, m1 0x2f86dc, ios inline {
        auto gameManager = GameManager::sharedState();
        gameManager->m_playerGlow = !gameManager->m_playerGlow;
        m_playerObject->m_hasGlowOutline = gameManager->m_playerGlow;
        m_playerObject->updateColors();
        if (gameManager->m_playerGlow) this->playRainbowEffect();
    }
    void updatePlayerColors() = win 0x277890, imac 0x36a980, m1 0x2f4a90;
    void updatePlayerName(char const* name) = win inline, imac 0x36c3a0, m1 0x2f6544, ios inline {}

    CCTextInputNode* m_usernameInput;
    SimplePlayer* m_playerObject;
    cocos2d::CCArray* m_tabButtons;
    cocos2d::CCArray* m_pageButtons;
    cocos2d::CCNode* m_unknown;
    cocos2d::CCSprite* m_supporter;
    bool m_hasClosed;
    IconType m_iconType;
    gd::map<IconType, int> m_iconPages;
    cocos2d::CCSprite* m_cursor1;
    cocos2d::CCSprite* m_cursor2;
    CCMenuItemSpriteExtra* m_currentIcon;
    ListButtonBar* m_iconSelection;
    CCMenuItemSpriteExtra* m_leftArrow;
    CCMenuItemSpriteExtra* m_rightArrow;
    cocos2d::CCMenu* m_navDotMenu;
    int m_iconID;
    IconType m_selectedIconType;
    bool m_videoPlaying;
}

[[link(android)]]
class GJGradientLayer : cocos2d::CCLayerGradient {
    // virtual ~GJGradientLayer();
    GJGradientLayer() {
        m_baseColor = 0;
        m_detailColor = 0;
        m_triggerObject = nullptr;
        m_noScale = false;
        m_blendingMode = 0;
        m_blendingLayer = 0;
        m_gradientID = 0;
    }

    static GJGradientLayer* create() = win inline, m1 0x10e4d4 {
        auto ret = new GJGradientLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x248bb0, imac 0x164d60, m1 0x1325d0;

    int m_baseColor;
    int m_detailColor;
    cocos2d::CCPoint m_gradientPosition;
    GradientTriggerObject* m_triggerObject;
    bool m_noScale;
    int m_blendingMode;
    int m_blendingLayer;
    int m_gradientID;
}

[[link(android)]]
class GJGroundLayer : cocos2d::CCLayer {
    // virtual ~GJGroundLayer();

    static GJGroundLayer* create(int groundID, int lineType) = win 0x27e000, imac 0x5ea3e0, m1 0x5143d4;

    virtual void draw() = win inline, imac 0x5eb510, m1 0x5154d4 {}
    virtual void showGround() = win 0x27ec50, imac 0x5eb330, m1 0x5152c8;
    virtual void fadeInGround(float duration) = win 0x27ec60, imac 0x5eb340, m1 0x5152d4;
    virtual void fadeOutGround(float duration) = win 0x27ee50, m1 0x5154a8, imac 0x5eb4e0;

    void createLine(int lineType) = win 0x27e8b0, imac 0x5ea9d0, m1 0x382af4;
    void deactivateGround() = win inline, m1 0x5154b0, ios inline {
        this->stopAllActions();
        m_showGround = false;
    }
    void fadeInFinished() = imac 0x5eb3b0, m1 0x515354;
    float getGroundY() = win inline, imac 0x5eb560, m1 0x515520, ios inline {
        return 0.f;
    }
    void hideShadows() = win inline, imac 0x5eb3c0, m1 0x515360, ios inline {
        if (auto leftShadow = this->getChildByTag(0)) leftShadow->setVisible(false);
        if (auto rightShadow = this->getChildByTag(1)) rightShadow->setVisible(false);
    }
    bool init(int groundID, int lineType) = win 0x27e080;
    void loadGroundSprites(int count, bool ground1) = win 0x27e5f0, imac 0x5eab90, m1 0x514b64;
    void positionGround(float y) = win inline, imac 0x5eb520, m1 0x5154d8 {
        this->setPosition(0.f, y);
    }
    float scaleGround(float scale) = win 0xcd280, imac 0x5eafc0, m1 0x514f9c;
    void toggleVisible01(bool visible) = win inline, m1 0x514e60 {
        if (m_showGround1 == visible) return;
        m_showGround1 = visible;
        this->setVisible(visible && m_showGround2);
    }
    void toggleVisible02(bool visible) = win inline {
        if (m_showGround2 == visible) return;
        m_showGround2 = visible;
        this->setVisible(visible && m_showGround1);
    }
    void updateGround01Color(cocos2d::ccColor3B color) = win inline, imac 0x5eadf0, m1 0x514de0 {
        if (auto children = m_ground1Sprite->getChildren()) {
            for (int i = 0; i < children->count(); i++) {
                static_cast<cocos2d::CCSprite*>(children->objectAtIndex(i))->setColor(color);
            }
        }
    }
    void updateGround02Color(cocos2d::ccColor3B color) = win inline, imac 0x5eaf30, m1 0x514f18 {
        if (!m_ground2Sprite) return;
        if (auto children = m_ground2Sprite->getChildren()) {
            for (int i = 0; i < children->count(); i++) {
                static_cast<cocos2d::CCSprite*>(children->objectAtIndex(i))->setColor(color);
            }
        }
    }
    void updateGroundPos(cocos2d::CCPoint pos) = win inline, imac 0x5eaee0, m1 0x514ec8 {
        m_ground1Sprite->setPosition(pos);
        if (m_ground2Sprite) m_ground2Sprite->setPosition(pos);
    }
    void updateGroundWidth(bool useThis) = win inline, imac 0x5eb0d0, m1 0x515090 {
        auto parent = this->getParent();
        if (!parent) return;
        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        auto scale = useThis ? this->getScaleX() : parent->getScale();
        m_groundWidth = winSize.width / scale + 10.f;
        int count = ceilf(m_groundWidth / m_textureWidth) + 1.f;
        if (m_cameraRotated) count++;
        this->loadGroundSprites(count, true);
        this->loadGroundSprites(count, false);
        m_lineSprite->setScaleX(m_lineType > 1 ? (((winSize.width + 10.f) / scale) / m_lineSprite->getTextureRect().size.width) : (1.f / scale));
        m_lineSprite->setPosition({ m_groundWidth * .5f - 5.f, m_lineSprite->getPosition().y } );
    }
    void updateLineBlend(bool blend) = win inline, imac 0x5eb2e0, m1 0x51528c {
        if (m_blendLine == blend) return;
        m_blendLine = blend;
        if (blend) m_lineSprite->setBlendFunc({ GL_SRC_ALPHA, GL_ONE });
        else m_lineSprite->setBlendFunc({ GL_ONE, GL_ONE_MINUS_SRC_ALPHA });
    }
    void updateShadows() = win 0x27ece0, imac 0x5eb250, m1 0x5151f8;
    void updateShadowXPos(float leftX, float rightX) = win 0x27ed80, imac 0x5eb420, m1 0x5153e0;

    cocos2d::CCSprite* m_ground1Sprite;
    cocos2d::CCSprite* m_ground2Sprite;
    float m_textureWidth;
    cocos2d::CCSprite* m_lineSprite;
    bool m_showGround;
    bool m_blendLine;
    float m_ground1Offset;
    int m_lineType;
    float m_groundWidth;
    bool m_showGround1;
    bool m_showGround2;
    float m_unk1cc;
    bool m_cameraRotated;
}

[[link(android)]]
class GJHttpResult : cocos2d::CCNode {
    // virtual ~GJHttpResult();
    GJHttpResult() {
        m_success = false;
        m_httpType = (GJHttpType)0;
    }

    static GJHttpResult* create(bool success, gd::string response, gd::string tag, GJHttpType type) = win inline, imac 0x51db10, m1 0x473668, ios inline {
        auto ret = new GJHttpResult();
        if (ret->init(success, response, tag, type)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init(bool success, gd::string response, gd::string tag, GJHttpType type) = win inline, m1 0x4b06a8, ios inline {
        if (!cocos2d::CCNode::init()) return false;
        m_success = success;
        m_response = response;
        m_requestTag = tag;
        m_httpType = type;
        return true;
    }

    bool m_success;
    gd::string m_response;
    gd::string m_requestTag;
    GJHttpType m_httpType;
}

[[link(android)]]
class GJItemIcon : cocos2d::CCSprite {
    GJItemIcon() {
        m_player = nullptr;
        m_iconRequestID = 0;
        m_isIcon = false;
        m_unlockID = 0;
        m_unlockType = (UnlockType)0;
    }
    ~GJItemIcon() = win inline, m1 0x2fa66c {
        GameManager::sharedState()->unloadIcons(m_iconRequestID);
    }

    static GJItemIcon* create(UnlockType type, int id, cocos2d::ccColor3B color1, cocos2d::ccColor3B color2, bool dark, bool unused, bool noLabel, cocos2d::ccColor3B unlockColor) = win inline, imac 0x370af0, m1 0x2fa770 {
        auto ret = new GJItemIcon();
        if (ret->init(type, id, color1, color2, dark, unused, noLabel, unlockColor)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static GJItemIcon* createBrowserItem(UnlockType unlockType, int itemID) = win 0x27a800, imac 0x36d9b0, m1 0x2f7ad0, ios inline {
        return create(unlockType, itemID, { 175, 175, 175 }, { 255, 255, 255 }, false, true, true, { 255, 255, 255 });
    }
    static GJItemIcon* createStoreItem(UnlockType type, int id, bool dark, cocos2d::ccColor3B unlockColor) = win 0x27a6d0, imac 0x370ac0, m1 0x2fa754;
    static float scaleForType(UnlockType type) = win 0x27b520, m1 0x2f7af0;
    static cocos2d::ccColor3B unlockedColorForType(int type) = win inline, m1 0x2faed8 {
        switch (type) {
            case 1: return { 10, 30, 20 };
            case 2: return { 33, 22, 66 };
            case 3: return { 20, 20, 40 };
            case 4: return { 20, 30, 50 };
            case 5: return { 50, 50, 50 };
            default: return { 60, 30, 20 };
        }
    }

    virtual void setOpacity(unsigned char opacity) = win 0x27b030, m1 0x2fadac, imac 0x371170;

    void changeToLockedState(float scale) = win 0x27b440, imac 0x36e110, m1 0x2f7fe8;
    void darkenStoreItem(ShopType type) = win 0x27b0d0, m1 0x2f7fc0;
    void darkenStoreItem(cocos2d::ccColor3B color) = win 0x27b150, imac 0x371310, m1 0x2faf4c;
    bool init(UnlockType type, int id, cocos2d::ccColor3B color1, cocos2d::ccColor3B color2, bool dark, bool unused, bool noLabel, cocos2d::ccColor3B unlockColor) = win 0x27a920;
    void toggleEnabledState(bool enabled) = win 0x27b380;

    cocos2d::CCSprite* m_player;
    int m_iconRequestID;
    cocos2d::CCSize m_playerSize;
    bool m_isIcon;
    int m_unlockID;
    UnlockType m_unlockType;
}

[[link(android)]]
class GJLevelList : cocos2d::CCNode {
    // virtual ~GJLevelList();
    GJLevelList() {
        m_listID = 0;
        m_listVersion = 0;
        m_downloads = 0;
        m_likes = 0;
        m_difficulty = -1;
        m_accountID = 0;
        m_folder = 0;
        m_listRevision = 0;
        m_listOrder = 0;
        m_original = 0;
        m_diamonds = 0;
        m_levelsToClaim = 0;
        m_isEditable = false;
        m_unlisted = false;
        m_friendsOnly = false;
        m_uploaded = false;
        m_favorite = false;
        m_featured = false;
        m_onlineLevelsLoaded = false;
        m_modified = false;
        m_levelsDict = nullptr;
        m_listType = GJLevelType::Default;
        m_M_ID = 0;
    }

    static GJLevelList* create() = win 0x1767b0, imac 0x52d100, m1 0x4812b4;
    static GJLevelList* create(cocos2d::CCDictionary* dict) = win 0x175ec0, m1 0x484a74;
    static GJLevelList* createWithCoder(DS_Dictionary* dict) = win inline, m1 0x4b1f98 {
        auto ret = GJLevelList::create();
        ret->dataLoaded(dict);
        return ret;
    }
    static gd::string frameForListDifficulty(int diff, DifficultyIconType type) = win inline, imac 0x5634d0 {
        if (diff == 0) return type == DifficultyIconType::NoText ? "diffIcon_auto_btn_001.png" : "difficulty_auto_btn_001.png";

        if (diff > 10) diff = 0;
        switch (diff) {
            case 6: diff = 7; break;
            case 7: diff = 8; break;
            case 8: diff = 6; break;
        }

        if (type == DifficultyIconType::NoText) {
            return cocos2d::CCString::createWithFormat("diffIcon_%02d_btn_001.png", diff)->getCString();
        }
        else if (type == DifficultyIconType::DefaultText && diff > 5) {
            return cocos2d::CCString::createWithFormat("difficulty_%02d_btn2_001.png", diff)->getCString();
        }
        else {
            return cocos2d::CCString::createWithFormat("difficulty_%02d_btn_001.png", diff)->getCString();
        }
    }

    virtual void encodeWithCoder(DS_Dictionary* dict) = win 0x178040, imac 0x563250, m1 0x4b22f4;
    virtual bool canEncode() = win inline, imac 0x5634c0, m1 0x4b252c { return true; }
    virtual bool init() = win 0x176940, m1 0x4b07e4, imac 0x5616e0;

    void addLevelToList(GJGameLevel* level) = win 0x176f30, m1 0x4b0ffc;
    int completedLevels() = win 0x1778b0, imac 0x562a30, m1 0x4b1ab0;
    void dataLoaded(DS_Dictionary* dict) = win 0x177d20, imac 0x562f10, m1 0x4b1fc8;
    void duplicateListLevels(GJLevelList* list) = win inline, imac 0x5619d0, m1 0x4b0adc {
        auto levels = list->getListLevelsArray(nullptr);
        for (int i = 0; i < levels->count(); i++) {
            this->addLevelToList(static_cast<GJGameLevel*>(levels->objectAtIndex(i)));
        }
    }
    cocos2d::CCArray* getListLevelsArray(cocos2d::CCArray* levels) = win 0x1771b0, imac 0x561a40;
    gd::string getUnpackedDescription();
    void handleStatsConflict(GJLevelList* list) = win inline, imac 0x561760, m1 0x4b085c {
        m_listOrder = std::max(m_listOrder, list->m_listOrder);
    }
    bool hasMatchingLevels(GJLevelList* list) = win 0x1769c0, imac 0x561780, m1 0x4b0874;
    int orderForLevel(int id) = win inline, imac 0x13e530, m1 0x4b1520 {
        auto index = 0;
        for (auto levelID : m_levels) {
            if (levelID == id) return index;
            index++;
        }
        return index;
    }
    void parseListLevels(gd::string str) = win 0x176c90;
    void removeLevelFromList(int id) = win inline, m1 0x4b13d8 {
        for (auto it = m_levels.begin(); it != m_levels.end(); ++it) {
            if (*it == id) {
                m_levels.erase(it);
                this->updateLevelsString();
                break;
            }
        }
        m_levelsDict->removeObjectForKey(GameToolbox::intToString(id));
        m_modified = true;
    }
    void reorderLevel(int levelID, int newPosition) = win 0x1770c0;
    void reorderLevelStep(int id, bool up) = win inline, m1 0xadf4 {
        this->reorderLevel(id, this->orderForLevel(id) + (up ? -1 : 1));
    }
    void showListInfo() = win 0x177950, imac 0x562a80, m1 0x4b1b14;
    int totalLevels() = win inline, imac 0x562a10, m1 0x4b1aa0 {
        return m_levels.size();
    }
    void updateLevelsString() = win 0x1777a0, m1 0x4b11e8;

    gd::vector<int> m_levels;
    int m_listID;
    int m_listVersion;
    int m_downloads;
    int m_likes;
    int m_difficulty;
    int m_accountID;
    int m_folder;
    int m_listRevision;
    int m_listOrder;
    int m_original;
    int m_diamonds;
    int m_levelsToClaim;
    bool m_isEditable;
    bool m_unlisted;
    bool m_friendsOnly;
    bool m_uploaded;
    bool m_favorite;
    bool m_featured;
    bool m_onlineLevelsLoaded;
    bool m_modified;
    gd::string m_creatorName;
    gd::string m_listName;
    gd::string m_unkString;
    gd::string m_levelsString;
    gd::string m_listDesc;
    int m_uploadDate;
    int m_updateDate;
    cocos2d::CCDictionary* m_levelsDict;
    GJLevelType m_listType;
    int m_M_ID;
}

[[link(android)]]
class GJLevelScoreCell : TableViewCell {
    // virtual ~GJLevelScoreCell();
    GJLevelScoreCell(char const* identifier, float width, float height) = win inline, ios inline : TableViewCell(identifier, width, height) {
        this->init();
    }

    virtual bool init() = win 0x3c850, imac 0x255a00, m1 0x1fb61c;
    virtual void draw() = win 0xade40, m1 0x1fb660, imac 0x255a50;

    void loadFromScore(GJUserScore* score) = win 0xba0c0, imac 0x24a8d0, m1 0x1f14a4;
    void onViewProfile(cocos2d::CCObject* sender);
    void updateBGColor(int index) = win inline, imac 0x24a870, m1 0x1f1424 {
        m_backgroundLayer->setColor(index % 2 == 0 ? cocos2d::ccColor3B { 161, 88, 44 } : cocos2d::ccColor3B { 194, 114, 62 });
        m_backgroundLayer->setOpacity(255);
    }

    GJUserScore* m_userScore;
}

[[link(android)]]
class GJListLayer : cocos2d::CCLayerColor {
    // virtual ~GJListLayer();

    static GJListLayer* create(BoomListView* listView, char const* title, cocos2d::ccColor4B color, float width, float height, int type) = win 0x27f600, imac 0x5d2040, m1 0x4fe658;

    bool init(BoomListView* listView, char const* title, cocos2d::ccColor4B color, float width, float height, int type) = win 0x27f730, m1 0x4fe74c;

    BoomListView* m_listView;
}

[[link(android)]]
class GJLocalLevelScoreCell : TableViewCell {
    // virtual ~GJLocalLevelScoreCell();
    GJLocalLevelScoreCell(char const* identifier, float width, float height) = win inline, m1 0x1fb4a0, ios inline : TableViewCell(identifier, width, height) {
        this->init();
    }

    virtual bool init() = win 0x3c850, imac 0x255810, m1 0x1fb4e4;
    virtual void draw() = win 0xade40, m1 0x1fb4f0, imac 0x255830;

    void loadFromScore(GJLocalScore* score) = win 0xb9cc0, imac 0x24b2d0, m1 0x1f1e7c;
    void updateBGColor(int index) = win inline, imac 0x24b500 {
        m_backgroundLayer->setColor(index % 2 == 0 ? cocos2d::ccColor3B { 161, 88, 44 } : cocos2d::ccColor3B { 194, 114, 62 });
        m_backgroundLayer->setOpacity(255);
    }

    GJLocalScore* m_localScore;
}

[[link(android)]]
class GJLocalScore : cocos2d::CCObject {
    // virtual ~GJLocalScore();
    GJLocalScore() {
        m_points = 0;
        m_type = LevelLeaderboardType::Friends;
        m_currentScore = false;
    }

    static GJLocalScore* create(int points, int type) = win inline, imac 0x55f8d0, m1 0x4aeed0 {
        auto ret = new GJLocalScore();
        if (ret->init(points, type)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init(int points, int type) = win inline, imac 0x55f940, m1 0x4aef40, ios inline {
        m_points = points;
        m_type = (LevelLeaderboardType)type;
        return true;
    }

    int m_points;
    LevelLeaderboardType m_type;
    bool m_currentScore;
}

[[link(android)]]
class GJMapObject : cocos2d::CCNode {
    // virtual ~GJMapObject();

    static GJMapObject* create(cocos2d::CCNode* parent) = m1 0x20a128;
    static GJMapObject* createMonster(int objectID) = imac 0x2667f0, m1 0x20a2f4;

    bool init(cocos2d::CCNode* parent) = imac 0x2666f0;
    void monsterIdle() = imac 0x2673d0, m1 0x20ae34;
    void monsterJump() = imac 0x2671c0, m1 0x20ac34;
    void moveFinished() = m1 0x20abb4;
    void moveMonster() = imac 0x266fa0;
    void moveMonster(cocos2d::CCPoint position, float offset) = imac 0x266fe0;
    void playerJump() = imac 0x266cf0, m1 0x20a7ac;
    void setObjectOrigin(cocos2d::CCPoint position, float offset) = imac 0x266f60, m1 0x20a9ec;
    void startMonsterJumpLoop() = imac 0x266af0;
    void startPlayerJumpLoop() = m1 0x20a754;
    void touchMonster();
    void updateShadow(float scaleX, float scaleY, cocos2d::CCPoint position) = imac 0x266a90, m1 0x20a590;

    float m_jumpStopTime;
    cocos2d::CCNode* m_mainNode;
    cocos2d::CCSprite* m_shadowSprite;
    cocos2d::CCPoint m_objectOrigin;
    float m_objectOffset;
    bool m_monsterIdle;
    bool m_monsterMoving;
    float m_moveStopTime;
    int m_monstersTouched;
}

[[link(android)]]
class GJMapPack : cocos2d::CCNode {
    GJMapPack() {
        m_levels = nullptr;
        m_packID = 0;
        m_difficulty = GJDifficulty::Auto;
        m_stars = 0;
        m_coins = 0;
        m_MId = 0;
        m_isGauntlet = false;
    }
    ~GJMapPack() = win inline {
        CC_SAFE_RELEASE(m_levels);
    }

    static GJMapPack* create() = win inline, m1 0x4ae940 {
        auto ret = new GJMapPack();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static GJMapPack* create(cocos2d::CCDictionary* dict) = win 0x170160, imac 0x531d90, m1 0xf29ac;

    virtual bool init() = win 0x170cc0, imac 0x55f740, m1 0x4aed5c;

    int completedMaps() = win 0x170fd0, imac 0x55f7c0, m1 0x4aedbc;
    bool hasCompletedMapPack() = win inline, imac 0x55f870, m1 0x4aee84 {
        auto total = this->totalMaps();
        if (total > 0) return this->completedMaps() >= total;
        else return 0;
    }
    void parsePackColors(gd::string textColorStr, gd::string barColorStr) = win 0x170d20, imac 0x51dde0, m1 0x4aeaec;
    void parsePackLevels(gd::string levelsStr) = win inline, imac 0x55f390, m1 0x4ae9e4 {
        CC_SAFE_RELEASE(m_levels);
        auto levels = cocos2d::CCArray::create();
        auto start = 0;
        auto index = levelsStr.find_first_of(",");
        auto size = levelsStr.size();
        while (index != std::string::npos) {
            auto str = levelsStr.substr(start, index - start);
            if (!str.empty() || start != size) {
                levels->addObject(cocos2d::CCString::create(str));
            }
            start = index + 1;
            index = levelsStr.find_first_of(",", start);
        }
        m_levels = levels;
        levels->retain();
    }
    int totalMaps() = win inline, m1 0x4aedac {
        if (this->m_levels) {
            return this->m_levels->count();
        }

        return 0;
    }

    cocos2d::CCArray* m_levels;
    int m_packID;
    GJDifficulty m_difficulty;
    int m_stars;
    int m_coins;
    gd::string m_packName;
    gd::string m_levelStrings;
    cocos2d::ccColor3B m_textColour;
    cocos2d::ccColor3B m_barColour;
    int m_MId;
    bool m_isGauntlet;
}

[[link(android)]]
class GJMessageCell : TableViewCell, FLAlertLayerProtocol, UploadPopupDelegate, UploadActionDelegate {
    GJMessageCell(char const* identifier, float width, float height) = win inline, ios inline : TableViewCell(identifier, width, height) {
        this->init();
    }
    ~GJMessageCell() = win inline {
        auto glm = GameLevelManager::sharedState();
        if (glm->m_uploadActionDelegate == this) glm->m_uploadActionDelegate = nullptr;
        if (m_popup) m_popup->m_delegate = nullptr;
        CC_SAFE_RELEASE(m_message);
    }

    virtual bool init() = win 0xbc340, imac 0x2580b0, m1 0x1fd624;
    virtual void draw() = win 0xade40, m1 0x1fd8f4, imac 0x2583b0;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0xbe180, imac 0x258480, m1 0x1fd9a0;
    virtual void uploadActionFinished(int id, int response) = win 0xbe320, m1 0x1fdb04, imac 0x258610;
    virtual void uploadActionFailed(int id, int response) = win 0xbe4a0, m1 0x1fdcec, imac 0x2587f0;
    virtual void onClosePopup(UploadActionPopup* popup) = win 0xbc1d0, m1 0x1fde54, imac 0x258960;

    void loadFromMessage(GJUserMessage* message) = win 0xbd520, imac 0x24c5e0, m1 0x1f31ec;
    void markAsRead() = win 0xbdeb0;
    void onDeleteMessage(cocos2d::CCObject* sender) = win 0xbdfc0, imac 0x2581b0;
    void onToggle(cocos2d::CCObject* sender) = m1 0x1fd850;
    void onViewMessage(cocos2d::CCObject* sender) = win 0xbde10, imac 0x2580d0;
    void onViewProfile(cocos2d::CCObject* sender);
    void updateBGColor(int index) = win inline, imac 0x24cf50, m1 0x1f3b44 {
        m_backgroundLayer->setColor(index % 2 == 0 ? cocos2d::ccColor3B { 161, 88, 44 } : cocos2d::ccColor3B { 194, 114, 62 });
        m_backgroundLayer->setOpacity(255);
    }
    void updateToggle() = win inline, m1 0x1f4aec, ios inline {
       if (m_message && m_toggler) m_toggler->toggle(m_message->m_toggled);
    }

    GJUserMessage* m_message;
    UploadActionPopup* m_popup;
    CCMenuItemToggler* m_toggler;
}

[[link(android)]]
class GJMessagePopup : FLAlertLayer, UploadActionDelegate, UploadPopupDelegate, FLAlertLayerProtocol, DownloadMessageDelegate {
    // virtual ~GJMessagePopup();

    static GJMessagePopup* create(GJUserMessage* message) = win 0x2971d0, imac 0x2a66d0, m1 0x24531c;

    virtual void keyBackClicked() = win 0x846c0, m1 0x246b7c, imac 0x2a8030;
    virtual void downloadMessageFinished(GJUserMessage* message) = win 0x298970, m1 0x246bf8, imac 0x2a80a0;
    virtual void downloadMessageFailed(int id) = win 0x2989c0, m1 0x246cc0, imac 0x2a8160;
    virtual void uploadActionFinished(int id, int response) = win 0x298a00, imac 0x2a8200, m1 0x246d70;
    virtual void uploadActionFailed(int id, int response) = win 0x298b90, m1 0x246f58, imac 0x2a83d0;
    virtual void onClosePopup(UploadActionPopup* popup) = win 0x298c60, m1 0x2470c8, imac 0x2a8520;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x298ce0, imac 0x2a8620, m1 0x2471f4;

    void blockUser() = win inline {
        if (GameLevelManager::sharedState()->blockUser(m_message->m_accountID)) {
            m_uploadPopup = UploadActionPopup::create(this, "Blocking user...");
            m_uploadPopup->show();
        }
    }
    bool init(GJUserMessage* message) = win 0x297310;
    void loadFromGJMessage(GJUserMessage* message) = win 0x297c20, imac 0x2a7210, m1 0x245df4;
    void onBlock(cocos2d::CCObject* sender) = win 0x298740, m1 0x246600;
    void onClose(cocos2d::CCObject* sender) = win 0x84690, imac 0x2a71e0, m1 0x245db8;
    void onRemove(cocos2d::CCObject* sender) = imac 0x2a7d10;
    void onReply(cocos2d::CCObject* sender) = win 0x298270, m1 0x2463c4;

    bool m_actionSuccess;
    cocos2d::CCLabelBMFont* m_errorLabel;
    GJUserMessage* m_message;
    LoadingCircle* m_loadingCircle;
    CCMenuItemSpriteExtra* m_closeButton;
    UploadActionPopup* m_uploadPopup;
}

[[link(android)]]
class GJMGLayer : cocos2d::CCLayer {
    // virtual ~GJMGLayer();
    GJMGLayer() {
        m_ground1Sprite = nullptr;
        m_ground2Sprite = nullptr;
        m_textureWidth = 0.f;
        m_unk1b0 = nullptr;
        m_showGround = false;
        m_groundWidth = 0.f;
        m_showGround1 = true;
        m_showGround2 = true;
        m_unk1c4 = 0.f;
        m_cameraRotated = false;
        m_blendMG1 = false;
        m_blendMG2 = false;
        m_mg1BatchNode = nullptr;
        m_mg2BatchNode = nullptr;
        m_groundScale = 0.f;
        m_ground2Offset = 0.f;
    }

    static GJMGLayer* create(int index) = win inline, imac 0x5eb6b0, m1 0x51563c {
        auto ret = new GJMGLayer();
        if (ret->init(index)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static float defaultYOffsetForBG2(int index) = win inline, m1 0x51561c, ios inline {
        switch (index) {
            case 1: return 25.f;
            case 2: case 3: return 30.f;
            default: return 0.f;
        }
    }

    virtual void draw() = win inline, imac 0x5ec160, m1 0x5160b4 {}
    virtual void showGround() = win 0x27ec50, m1 0x516084, imac 0x5ec130;

    void deactivateGround() = win inline, m1 0x516090, ios inline {
        this->stopAllActions();
        m_showGround = false;
    }
    bool init(int index) = win 0x27ee60, m1 0x515718;
    void loadGroundSprites(int count, bool ground1) = win 0x27f360, imac 0x5ebc50, m1 0x515b94;
    float scaleGround(float scale) = win inline, imac 0x317720, m1 0x515f20 {
        m_groundScale = scale;
        this->setScaleX(scale);
        if (this->getScaleY() < 0.f) this->setScaleY(-scale);
        else this->setScaleY(scale);
        auto groundWidth = m_groundWidth;
        this->updateGroundWidth(true);
        return m_groundWidth - groundWidth;
    }
    void toggleVisible01(bool visible) = win inline, m1 0x515de0, ios inline {
        if (m_showGround1 == visible) return;
        m_showGround1 = visible;
        this->setVisible(visible && m_showGround2);
    }
    void toggleVisible02(bool visible) = win inline, m1 0x515e20 {
        if (m_showGround2 == visible) return;
        m_showGround2 = visible;
        this->setVisible(visible && m_showGround1);
    }
    void updateGroundColor(cocos2d::ccColor3B color, bool ground1) = win inline, imac 0x5ebdf0, m1 0x515d50 {
        auto groundSprite = ground1 ? m_ground1Sprite : m_ground2Sprite;
        if (!groundSprite) return;
        if (auto children = groundSprite->getChildren()) {
            for (int i = 0; i < children->count(); i++) {
                static_cast<cocos2d::CCSprite*>(children->objectAtIndex(i))->setColor(color);
            }
        }
    }
    void updateGroundOpacity(unsigned char opacity, bool ground1) = win inline {
        auto groundSprite = ground1 ? m_ground1Sprite : m_ground2Sprite;
        if (!groundSprite) return;
        if (auto children = groundSprite->getChildren()) {
            for (int i = 0; i < children->count(); i++) {
                static_cast<cocos2d::CCSprite*>(children->objectAtIndex(i))->setOpacity(opacity);
            }
        }
    }
    void updateGroundPos(cocos2d::CCPoint pos) = win inline {
        m_ground1Sprite->setPosition(pos);
        if (m_ground2Sprite) m_ground2Sprite->setPosition(pos);
    }
    void updateGroundWidth(bool useThis) = win inline, imac 0x5ec050 {
        auto parent = this->getParent();
        if (!parent) return;
        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        auto scale = useThis ? this->getScaleX() : parent->getScale();
        m_groundWidth = winSize.width / scale + 10.f;
        int count = ceilf(m_groundWidth / m_textureWidth) + 1.f;
        if (m_cameraRotated) count++;
        this->loadGroundSprites(count, true);
        this->loadGroundSprites(count, false);
    }
    void updateMG01Blend(bool blend) = win inline, imac 0x5ec170, m1 0x5160b8 {
        if (m_blendMG1 == blend) return;
        m_blendMG1 = blend;
        if (blend) m_mg1BatchNode->setBlendFunc({ GL_SRC_ALPHA, GL_ONE });
        else m_mg1BatchNode->setBlendFunc({ GL_ONE, GL_ONE_MINUS_SRC_ALPHA });
    }
    void updateMG02Blend(bool blend) = win inline, imac 0x5ec1c0, m1 0x5160f4 {
        if (m_blendMG2 == blend) return;
        m_blendMG2 = blend;
        if (blend) m_mg2BatchNode->setBlendFunc({ GL_SRC_ALPHA, GL_ONE });
        else m_mg2BatchNode->setBlendFunc({ GL_ONE, GL_ONE_MINUS_SRC_ALPHA });
    }

    cocos2d::CCSprite* m_ground1Sprite;
    cocos2d::CCSprite* m_ground2Sprite;
    float m_textureWidth;
    void* m_unk1b0;
    bool m_showGround;
    float m_groundWidth;
    bool m_showGround1;
    bool m_showGround2;
    float m_unk1c4;
    bool m_cameraRotated;
    bool m_blendMG1;
    bool m_blendMG2;
    cocos2d::CCSpriteBatchNode* m_mg1BatchNode;
    cocos2d::CCSpriteBatchNode* m_mg2BatchNode;
    float m_groundScale;
    float m_ground2Offset;
}

[[link(android)]]
class GJMoreGamesLayer : GJDropDownLayer {
    // virtual ~GJMoreGamesLayer();
    // GJMoreGamesLayer();

    static GJMoreGamesLayer* create() = win 0x27fda0, m1 0x69cb3c;

    virtual void customSetup() = win 0x280480, m1 0x69d21c, imac 0x794f10;

    cocos2d::CCArray* getMoreGamesList() = win 0x2800e0, m1 0x480f24;

    cocos2d::CCArray* m_moreGamesList;
}

[[link(android)]]
class GJMPDelegate {
    virtual void joinLobbyFinished(int id) {}
    virtual void joinLobbyFailed(int id, GJMPErrorCode errorType) {}
    virtual void didUploadMPComment(int id) {}
    virtual void updateComments() {}
}

[[link(android)]]
class GJMultiplayerManager : cocos2d::CCNode {
    // virtual ~GJMultiplayerManager();

    static GJMultiplayerManager* sharedState() = win 0x282450, imac 0x6585b0, m1 0x57876c;

    virtual bool init() = win 0x282ba0, m1 0x579d70, imac 0x659d20;

    void addComment(gd::string str, int lobbyID) = win 0x283b70, imac 0x65a950, m1 0x57aa48;
    void addDLToActive(char const* tag) = win inline, ios inline {
        this->addDLToActive(tag, cocos2d::CCNode::create());
    }
    void addDLToActive(char const* tag, cocos2d::CCObject* obj) = win inline, ios inline {
        m_activeDownloads->setObject(obj, tag);
    }
    void createAndAddComment(gd::string text, int lobbyID) = win 0x283990, m1 0x57b6d4;
    void dataLoaded(DS_Dictionary* dict) = win inline, m1 0x57b88c {}
    void encodeDataTo(DS_Dictionary* dict) = win inline, m1 0x57b888 {}
    bool exitLobby(int id) = m1 0x57ac48;
    void firstSetup() = win inline, m1 0x57b884 {}
    gd::string getBasePostString() = win 0x283d30, m1 0x57a468;
    cocos2d::CCObject* getDLObject(char const* tag) = win inline, ios inline {
        return m_activeDownloads->objectForKey(tag);
    }
    int getLastCommentIDForGame(int id) = win inline, imac 0x65a500, m1 0x57a570, ios inline {
        auto comments = static_cast<cocos2d::CCArray*>(m_lobbyComments->objectForKey(id));
        if (comments && comments->count() > 0) {
            auto commentID = 0;
            for (int i = 0; i < comments->count(); i++) {
                auto comment = static_cast<GJComment*>(comments->objectAtIndex(i));
                if (comment->m_commentID > commentID) commentID = comment->m_commentID;
            }
            return commentID;
        }
        return 0;
    }
    void handleIt(bool success, gd::string response, gd::string tag, GJHttpType type) = win 0x282910, imac 0x658af0, m1 0x578c6c;
    void handleItDelayed(bool success, gd::string response, gd::string tag, GJHttpType type) = win inline, ios inline {
        auto result = GJHttpResult::create(true, response, tag, type);
        result->retain();
        m_pActionManager->addAction(cocos2d::CCSequence::create(
            cocos2d::CCDelayTime::create(.1f),
            cocos2d::CCCallFuncND::create(this, callfuncND_selector(GJMultiplayerManager::handleItND), result),
            nullptr
        ), this, false);
    }
    void handleItND(cocos2d::CCNode* node, void* data) = win inline, ios inline {
        auto result = static_cast<GJHttpResult*>(data);
        this->handleIt(result->m_success, result->m_response, result->m_requestTag, result->m_httpType);
        result->release();
    }
    bool isDLActive(char const* tag) = win inline, ios inline {
        return this->getDLObject(tag) != nullptr;
    }
    bool joinLobby(int id) = m1 0x57a114;
    void onExitLobbyCompleted(gd::string response, gd::string tag) = win inline, m1 0x579b08 {
        this->removeDLFromActive(tag.c_str());
        auto id = atoi(tag.c_str());
        if (response == "-1") {
            if (m_uploadDelegate) m_uploadDelegate->uploadActionFailed(id, 58);
        }
        else {
            if (m_uploadDelegate) m_uploadDelegate->uploadActionFinished(id, 58);
        }
    }
    void onJoinLobbyCompleted(gd::string response, gd::string tag) = win 0x282cd0, imac 0x523ea0, m1 0x5792e8;
    void onProcessHttpRequestCompleted(cocos2d::extension::CCHttpClient* client, cocos2d::extension::CCHttpResponse* response);
    void onUploadCommentCompleted(gd::string response, gd::string tag) = win inline, m1 0x579c08 {
        this->removeDLFromActive(tag.c_str());
        if (response != "-1") {
            if (m_mpDelegate) m_mpDelegate->didUploadMPComment(atoi(tag.c_str()));
        }
    }
    void ProcessHttpRequest(gd::string url, gd::string params, gd::string tag, GJHttpType type) = win 0x282500, imac 0x658630, m1 0x5787e8;
    void removeDLFromActive(char const* tag) = win 0x282c20;
    bool uploadComment(gd::string text, int lobbyID) = win 0x283430, imac 0x65ae40, m1 0x3f33cc;

    cocos2d::CCDictionary* m_activeDownloads;
    cocos2d::CCDictionary* m_lobbyScores;
    cocos2d::CCDictionary* m_scoreArrays;
    cocos2d::CCDictionary* m_lobbyComments;
    GJMPDelegate* m_mpDelegate;
    UploadActionDelegate* m_uploadDelegate;
}

[[link(android)]]
class GJObjectDecoder : cocos2d::CCNode, ObjectDecoderDelegate {
    // virtual ~GJObjectDecoder();

    static GJObjectDecoder* sharedDecoder() = win 0x283e20, m1 0x636aa8;

    virtual bool init() = win 0x77e00, m1 0x636b50, imac 0x7242f0;
    virtual cocos2d::CCObject* getDecodedObject(int type, DS_Dictionary* dict) = win 0x283ec0, m1 0x636b54, imac 0x724300;
}

[[link(android)]]
class GJOnlineRewardDelegate {
    virtual void onlineRewardStatusFinished(gd::string key) {}
    virtual void onlineRewardStatusFailed() {}
}

[[link(android)]]
class GJOptionsLayer : SetupTriggerPopup {
    GJOptionsLayer() {
        m_gap = 48.f;
        m_page = 0;
        m_togglesPerPage = 10;
        m_toggleCount = 0;
        m_maxPage = 0;
        m_maxLabelScale = .5f;
        m_maxLabelWidth = 130.f;
        m_offset = 0.f;
    }
    ~GJOptionsLayer() = win 0x28f7f0, imac 0x29b260, m1 0x23aeb8;

    static GJOptionsLayer* create(int background) = win inline, imac 0x29b6b0, m1 0x23b190, ios inline {
        auto ret = new GJOptionsLayer();
        if (ret->init(background)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void setupOptions() = win inline, imac 0x29c100, m1 0x23ba44 {}
    virtual void didToggleGV(gd::string variable) = win 0x1f5d20 {}
    virtual void didToggle(int toggle) {}

    void addGVToggle(char const* title, char const* variable, char const* description) = win 0x28fc00, imac 0x29c110, m1 0x23ba48;
    void addToggle(char const* title, int id, bool initial, char const* description) = win inline, m1 0x23c018 {
        addToggleInternal(title, id, initial, description);
    }
    void addToggleInternal(char const* title, int id, bool initial, char const* description) = win 0x28fd40;
    int countForPage(int page) = win 0x290280;
    void goToPage(int page);
    void incrementCountForPage(int page) = win 0x290350;
    const char* infoKey(int index) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("info_%i", index)->getCString();
    }
    bool init(int background) = win 0x28f8c0, imac 0x29b900, m1 0x23b328;
    cocos2d::CCLayer* layerForPage(int page);
    const char* layerKey(int page) = win inline, m1 0x23cacc, ios inline {
        return cocos2d::CCString::createWithFormat("layer_%i", page)->getCString();
    }
    cocos2d::CCPoint nextPosition(int page) = win inline, imac 0x29c750, m1 0x23c01c {
        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        auto count = this->countForPage(page);
        cocos2d::CCPoint pos = winSize * .5f + cocos2d::CCPoint { count % 2 == 0 ? -160.f : 80.f, m_offset + 80.f };
        if (count > 1) pos.y -= floorf(count / 2.f) * m_gap;
        return pos;
    }
    const char* objectKey(int page) = win inline, m1 0x23caa4, ios inline {
        return cocos2d::CCString::createWithFormat("object_%i", page)->getCString();
    }
    cocos2d::CCArray* objectsForPage(int page);
    void offsetToNextPage() = win inline, imac 0x29c0d0, m1 0x23ba20, ios inline {
        m_toggleCount += m_togglesPerPage - m_toggleCount % m_togglesPerPage;
    }
    void onInfo(cocos2d::CCObject* sender);
    void onNextPage(cocos2d::CCObject* sender);
    void onPrevPage(cocos2d::CCObject* sender);
    void onToggle(cocos2d::CCObject* sender) = win 0x290bb0, imac 0x29ca40, m1 0x23c2e8;
    const char* pageKey(int page) = win inline, m1 0x23ca7c, ios inline {
        return cocos2d::CCString::createWithFormat("page_%i", page)->getCString();
    }

    float m_gap;
    int m_page;
    int m_togglesPerPage;
    int m_toggleCount;
    int m_maxPage;
    float m_maxLabelScale;
    float m_maxLabelWidth;
    cocos2d::CCDictionary* m_values;
    cocos2d::CCDictionary* m_variables;
    CCMenuItemSpriteExtra* m_prevButton;
    CCMenuItemSpriteExtra* m_nextButton;
    float m_offset;
}

[[link(android)]]
class GJPathPage : FLAlertLayer, FLAlertLayerProtocol, GJPurchaseDelegate {
    // virtual ~GJPathPage();

    static GJPathPage* create(int path, GJPathsLayer* layer) = win 0x285310, imac 0x2fe6a0, m1 0x28f6cc;

    virtual void registerWithTouchDispatcher() = win 0x42660, m1 0x2932ac, imac 0x302710;
    virtual void keyBackClicked() = win 0x288ea0, m1 0x293168, imac 0x3025d0;
    virtual void show() = win 0x86810, m1 0x2932e4, imac 0x302750;
    virtual void didPurchaseItem(GJStoreItem* item) = win 0x2872d0, imac 0x300a00, m1 0x2918b0;

    bool init(int path, GJPathsLayer* layer) = win 0x285440, m1 0x4249f8;
    void onActivatePath(cocos2d::CCObject* sender) = win 0x287070, imac 0x3009d0;
    void onBack(cocos2d::CCObject* sender) = win 0x288e00;
    void onIconInfo(cocos2d::CCObject* sender) = win 0x2870e0, imac 0x300730, m1 0x2915c4;
    void onUnlock(cocos2d::CCObject* sender) = win 0x2872e0, imac 0x3008e0;
    void playUnlockAnimation() = win 0x287b90, m1 0x37bdbc;
    void showCantAffordMessage(GJStoreItem* item);
    void unlockAnimationFinished() = win 0x288cd0, imac 0x301a50, m1 0x29275c;
    void unlockAnimationStep2() = win 0x2881e0, m1 0x292514;
    void unlockAnimationStep3() = win 0x288460, imac 0x301bb0, m1 0x2197e8;

    GJPathsLayer* m_pathsLayer;
    int m_pathNumber;
    bool m_animationPlaying;
    int m_dialogIndex;
}

[[link(android)]]
class GJPathRewardPopup : FLAlertLayer {
    // virtual ~GJPathRewardPopup();
    GJPathRewardPopup() {
        m_pathNumber = 0;
    }

    static GJPathRewardPopup* create(int path) = win inline, imac 0x2fe820, m1 0x28f7f8 {
        auto ret = new GJPathRewardPopup();
        if (ret->init(path)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyBackClicked() = win inline, m1 0x293d00, imac 0x303100 {}

    void closePopup() = win 0x285250, m1 0x293c98;
    bool init(int path) = win 0x289d80;
    void onClaim(cocos2d::CCObject* sender) = win 0x28a260, m1 0x293b3c;

    int m_pathNumber;
}

[[link(android)]]
class GJPathsLayer : FLAlertLayer, FLAlertLayerProtocol {
    // virtual ~GJPathsLayer();

    static GJPathsLayer* create() = win 0x284960, imac 0x2fdda0, m1 0x28ee0c;
    static gd::string nameForPath(int path) = win 0x2846f0, imac 0x2fdbc0;

    virtual bool init() = win 0x284a60, m1 0x28ef0c, imac 0x2fdef0;
    virtual void onExit() = win 0x284fc0, m1 0x28f62c, imac 0x2fe610;
    virtual void registerWithTouchDispatcher() = win 0x42660, m1 0x28f9c4, imac 0x2fea30;
    virtual void keyBackClicked() = win 0x2852b0, m1 0x28f8f4, imac 0x2fe960;
    virtual void show() = win 0x86810, m1 0x28f9fc, imac 0x2fea70;

    void darkenButtons(bool darken) = win inline, imac 0x2fe660, m1 0x28f680, ios inline {
        m_closeSprite->setColor(darken ? cocos2d::ccColor3B { 75, 75, 75 } : cocos2d::ccColor3B { 255, 255, 255 });
    }
    void onClose(cocos2d::CCObject* sender) = win 0x285250, m1 0x28f40c;
    void onPath(cocos2d::CCObject* sender) = win 0x285010, imac 0x2fe590, m1 0x28f5a0;

    cocos2d::CCSprite* m_closeSprite;
    bool m_exiting;
}

[[link(android)]]
class GJPathSprite : CCSpriteCOpacity {
    // virtual ~GJPathSprite();

    static GJPathSprite* create(int path) = win 0x288eb0, m1 0x28f474;

    void addRankLabel(int path) = win inline, m1 0x2935a4 {
        auto rankLabel = cocos2d::CCLabelBMFont::create(GameToolbox::intToString(path).c_str(), "bigFont.fnt");
        rankLabel->setScale(0.55f);
        this->addChild(rankLabel, 1);
        rankLabel->setPosition(this->convertToNodeSpace({ 0.f, 0.f }) + cocos2d::CCPoint { 0.f, 1.f });
    }
    void addShardSprite() = win 0x289520, imac 0x3024c0, m1 0x29303c;
    void changeToLockedArt() = win 0x289260, imac 0x301470, m1 0x2921e4;
    bool init(int path) = win inline {
        if (!cocos2d::CCSprite::initWithSpriteFrameName(cocos2d::CCString::createWithFormat("pathIcon_%02d_001.png", path)->getCString())) return false;
        m_pathNumber = path;
        return true;
    }
    void updateState() = win 0x289080, m1 0x28f520;

    int m_pathNumber;
}

[[link(android)]]
class GJPFollowCommandLayer : SetupTriggerPopup {
    // virtual ~GJPFollowCommandLayer();

    static GJPFollowCommandLayer* create(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x28a530, imac 0x3642d0;

    virtual void determineStartValues() = win 0x28bf20, imac 0x366440, m1 0x2f0f20;
    virtual void onClose(cocos2d::CCObject* sender) = win 0x28cd80, imac 0x367240, m1 0x2f1a2c;
    virtual void textChanged(CCTextInputNode* node) = win 0x28c4b0, m1 0x2f1498, imac 0x366af0;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x28a660, imac 0x364510, m1 0x2ef0d4;
    void onUpdateGroupID(cocos2d::CCObject* sender) = win 0x28c450, m1 0x2f0860, imac 0x365d90;
    void sliderChanged(cocos2d::CCObject* sender) = win 0x271b30;
    void sliderXModChanged(cocos2d::CCObject* sender) = m1 0x2f0758;
    void sliderYModChanged(cocos2d::CCObject* sender) = m1 0x2f07dc;
    void updateDuration();
    void updateDurLabel(bool decimals);
    void updateMaxSpeed() = win inline, m1 0x2f19b4 {
        if (m_gameObject) {
            m_gameObject->m_followYMaxSpeed = m_maxSpeed;
        }
        else {
            for (int i = 0; i < m_gameObjects->count(); i++) {
                static_cast<EffectGameObject*>(m_gameObjects->objectAtIndex(i))->m_followYMaxSpeed = m_maxSpeed;
            }
        }
    }
    void updateMaxSpeedLabel() = win inline {
        m_disableTextDelegate = true;
        if (m_maxSpeed == -99999.f) m_maxSpeedInput->setString("");
        else m_maxSpeedInput->setString(cocos2d::CCString::createWithFormat("%0.1f", m_maxSpeed)->getCString());
        m_disableTextDelegate = false;
    }
    void updateOffsetLabel() = win inline {
        m_disableTextDelegate = true;
        if (m_offset == -99999) m_offsetInput->setString("");
        else m_offsetInput->setString(cocos2d::CCString::createWithFormat("%i", (int)(m_offset / 3.f))->getCString());
        m_disableTextDelegate = false;
    }
    void updatePlayerOffset() = win inline, m1 0x2f1944 {
        if (m_gameObject) {
            m_gameObject->m_followYOffset = m_offset;
        }
        else {
            for (int i = 0; i < m_gameObjects->count(); i++) {
                static_cast<EffectGameObject*>(m_gameObjects->objectAtIndex(i))->m_followYOffset = m_offset;
            }
        }
    }
    void updateTargetGroupID();
    void updateTextInputLabel();
    void updateXMod();
    void updateXModLabel();
    void updateYMod();
    void updateYModLabel();

    CCTextInputNode* m_moveTimeInput;
    Slider* m_moveTimeSlider;
    float m_moveTime;
    CCTextInputNode* m_speedInput;
    CCTextInputNode* m_delayInput;
    CCTextInputNode* m_offsetInput;
    CCTextInputNode* m_maxSpeedInput;
    Slider* m_speedSlider;
    Slider* m_delaySlider;
    float m_delay;
    float m_speed;
    int m_offset;
    float m_maxSpeed;
    CCTextInputNode* m_targetIDInput;
    int m_targetGroupID;
}

[[link(android)]]
class GJPromoPopup : FLAlertLayer {
    // virtual ~GJPromoPopup();
    GJPromoPopup() {}

    static GJPromoPopup* create(gd::string filename) = win inline, imac 0x2b5e70, m1 0x253860 {
        auto ret = new GJPromoPopup();
        if (ret->init(filename)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void onExit() = win 0x2a4db0, m1 0x253c7c, imac 0x2b62f0;
    virtual void registerWithTouchDispatcher() = win 0x42660, m1 0x253d8c, imac 0x2b6400;
    virtual void keyBackClicked() = win 0x2852b0, m1 0x253cbc, imac 0x2b6330;
    virtual void show() = win 0x86810, m1 0x253dc4, imac 0x2b6440;

    bool init(gd::string filename) = win 0x2a4ab0, imac 0x2b6010;
    void onClose(cocos2d::CCObject* sender) = win 0x285250, m1 0x253c14;

    gd::string m_promoFrame;
}

[[link(android)]]
class GJPurchaseDelegate {
    virtual void didPurchaseItem(GJStoreItem* item) {}
}

[[link(android)]]
class GJRequestCell : TableViewCell, FLAlertLayerProtocol, UploadPopupDelegate, UploadActionDelegate {
    GJRequestCell(char const* identifier, float width, float height) = win inline, ios inline : TableViewCell(identifier, width, height) {
        this->init();
    }
    ~GJRequestCell() = win inline {
        auto glm = GameLevelManager::sharedState();
        if (glm->m_uploadActionDelegate == this) glm->m_uploadActionDelegate = nullptr;
        if (m_popup) m_popup->m_delegate = nullptr;
        CC_SAFE_RELEASE(m_score);
    }

    virtual bool init() = win 0xbc340, imac 0x2572f0, m1 0x1fcaf4;
    virtual void draw() = win 0xade40, m1 0x1fcdd8, imac 0x257610;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0xbcf30, imac 0x2576e0, m1 0x1fce84;
    virtual void uploadActionFinished(int id, int response) = win 0xbd0e0, m1 0x1fd010, imac 0x2578b0;
    virtual void uploadActionFailed(int id, int response) = win 0xbd2c0, imac 0x257ac0, m1 0x1fd214;
    virtual void onClosePopup(UploadActionPopup* popup) = win 0xbc1d0, m1 0x1fd2ec, imac 0x257bd0;

    void loadFromScore(GJUserScore* score) = win 0xbc360, m1 0x1f2a5c;
    void markAsRead() = win 0xbcc90; // inlined on macos
    void onDeleteRequest(cocos2d::CCObject* sender) = win 0xbcd70;
    void onToggle(cocos2d::CCObject* sender);
    void onViewFriendRequest(cocos2d::CCObject* sender) = win 0xbcbe0;
    void onViewProfile(cocos2d::CCObject* sender);
    void updateBGColor(int index) = win inline, m1 0x1f29dc {
        m_backgroundLayer->setColor(index % 2 == 0 ? cocos2d::ccColor3B { 161, 88, 44 } : cocos2d::ccColor3B { 194, 114, 62 });
        m_backgroundLayer->setOpacity(255);
    }
    void updateToggle() = win inline, m1 0x1f4b08, ios inline {
        if (m_score && m_toggler) m_toggler->toggle(m_score->m_toggled);
    }

    GJUserScore* m_score;
    UploadActionPopup* m_popup;
    CCMenuItemToggler* m_toggler;
}

[[link(android)]]
class GJRewardDelegate {
    virtual void rewardsStatusFinished(int type) {}
    virtual void rewardsStatusFailed() {}
}

[[link(android)]]
class GJRewardItem : cocos2d::CCObject {
    // virtual ~GJRewardItem();

    static GJRewardItem* create() = win 0x1f3e90, imac 0x8efc0, m1 0x80680;
    static GJRewardItem* create(int chestID, int timeRemaining, gd::string rewardStr) = win 0x1f41d0, imac 0x72200, m1 0x63ac8;
    static GJRewardItem* createSpecial(GJRewardType rewardType, int orbs, int diamonds, SpecialRewardItem specialType1, int specialCount1, SpecialRewardItem specialType2, int specialCount2, int unlockType, int itemID) = win 0x1f3fe0, imac 0x667c0, m1 0x6915c;
    static GJRewardItem* createWithCoder(DS_Dictionary* dict) = win inline, imac 0x8f2e0, m1 0x80980 {
        auto ret = create();
        ret->dataLoaded(dict);
        return ret;
    }
    static GJRewardItem* createWithObject(GJRewardType type, GJRewardObject* object) = win 0x1f3ed0, imac 0x8c4f0, m1 0x7dfd8, ios inline {
        return createWithObjects(type, cocos2d::CCArray::createWithObject(object));
    }
    static GJRewardItem* createWithObjects(GJRewardType type, cocos2d::CCArray* objects) = win 0x1f3f60, imac 0x72090, m1 0x63938, ios inline {
        auto ret = create();
        if (ret->m_rewardObjects != objects) {
            CC_SAFE_RETAIN(objects);
            CC_SAFE_RELEASE(ret->m_rewardObjects);
            ret->m_rewardObjects = objects;
        }
        return ret;
    }
    static SpecialRewardItem getNextShardType(SpecialRewardItem type) = win inline, m1 0x80904 {
        switch (type) {
            case SpecialRewardItem::FireShard: return SpecialRewardItem::IceShard;
            case SpecialRewardItem::IceShard: return SpecialRewardItem::PoisonShard;
            case SpecialRewardItem::PoisonShard: return SpecialRewardItem::ShadowShard;
            case SpecialRewardItem::ShadowShard: return SpecialRewardItem::LavaShard;
            case SpecialRewardItem::LavaShard: return SpecialRewardItem::EarthShard;
            case SpecialRewardItem::EarthShard: return SpecialRewardItem::BloodShard;
            case SpecialRewardItem::BloodShard: return SpecialRewardItem::MetalShard;
            case SpecialRewardItem::MetalShard: return SpecialRewardItem::LightShard;
            case SpecialRewardItem::LightShard: return SpecialRewardItem::SoulShard;
            case SpecialRewardItem::SoulShard: return SpecialRewardItem::FireShard;
            default: return (SpecialRewardItem)0;
        }
    }
    static SpecialRewardItem getRandomNonMaxShardType() = win inline, m1 0x65f98 {
        auto type = getRandomShardType();
        for (int i = 10; i > 0; i--) {
            if (GameStatsManager::sharedState()->getStat(rewardItemToStat(type).c_str()) < 100) return type;
            type = getNextShardType(type);
        }
        return (SpecialRewardItem)0;
    }
    static SpecialRewardItem getRandomShardType() = win inline {
        int randomValue = floorf((rand() / (float)RAND_MAX) * 10.f) + 1.f;
        switch (randomValue) {
            case 2: return SpecialRewardItem::IceShard;
            case 3: return SpecialRewardItem::PoisonShard;
            case 4: return SpecialRewardItem::ShadowShard;
            case 5: return SpecialRewardItem::LavaShard;
            case 6: return SpecialRewardItem::EarthShard;
            case 7: return SpecialRewardItem::BloodShard;
            case 8: return SpecialRewardItem::MetalShard;
            case 9: return SpecialRewardItem::LightShard;
            case 10: return SpecialRewardItem::SoulShard;
            default: return SpecialRewardItem::FireShard;
        }
    }
    static bool isShardType(SpecialRewardItem type) = win inline, ios inline {
        return type == SpecialRewardItem::FireShard || type == SpecialRewardItem::IceShard || type == SpecialRewardItem::PoisonShard
            || type == SpecialRewardItem::ShadowShard || type == SpecialRewardItem::LavaShard || type == SpecialRewardItem::EarthShard
            || type == SpecialRewardItem::BloodShard || type == SpecialRewardItem::MetalShard || type == SpecialRewardItem::LightShard
            || type == SpecialRewardItem::SoulShard;
    }
    static gd::string rewardItemToStat(SpecialRewardItem rewardItem) = win 0x1f4500;

    virtual void encodeWithCoder(DS_Dictionary* dict) = win 0x1f4760, imac 0x8f3f0, m1 0x80ab4;
    virtual bool canEncode() = win inline, imac 0x8f450, m1 0x80b20 {
        return true;
    }

    void dataLoaded(DS_Dictionary* dict) = win inline, m1 0x80a2c {
        m_chestID = dict->getIntegerForKey("1");
        m_rewardType = (GJRewardType)dict->getIntegerForKey("2");
        auto rewardObjects = dict->getArrayForKey("3", false);
        CC_SAFE_RETAIN(rewardObjects);
        CC_SAFE_RELEASE(m_rewardObjects);
        m_rewardObjects = rewardObjects;
    }
    int getRewardCount(SpecialRewardItem type) = win inline, imac 0x76ed0, m1 0x6857c {
        if (!m_rewardObjects) return 0;

        int count = 0;
        for (int i = 0; i < m_rewardObjects->count(); i++) {
            auto obj = static_cast<GJRewardObject*>(m_rewardObjects->objectAtIndex(i));
            if (obj->m_specialRewardItem == type) count += obj->m_total;
        }

        return count;
    }
    GJRewardObject* getRewardObjectForType(SpecialRewardItem type) = win inline, m1 0x64598 {
        if (!m_rewardObjects) {
            auto rewardObjects = cocos2d::CCArray::create();
            CC_SAFE_RETAIN(rewardObjects);
            CC_SAFE_RELEASE(m_rewardObjects);
            m_rewardObjects = rewardObjects;
        }

        for (int i = 0; i < m_rewardObjects->count(); i++) {
            auto obj = static_cast<GJRewardObject*>(m_rewardObjects->objectAtIndex(i));
            if (obj->m_specialRewardItem == type) return obj;
        }

        auto obj = GJRewardObject::create(type, 0, 0);
        m_rewardObjects->addObject(obj);
        return obj;
    }
    bool init(int chestID, int timeRemaining, gd::string rewardStr) = win 0x1f42a0, imac 0x8eff0, m1 0x806b0;

    int m_chestID;
    int m_timeRemaining;
    GJRewardType m_rewardType;
    cocos2d::CCArray* m_rewardObjects;
    bool m_unk;
}

[[link(android)]]
class GJRewardObject : cocos2d::CCObject {
    // virtual ~GJRewardObject();

    static GJRewardObject* create() = win inline, m1 0x80398, ios inline {
        auto ret = create(SpecialRewardItem::FireShard, 0, 0); // the first param is meant to be 0
        return ret;
    }
    static GJRewardObject* create(SpecialRewardItem type, int total, int itemID) = win 0x1f3d90, imac 0x72020, m1 0x638c8;
    static GJRewardObject* createItemUnlock(UnlockType type, int id) = win 0x1f3d20, m1 0x63850, ios inline {
        auto ret = create(SpecialRewardItem::CustomItem, 1, id);
        ret->m_unlockType = type;
        return ret;
    }
    static GJRewardObject* createWithCoder(DS_Dictionary* dict) = win inline, imac 0x8ed60, m1 0x80420 {
        auto ret = create();
        ret->dataLoaded(dict);
        return ret;
    }

    virtual void encodeWithCoder(DS_Dictionary* dict) = win 0x1f3e00, imac 0x8ee70, m1 0x80540;
    virtual bool canEncode() = win inline, imac 0x8eef0, m1 0x805c0 {
        return true;
    }

    void dataLoaded(DS_Dictionary* dict) = win inline, m1 0x804d0 {
        m_specialRewardItem = (SpecialRewardItem)dict->getIntegerForKey("1");
        m_itemID = dict->getIntegerForKey("2");
        m_total = dict->getIntegerForKey("3");
        m_unlockType = (UnlockType)dict->getIntegerForKey("4");
    }
    bool init(SpecialRewardItem specialRewardItem, int total, int itemID) = win inline, imac 0x8ed20, m1 0x803f4, ios inline {
        this->m_specialRewardItem = specialRewardItem;
        this->m_total = total;
        this->m_itemID = itemID;
        return true;
    }
    bool isSpecialType() = win inline, m1 0x80404 {
        auto type = m_specialRewardItem;
        return type == SpecialRewardItem::FireShard || type == SpecialRewardItem::IceShard || type == SpecialRewardItem::PoisonShard
            || type == SpecialRewardItem::ShadowShard || type == SpecialRewardItem::LavaShard || type == SpecialRewardItem::BonusKey
            || type == SpecialRewardItem::EarthShard || type == SpecialRewardItem::BloodShard || type == SpecialRewardItem::MetalShard
            || type == SpecialRewardItem::LightShard || type == SpecialRewardItem::SoulShard;
    }

    SpecialRewardItem m_specialRewardItem;
    UnlockType m_unlockType;
    int m_itemID;
    int m_total;
}

[[link(android)]]
class GJRobotSprite : CCAnimatedSprite {
    // virtual ~GJRobotSprite();
    // GJRobotSprite();

    static GJRobotSprite* create(int frame) = win 0x2a64f0, m1 0x506da0;

    virtual void setOpacity(unsigned char opacity) = win 0x2a71e0, m1 0x507ef4, imac 0x5dca70;
    virtual void hideSecondary() = win 0x2a78d0, m1 0x507fd8, imac 0x5dcb80;

    void hideGlow() = win inline, imac 0x5dc680, m1 0x507bac {
        m_glowSprite->setVisible(false);
    }
    bool init(int frame) = win inline, imac 0x5db7f0, m1 0x506ed8 {
        return GJRobotSprite::init(frame, "Robot");
    }
    bool init(int frame, gd::string animName) = win 0x2a65a0;
    void showGlow() = win inline, imac 0x5dc660, m1 0x507b98 {
        m_glowSprite->setVisible(true);
    }
    void updateColor01(cocos2d::ccColor3B color) = win inline, imac 0x5dc6a0, m1 0x507bc0 {
        m_color = color;
        this->updateColors();
    }
    void updateColor02(cocos2d::ccColor3B color) = win inline, imac 0x5dc9d0, m1 0x507e68 {
        m_secondColor = color;
        this->updateColors();
    }
    void updateColors() = win 0x2a6d30, imac 0x5dc6c0, m1 0x507bd4;
    void updateFrame(int frame) = win 0x2a72e0, m1 0x507498;
    void updateGlowColor(cocos2d::ccColor3B color, bool simple) = win inline, imac 0x5dc9f0, m1 0x507e78 {
        auto children = m_glowSprite->getChildren();
        for (int i = 0; i < children->count(); i++) {
            static_cast<cocos2d::CCSprite*>(children->objectAtIndex(i))->setColor(color);
        }
    }

    cocos2d::CCArray* m_unkArray;
    bool m_hasExtra;
    cocos2d::ccColor3B m_color;
    cocos2d::ccColor3B m_secondColor;
    cocos2d::CCArray* m_secondArray;
    cocos2d::CCSprite* m_glowSprite;
    cocos2d::CCSprite* m_extraSprite;
    IconType m_iconType;
    int m_iconRequestID;
    CCSpritePart* m_headSprite;
    CCSpritePart* m_footSprite;
}

[[link(android)]]
class GJRotateCommandLayer : SetupTriggerPopup {
    // virtual ~GJRotateCommandLayer();

    static GJRotateCommandLayer* create(EffectGameObject* object, cocos2d::CCArray* objects) = imac 0x14c0, m1 0x1504;

    virtual void determineStartValues() = imac 0x3f70, m1 0x3d60;
    virtual void onClose(cocos2d::CCObject* sender) = m1 0x4a10, imac 0x4f60;
    virtual void textChanged(CCTextInputNode* node) = m1 0x45cc, imac 0x49c0;
    virtual void valuePopupClosed(ConfigureValuePopup* popup, float value) = m1 0x41e0, imac 0x4530;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects);
    void onEasing(cocos2d::CCObject* sender);
    void onEasingRate(cocos2d::CCObject* sender);
    void onFollowRotation(cocos2d::CCObject* sender) = imac 0x37d0, m1 0x35a0;
    void onLockRotation(cocos2d::CCObject* sender) = m1 0x18ab60;
    void onUpdateGroupID(cocos2d::CCObject* sender) = imac 0x38c0, m1 0x366c;
    void onUpdateGroupID2(cocos2d::CCObject* sender) = imac 0x3980, m1 0x3728;
    void sliderChanged(cocos2d::CCObject* sender) = m1 0x2e4c;
    void sliderDegreesChanged(cocos2d::CCObject* sender) = m1 0x33ec;
    void sliderTimesChanged(cocos2d::CCObject* sender) = m1 0x348c;
    void toggleEasingRateVisibility();
    void updateCommandDegrees() = m1 0x445c;
    void updateCommandTimes() = m1 0x43ec;
    void updateDegreesLabel() = imac 0x3c70;
    void updateDuration() = m1 0x437c;
    void updateDurLabel(bool decimals) = m1 0x2edc;
    void updateEasingLabel() = m1 0x3c70;
    void updateEasingRateLabel();
    void updateMoveCommandEasing();
    void updateMoveCommandEasingRate();
    void updateTargetGroupID();
    void updateTargetGroupID2();
    void updateTextInputLabel();
    void updateTextInputLabel2();
    void updateTimesLabel();

    CCTextInputNode* m_moveTimeInput;
    Slider* m_moveTimeSlider;
    float m_moveTime;
    cocos2d::CCLabelBMFont* m_rotateEasingLabel;
    EasingType m_rotateEasingType;
    float m_rotateEasingRate;
    CCMenuItemSpriteExtra* m_rotateEasingRateButton;
    cocos2d::CCLabelBMFont* m_rotateEasingRateLabel;
    CCTextInputNode* m_degreesInput;
    CCTextInputNode* m_timesInput;
    Slider* m_degreesSlider;
    Slider* m_timesSlider;
    float m_degrees;
    int m_times360;
    CCTextInputNode* m_targetIDInput;
    bool m_disableTextChanged;
    int m_targetGroupID;
    CCTextInputNode* m_centerIDInput;
    int m_centerGroupID;
    bool m_lockObjectRotation;
    bool m_followP1;
    bool m_followP2;
    CCMenuItemToggler* m_followP1Toggler;
    CCMenuItemToggler* m_followP2Toggler;
}

[[link(android)]]
class GJRotationControl : cocos2d::CCLayer {
    // virtual ~GJRotationControl();
    GJRotationControl() {
        m_controlSprite = nullptr;
        m_startingRotation = 0.0f;
        m_currentRotation = 0.0f;
        m_touchID = -1;
        m_delegate = nullptr;
    }

    static GJRotationControl* create() = win inline, m1 0xa364 {
        auto ret = new GJRotationControl();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x1295d0, m1 0x46798, imac 0x51920;
    virtual void draw() = win 0x129a30, imac 0x51f20, m1 0x46d20;
    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x129770, imac 0x51b90, m1 0x469e8;
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x129870, m1 0x46ae8, imac 0x51cb0;
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x129a10, imac 0x51e10, m1 0x46c0c;
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x71260, imac 0x51ee0, m1 0x46d04;

    void finishTouch() = win 0x1296f0, imac 0x4e4a0;
    void setAngle(float angle) = win inline, imac 0x51a10, m1 0x46880 {
        m_startingRotation = angle;
        m_currentRotation = angle;
        m_controlPosition.x = cosf(-angle * (M_PI / 180.f)) * 60.f;
        m_controlPosition.y = sinf(-angle * (M_PI / 180.f)) * 60.f;
        m_controlSprite->setPosition(m_controlPosition);
    }
    void updateSliderPosition(cocos2d::CCPoint position) = win inline, imac 0x51a90, m1 0x468fc {
        auto angle = atan2f(position.y - m_cursorDifference.y, position.x - m_cursorDifference.x);
        m_controlPosition.x = cosf(angle) * 60.f;
        m_controlPosition.y = sinf(angle) * 60.f;
        m_controlSprite->setPosition(m_controlPosition);
        auto degrees = roundf(-(angle * (180.f / M_PI)) * 1000.f) / 1000.f;
        auto rotation = m_currentRotation;
        if (degrees != m_currentRotation) {
            m_currentRotation = degrees;
            if (m_delegate) m_delegate->angleChanged(degrees - rotation);
        }
    }

    cocos2d::CCPoint m_cursorDifference;
    cocos2d::CCPoint m_controlPosition;
    cocos2d::CCSprite* m_controlSprite;
    float m_startingRotation;
    float m_currentRotation;
    int m_touchID;
    GJRotationControlDelegate* m_delegate;
}

[[link(android)]]
class GJRotationControlDelegate {
    virtual void angleChanged(float angle) {}
    virtual void angleChangeBegin() {}
    virtual void angleChangeEnded() {}
}

[[link(android)]]
class GJScaleControl : cocos2d::CCLayer {
    // virtual ~GJScaleControl();
    GJScaleControl() {
        m_sliderX = nullptr;
        m_sliderY = nullptr;
        m_sliderXY = nullptr;
        m_touchID = -1;
        m_valueX = 0.0f;
        m_valueY = 0.0f;
        m_unkSize4 = 0;
        m_changedValueX = 0.0f;
        m_changedValueY = 0.0f;
        m_scale1Lock = false;
        m_scaleButtonType = 0;
        m_delegate = nullptr;
        m_upperBound = 2.0f;
        m_lowerBound = 0.5f;
        m_senderTag = 0;
        m_scaleLockButton = nullptr;
        m_scaleLocked = false;
    }

    static GJScaleControl* create() = win inline, imac 0xba00, m1 0xa4f0 {
        auto ret = new GJScaleControl();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x129ab0, m1 0x46d88, imac 0x51f90;
    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x12a5a0, m1 0x473c0, imac 0x52640;
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x12a7b0, imac 0x52820, m1 0x4754c;
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x12abd0, imac 0x52cd0, m1 0x47984;
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x71260, imac 0x52e30, m1 0x47abc;

    void finishTouch() = win inline, imac 0x3ee20, m1 0x37150, ios inline {
        if (m_touchID != -1) {
            m_touchID = -1;
            if (m_delegate) m_delegate->scaleChangeEnded();
        }
    }
    void loadValues(GameObject* object, cocos2d::CCArray* objects, gd::unordered_map<int, GameObjectEditorState>& editorStates) = win 0x129f80, imac 0x3eff0;
    void onToggleLockScale(cocos2d::CCObject* sender) = m1 0x4716c;
    float scaleFromValue(float value) = win inline, imac 0x52570, m1 0x47344, ios inline {
        return cocos2d::CCString::createWithFormat("%.02f", (m_upperBound - m_lowerBound) * value + m_lowerBound)->floatValue();
    }
    float skewFromValue(float value) = win inline, imac 0x525b0, m1 0x47380, ios inline {
        return (m_upperBound - m_lowerBound) * value + m_lowerBound;
    }
    void sliderChanged(cocos2d::CCObject* sender) = m1 0x471dc;
    void updateLabelX(float value) = m1 0x4720c, win 0x12ad10;
    void updateLabelXY(float value) = m1 0x472dc, win 0x12ae10;
    void updateLabelY(float value) = m1 0x47274, win 0x12ad90;
    float valueFromScale(float scale) = win inline, ios inline {
        auto value = (scale - m_lowerBound) / (m_upperBound - m_lowerBound);
        return value < 0 ? 0 : (value > 1 ? 1 : value);
    }
    float valueFromSkew(float value) = win inline, imac 0x52410, m1 0x471e4, ios inline {
        return std::clamp<float>((value - m_lowerBound) / (m_upperBound - m_lowerBound), 0.f, 1.f);
    }

    Slider* m_sliderX;
    Slider* m_sliderY;
    Slider* m_sliderXY;
    int m_touchID;
    float m_valueX;
    float m_valueY;
    int m_unkSize4;
    float m_changedValueX;
    float m_changedValueY;
    bool m_scale1Lock;
    short m_scaleButtonType;
    cocos2d::CCLabelBMFont* m_scaleXLabel;
    cocos2d::CCLabelBMFont* m_scaleYLabel;
    cocos2d::CCLabelBMFont* m_scaleLabel;
    GJScaleControlDelegate* m_delegate;
    float m_upperBound;
    float m_lowerBound;
    int m_senderTag;
    CCMenuItemSpriteExtra* m_scaleLockButton;
    bool m_scaleLocked;
}

[[link(android)]]
class GJScaleControlDelegate {
    virtual void scaleXChanged(float scaleX, bool lock) {}
    virtual void scaleYChanged(float scaleY, bool lock) {}
    virtual void scaleXYChanged(float scaleX, float scaleY, bool lock) {}
    virtual void scaleChangeBegin() {}
    virtual void scaleChangeEnded() {}
    virtual void updateScaleControl() {}
    virtual void anchorPointMoved(cocos2d::CCPoint newAnchor) {}
}

[[link(android)]]
class GJScoreCell : TableViewCell, FLAlertLayerProtocol {
    // virtual ~GJScoreCell();
    GJScoreCell(char const* identifier, float width, float height) = win inline, m1 0x1fb0c8, ios inline : TableViewCell(identifier, width, height) {
        this->init();
    }

    virtual bool init() = win 0xb46a0, imac 0x255380, m1 0x1fb114;
    virtual void draw() = win 0xade40, m1 0x1fb3b8, imac 0x255640;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0xb9bd0, imac 0x255580, m1 0x1fb2f0;

    void loadFromScore(GJUserScore* score) = win 0xb84b0;
    void onBan(cocos2d::CCObject* sender) = win inline, imac 0x255560, m1 0x1fb2e8, ios inline {}
    void onCheck(cocos2d::CCObject* sender) = win inline, imac 0x255570, m1 0x1fb2ec, ios inline {}
    void onMoreLevels(cocos2d::CCObject* sender) = win inline, imac 0x255610, m1 0x1fb390, ios inline {
        ProfilePage::create(m_score->m_accountID, false)->show();
    }
    void onViewProfile(cocos2d::CCObject* sender) = win 0xb9a50, imac 0x2553a0, m1 0x1fb120;
    void updateBGColor(int index) = win inline, imac 0x24bd90 {
        m_backgroundLayer->setColor(index % 2 == 0 ? cocos2d::ccColor3B { 161, 88, 44 } : cocos2d::ccColor3B { 194, 114, 62 });
        m_backgroundLayer->setOpacity(255);
    }

    GJUserScore* m_score;
}

[[link(android)]]
class GJSearchObject : cocos2d::CCNode {
    // virtual ~GJSearchObject();

    static GJSearchObject* create(SearchType searchType) = win 0x174740, imac 0x560780, m1 0x4afb80;
    static GJSearchObject* create(SearchType searchType, gd::string searchQuery) = win 0x174820, imac 0x5607f0, m1 0x4afbec;
    static GJSearchObject* create(SearchType searchType, gd::string searchQuery, gd::string difficulty, gd::string length, int page, bool star, bool uncompleted, bool featured, int songID, bool original, bool twoPlayer, bool customSong, bool songFilter, bool noStar, bool coins, bool epic, bool legendary, bool mythic, bool onlyCompleted, int demonFilter, int folder, int searchMode) = win 0x174950, imac 0x141ae0, m1 0x4af8d8;
    static GJSearchObject* createFromKey(char const* key) = win 0x174040, imac 0x1181b0, m1 0x48b7e4;
    static char const* getSearchKey(SearchType searchType, gd::string searchQuery, gd::string difficulty, gd::string length, int page, bool star, bool uncompleted, bool featured, int songID, bool original, bool twoPlayer, bool customSong, bool songFilter, bool noStar, bool coins, bool epic, bool legendary, bool mythic, bool onlyCompleted, int demonFilter, int folder, int searchMode) = win 0x174f50, m1 0x4afe14;

    char const* getKey() = win 0x174c90;
    char const* getNextPageKey() = win inline {
        return this->getSearchKey(m_searchType, m_searchQuery, m_difficulty, m_length, m_page + 1, m_starFilter, m_uncompletedFilter, m_featuredFilter, m_songID, m_originalFilter, m_twoPlayerFilter, m_customSongFilter, m_songFilter, m_noStarFilter, m_coinsFilter, m_epicFilter, m_legendaryFilter, m_mythicFilter, m_completedFilter, (int)m_demonFilter, m_folder, m_searchMode);
    }
    GJSearchObject* getNextPageObject() = win inline, imac 0x560f40, m1 0x4b017c {
        return this->getPageObject(m_page + 1);
    }
    GJSearchObject* getPageObject(int page) = win 0x174de0, m1 0x4b0188;
    GJSearchObject* getPrevPageObject() = win inline, imac 0x561220, m1 0x4b037c {
        return this->getPageObject(std::max(m_page - 1, 0));
    }
    bool init(SearchType searchType, gd::string searchQuery, gd::string difficulty, gd::string length, int page, bool star, bool uncompleted, bool featured, int songID, bool original, bool twoPlayer, bool customSong, bool songFilter, bool noStar, bool coins, bool epic, bool legendary, bool mythic, bool onlyCompleted, int demonFilter, int folder, int searchMode) = win inline, m1 0x4afcd4 {
        m_searchType = searchType;
        m_searchQuery = searchQuery;
        m_difficulty = difficulty;
        m_length = length;
        m_page = page;
        m_starFilter = star;
        m_uncompletedFilter = uncompleted;
        m_featuredFilter = featured;
        m_songID = songID;
        m_originalFilter = original;
        m_twoPlayerFilter = twoPlayer;
        m_customSongFilter = customSong;
        m_songFilter = songFilter;
        m_noStarFilter = noStar;
        m_coinsFilter = coins;
        m_epicFilter = epic;
        m_mythicFilter = mythic;
        m_legendaryFilter = legendary;
        m_completedFilter = onlyCompleted;
        m_demonFilter = (GJDifficulty)demonFilter;
        m_folder = folder;
        m_searchMode = searchMode;
        return true;
    }
    bool isLevelSearchObject() = win 0x175230, imac 0x561240, m1 0x4b0390;

    SearchType m_searchType;
    gd::string m_searchQuery;
    gd::string m_difficulty;
    gd::string m_length;
    int m_page;
    bool m_starFilter;
    bool m_noStarFilter;
    int m_total;
    bool m_uncompletedFilter;
    bool m_completedFilter;
    bool m_featuredFilter;
    bool m_originalFilter;
    bool m_twoPlayerFilter;
    bool m_coinsFilter;
    bool m_epicFilter;
    bool m_legendaryFilter;
    bool m_mythicFilter;
    GJDifficulty m_demonFilter;
    int m_folder;
    int m_songID;
    bool m_customSongFilter;
    bool m_songFilter;
    bool m_searchIsOverlay;
    int m_searchMode;
}

[[link(android), depends(GJValueTween)]]
class GJShaderState {
    GJShaderState() = imac 0xcaa40, m1 0xb25ac {
        m_time = 0.0;
        m_prevTime = -1.0;
        m_textureScaleX = 1.f;
        m_textureScaleY = 1.f;
        m_blurRefChannel = 0;
        m_shockWaveStartTime = 0.f;
        m_shockWaveSpeed = 0.f;
        m_shockLineStartTime = 0.0;
        m_shockLineTargetID = 0;
        m_shockLineTarget = false;
        m_glitchStrength = 0.f;
        m_chromaticTargetX = 0.f;
        m_chromaticTargetY = 0.f;
        m_cGRGBOffset = 0.f;
        m_cGStrength = 0.f;
        m_cGSegmentHeight = 1.f;
        m_cGLineThickness = 0.f;
        m_cGLineStrength = 0.f;
        m_cGEnable = false;
        m_cGActive = false;
        m_pixelateTargetX = 1.f;
        m_pixelateTargetY = 1.f;
        m_pixelateSnapGrid = false;
        m_pixelatePixelating = false;
        m_lensCircleSize = 1.f;
        m_lensCircleFade = 0.f;
        m_lensCircleStrength = 0.f;
        m_lensCircleTargetID = 0;
        m_lensCircleTintChannel = 0;
        m_lensCircleRelative = false;
        m_lensCircleAdditive = false;
        m_radialBlurSize = 0.f;
        m_radialBlurFade = 0.f;
        m_motionBlurTargetX = 0.f;
        m_motionBlurTargetY = 0.f;
        m_motionBlurSpeedX = 0.f;
        m_motionBlurSpeedY = 0.f;
        m_motionBlurFollowEaseX = 1.f;
        m_motionBlurFollowEaseY = 1.f;
        m_motionBlurTargetIDX = 0;
        m_motionBlurTargetIDY = 0;
        m_motionBlurDual = false;
        m_bulgeValue = 0.f;
        m_bulgeRelative = false;
        m_bulgeTargetID = 0;
        m_bulgeRadius = 0.f;
        m_pinchTargetX = 0.f;
        m_pinchTargetY = 0.f;
        m_pinchTargetEnabledX = false;
        m_pinchTargetEnabledY = false;
        m_pinchTargetIDX = 0;
        m_pinchTargetIDY = 0;
        m_pinchRadius = 0.f;
        m_grayscaleValue = 0.f;
        m_grayscaleTintChannel = 0;
        m_sepiaValue = 0.f;
        m_invertColorEditRGB = 0.f;
        m_invertColorR = 1.f;
        m_invertColorG = 1.f;
        m_invertColorB = 1.f;
        m_invertColorClampRGB = false;
        m_hueShiftDegrees = 0.f;
        m_colorChangeCR = 1.f;
        m_colorChangeCG = 1.f;
        m_colorChangeCB = 1.f;
        m_colorChangeBR = 0.f;
        m_colorChangeBG = 0.f;
        m_colorChangeBB = 0.f;
        m_splitTargetRows = 0.f;
        m_splitTargetCols = 0.f;
        m_splitActive = false;
        m_minBlendingLayer = 0;
        m_maxBlendingLayer = 0;
        m_zLayerDirty = false;
        m_noPlayerParticles = false;
        m_usesShaders = false;
    }

    void reset() = win inline, imac 0x3c9d70 {
        m_cGSegmentHeight = 1.f;
        m_shockWaveStartTime = 0.f;
        m_shockLineStartTime = 0.0;
        m_glitchStrength = 0.f;
        m_chromaticTargetX = 0.f;
        m_chromaticTargetY = 0.f;
        m_blurIntensity = 0.f;
        m_cGEnable = false;
        m_cGSpeed = 0.f;
        m_cGRGBOffset = 0.f;
        m_cGStrength = 0.f;
        m_cGLineThickness = 0.f;
        m_cGLineStrength = 0.f;
        m_pixelateTargetX = 0.f;
        m_pixelateTargetY = 0.f;
        m_pixelateSnapGrid = false;
        m_lensCircleStrength = 0.f;
        m_lensCircleTargetID = 0;
        m_lensCircleTintChannel = 0;
        m_radialBlurSize = 0.f;
        m_motionBlurTargetX = 0.f;
        m_motionBlurTargetY = 0.f;
        m_motionBlurTargetIDX = 0;
        m_motionBlurTargetIDY = 0;
        m_motionBlurSpeedX = 0.f;
        m_motionBlurSpeedY = 0.f;
        m_textureScaleX = 1.f;
        m_textureScaleY = 1.f;
        m_lensCircleSize = 1.f;
        m_lensCircleFade = 0.f;
        m_radialBlurCenter.x = 0.f;
        m_radialBlurCenter.y = 0.f;
        m_bulgeValue = 0.f;
        m_pinchTargetX = 0.f;
        m_pinchTargetY = 0.f;
        m_pinchTargetIDX = 0;
        m_pinchTargetIDY = 0;
        m_pinchTargetEnabledX = false;
        m_pinchTargetEnabledY = false;
        m_pinchScreenOffset.x = 0.f;
        m_pinchScreenOffset.y = 0.f;
        m_grayscaleValue = 0.f;
        m_prevTime = -1.f;
        m_sepiaValue = 0.f;
        m_invertColorEditRGB = 0.f;
        m_hueShiftDegrees = 0.f;
        m_invertColorR = 1.f;
        m_invertColorG = 1.f;
        m_invertColorB = 1.f;
        m_colorChangeCR = 1.f;
        m_colorChangeCG = 1.f;
        m_colorChangeCB = 1.f;
        m_colorChangeBR = 0.f;
        m_colorChangeBG = 0.f;
        m_colorChangeBB = 0.f;
        m_invertColorClampRGB = false;
        m_splitTargetRows = 0.f;
        m_splitTargetCols = 0.f;
        m_zLayerDirty = false;
        m_noPlayerParticles = false;
        m_minBlendingLayer = 0;
        m_maxBlendingLayer = 0;
    }
    void stopTweenAction(int action) = win inline, imac 0x3c9690, m1 0x34abb8, ios inline {
        m_tweenActions.erase(action);
    }
    void timesyncShaderAction(int action) = win 0x481830, imac 0x3c9b80;
    void timesyncShaderActions() = win inline, imac 0x3c9b40, m1 0x34aed0 {
        for (auto& pair : m_tweenTimes) {
            this->timesyncShaderAction(pair.first);
        }
    }
    void tweenValue(float fromValue, float toValue, int action, float duration, int easingType, float easingRate) = win inline, imac 0x3c95a0, m1 0x34aad0 {
        this->stopTweenAction(action);
        if (duration <= 0.f) {
            this->updateTweenAction(toValue, action);
            return;
        }
        GJValueTween tween;
        tween.m_easingRate = easingRate;
        tween.m_duration = duration;
        tween.m_deltaTime = 0.f;
        tween.m_currentValue = 0.f;
        tween.m_finished = false;
        tween.m_disabled = false;
        tween.m_easingType = easingType;
        tween.m_uniqueID = -1;
        tween.m_controlID = -1;
        tween.m_fromValue = fromValue;
        tween.m_toValue = toValue;
        m_tweenActions.emplace(action, tween);
        m_tweenTimes[action] = m_time;
    }
    void updateTweenAction(float value, int actionID) = win 0x481470, m1 0x34abdc;
    void updateTweenActions(float tweenValue) = win inline, imac 0x3c9aa0, m1 0x34ae30 {
        for (auto it = m_tweenActions.begin(); it != m_tweenActions.end();) {
            it->second.step(tweenValue);
            this->updateTweenAction(it->second.m_currentValue, it->first);
            if (it->second.m_finished) it = m_tweenActions.erase(it);
            else ++it;
        }
    }

    gd::unordered_map<int, GJValueTween> m_tweenActions;
    gd::unordered_map<int, double> m_tweenTimes;
    double m_time;
    double m_prevTime;
    double m_startTime;
    float m_textureScaleX;
    float m_textureScaleY;
    cocos2d::ccColor3B m_blurRefColor;
    float m_blurIntensity;
    int m_blurRefChannel;
    bool m_blurOnlyEmpty;
    float m_shockWaveStartTime;
    float m_shockWaveTime;
    float m_shockWaveTimeOffset;
    float m_shockWaveSpeed;
    float m_shockWaveThickness;
    float m_shockWaveStrength;
    float m_shockWaveWidth;
    float m_shockWaveFadeIn;
    float m_shockWaveFadeOut;
    bool m_shockWaveInvert;
    float m_shockWaveInner;
    float m_shockWaveOuter;
    int m_shockWaveTargetID;
    bool m_shockWaveTarget;
    bool m_shockWaveCenterMoving;
    bool m_shockWaveRelative;
    float m_shockWaveMaxSize;
    cocos2d::CCPoint m_shockWaveScreenOffset;
    bool m_shockWaveCenterDirty;
    cocos2d::CCPoint m_shockWaveCenter;
    double m_shockLineStartTime;
    float m_shockLineTime;
    float m_shockLineTimeOffset;
    float m_shockLineSpeed;
    bool m_shockLineAxis;
    bool m_shockLineDirection;
    bool m_shockLineDual;
    bool m_shockLineInvert;
    float m_shockLineScreenOffset;
    float m_shockLineStrength;
    float m_shockLineWidth;
    float m_shockLineFadeIn;
    float m_shockLineFadeOut;
    float m_shockLineThickness;
    int m_shockLineTargetID;
    bool m_shockLineTarget;
    bool m_shockLineCenterMoving;
    bool m_shockLineRelative;
    float m_shockLineMaxSize;
    cocos2d::CCPoint m_shockLineScreenOffset2;
    bool m_shockLineCenterDirty;
    cocos2d::CCPoint m_shockLineCenter;
    float m_glitchStrength;
    float m_glitchSpeed;
    float m_glitchSliceHeight;
    float m_glitchMaxSliceXOff;
    float m_glitchMaxColXOff;
    float m_glitchMaxColYOff;
    bool m_glitchRelative;
    float m_chromaticTargetX;
    float m_chromaticTargetY;
    bool m_chromaticRelative;
    float m_cGStartTime;
    float m_cGTime;
    float m_cGSpeed;
    float m_cGRGBOffset;
    float m_cGStrength;
    float m_cGSegmentHeight;
    float m_cGLineThickness;
    float m_cGLineStrength;
    bool m_cGEnable;
    bool m_cGActive;
    bool m_cGRelative;
    bool m_cGRelativePos;
    float m_pixelateTargetX;
    float m_pixelateTargetY;
    bool m_pixelateSnapGrid;
    bool m_pixelatePixelating;
    bool m_pixelateRelative;
    bool m_pixelateHardEdges;
    float m_lensCircleSize;
    float m_lensCircleFade;
    float m_lensCircleStrength;
    int m_lensCircleTargetID;
    int m_lensCircleTintChannel;
    bool m_lensCircleRelative;
    bool m_lensCircleAdditive;
    cocos2d::ccColor3B m_lensCircleTint;
    cocos2d::CCPoint m_lensCircleCenter;
    cocos2d::CCPoint m_lensCircleScreenOffset;
    float m_radialBlurSize;
    float m_radialBlurFade;
    bool m_radialBlurTarget;
    int m_radialBlurTargetID;
    cocos2d::CCPoint m_radialBlurCenter;
    cocos2d::CCPoint m_radialBlurScreenOffset;
    float m_motionBlurTargetX;
    float m_motionBlurTargetY;
    float m_motionBlurSpeedX;
    float m_motionBlurSpeedY;
    float m_motionBlurFollowEaseX;
    float m_motionBlurFollowEaseY;
    int m_motionBlurTargetIDX;
    int m_motionBlurTargetIDY;
    bool m_motionBlurDual;
    bool m_motionBlurRelative;
    float m_bulgeValue;
    bool m_bulgeRelative;
    int m_bulgeTargetID;
    float m_bulgeRadius;
    cocos2d::CCPoint m_bulgeCenter;
    cocos2d::CCPoint m_bulgeScreenOffset;
    float m_pinchTargetX;
    float m_pinchTargetY;
    bool m_pinchTargetEnabledX;
    bool m_pinchTargetEnabledY;
    int m_pinchTargetIDX;
    int m_pinchTargetIDY;
    cocos2d::CCPoint m_pinchCenter;
    cocos2d::CCPoint m_pinchScreenOffset;
    bool m_pinchRelative;
    float m_pinchRadius;
    cocos2d::CCPoint m_pinchModifier;
    float m_grayscaleValue;
    bool m_grayscaleUseLum;
    int m_grayscaleTintChannel;
    cocos2d::ccColor3B m_grayscaleTint;
    float m_sepiaValue;
    float m_invertColorEditRGB;
    float m_invertColorR;
    float m_invertColorG;
    float m_invertColorB;
    bool m_invertColorClampRGB;
    float m_hueShiftDegrees;
    float m_colorChangeCR;
    float m_colorChangeCG;
    float m_colorChangeCB;
    float m_colorChangeBR;
    float m_colorChangeBG;
    float m_colorChangeBB;
    float m_splitTargetRows;
    float m_splitTargetCols;
    bool m_splitActive;
    int m_minBlendingLayer;
    int m_maxBlendingLayer;
    bool m_zLayerDirty;
    bool m_noPlayerParticles;
    bool m_usesShaders;
}

[[link(android)]]
class GJShopLayer : cocos2d::CCLayer, GJPurchaseDelegate, DialogDelegate, RewardedVideoDelegate {
    GJShopLayer() {
        m_closing = false;
        m_currencyLabel = nullptr;
        m_shopItems = nullptr;
        m_type = ShopType::Normal;
        m_unkNode1 = nullptr;
        m_unkNode2 = nullptr;
        m_videoPlaying = false;
        m_unkBool = false;
        m_shopKeeper = nullptr;
        m_zolgurothDialogIndex = 0;
        m_affordDialogIndex = 0;
    }
    ~GJShopLayer() = win inline, m1 0x2b025c {
        cocos2d::CCDirector::sharedDirector()->getTouchDispatcher()->unregisterForcePrio(this);
        auto gm = GameManager::sharedState();
        if (gm->m_rewardedVideoDelegate == this) gm->m_rewardedVideoDelegate = nullptr;
        CC_SAFE_RELEASE(m_shopItems);
    }

    static GJShopLayer* create(ShopType type) = win inline, imac 0x322a90, m1 0x2b0468 {
        auto ret = new GJShopLayer();
        if (ret->init(type)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static cocos2d::CCScene* scene(ShopType type) = win 0x2a9410, m1 0x2b0364;

    virtual void onExit() = win 0x2ab680, m1 0x2b211c, imac 0x324800;
    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x2ae7b0, imac 0x326dd0, m1 0x2b4280;
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline, m1 0x2b4630, imac 0x327160 {}
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline, m1 0x2b4638, imac 0x327180 {}
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x71260, m1 0x2b4640, imac 0x3271a0;
    virtual void registerWithTouchDispatcher() = win 0x42660, m1 0x2b465c, imac 0x3271e0;
    virtual void keyBackClicked() = win 0x2acdf0, imac 0x3257f0, m1 0x2b2fd4;
    virtual void didPurchaseItem(GJStoreItem* item) = win 0x2ac3f0, m1 0x2b2968, imac 0x3250f0;
    virtual void rewardedVideoFinished() = win 0x2aba40, imac 0x324b10, m1 0x2b23f4;
    virtual void dialogClosed(DialogLayer* layer) = win 0x2ae480, imac 0x326c10, m1 0x2b409c;

    void exitVideoAdItems() = imac 0x324a40, m1 0x2b232c;
    bool init(ShopType type) = win 0x2a9590;
    void onBack(cocos2d::CCObject* sender) = win 0x2acbd0;
    void onCommunityCredits(cocos2d::CCObject* sender) = win 0x2ab900;
    void onPlushies(cocos2d::CCObject* sender) = win inline {}
    void onSelectItem(cocos2d::CCObject* sender) = win 0x2abb10, imac 0x3246f0;
    void onVideoAd(cocos2d::CCObject* sender) = imac 0x3244e0;
    void showCantAffordMessage(GJStoreItem* item);
    void showReactMessage() = win 0x2ace00, imac 0x325820, m1 0x2b2fe0;
    void updateCurrencyCounter() = m1 0x2b2450;

    bool m_closing;
    CCCounterLabel* m_currencyLabel;
    cocos2d::CCDictionary* m_shopItems;
    ShopType m_type;
    gd::string m_sheetName;
    cocos2d::CCNode* m_unkNode1;
    cocos2d::CCNode* m_unkNode2;
    bool m_videoPlaying;
    bool m_unkBool;
    AnimatedShopKeeper* m_shopKeeper;
    int m_zolgurothDialogIndex;
    int m_affordDialogIndex;
}

[[link(android), depends(SmartPrefabResult)]]
class GJSmartBlockPreview : cocos2d::CCNode {
    // virtual ~GJSmartBlockPreview();

    static GJSmartBlockPreview* create(gd::string key) = win 0x2b5830, imac 0x428290, m1 0x39ac50;

    void addChance(int count, int total) = win 0x2b65d0, imac 0x2b6710, m1 0x39b9e8;
    void addCount(int count) = win inline, imac 0x428ef0, m1 0x39b910 {
        this->createInfoLabel();
        m_infoLabel->setPosition({ 90.f, 90.f });
        m_infoLabel->setString(cocos2d::CCString::createWithFormat("%i", count)->getCString());
        m_infoLabel->limitLabelWidth(20.f, .6f, .0f);
    }
    void addPreview(gd::string key, gd::string data, LevelEditorLayer* layer) = win 0x2b6450, imac 0x428d20, m1 0x39b730;
    cocos2d::CCArray* addTemplateGuide(SmartPrefabResult result, float opacity) = win 0x2b5c00, imac 0x428710, m1 0x39b10c;
    void addTemplateGuide(gd::string key, int type) = win 0x2b5970, imac 0x428410, m1 0x39ae00;
    void createInfoLabel() = win inline {
        if (m_infoLabel) return;
        m_infoLabel = cocos2d::CCLabelBMFont::create(" ", "bigFont.fnt");
        this->addChild(m_infoLabel);
    }
    bool init(gd::string key) = win inline {
        if (!cocos2d::CCNode::init()) return false;
        this->setContentSize({ 90.f, 90.f });
        m_prefabKey = key;
        return true;
    }
    void toggleSelectItem(bool selected) = win inline {
        if (m_selected == selected) return;
        m_selected = selected;
        if (!m_selectSprite) {
            m_selectSprite = cocos2d::CCSprite::createWithSpriteFrameName("GJ_select_001.png");
            this->addChild(m_selectSprite);
            m_selectSprite->setScale(2.8f);
            m_selectSprite->setPosition({ 45.f, 45.f });
        }
        m_selectSprite->setVisible(m_selected);
    }

    gd::string m_prefabKey;
    cocos2d::CCLabelBMFont* m_infoLabel;
    cocos2d::CCSprite* m_selectSprite;
    bool m_selected;
}

[[link(android)]]
class GJSmartBlockPreviewSprite : cocos2d::CCNode {
    // virtual ~GJSmartBlockPreviewSprite();
    GJSmartBlockPreviewSprite() {}

    static GJSmartBlockPreviewSprite* create() = win inline, m1 0x39b6ac {
        auto ret = new GJSmartBlockPreviewSprite();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x77e00, m1 0x39bc90, imac 0x4292a0;
    virtual void visit() = win 0x2b67d0, imac 0x4292b0, m1 0x39bc94;
}

[[link(android)]]
class GJSmartPrefab : cocos2d::CCObject {
    // virtual ~GJSmartPrefab();

    static GJSmartPrefab* create() = win 0x2b5750, imac 0x421d60, m1 0x395294;
    static GJSmartPrefab* createWithCoder(DS_Dictionary* dict) = win inline, imac 0x428040 {
        auto ret = GJSmartPrefab::create();
        ret->dataLoaded(dict);
        return ret;
    }

    virtual void encodeWithCoder(DS_Dictionary* dict) = win 0x2b57d0, imac 0x428180, m1 0x39ab1c;
    virtual bool canEncode() = win inline, imac 0x428030, m1 0x39a9d4 { return true; }

    void dataLoaded(DS_Dictionary* dict) = win inline, imac 0x428110 {
        m_prefabData = dict->getStringForKey("1");
        m_prefabChance = dict->getIntegerForKey("2");
    }
    bool init() = win inline, imac 0x428010, m1 0x39a9b8, ios inline {
        m_prefabID = (*reinterpret_cast<int*>(geode::base::get() + GEODE_WINDOWS(0x69c174) GEODE_IOS(0x83ef48)))++;
        return true;
    }

    gd::string m_prefabKey;
    gd::string m_prefabData;
    int m_prefabID;
    int m_prefabChance;
}

[[link(android), depends(SmartPrefabResult)]]
class GJSmartTemplate : cocos2d::CCObject {
    // virtual ~GJSmartTemplate();

    static void applyTransformationsForType(SmartBlockType type, cocos2d::CCSprite* sprite) = win 0x2b35a0, imac 0x426430;
    static GJSmartTemplate* create() = win 0x2b0800, imac 0x421a20, m1 0x394f88;
    static GJSmartTemplate* createWithCoder(DS_Dictionary* dict) = win inline, imac 0x427ab0, m1 0x39a42c {
        auto ret = GJSmartTemplate::create();
        ret->dataLoaded(dict);
        return ret;
    }
    static SmartBlockType flipBlockType(SmartBlockType type, bool flipX, bool flipY) = win 0x2b3ed0, m1 0x399270;
    static SmartBlockType flipBlockTypeX(SmartBlockType type) = win inline, m1 0x399228 {
        switch (type) {
            case SmartBlockType::NormalSlope1: return SmartBlockType::NormalSlope2;
            case SmartBlockType::NormalSlope2: return SmartBlockType::NormalSlope1;
            case SmartBlockType::NormalSlope3: return SmartBlockType::NormalSlope4;
            case SmartBlockType::NormalSlope4: return SmartBlockType::NormalSlope3;
            case SmartBlockType::WideSlope1: return SmartBlockType::WideSlope3;
            case SmartBlockType::WideSlope2: return SmartBlockType::WideSlope4;
            case SmartBlockType::WideSlope3: return SmartBlockType::WideSlope1;
            case SmartBlockType::WideSlope4: return SmartBlockType::WideSlope2;
            case SmartBlockType::WideSlope5: return SmartBlockType::WideSlope7;
            case SmartBlockType::WideSlope6: return SmartBlockType::WideSlope8;
            case SmartBlockType::WideSlope7: return SmartBlockType::WideSlope5;
            case SmartBlockType::WideSlope8: return SmartBlockType::WideSlope6;
            case SmartBlockType::WideSlope9: return SmartBlockType::WideSlope11;
            case SmartBlockType::WideSlope10: return SmartBlockType::WideSlope12;
            case SmartBlockType::WideSlope11: return SmartBlockType::WideSlope9;
            case SmartBlockType::WideSlope12: return SmartBlockType::WideSlope10;
            case SmartBlockType::WideSlope13: return SmartBlockType::WideSlope15;
            case SmartBlockType::WideSlope14: return SmartBlockType::WideSlope16;
            case SmartBlockType::WideSlope15: return SmartBlockType::WideSlope13;
            case SmartBlockType::WideSlope16: return SmartBlockType::WideSlope14;
            default: return type;
        }
    }
    static SmartBlockType flipBlockTypeY(SmartBlockType type) = win inline, m1 0x39924c {
        switch (type) {
            case SmartBlockType::NormalSlope1: return SmartBlockType::NormalSlope3;
            case SmartBlockType::NormalSlope2: return SmartBlockType::NormalSlope4;
            case SmartBlockType::NormalSlope3: return SmartBlockType::NormalSlope1;
            case SmartBlockType::NormalSlope4: return SmartBlockType::NormalSlope2;
            case SmartBlockType::WideSlope1: return SmartBlockType::WideSlope5;
            case SmartBlockType::WideSlope2: return SmartBlockType::WideSlope6;
            case SmartBlockType::WideSlope3: return SmartBlockType::WideSlope7;
            case SmartBlockType::WideSlope4: return SmartBlockType::WideSlope8;
            case SmartBlockType::WideSlope5: return SmartBlockType::WideSlope1;
            case SmartBlockType::WideSlope6: return SmartBlockType::WideSlope2;
            case SmartBlockType::WideSlope7: return SmartBlockType::WideSlope3;
            case SmartBlockType::WideSlope8: return SmartBlockType::WideSlope4;
            case SmartBlockType::WideSlope9: return SmartBlockType::WideSlope13;
            case SmartBlockType::WideSlope10: return SmartBlockType::WideSlope14;
            case SmartBlockType::WideSlope11: return SmartBlockType::WideSlope15;
            case SmartBlockType::WideSlope12: return SmartBlockType::WideSlope16;
            case SmartBlockType::WideSlope13: return SmartBlockType::WideSlope9;
            case SmartBlockType::WideSlope14: return SmartBlockType::WideSlope10;
            case SmartBlockType::WideSlope15: return SmartBlockType::WideSlope11;
            case SmartBlockType::WideSlope16: return SmartBlockType::WideSlope12;
            default: return type;
        }
    }
    static gd::string flipKey(gd::string key, bool flipX, bool flipY) = win 0x2b44e0, imac 0x425660;
    static cocos2d::CCDictionary* generateRemapDict() = imac 0x426980, m1 0x39950c;
    static gd::string getSimplifiedKey(gd::string key) = win 0x2b0f30;
    static SmartBlockType getSimplifiedType(SmartBlockType type, bool& changed) = win inline, m1 0x3967e4, ios inline {
        switch (type) {
            case SmartBlockType::NormalSlope1: case SmartBlockType::NormalSlope2:
            case SmartBlockType::NormalSlope3: case SmartBlockType::NormalSlope4:
            case SmartBlockType::WideSlope1: case SmartBlockType::WideSlope2:
            case SmartBlockType::WideSlope3: case SmartBlockType::WideSlope4:
            case SmartBlockType::WideSlope5: case SmartBlockType::WideSlope6:
            case SmartBlockType::WideSlope7: case SmartBlockType::WideSlope8:
            case SmartBlockType::WideSlope9: case SmartBlockType::WideSlope10:
            case SmartBlockType::WideSlope11: case SmartBlockType::WideSlope12:
            case SmartBlockType::WideSlope13: case SmartBlockType::WideSlope14:
            case SmartBlockType::WideSlope15: case SmartBlockType::WideSlope16:
                changed = true;
                return SmartBlockType::Block;
            default: return type;
        }
    }
    static gd::string getVerySimplifiedKey(gd::string key) = win 0x2b1710, imac 0x423250, m1 0x3965b0;
    static gd::string keyFromNeighbors(SmartBlockType type, SmartBlockType left, SmartBlockType right, SmartBlockType top, SmartBlockType bottom, SmartBlockType topLeft, SmartBlockType topRight, SmartBlockType bottomLeft, SmartBlockType bottomRight) = win inline, imac 0x423440, m1 0x396814 {
        std::string result;
        result += (char)type;
        result += (char)left;
        result += (char)right;
        result += (char)top;
        result += (char)bottom;
        result += (char)topLeft;
        result += (char)topRight;
        result += (char)bottomLeft;
        result += (char)bottomRight;
        return result;
    }
    static gd::string keyFromNeighbors(cocos2d::CCPoint position, SmartGameObject* object, SmartGameObject* left, SmartGameObject* right, SmartGameObject* top, SmartGameObject* bottom, SmartGameObject* topLeft, SmartGameObject* topRight, SmartGameObject* bottomLeft, SmartGameObject* bottomRight) = win 0x2b3970;
    static gd::string keyFromNeighborsOld(bool left, bool right, bool top, bool bottom, bool topLeft, bool topRight, bool bottomLeft, bool bottomRight) = win inline, imac 0x426710, m1 0x3992d4, ios inline {
        fmt::memory_buffer buffer;
        fmt::format_to(std::back_inserter(buffer), "{}{}{}{}{}{}{}{}{}", 1, (int)left, (int)right, (int)top, (int)bottom, (int)topLeft, (int)topRight, (int)bottomLeft, (int)bottomRight);
        return fmt::to_string(buffer);
    }
    static cocos2d::CCPoint offsetForDir(GJSmartDirection direction, int key) = win 0x2b33b0;
    static cocos2d::CCPoint offsetForObject(SmartGameObject* object) = win inline, imac 0x425f80, m1 0x398b30 {
        return object ? offsetForType(smartObjectToType(object, { 0.f, 0.f })) : cocos2d::CCPoint{ 0.f, 0.f };
    }
    static cocos2d::CCPoint offsetForType(SmartBlockType type) = win 0x2b34b0, imac 0x4262a0;
    static SmartBlockType rotateBlockType(SmartBlockType type, int degrees) = win 0x2b3d60, m1 0x3991d4, ios inline {
        if (type == SmartBlockType::Block || degrees == 0) return type;
        for (; degrees > 0; degrees -= 90) {
            type = rotateBlockType90(type);
        }
        return type;
    }
    static SmartBlockType rotateBlockType90(SmartBlockType type) = win inline, m1 0x3991a8 {
        switch (type) {
            case SmartBlockType::NormalSlope1: return SmartBlockType::NormalSlope2;
            case SmartBlockType::NormalSlope2: return SmartBlockType::NormalSlope4;
            case SmartBlockType::NormalSlope3: return SmartBlockType::NormalSlope1;
            case SmartBlockType::NormalSlope4: return SmartBlockType::NormalSlope3;
            case SmartBlockType::WideSlope1: return SmartBlockType::WideSlope11;
            case SmartBlockType::WideSlope2: return SmartBlockType::WideSlope12;
            case SmartBlockType::WideSlope3: return SmartBlockType::WideSlope15;
            case SmartBlockType::WideSlope4: return SmartBlockType::WideSlope16;
            case SmartBlockType::WideSlope5: return SmartBlockType::WideSlope9;
            case SmartBlockType::WideSlope6: return SmartBlockType::WideSlope10;
            case SmartBlockType::WideSlope7: return SmartBlockType::WideSlope13;
            case SmartBlockType::WideSlope8: return SmartBlockType::WideSlope14;
            case SmartBlockType::WideSlope9: return SmartBlockType::WideSlope3;
            case SmartBlockType::WideSlope10: return SmartBlockType::WideSlope4;
            case SmartBlockType::WideSlope11: return SmartBlockType::WideSlope7;
            case SmartBlockType::WideSlope12: return SmartBlockType::WideSlope8;
            case SmartBlockType::WideSlope13: return SmartBlockType::WideSlope1;
            case SmartBlockType::WideSlope14: return SmartBlockType::WideSlope2;
            case SmartBlockType::WideSlope15: return SmartBlockType::WideSlope5;
            case SmartBlockType::WideSlope16: return SmartBlockType::WideSlope6;
            default: return type;
        }
    }
    static gd::string rotateKey(gd::string key, int degrees) = win 0x2b4180, imac 0x424270;
    static bool shouldDiscardObject(SmartBlockType type, GJSmartDirection direction) = win inline {
        switch (type) {
            case SmartBlockType::WideSlope2: case SmartBlockType::WideSlope6:
                return direction == GJSmartDirection::Top ||
                    direction == GJSmartDirection::Bottom ||
                    direction == GJSmartDirection::TopRight ||
                    direction == GJSmartDirection::BottomRight;
            case SmartBlockType::WideSlope4: case SmartBlockType::WideSlope8:
                return direction == GJSmartDirection::Top ||
                    direction == GJSmartDirection::Bottom ||
                    direction == GJSmartDirection::TopLeft ||
                    direction == GJSmartDirection::BottomLeft;
            case SmartBlockType::WideSlope10: case SmartBlockType::WideSlope12:
                return direction == GJSmartDirection::Left ||
                    direction == GJSmartDirection::Right ||
                    direction == GJSmartDirection::BottomLeft ||
                    direction == GJSmartDirection::BottomRight;
            case SmartBlockType::WideSlope14: case SmartBlockType::WideSlope16:
                return direction == GJSmartDirection::Left ||
                    direction == GJSmartDirection::Right ||
                    direction == GJSmartDirection::TopLeft ||
                    direction == GJSmartDirection::TopRight;
            default:
                return false;
        }
    }
    static SmartBlockType smartObjectToType(SmartGameObject* object, cocos2d::CCPoint point) = win 0x2b36e0, imac 0x425fe0, m1 0x398b9c;
    static int smartTypeToObjectKey(SmartBlockType type) = win inline, m1 0x399184 {
        switch (type) {
            case SmartBlockType::NormalSlope1:
            case SmartBlockType::NormalSlope2:
            case SmartBlockType::NormalSlope3:
            case SmartBlockType::NormalSlope4:
                return 2896;
            case SmartBlockType::WideSlope1:
            case SmartBlockType::WideSlope2:
            case SmartBlockType::WideSlope3:
            case SmartBlockType::WideSlope4:
            case SmartBlockType::WideSlope5:
            case SmartBlockType::WideSlope6:
            case SmartBlockType::WideSlope7:
            case SmartBlockType::WideSlope8:
            case SmartBlockType::WideSlope9:
            case SmartBlockType::WideSlope10:
            case SmartBlockType::WideSlope11:
            case SmartBlockType::WideSlope12:
            case SmartBlockType::WideSlope13:
            case SmartBlockType::WideSlope14:
            case SmartBlockType::WideSlope15:
            case SmartBlockType::WideSlope16:
                return 2897;
            default:
                return 2895;
        }
    }

    virtual void encodeWithCoder(DS_Dictionary* dict) = win 0x2b5670, imac 0x427e80, m1 0x39a7c8;
    virtual bool canEncode() = win inline, imac 0x427aa0, m1 0x39a424 { return true; }

    void dataLoaded(DS_Dictionary* dict) = win 0x2b53a0, imac 0x293e70;
    gd::string getNoCornerKey(gd::string key) = win 0x2b1820, imac 0x423110, m1 0x396460;
    GJSmartPrefab* getPrefab(gd::string key, bool flipX, bool flipY) = win 0x2b2a00, imac 0x424ac0, m1 0x39784c;
    GJSmartPrefab* getPrefab(cocos2d::CCPoint position, SmartGameObject* object, SmartGameObject* left, SmartGameObject* right, SmartGameObject* top, SmartGameObject* bottom, SmartGameObject* topLeft, SmartGameObject* topRight, SmartGameObject* bottomLeft, SmartGameObject* bottomRight) = win inline, imac 0x425940, m1 0x3984b8, ios inline {
        return this->getPrefab(keyFromNeighbors(position, object, left, right, top, bottom, topLeft, topRight, bottomLeft, bottomRight), false, false);
    }
    cocos2d::CCArray* getPrefabs(gd::string key) = win inline, m1 0x3984b0 {
        return static_cast<cocos2d::CCArray*>(m_prefabArrays->objectForKey(key));
    }
    GJSmartPrefab* getPrefabWithID(gd::string key, int id) = win 0x2b32f0, imac 0x13d480, m1 0x398868;
    GJSmartPrefab* getRandomPrefab(gd::string key) = win 0x2b2890, imac 0x4240d0, m1 0x397274;
    void getTemplateState(gd::vector<SmartPrefabResult>& results) = win 0x2b4db0, m1 0x443160;
    int getTotalChanceForPrefab(gd::string key) = win 0x2b27d0, imac 0x425870;
    bool init() = win inline, m1 0x395010 {
        CC_SAFE_RELEASE(m_prefabArrays);
        m_prefabArrays = cocos2d::CCDictionary::create();
        m_prefabArrays->retain();
        m_remapDict1 = cocos2d::CCDictionary::create();
        m_remapDict1->retain();
        m_remapDict2 = cocos2d::CCDictionary::create();
        m_remapDict2->retain();
        m_remapDict3 = cocos2d::CCDictionary::create();
        m_remapDict3->retain();
        m_remapDict4 = cocos2d::CCDictionary::create();
        m_remapDict4->retain();
        m_remapDict5 = cocos2d::CCDictionary::create();
        m_remapDict5->retain();
        m_remapDict6 = cocos2d::CCDictionary::create();
        m_remapDict6->retain();
        return true;
    }
    bool isUnrequired(gd::string key) = win 0x2b4c10, imac 0x4272f0;
    gd::string logTemplateStatus(bool unused) = win 0x2b4810, imac 0x426e10, m1 0x399940;
    void removePrefab(gd::string prefabKey, int prefabID) = win inline, imac 0x425e00, m1 0x398908 {
        if (prefabID <= 0) return;
        auto prefabArray = static_cast<cocos2d::CCArray*>(m_prefabArrays->objectForKey(prefabKey));
        if (!prefabArray || prefabArray->count() == 0) return;
        for (int i = 0; i < prefabArray->count(); i++) {
            auto prefab = static_cast<GJSmartPrefab*>(prefabArray->objectAtIndex(i));
            if (prefab->m_prefabID == prefabID) {
                prefabArray->removeObjectAtIndex(i);
                break;
            }
        }
    }
    void resetScannedPrefabs() = win inline, imac 0x423500 {
        m_prefabResults.clear();
    }
    void savePrefab(gd::string key, gd::string data) = win inline, imac 0x180450 {
        m_unk0a8 = "";
        auto prefabArray = static_cast<cocos2d::CCArray*>(m_prefabArrays->objectForKey(key));
        if (!prefabArray) {
            prefabArray = cocos2d::CCArray::create();
            m_prefabArrays->setObject(prefabArray, key);
        }
        for (int i = 0; i < prefabArray->count(); i++) {
            if (static_cast<GJSmartPrefab*>(prefabArray->objectAtIndex(i))->m_prefabData == data) return;
        }
        auto prefab = GJSmartPrefab::create();
        prefab->m_prefabKey = key;
        prefab->m_prefabData = data;
        prefabArray->addObject(prefab);
        this->saveRemap(key);
    }
    void saveRemap(gd::string key) = win 0x2b0980, imac 0x421de0, m1 0x395310;
    void saveRemapToDict(gd::string key, gd::string remap, cocos2d::CCDictionary* dict) = win 0x2b0d50, imac 0x422f20, m1 0x396294;
    SmartPrefabResult scanForPrefab(gd::string key) = win 0x2b19a0;

    cocos2d::CCDictionary* m_prefabArrays;
    cocos2d::CCDictionary* m_remapDict1;
    cocos2d::CCDictionary* m_remapDict2;
    cocos2d::CCDictionary* m_remapDict3;
    cocos2d::CCDictionary* m_remapDict4;
    cocos2d::CCDictionary* m_remapDict5;
    cocos2d::CCDictionary* m_remapDict6;
    gd::map<gd::string, SmartPrefabResult> m_prefabResults;
    bool m_allowFlipX;
    bool m_allowFlipY;
    bool m_allowRotation;
    bool m_ignoreCorners;
    gd::string m_templateName;
    gd::string m_unk0a8;
    int m_nameIndex;
    int m_prefabIndex;
}

[[link(android)]]
class GJSongBrowser : GJDropDownLayer, FLAlertLayerProtocol, TableViewCellDelegate {
    // virtual ~GJSongBrowser();

    static GJSongBrowser* create() = win 0x2b6fd0, m1 0x526894;

    virtual bool init() = win 0x2b7150, m1 0x526b80, imac 0x5fe7b0;
    virtual void customSetup() = win 0x2b7250, m1 0x526e2c, imac 0x5fea80;
    virtual void exitLayer(cocos2d::CCObject* sender) = win 0x2b7190, m1 0x526df8, imac 0x5fea50;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x2b7990, imac 0x5ff000, m1 0x527354;
    virtual bool cellPerformedAction(TableViewCell* cell, int listType, CellAction action, cocos2d::CCNode* parent) = win 0x2b7a90, m1 0x527410, imac 0x5ff0e0;
    virtual int getSelectedCellIdx() = win 0x2b7ac0, imac 0x5ff150, m1 0x527470;

    void loadPage(int page) = win 0x2b75d0, imac 0x5fe7e0, m1 0x526bc0;
    void onDeleteAll(cocos2d::CCObject* sender) = imac 0x5fee10;
    void onNextPage(cocos2d::CCObject* sender) = win 0x2b7860, imac 0x5fedf0, m1 0x527148;
    void onPrevPage(cocos2d::CCObject* sender) = win 0x2b7870, imac 0x5fedd0, m1 0x52713c;
    void setupPageInfo(int itemCount, int pageStartIdx, int pageEndIdx) = win inline, m1 0x5272b8 {
        m_leftArrow->setVisible(pageStartIdx != 0);
        auto nextIndex = pageStartIdx + pageEndIdx;
        m_rightArrow->setVisible(itemCount > nextIndex);
        nextIndex = std::min(nextIndex, itemCount);
        m_countText->setString(cocos2d::CCString::createWithFormat("%i to %i of %i", pageStartIdx + 1, nextIndex, itemCount)->getCString());
    }
    void setupSongBrowser(cocos2d::CCArray* songs) = win inline, imac 0x5feee0 {
        m_listLayer->removeChildByTag(9, true);
        m_listView = CustomListView::create(songs, this, 220.f, 356.f, 0, BoomListType::CustomSong, 0.f);
        m_listView->setTag(9);
        m_listLayer->addChild(m_listView, 6);
    }

    int m_page;
    int m_songID;
    bool m_selected;
    CCMenuItemSpriteExtra* m_rightArrow;
    CCMenuItemSpriteExtra* m_leftArrow;
    cocos2d::CCLabelBMFont* m_countText;
    cocos2d::CCPoint m_unk298;
    cocos2d::CCArray* m_downloadedSongs;
    CustomListView* m_listView;
}

[[link(android)]]
class GJSpecialColorSelect : FLAlertLayer {
    // virtual ~GJSpecialColorSelect();

    static GJSpecialColorSelect* create(int id, GJSpecialColorSelectDelegate* delegate, ColorSelectType type) = win 0x2b7b90, imac 0x625960, m1 0x548f4c;
    static const char* textForColorIdx(int index) = win 0x2b88e0, m1 0x549a9c;

    virtual void keyBackClicked() = win 0x2b8890, imac 0x626750, m1 0x549ce4;

    ButtonSprite* getButtonByTag(int tag) = win inline, m1 0x549ba0, ios inline {
        for (int i = 0; i < m_buttonSprites->count(); i++) {
            auto sprite = static_cast<ButtonSprite*>(m_buttonSprites->objectAtIndex(i));
            if (sprite->getTag() == tag) return sprite;
        }
        return nullptr;
    }
    void highlightSelected(ButtonSprite* sprite) = win inline, imac 0x626690, m1 0x549c30 {
        for (int i = 0; i < m_buttonSprites->count(); i++) {
            auto sprite = static_cast<ButtonSprite*>(m_buttonSprites->objectAtIndex(i));
            sprite->updateBGImage(sprite->getTag() == 1008 ? "GJ_button_05.png" : "GJ_button_04.png");
        }
        if (sprite) sprite->updateBGImage("GJ_button_02.png");
    }
    bool init(int id, GJSpecialColorSelectDelegate* delegate, ColorSelectType type) = win 0x2b7ca0;
    void onClose(cocos2d::CCObject* sender) = win 0x2b8840, m1 0x549a40;
    void onSelectColor(cocos2d::CCObject* sender) = win 0x2b8760, imac 0x626530, m1 0x549ac4;

    GJSpecialColorSelectDelegate* m_delegate;
    int m_colorID;
    cocos2d::CCArray* m_buttonSprites;
}

[[link(android)]]
class GJSpecialColorSelectDelegate {
    virtual void colorSelectClosed(GJSpecialColorSelect* select, int id) {}
}

[[link(android)]]
class GJSpiderSprite : GJRobotSprite {
    // virtual ~GJSpiderSprite();

    static GJSpiderSprite* create(int frame) = win 0x2a7940, m1 0x508174;

    bool init(int frame) = win inline, imac 0x5dced0, m1 0x5082b0 {
        return GJRobotSprite::init(frame, "Spider");
    }
}

[[link(android)]]
class GJSpriteColor {
    GJSpriteColor() {
        m_colorID = 0;
        m_defaultColorID = 0;
        m_opacity = 1.f;
        m_baseOpacity = 1.f;
        m_hsv.h = 0.f;
        m_hsv.s = 1.f;
        m_hsv.v = 1.f;
        m_hsv.absoluteSaturation = false;
        m_hsv.absoluteBrightness = false;
        m_usesHSV = false;
        m_usesCustomBlend = false;
        m_customColor.r = 255;
        m_customColor.g = 255;
        m_customColor.b = 255;
    }

    int getColorMode() {
        return m_defaultColorID == m_colorID || m_colorID != 0 ? m_colorID : m_defaultColorID;
    }

    int m_colorID;
    int m_defaultColorID;
    float m_opacity;
    float m_baseOpacity;
    cocos2d::ccHSVValue m_hsv;
    bool m_usesHSV;
    bool m_usesCustomBlend;
    cocos2d::ccColor3B m_customColor;
}

[[link(android)]]
class GJStoreItem : cocos2d::CCNode {
    // virtual ~GJStoreItem();
    GJStoreItem() {
        m_index = 0;
        m_typeID = 0;
        m_unlockType = 0;
        m_price = 0;
        m_shopType = ShopType::Normal;
    }

    static GJStoreItem* create(int index, int typeID, int unlockType, int price, ShopType shopType) = win inline, imac 0x668f0, m1 0x58774 {
        auto ret = new GJStoreItem();
        if (ret->init(index, typeID, unlockType, price, shopType)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    gd::string getCurrencyKey() = win inline, imac 0x66cc0, m1 0x58b58 {
        return m_shopType == ShopType::Diamond ? "29" : "14";
    }
    bool init(int index, int typeID, int unlockType, int price, ShopType shopType) = win inline, m1 0x811c8 {
        if (!CCNode::init()) return false;
        m_index = index;
        m_typeID = typeID;
        m_unlockType = unlockType;
        m_price = price;
        m_shopType = shopType;
        return true;
    }

    geode::SeedValueRSV m_index;
    geode::SeedValueRSV m_typeID;
    geode::SeedValueRSV m_unlockType;
    geode::SeedValueRSV m_price;
    ShopType m_shopType;
}

[[link(android)]]
class GJTransformControl : cocos2d::CCLayer {
    GJTransformControl() = m1 0x49404 {
        m_objects = nullptr;
        m_touchID = -1;
        m_transformButtonType = 0;
        m_delegate = nullptr;
        m_warpSprites = nullptr;
        m_warpLockButton = nullptr;
        m_scaleX = 1.0f;
        m_scaleY = 1.0f;
        m_warpLocked = false;
        m_rotationX = 0.0f;
        m_rotationY = 0.0f;
        m_rotation = 0.0f;
        m_buttonScale = 1.0f;
    }
    ~GJTransformControl() = win inline {
        CC_SAFE_RELEASE(m_warpSprites);
        CC_SAFE_RELEASE(m_objects);
    }

    static GJTransformControl* create() = win inline, imac 0xbbd0, m1 0xa66c {
        auto ret = new GJTransformControl();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x12ae90, m1 0x47cf0, imac 0x53180;
    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x12c520, imac 0x53630, m1 0x48170;
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x12c6f0, imac 0x53ab0, m1 0x4855c;
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x12cc50, imac 0x54030, m1 0x48a90;
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x71260, imac 0x54240, m1 0x48c68;

    void applyRotation(float rotation) = win inline, imac 0x40da0, m1 0x38cec {
        if (m_rotationY != rotation) {
            m_rotationY = rotation;
            m_mainNode->setRotation(rotation);
            if (m_delegate) m_delegate->transformRotationChanged(rotation);
        }
        this->updateButtons(false, false);
    }
    void calculateRotationOffset() = win inline, imac 0x535e0, m1 0x48124, ios inline {
        m_rotation = (-(atan2f(m_rotatePosition.y, m_rotatePosition.x) * (180.f / M_PI)) * 100.f) / 100.f;
    }
    void finishTouch() = win inline, imac 0x40450, m1 0x38484, ios inline {
        if (m_touchID != -1) {
            m_touchID = -1;
            if (m_delegate) m_delegate->transformChangeEnded();
        }
    }
    void loadFromState(GJTransformState& state) = win inline, imac 0x53520, m1 0x48078 {
        m_rotationX = state.m_transformRotationX;
        m_rotationY = state.m_transformRotationY;
        m_scaleX = state.m_transformScaleX;
        m_scaleY = state.m_transformScaleY;
        m_mainNode->setRotation(m_rotationY);
        this->setPosition(state.m_transformPosition);
        this->spriteByTag(1)->setPosition({ 0.f, 0.f });
        this->spriteByTag(10)->setPosition(state.m_transformSkewX);
        this->spriteByTag(11)->setPosition(state.m_transformSkewY);
    }
    void loadValues(GameObject* object, cocos2d::CCArray* objects, gd::unordered_map<int, GameObjectEditorState>& states) = win inline, imac 0x40c20 {
        if (object && !objects || objects->count() == 0) objects = cocos2d::CCArray::createWithObject(object);
        CC_SAFE_RELEASE(m_objects);
        m_objects = objects;
        objects->retain();
        if (objects->count() != 0) {
            for (int i = 0; i < objects->count(); i++) {
                auto obj = static_cast<GameObject*>(objects->objectAtIndex(i));
                obj->updateStartPos();
                states[obj->m_uniqueID].loadValues(obj);
            }
        }
        this->updateButtons(true, false);
    }
    void logCurrentZeroPos() = win inline, m1 0x48c84, ios inline {}
    void onToggleLockScale(cocos2d::CCObject* sender) = m1 0x47ffc;
    void refreshControl() = win 0x12b3e0, m1 0x40c54;
    void saveToState(GJTransformState& state) = win inline, imac 0x40e60, m1 0x38d70 {
        state.m_transformScaleX = m_scaleX;
        state.m_transformScaleY = m_scaleY;
        state.m_transformRotationX = m_rotationX;
        state.m_transformRotationY = m_rotationY;
        state.m_transformPosition = this->spriteByTag(1)->getPosition();
        state.m_transformSkewX = this->spriteByTag(10)->getPosition();
        state.m_transformSkewY = this->spriteByTag(11)->getPosition();
    }
    void scaleButtons(float scale) = win 0x12b600, imac 0x3dce0, m1 0x35fb8;
    cocos2d::CCSprite* spriteByTag(int tag) = win inline, m1 0x4806c, ios inline {
        return static_cast<cocos2d::CCSprite*>(m_warpSprites->objectAtIndex(tag - 1));
    }
    void updateAnchorSprite(cocos2d::CCPoint position) = win inline, imac 0x40400, m1 0x3842c {
        this->spriteByTag(0)->setPosition(position);
        if (m_delegate) m_delegate->updateTransformControl();
    }
    void updateButtons(bool transform, bool skew) = win 0x12b6c0, m1 0x41208;
    void updateMinMaxPositions() = win inline, m1 0x48c88, ios inline {
        auto topRightPosition = this->spriteByTag(7)->getPosition();
        auto bottomLeftPosition = this->spriteByTag(8)->getPosition();
        if (m_transformButtonType == 10) {
            auto divisor = m_topRightPosition.x / m_topRight.x;
            m_topRight.x = topRightPosition.x / divisor;
            m_bottomLeft.x = bottomLeftPosition.x / divisor;
        }
        else if (m_transformButtonType == 11) {
            auto divisor = m_bottomLeftPosition.y / m_bottomLeft.y;
            m_topRight.y = topRightPosition.y / divisor;
            m_bottomLeft.y = bottomLeftPosition.y / divisor;
        }
    }

    cocos2d::CCNode* m_mainNodeParent;
    cocos2d::CCNode* m_mainNode;
    cocos2d::CCArray* m_objects;
    int m_touchID;
    short m_transformButtonType;
    GJTransformControlDelegate* m_delegate;
    cocos2d::CCPoint m_cursorDifference;
    cocos2d::CCPoint m_topRight;
    cocos2d::CCPoint m_bottomLeft;
    cocos2d::CCPoint m_topRightPosition;
    cocos2d::CCPoint m_bottomLeftPosition;
    cocos2d::CCPoint m_topRightOrigin;
    cocos2d::CCPoint m_bottomLeftOrigin;
    cocos2d::CCArray* m_warpSprites;
    cocos2d::CCPoint m_rotatePosition;
    CCMenuItemSpriteExtra* m_warpLockButton;
    float m_scaleX;
    float m_scaleY;
    bool m_warpLocked;
    float m_rotationX;
    float m_rotationY;
    float m_rotation;
    float m_buttonScale;
}

[[link(android)]]
class GJTransformControlDelegate {
    virtual void transformScaleXChanged(float scaleX) {}
    virtual void transformScaleYChanged(float scaleY) {}
    virtual void transformScaleXYChanged(float scaleX, float scaleY) {}
    virtual void transformRotationXChanged(float rotationX) {}
    virtual void transformRotationYChanged(float rotationY) {}
    virtual void transformRotationChanged(float rotation) {}
    virtual void transformResetRotation() {}
    virtual void transformRestoreRotation() {}
    virtual void transformSkewXChanged(float skewX) {}
    virtual void transformSkewYChanged(float skewY) {}
    virtual void transformChangeBegin() {}
    virtual void transformChangeEnded() {}
    virtual void updateTransformControl() {}
    virtual void anchorPointMoved(cocos2d::CCPoint anchorPoint) {}
    virtual cocos2d::CCNode* getTransformNode() { return nullptr; }
    virtual EditorUI* getUI() { return nullptr; }
}

[[link(android)]]
class GJUINode : cocos2d::CCNode {
    // virtual ~GJUINode();

    static GJUINode* create(UIButtonConfig& config) = win 0x4ce6d0, imac 0x4c7df0;

    virtual void draw() = win 0x4cf210, m1 0x429f1c, imac 0x4cb120;

    int activeRangeTouchTest(cocos2d::CCPoint position) = win inline, imac 0x4cafd0, m1 0x429dd0 {
        cocos2d::CCPoint rangePos = { m_firstSprite->getPosition().x, position.y + 40.f };
        auto xDiff = position.x - rangePos.x;
        int touchResult;
        if (m_deadzone <= std::abs(xDiff)) {
            auto radius = m_radius;
            rangePos.x = std::abs(xDiff) > radius ? position.x + radius : position.x - radius;
            touchResult = xDiff > 0.f ? 3 : 2;
        }
        else {
            touchResult = 0;
        }
        auto centerX = m_rect.size.width * .5f;
        auto reverseCenterX = -m_rect.size.width * .5f;
        if (std::min(rangePos.x, centerX) > reverseCenterX) rangePos.x = reverseCenterX;
        else rangePos.x = std::min(rangePos.x, centerX);
        auto centerY = 40.f + m_rect.size.height * .5f;
        auto reverseCenterY = 40.f - m_rect.size.height * .5f;
        if (std::min(rangePos.y, centerY) > reverseCenterY) rangePos.y = reverseCenterY;
        else rangePos.y = std::min(rangePos.y, centerY);
        m_firstSprite->setVisible(true);
        m_firstSprite->setPosition(rangePos);
        return touchResult;
    }
    int activeTouchTest(cocos2d::CCPoint position) = win 0x4ceee0;
    float getButtonScale() = win inline, imac 0x4cad60 {
        return m_firstSprite->getScale();
    }
    uint8_t getOpacity() = win inline {
        return m_firstSprite->getOpacity();
    }
    void highlightButton(int button) = win inline {
        if (m_modeB) return;
        this->toggleHighlight(button, true);
        this->toggleHighlight(button == 2 ? 3 : 2, false);
    }
    bool init(UIButtonConfig& config) = win 0x4ce7b0, m1 0x429380;
    void loadFromConfig(UIButtonConfig& config) = win inline, imac 0x4c82c0, m1 0x427414 {
        this->updateSize(config.m_width, config.m_height);
        this->updateDragRadius(config.m_radius);
        this->updateDeadzone(config.m_deadzone);
        this->toggleModeB(config.m_modeB);
        m_snap = config.m_snap;
        this->updateButtonScale(config.m_scale);
        this->setOpacity(config.m_opacity);
        m_oneButton = config.m_oneButton;
        m_split = config.m_split;
        this->updateButtonFrames();
        if (config.m_player2) {
            this->setPosition({ cocos2d::CCDirector::sharedDirector()->getWinSize().width - config.m_position.x, config.m_position.y });
        }
        else {
            this->setPosition(config.m_position);
        }
    }
    void resetState() = win inline, imac 0x4c8730, m1 0x427824 {
        m_touchID = -1;
        m_swiping = false;
        m_moving = false;
        this->toggleHighlight(2, false);
        this->toggleHighlight(3, false);
    }
    void saveToConfig(UIButtonConfig& config) = win 0x4cea60, imac 0x4cacb0, m1 0x114954;
    void setOpacity(unsigned char opacity) = win inline, imac 0x4cac70, m1 0x429ad0 {
        m_firstSprite->setOpacity(opacity);
        if (m_secondSprite) m_secondSprite->setOpacity(opacity);
    }
    void toggleHighlight(int button, bool highlight) = win 0x4cf180, ios inline {
        if (m_modeB) {
            if (m_firstSprite) m_firstSprite->setColor({ 255, 255, 255 });
        }
        else {
            auto sprite = button == 3 ? m_secondSprite : m_firstSprite;
            if (sprite) sprite->setColor(highlight ? cocos2d::ccColor3B { 150, 150, 150 } : cocos2d::ccColor3B { 255, 255, 255 });
        }
    }
    void toggleModeB(bool modeB) = win inline {
        if (m_secondSprite) {
            m_modeB = modeB;
            m_firstSprite->setVisible(!modeB);
            m_secondSprite->setVisible(!m_modeB);
            this->updateButtonFrames();
        }
    }
    void touchEnded() = win 0x4cf0c0, imac 0x4c9fd0, m1 0x428fe8;
    int touchTest(cocos2d::CCPoint position) = win 0x4cedd0, m1 0x428cf0;
    void updateButtonFrames() = win 0x4ceb10;
    void updateButtonPositions() = win 0x4cecd0;
    void updateButtonScale(float scale) = win inline, imac 0x4cab40, m1 0x4299a0 {
        if (scale < .1f) scale = .1f;
        m_firstSprite->setScale(scale);
        if (m_secondSprite) m_secondSprite->setScale(scale);
        this->updateButtonPositions();
    }
    void updateDeadzone(int deadzone) = win inline, imac 0x4caa20, ios inline {
        m_deadzone = deadzone;
    }
    void updateDragRadius(float radius) = win inline {
        if (radius < 0.f) radius = 0.f;
        m_radius = radius;
        this->updateButtonPositions();
    }
    void updateHeight(float height) = win 0x4cec60, imac 0x4caed0;
    void updateRangePos(cocos2d::CCPoint position) = win inline, imac 0x4caf40, m1 0x429d48 {
        m_firstSprite->setPosition(position + cocos2d::CCPoint { 0.f, 40.f });
        m_firstSprite->setVisible(true);
        m_swiping = true;
    }
    void updateSize(float width, float height) = win inline, imac 0x4ca7f0, m1 0x42968c {
        if (width < 10.f) width = 10.f;
        if (height < 10.f) height = 10.f;
        m_rect.origin.x = width * -.5f;
        m_rect.origin.y = height * -.5f;
        m_rect.size.width = width;
        m_rect.size.height = height;
    }
    void updateWidth(float width) = win 0x4cebf0, imac 0x4cae60;

    cocos2d::CCSprite* m_firstSprite;
    cocos2d::CCSprite* m_secondSprite;
    cocos2d::CCRect m_rect;
    int m_touchID;
    cocos2d::CCPoint m_touchDelta;
    cocos2d::CCPoint m_touchPosition;
    float m_radius;
    float m_deadzone;
    bool m_drawLines;
    bool m_modeB;
    bool m_snap;
    bool m_swiping;
    bool m_moving;
    bool m_player2;
    bool m_oneButton;
    bool m_split;
    PlayerButton m_currentButton;
}

[[link(android)]]
class GJUnlockableItem : cocos2d::CCObject {
    // virtual ~GJUnlockableItem();
    GJUnlockableItem() {}

    static GJUnlockableItem* create() = win inline, imac 0x66370, m1 0x58230 {
        auto ret = new GJUnlockableItem();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init() = win inline, ios inline {
        return true;
    }
}

[[link(android)]]
class GJUserCell : TableViewCell, FLAlertLayerProtocol, UploadPopupDelegate, UploadActionDelegate {
    GJUserCell(char const* identifier, float width, float height) = win inline, m1 0x1fb98c, ios inline : TableViewCell(identifier, width, height) {
        this->init();
    }
    ~GJUserCell() = win inline, m1 0x1fb70c {
        if (m_uploadPopup) m_uploadPopup->m_delegate = nullptr;
        CC_SAFE_RELEASE(m_userScore);
    }

    virtual bool init() = win 0xbac60, imac 0x255fc0, m1 0x1fb9ec;
    virtual void draw() = win 0xade40, m1 0x1fc154, imac 0x256720;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0xbbb90, imac 0x2567f0, m1 0x1fc200;
    virtual void uploadActionFinished(int id, int response) = win 0xbbf50, m1 0x1fc448, imac 0x256aa0;
    virtual void uploadActionFailed(int id, int response) = win 0xbc100, m1 0x1fc654, imac 0x256ca0;
    virtual void onClosePopup(UploadActionPopup* popup) = win 0xbc1d0, m1 0x1fc7bc, imac 0x256e10;

    void loadFromScore(GJUserScore* score) = win 0xbac80, imac 0x24b5f0, m1 0x1f2228;
    void onCancelFriendRequest(cocos2d::CCObject* sender) = win 0xbb770;
    void onRemoveFriend(cocos2d::CCObject* sender) = win 0xbb910;
    void onSendMessage(cocos2d::CCObject* sender);
    void onUnblockUser(cocos2d::CCObject* sender) = win 0xbb560;
    void onViewFriendRequest(cocos2d::CCObject* sender) = win inline, m1 0x1fc0b0, ios inline {
        if (!m_userScore || m_userScore->m_accountID <= 0) return;
        if (auto request = GameLevelManager::sharedState()->friendRequestFromAccountID(m_userScore->m_accountID)) {
            if (m_userScore->m_newFriendRequest) {
                if (auto child = m_mainLayer->getChildByTag(100)) child->setVisible(false);
                m_userScore->m_newFriendRequest = false;
            }
            FriendRequestPopup::create(request)->show();
        }
    }
    void onViewProfile(cocos2d::CCObject* sender);
    void updateBGColor(int index) = win inline, imac 0x24b590, m1 0x1f21a8 {
        m_backgroundLayer->setColor(index % 2 == 0 ? cocos2d::ccColor3B { 161, 88, 44 } : cocos2d::ccColor3B { 194, 114, 62 });
        m_backgroundLayer->setOpacity(255);
    }

    GJUserScore* m_userScore;
    UploadActionPopup* m_uploadPopup;
}

[[link(android)]]
class GJUserMessage : cocos2d::CCNode {
    // virtual ~GJUserMessage();
    GJUserMessage() {
        m_messageID = 0;
        m_accountID = 0;
        m_userID = 0;
        m_read = false;
        m_outgoing = false;
        m_toggled = false;
    }

    static GJUserMessage* create() = win 0x173f10, imac 0x560220, m1 0x4af6bc;
    static GJUserMessage* create(cocos2d::CCDictionary* dict) = win 0x1733d0, imac 0x54d3d0, m1 0x49d9fc;

    virtual bool init() = win 0x77e00, m1 0x4af758, imac 0x5602c0;

    int m_messageID;
    int m_accountID;
    int m_userID;
    gd::string m_title;
    gd::string m_content;
    gd::string m_username;
    gd::string m_uploadDate;
    bool m_read;
    bool m_outgoing;
    bool m_toggled;
}

[[link(android)]]
class GJUserScore : cocos2d::CCNode {
    GJUserScore() = win 0x142140 {
        m_scoreType = 0;
        m_userID = 0;
        m_accountID = 0;
        m_stars = 0;
        m_moons = 0;
        m_diamonds = 0;
        m_demons = 0;
        m_playerRank = 0;
        m_creatorPoints = 0;
        m_secretCoins = 0;
        m_iconID = 0;
        m_color1 = 0;
        m_color2 = 0;
        m_special = 0;
        m_iconType = IconType::Cube;
        m_messageState = 0;
        m_friendStatus = 0;
        m_commentHistoryStatus = 0;
        m_glowEnabled = false;
        m_modBadge = 0;
        m_globalRank = 0;
        m_friendReqStatus = 0;
        m_newMsgCount = 0;
        m_friendReqCount = 0;
        m_newFriendCount = 0;
        m_newFriendRequest = false;
        m_toggled = false;
        m_playerCube = 1;
        m_playerShip = 1;
        m_playerBall = 1;
        m_playerUfo = 1;
        m_playerWave = 1;
        m_playerRobot = 1;
        m_playerSpider = 1;
        m_playerSwing = 1;
        m_playerStreak = 1;
        m_unkInt = 0;
        m_unkInt2 = 0;
        m_levelMode = 0;
        m_leaderboardMode = LevelLeaderboardMode::Time;
        m_unk390 = 0;
    }

    // virtual ~GJUserScore();
    static GJUserScore* create() = win inline {
        auto ret = new GJUserScore();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }

        delete ret;
        return nullptr;
    }
    static GJUserScore* create(cocos2d::CCDictionary* dict);

    virtual bool init() = win 0x172b90, m1 0x4af1bc, imac 0x55fd10;

    bool isCurrentUser() = win 0x172be0, m1 0x4af230;
    void mergeWithScore(GJUserScore* score) = win inline, imac 0x55fd60, m1 0x4af204, ios inline {
        m_stars = std::max(m_stars, score->m_stars);
        m_moons = std::max(m_moons, score->m_moons);
        m_diamonds = std::max(m_diamonds, score->m_diamonds);
        m_demons = std::max(m_demons, score->m_demons);
        m_creatorPoints = std::max(m_creatorPoints, score->m_creatorPoints);
        m_secretCoins = std::max(m_secretCoins, score->m_secretCoins);
    }

    gd::string m_userName;
    gd::string m_userUDID;
    int m_scoreType;
    int m_userID;
    int m_accountID;
    int m_stars;
    int m_moons;
    int m_diamonds;
    int m_demons;
    int m_playerRank;
    int m_creatorPoints;
    int m_secretCoins;
    int m_userCoins;
    int m_iconID;
    int m_color1;
    int m_color2;
    int m_color3;
    int m_special;
    IconType m_iconType;
    int m_messageState;
    int m_friendStatus;
    int m_commentHistoryStatus;
    gd::string m_youtubeURL;
    gd::string m_twitterURL;
    gd::string m_twitchURL;
    gd::string m_discordUsername;
    gd::string m_instagramURL;
    gd::string m_tiktokURL;
    gd::string m_customString;
    int m_playerCube;
    int m_playerShip;
    int m_playerBall;
    int m_playerUfo;
    int m_playerWave;
    int m_playerRobot;
    int m_playerSpider;
    int m_playerSwing;
    int m_playerJetpack;
    int m_playerStreak;
    bool m_glowEnabled;
    int m_playerExplosion;
    int m_modBadge;
    int m_globalRank;
    int m_friendReqStatus;
    int m_newMsgCount;
    int m_friendReqCount;
    int m_newFriendCount;
    bool m_newFriendRequest;
    bool m_toggled;
    gd::string m_unkString;
    int m_unkInt;
    int m_unkInt2;
    gd::string m_demonInfo;
    gd::string m_starsInfo;
    gd::string m_platformerInfo;
    int m_levelMode;
    LevelLeaderboardMode m_leaderboardMode;
    int m_unk390;
}

[[link(android)]]
class GJValueTween {
    void step(float delta) = win 0x205350;

    float m_fromValue;
    float m_toValue;
    float m_duration;
    float m_deltaTime;
    float m_currentValue;
    int m_easingType;
    float m_easingRate;
    bool m_finished;
    bool m_disabled;
    int m_uniqueID;
    int m_controlID;
}

[[link(android)]]
class GJWorldNode : cocos2d::CCNode {
    // virtual ~GJWorldNode();

    static GJWorldNode* create(int type, WorldSelectLayer* layer) = imac 0x3c31e0, m1 0x3449e8;

    float addDotsToLevel(int levelID, bool animate) = imac 0x3c43e0, m1 0x345bb8;
    cocos2d::CCPoint dotPositionForLevel(int levelID, int index) = imac 0x3c4a30;
    bool init(int type, WorldSelectLayer* layer) = imac 0x3c3930;
    void onLevel(cocos2d::CCObject* sender) = imac 0x3c4360;
    void playStep1() = imac 0x3c47a0;
    void playStep2();
    void playStep3();
    cocos2d::CCPoint positionForLevelButton(int levelID) = imac 0x3c4240;
    void unlockActiveItem() = imac 0x3c2b80;

    cocos2d::CCArray* m_activeObjects;
    CCMenuItemSpriteExtra* m_activeButton;
    GJGameLevel* m_level;
    WorldSelectLayer* m_selectLayer;
    bool m_unlocked;
    cocos2d::CCPoint m_levelPosition;
    cocos2d::ccColor3B m_particleColor;
    int m_islandType;
    bool m_islandUnlocked;
    cocos2d::CCSprite* m_arrowSprite;
}

[[link(android)]]
class GJWriteMessagePopup : FLAlertLayer, TextInputDelegate, UploadMessageDelegate, UploadPopupDelegate, FLAlertLayerProtocol {
    // virtual ~GJWriteMessagePopup();

    static GJWriteMessagePopup* create(int accountID, int messageID) = win 0x298f10, imac 0x2a7e10, m1 0x2469b4;

    virtual void registerWithTouchDispatcher() = win 0x42660, m1 0x2488c4, imac 0x2a9f00;
    virtual void keyBackClicked() = win 0x29a590, imac 0x2a9ed0, m1 0x2488b0;
    virtual void textInputOpened(CCTextInputNode* node) = win inline, imac 0x2a9f80, m1 0x248918 {}
    virtual void textInputClosed(CCTextInputNode* node) = win 0x8b870, imac 0x2a9f40, m1 0x2488fc;
    virtual void textChanged(CCTextInputNode* node) = win 0x29a5a0, imac 0x2a9fa0, m1 0x248920;
    virtual void uploadMessageFinished(int accountID) = win 0x29ab80, m1 0x248f90, imac 0x2aa650;
    virtual void uploadMessageFailed(int accountID) = win 0x29ac00, imac 0x2aa710, m1 0x249070;
    virtual void onClosePopup(UploadActionPopup* popup) = win 0x29acb0, imac 0x2aa840, m1 0x2491b0;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x29ad50, imac 0x2aa990, m1 0x249344;
    virtual void textInputShouldOffset(CCTextInputNode* node, float yOffset) = win 0x7b620, m1 0x249464, imac 0x2aaa70;
    virtual void textInputReturn(CCTextInputNode* node) = win 0x7b680, m1 0x249534, imac 0x2aab30;

    void closeMessagePopup(bool fullExit) = win 0x29a3b0, imac 0x2a9d00, m1 0x2486f0;
    bool init(int accountID, int messageID) = win 0x2990a0;
    void onClearBody(cocos2d::CCObject* sender) = imac 0x2a9c10;
    void onClose(cocos2d::CCObject* sender) = m1 0x2481e4;
    void onSend(cocos2d::CCObject* sender) = win 0x299f40, imac 0x2a97d0, m1 0x2481ec;
    void updateBody(gd::string body);
    void updateCharCountLabel(int type) = win inline, imac 0x2aa530, m1 0x248e6c {
        cocos2d::CCLabelBMFont* label;
        int count;
        int maxCount;
        if (type == 0) {
            label = m_subjectCountLabel;
            count = m_subjectText.size();
            maxCount = 35;
        }
        else {
            label = m_messageCountLabel;
            count = m_messageText.size();
            maxCount = 200;
        }
        if (maxCount * .9f <= count) {
            label->setOpacity(255);
            label->setColor({ 255, 0, 0 });
        }
        else if (maxCount * .7f <= count) {
            label->setOpacity(255);
            label->setColor({ 255, 255, 255 });
        }
        else {
            label->setOpacity(100);
            label->setColor({ 255, 255, 255 });
        }
        label->setString(cocos2d::CCString::createWithFormat("%i", maxCount - count)->getCString());
    }
    void updateSubject(gd::string subject);
    void updateText(gd::string text, int type) = win 0x29a7f0, imac 0x25df30, m1 0x248c08;

    int m_unk298;
    int m_messageID;
    int m_accountID;
    CCTextInputNode* m_messageInput;
    CCTextInputNode* m_subjectInput;
    gd::string m_messageText;
    gd::string m_subjectText;
    cocos2d::CCLabelBMFont* m_messageCountLabel;
    cocos2d::CCLabelBMFont* m_subjectCountLabel;
    UploadActionPopup* m_uploadPopup;
    bool m_uploadSuccess;
}

[[link(android)]]
class GManager : cocos2d::CCNode {
    GManager() = win 0x51660 {
        m_setup = false;
        m_saved = false;
        m_quickSave = false;
    }

    virtual bool init() = win 0x6a810, imac 0x4aba80, m1 0x40e7d8;
    virtual void setup() = win 0x6a820, imac 0x4abaa0, m1 0x40e7e8;
    virtual void encodeDataTo(DS_Dictionary* dict) = win inline, imac 0x4abf80, m1 0x40ece4 {}
    virtual void dataLoaded(DS_Dictionary* dict) = win inline, m1 0x40f38c, imac 0x4ac610 {}
    virtual void firstLoad() = win inline, m1 0x40f390, imac 0x4ac620 {}

    gd::string getCompressedSaveString() = win 0x6a840, imac 0x4abb70, m1 0x40e884;
    gd::string getSaveString() = win inline, imac 0x4abae0, m1 0x40e800 {
        auto dict = new DS_Dictionary();
        this->encodeDataTo(dict);
        auto str = dict->saveRootSubDictToString();
        delete dict;
        return str;
    }
    void load() = win inline, imac 0x4abac0, m1 0x40e7f8, ios inline {
        this->loadDataFromFile(m_fileName);
    }
    void loadDataFromFile(gd::string const& filename) = win 0x6aae0, imac 0x15e4e0, m1 0x40ece8;
    void loadFromCompressedString(gd::string& str) = win 0x6a910, imac 0x4abc90, m1 0x40e9ac;
    void loadFromString(gd::string& str) = win inline, imac 0x4abbe0, m1 0x40e900 {
        auto dict = new DS_Dictionary();
        auto loaded = dict->loadRootSubDictFromString(str.c_str());
        str.clear();
        if (loaded) this->dataLoaded(dict);
        delete dict;
    }
    void save() = win 0x6a9f0;
    void saveData(DS_Dictionary* dict, gd::string filename) = win inline, imac 0x4abf10, m1 0x40ec58 {
        dict->saveRootSubDictToCompressedFile(filename.c_str());
    }
    void saveGMTo(gd::string filename) = win inline, imac 0x4abdb0, m1 0x40eaf4 {
        auto dict = new DS_Dictionary();
        this->encodeDataTo(dict);
        this->saveData(dict, filename);
        m_saved = false;
        delete dict;
    }
    bool tryLoadData(DS_Dictionary* dict, gd::string const& filename) = win inline, imac 0x4ac200, m1 0x40efa4 {
        return dict->loadRootSubDictFromCompressedFile(filename.c_str());
    }

    gd::string m_fileName;
    bool m_setup;
    bool m_saved;
    bool m_quickSave;
}

[[link(android)]]
class GooglePlayDelegate {
    virtual void googlePlaySignedIn() {}
}

[[link(android)]]
class GooglePlayManager : cocos2d::CCNode {
    // virtual ~GooglePlayManager();

    static GooglePlayManager* sharedState() = win 0x6aca0, imac 0x4778e0, m1 0x3de7f4;

    virtual bool init() = win inline, imac 0x477950, m1 0x3de860 { return true; }

    void googlePlaySignedIn() = win inline, imac 0x477960, m1 0x3de868, ios inline {
        if (m_delegate1) m_delegate1->googlePlaySignedIn();
        if (m_delegate2) m_delegate2->googlePlaySignedIn();
    }

    GooglePlayDelegate* m_delegate1;
    GooglePlayDelegate* m_delegate2;
}

[[link(android)]]
class GradientTriggerObject : EffectGameObject {
    // virtual ~GradientTriggerObject();
    GradientTriggerObject() {
        m_blendingLayer = 0;
        m_blendingMode = 0;
        m_gradientID = 0;
        m_upBottomLeftID = 0;
        m_downBottomRightID = 0;
        m_leftTopLeftID = 0;
        m_rightTopRightID = 0;
        m_vertexMode = false;
        m_disable = false;
        m_disableAll = false;
        m_previewOpacity = 1.f;
    }

    static GradientTriggerObject* create() = win inline, m1 0x15a9a0 {
        auto ret = new GradientTriggerObject();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x498eb0, m1 0x15aa7c, imac 0x19b0d0;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x499540, m1 0x15be28, imac 0x19ca80;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x498f30, m1 0x15aad0, imac 0x19b130;

    // property 202
    int m_blendingLayer;
    // property 174
    int m_blendingMode;
    // property 209
    int m_gradientID;
    // property 203
    int m_upBottomLeftID;
    // property 204
    int m_downBottomRightID;
    // property 205
    int m_leftTopLeftID;
    // property 206
    int m_rightTopRightID;
    // property 207
    bool m_vertexMode;
    // property 208
    bool m_disable;
    // property 508
    bool m_disableAll;
    // property 456
    float m_previewOpacity;
}

[[link(android)]]
class GraphicsReloadLayer : cocos2d::CCLayer {
    // virtual ~GraphicsReloadLayer();
    GraphicsReloadLayer() {}

    static GraphicsReloadLayer* create(cocos2d::TextureQuality quality, cocos2d::CCSize resolution, bool fullscreen, bool borderless, bool fix, bool changedResolution) = win inline, m1 0x6ab9d8, ios inline {
        auto ret = new GraphicsReloadLayer();
        if (ret->init(quality, resolution, fullscreen, borderless, fix, changedResolution)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static cocos2d::CCScene* scene(cocos2d::TextureQuality quality, cocos2d::CCSize resolution, bool fullscreen, bool borderless, bool fix, bool changedResolution) = win inline, imac 0x7a4800, m1 0x1e38f0, ios inline {
        auto scene = cocos2d::CCScene::create();
        AppDelegate::get()->m_runningScene = scene;
        auto layer = GraphicsReloadLayer::create(quality, resolution, fullscreen, borderless, fix, changedResolution);
        scene->addChild(layer);
        return scene;
    }

    bool init(cocos2d::TextureQuality quality, cocos2d::CCSize resolution, bool fullscreen, bool borderless, bool fix, bool changedResolution) = win inline, ios inline {
        if (!CCLayer::init()) return false;
        m_quality = quality;
        m_resolution = resolution;
        m_changedResolution = changedResolution;
        m_fullscreen = fullscreen;
        m_borderless = borderless;
        m_fix = fix;
        this->runAction(cocos2d::CCSequence::create(
            cocos2d::CCDelayTime::create(.1f),
            cocos2d::CCCallFunc::create(this, callfunc_selector(GraphicsReloadLayer::performReload)),
            nullptr
        ));
        return true;
    }
    void performReload() = win 0x37bf30, m1 0x6abbfc, ios inline {
        auto director = cocos2d::CCDirector::sharedDirector();
        director->replaceScene(cocos2d::CCScene::create());
        auto oldQuality = director->getLoadedTextureQuality();
        director->updateContentScale(m_quality);
        auto newQuality = director->getLoadedTextureQuality();
        auto gameManager = GameManager::sharedState();
        if (gameManager->getGameVariable("0025") == m_fullscreen) {
            gameManager->setGameVariable("0025", !m_fullscreen);
            gameManager->setGameVariable("0170", m_borderless);
            gameManager->setGameVariable("0175", m_fix);
            gameManager->switchScreenMode(m_fullscreen, m_borderless, m_fix, true);
        }
        else if (!m_fullscreen || m_borderless == gameManager->getGameVariable("0170") || m_fix == gameManager->getGameVariable("0175")) {
            gameManager->setGameVariable("0170", m_borderless);
            gameManager->setGameVariable("0175", m_fix);
            if (oldQuality == newQuality) gameManager->queueReloadMenu();
            else gameManager->reloadAll(false, false, false, false, true);
        }
        if (gameManager->getGameVariable("0115")) director->toggleShowFPS(1, "chatFont.fnt", { 0.f, 0.f });
    }

    cocos2d::TextureQuality m_quality;
    cocos2d::CCSize m_resolution;
    bool m_fullscreen;
    bool m_borderless;
    bool m_fix;
    bool m_changedResolution;
}

[[link(android)]]
class GravityEffectSprite : cocos2d::CCSprite {
    // virtual ~GravityEffectSprite();
    GravityEffectSprite() {}

    static GravityEffectSprite* create() = win inline, m1 0x9b938 {
        auto ret = new GravityEffectSprite();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x3baf50, m1 0xac4c0, imac 0xbfaf0;
    virtual void draw() = win inline, m1 0xac6c4, imac 0xbfd50 {}

    void updateSpritesColor(cocos2d::ccColor3B color) = win inline, imac 0xb9690, m1 0xa6de4 {
        if (auto gravityBatchNode = this->getChildByTag(1)) {
            auto children = gravityBatchNode->getChildren();
            for (int i = 0; i < children->count(); i++) {
                static_cast<cocos2d::CCSprite*>(children->objectAtIndex(i))->setColor(color);
            }
        }
    }
}

[[link(android), depends(KeyframeObject)]]
class GroupCommandObject2 {
    // ~GroupCommandObject2();
    GroupCommandObject2() = win 0x2574a0, imac 0x4ec580;

    // GroupCommandObject2(GroupCommandObject2 const&);
    void reset() = win 0x257510, imac 0x4ec750, m1 0x446c20;
    void resetDelta(bool intermediate) = win inline, imac 0x4ecf40, m1 0xacadc {
        m_oldDeltaX = m_deltaX;
        m_oldDeltaY = m_deltaY;
        m_oldDeltaX_3 = m_deltaX_3;
        m_oldDeltaY_3 = m_deltaY_3;
        m_deltaX = 0.0;
        m_deltaY = 0.0;
        m_currentRotateOrTransformDelta = 0.0;
        if (!intermediate) {
            m_deltaX_3 = 0.0;
            m_deltaY_3 = 0.0;
            m_Delta_3_Related = 0.0;
        }
    }
    void runFollowCommand(double xMod, double yMod, double duration) = win inline, imac 0x4ece90, m1 0x4471f4 {
        m_commandType = 2;
        m_followXMod = xMod;
        m_followYMod = yMod;
        m_duration = duration;
        if (xMod == 0.0 && yMod == 0.0) {
            m_finished = true;
            m_finishRelated = true;
        }
    }
    void runMoveCommand(cocos2d::CCPoint offset, double duration, int easingType, double easingRate, bool lockPlayerX, bool lockPlayerY, bool lockCameraX, bool lockCameraY, double moveModX, double moveModY) = win inline, m1 0x447034 {
        m_commandType = 0;
        m_moveOffset = offset;
        m_duration = duration;
        m_easingType = (EasingType)easingType;
        m_easingRate = easingRate;
        m_lockToPlayerX = lockPlayerX;
        m_lockToPlayerY = lockPlayerY;
        m_lockToCameraX = lockCameraX;
        m_lockToCameraY = lockCameraY;
        m_moveModX = moveModX != 0.0 ? moveModX : 1.0;
        m_moveModY = moveModY != 0.0 ? moveModY : 1.0;
        m_lockedInX = lockPlayerX || lockCameraX;
        m_lockedInY = lockPlayerY || lockCameraY;
        if (offset.x != 0.f || offset.y != 0.f || lockPlayerX || lockPlayerY || lockCameraX || lockCameraY) {
            if (offset.x != 0.f && !lockCameraX && !lockPlayerX) {
                m_actionType1 = 1;
                m_actionValue1 = offset.x;
            }
            if (offset.y != 0.f && !lockCameraY && !lockPlayerY) {
                if (m_actionType1 == 0) {
                    m_actionType1 = 2;
                    m_actionValue1 = offset.y;
                }
                else {
                    m_actionType2 = 2;
                    m_actionValue2 = offset.y;
                }
            }
        }
        else {
            m_finished = true;
            m_finishRelated = true;
        }
    }
    void runPlayerFollowCommand(double delay, double speed, int offset, double maxSpeed, double duration) = win inline, imac 0x4ecee0, m1 0x447224 {
        m_commandType = 3;
        m_followYDelay = delay;
        m_followYSpeed = std::clamp(speed, 0.0, 500.0);
        m_followYOffset = offset;
        m_followYMaxSpeed = maxSpeed;
        m_duration = duration;
        if (delay <= 0.0) {
            m_finished = true;
            m_finishRelated = true;
        }
    }
    void runRotateCommand(double offset, double duration, int easingType, double easingRate, bool lockRotation, int targetType) = win inline, imac 0x4ecde0, m1 0x447184 {
        m_commandType = 1;
        m_rotationOffset = offset;
        m_duration = duration;
        m_easingType = (EasingType)easingType;
        m_easingRate = easingRate;
        m_lockObjectRotation = lockRotation;
        m_targetPlayer = targetType;
        if (offset == 0.0) {
            m_finished = true;
            m_finishRelated = true;
        }
        else {
            m_actionType1 = 3;
            m_actionValue1 = offset;
        }
    }
    void runTransformCommand(double duration, int easingType, double easingRate) = win inline, imac 0x4ece50, m1 0x4471d4 {
        m_commandType = 4;
        m_duration = duration;
        m_easingType = (EasingType)easingType;
        m_easingRate = easingRate;
        m_actionType1 = 4;
        m_actionValue1 = 1.0;
    }
    void step(float dt) = win 0x257710;
    void stepTransformCommand(float dt, bool intermediate, bool skipStep) = win inline {
        if (!m_finishRelated) {
            if (!skipStep) this->step(dt);
            m_someInterpValue1RelatedZero = m_someInterpValue1RelatedOne;
            m_someInterpValue1RelatedOne += m_currentRotateOrTransformDelta;
            m_someInterpValue2RelatedZero = m_someInterpValue2RelatedOne;
            if (!intermediate) m_someInterpValue2RelatedOne = m_someInterpValue1RelatedOne;
        }
        m_someInterpValue1RelatedZero = m_someInterpValue1RelatedOne;
        m_someInterpValue2RelatedZero = m_someInterpValue2RelatedOne;
        m_someInterpValue2RelatedOne = m_someInterpValue1RelatedOne;
    }
    void updateAction(int type, float value) = win 0x2577e0, imac 0x4ec9a0, m1 0x446dd8;
    void updateEffectAction(float value, int type) = win inline {
        switch (type) {
            case 1:
                if (!m_lockedInX) {
                    m_currentXOffset = value;
                    m_deltaX += value;
                    m_deltaX_3 += value;
                }
                break;
            case 2:
                if (!m_lockedInY) {
                    m_currentYOffset = value;
                    m_deltaY += value;
                    m_deltaY_3 += value;
                }
                break;
            case 3:
            case 4:
                m_currentRotateOrTransformDelta += value - m_currentRotateOrTransformValue;
                m_currentRotateOrTransformValue = value;
                break;
        }
    }

    int m_groupCommandUniqueID;
    cocos2d::CCPoint m_moveOffset;
    EasingType m_easingType;
    double m_easingRate;
    double m_duration;
    double m_deltaTime;
    int m_targetGroupID;
    int m_centerGroupID;
    double m_currentXOffset;
    double m_currentYOffset;
    double m_deltaX;
    double m_deltaY;
    double m_oldDeltaX;
    double m_oldDeltaY;
    double m_lockedCurrentXOffset;
    double m_lockedCurrentYOffset;
    bool m_finished;
    bool m_disabled;
    bool m_finishRelated;
    bool m_lockToPlayerX;
    bool m_lockToPlayerY;
    bool m_lockToCameraX;
    bool m_lockToCameraY;
    bool m_lockedInX;
    bool m_lockedInY;
    double m_moveModX;
    double m_moveModY;
    double m_currentRotateOrTransformValue;
    double m_currentRotateOrTransformDelta;
    double m_someInterpValue1RelatedOne;
    double m_someInterpValue2RelatedOne;
    double m_rotationOffset;
    bool m_lockObjectRotation;
    int m_targetPlayer;
    double m_followXMod;
    double m_followYMod;
    int m_commandType;
    double m_someInterpValue1;
    double m_someInterpValue2;
    double m_keyframeRelated;
    double m_targetScaleX;
    double m_targetScaleY;
    double m_transformTriggerProperty450;
    double m_transformTriggerProperty451;
    double m_someInterpValue1RelatedZero;
    double m_someInterpValue2RelatedZero;
    bool m_onlyMove;
    bool m_transformRelatedFalse;
    bool m_relativeRotation;
    double m_someInterpValue1Related;
    double m_someInterpValue2Related;
    double m_followYSpeed;
    double m_followYDelay;
    int m_followYOffset;
    double m_followYMaxSpeed;
    int m_triggerUniqueID;
    int m_controlID;
    double m_deltaX_3;
    double m_deltaY_3;
    double m_oldDeltaX_3;
    double m_oldDeltaY_3;
    double m_Delta_3_Related;
    double m_unkDoubleMaybeUnused;
    int m_actionType1;
    int m_actionType2;
    double m_actionValue1;
    double m_actionValue2;
    bool m_someInterpValue1RelatedFalse;
    float m_deltaTimeInFloat;
    bool m_alreadyUpdated;
    bool m_doUpdate;
    gd::vector<KeyframeObject> m_keyframes;
    cocos2d::CCPoint m_splineRelated;
    GameObject* m_gameObject;
    float m_gameObjectRotation;
    gd::vector<int> m_remapKeys;
    bool m_someInterpValue2RelatedTrue;
    int m_unkInt204; // formerly m_unkFloat204
}

[[link(android)]]
class HardStreak : cocos2d::CCDrawNode {
    // virtual ~HardStreak();

    static HardStreak* create() = win 0x2b8ba0, m1 0x8d820;

    virtual bool init() = win 0x2b8c60, m1 0x8d8e8, imac 0x9ce40;

    void addPoint(cocos2d::CCPoint point) = win 0x2b9660, imac 0x9d8b0, m1 0x8e1bc;
    void clearAboveXPos(float x) = win inline {
        while (m_pointArray->count() > 1) {
            auto pointNode = static_cast<PointNode*>(m_pointArray->objectAtIndex(1));
            if (pointNode->m_point.x > x) m_pointArray->removeObjectAtIndex(0);
            else break;
        }
    }
    void clearBehindXPos(float x) = win inline {
        while (m_pointArray->count() > 1) {
            auto pointNode = static_cast<PointNode*>(m_pointArray->objectAtIndex(1));
            if (pointNode->m_point.x < x) m_pointArray->removeObjectAtIndex(0);
            else break;
        }
    }
    HardStreak* createDuplicate() = win inline {
        auto ret = HardStreak::create();
        ret->setBlendFunc(this->getBlendFunc());
        ret->m_currentPoint = m_currentPoint;
        ret->m_isSolid = m_isSolid;
        ret->m_waveSize = m_waveSize;
        ret->m_isSolid = m_isSolid;
        ret->m_isFlipped = m_isFlipped;
        ret->m_pulseSize = m_pulseSize;
        ret->setOpacity(this->getOpacity());
        ret->setColor(this->getColor());

        for (auto obj : geode::cocos::CCArrayExt<cocos2d::CCObject*, false>(m_pointArray)){
            auto nodePoint = static_cast<PointNode*>(obj);
            ret->addPoint(nodePoint->m_point);
        }

        return ret;
    }
    void firstSetup() = win inline, imac 0x9cf20, m1 0x8d9a8 {
        this->addPoint({ 0.f, 0.f });
        m_currentPoint.x = 10.f;
        m_currentPoint.y = 10.f;
        this->updateStroke(0.f);
        this->visit();
        this->reset();
    }
    double normalizeAngle(double angle) = win inline, imac 0x9dbd0, m1 0x8e4f8, ios inline {
        if (angle > 360.0) return angle - 360.0;
        if (angle < 0.0) return angle + 360.0;
        return angle;
    }
    cocos2d::CCPoint quadCornerOffset(cocos2d::CCPoint start, cocos2d::CCPoint end, float width) = win inline, imac 0x9d8f0, m1 0x8e1fc {
        if (width < 1.f) return { 0.f, 0.f };
        float angle = this->normalizeAngle(atan2f(end.y - start.y, end.x - start.x) * 180.f / M_PI + 90.f) * M_PI / 180.f;
        return { cosf(angle) * width * .5f, sinf(angle) * width * .5f };
    }
    void reset() = win inline, m1 0x8e198 {
        this->clear();
        m_pointArray->removeAllObjects();
    }
    void resumeStroke() = win inline, m1 0x8e150 {
        this->m_drawStreak = true;
        updateStroke(0.f);
    }
    void scheduleAutoUpdate() = win inline, imac 0x9cfd0, m1 0x8da44 {
        this->schedule(schedule_selector(HardStreak::updateStroke));
    }
    void stopStroke() = win 0x2b8d10, m1 0x8e15c;
    callback void updateStroke(float dt) = win 0x2b8d50;

    cocos2d::CCArray* m_pointArray;
    cocos2d::CCPoint m_currentPoint;
    float m_waveSize;
    float m_pulseSize;
    bool m_isSolid;
    bool m_isFlipped;
    bool m_drawStreak;
}

[[link(android)]]
class HSVLiveOverlay : FLAlertLayer, HSVWidgetDelegate {
    HSVLiveOverlay() {
        m_object = nullptr;
        m_objects = nullptr;
        m_controls = nullptr;
        m_unkArray = nullptr;
        m_delegate = nullptr;
        m_activeTab = -1;
        m_widget = nullptr;
        m_unkBool1 = false;
        m_unkBool2 = false;
        m_unkBool3 = false;
    }
    ~HSVLiveOverlay() = win inline, m1 0x20d850 {
        CCNode::removeAllChildrenWithCleanup(true);
        CC_SAFE_RELEASE(m_unkArray);
        CC_SAFE_RELEASE(m_controls);
        CC_SAFE_RELEASE(m_object);
        CC_SAFE_RELEASE(m_objects);
    }

    static HSVLiveOverlay* create(GameObject* object, cocos2d::CCArray* objects) = win inline, imac 0x26a3a0, m1 0x20d928 {
        auto ret = new HSVLiveOverlay();
        if (ret->init(object, objects)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyBackClicked() = win 0x2ba0e0, m1 0x20e13c, imac 0x26ac10;
    virtual void show() = win 0x8bb10, m1 0x20e1f4, imac 0x26acc0;
    virtual void hsvChanged(ConfigureHSVWidget* widget) = win 0x2ba130, imac 0x26ad90, m1 0x20e2a8;

    void closeColorSelect(cocos2d::CCObject* sender) = imac 0x26a910, m1 0x20de4c;
    void createHSVWidget(int tab) = win 0x2b9f40, imac 0x26aa90, m1 0x20dfdc;
    void determineStartValues() = win 0x2b9cc0, imac 0x26a960, m1 0x20deac;
    bool init(GameObject* object, cocos2d::CCArray* objects) = win 0x1f8530;
    void onSelectTab(cocos2d::CCObject* sender) = win 0x2b9f10, imac 0x26aa50, m1 0x20df90;
    void toggleControls(bool visible) = win inline, m1 0x20e240, ios inline {
        for (int i = 0; i < m_controls->count(); i++) {
            static_cast<cocos2d::CCNode*>(m_controls->objectAtIndex(i))->setVisible(visible);
        }
    }

    GameObject* m_object;
    cocos2d::CCArray* m_objects;
    cocos2d::CCArray* m_controls;
    cocos2d::CCArray* m_unkArray;
    ColorSelectDelegate* m_delegate;
    int m_activeTab;
    ConfigureHSVWidget* m_widget;
    bool m_unkBool1;
    bool m_unkBool2;
    bool m_unkBool3;
}

[[link(android)]]
class HSVWidgetDelegate {
    virtual void hsvPopupClosed(HSVWidgetPopup* popup, cocos2d::ccHSVValue value) {}
    virtual void hsvChanged(ConfigureHSVWidget* widget) {}
}

[[link(android)]]
class HSVWidgetPopup : FLAlertLayer {
    // virtual ~HSVWidgetPopup();

    static HSVWidgetPopup* create(cocos2d::ccHSVValue hsv, HSVWidgetDelegate* delegate, gd::string title) = win 0x964f0, imac 0x42ef10, m1 0x3a17bc;

    virtual void keyBackClicked() = win 0x96a20, imac 0x42f610, m1 0x3a1e2c;

    bool init(cocos2d::ccHSVValue hsv, HSVWidgetDelegate* delegate, gd::string title) = win 0x96610;
    void onClose(cocos2d::CCObject* sender) = win 0x96940, imac 0x42f420;

    ConfigureHSVWidget* m_widget;
    HSVWidgetDelegate* m_delegate;
}

[[link(android)]]
class InfoAlertButton : CCMenuItemSpriteExtra {
    // virtual ~InfoAlertButton();

    static InfoAlertButton* create(gd::string title, gd::string desc, float spriteScale) = win 0x2ba2b0, imac 0x5755a0, m1 0x4c3200;

    virtual void activate() = win 0x2ba4b0, m1 0x4c3490, imac 0x575820;

    bool init(gd::string title, gd::string desc, float spriteScale) = win inline, imac 0x575780, m1 0x4c33ec {
        auto infoSprite = cocos2d::CCSprite::createWithSpriteFrameName("GJ_infoBtn_001.png");
        infoSprite->setScale(spriteScale);
        if (!CCMenuItemSpriteExtra::init(infoSprite, nullptr, nullptr, nullptr)) return false;
        this->setSizeMult(1.5f);
        m_title = title;
        m_description = desc;
        return true;
    }

    gd::string m_title;
    gd::string m_description;
    float m_textScale;
    bool m_scroll;
}

[[link(android)]]
class InfoLayer : FLAlertLayer, LevelCommentDelegate, CommentUploadDelegate, FLAlertLayerProtocol {
    // virtual ~InfoLayer();

    static InfoLayer* create(GJGameLevel* level, GJUserScore* score, GJLevelList* list) = win 0x2ba730, imac 0x7adbf0, m1 0x6b427c;

    virtual void registerWithTouchDispatcher() = win 0x42660, m1 0x6b7f58, imac 0x7b1df0;
    virtual void keyBackClicked() = win 0x2be070, m1 0x6b7e6c, imac 0x7b1ce0;
    virtual void show() = win 0x2bf500, m1 0x6b8dc8, imac 0x7b2c70;
    virtual void loadCommentsFinished(cocos2d::CCArray* comments, char const* key) = win 0x2be9b0, m1 0x6b8098, imac 0x7b1f50;
    virtual void loadCommentsFailed(char const* key) = win 0x2bea20, m1 0x6b817c, imac 0x7b2020;
    virtual void setupPageInfo(gd::string info, char const* key) = win 0x2bea70, m1 0x6b8228, imac 0x7b20c0;
    virtual void commentUploadFinished(int parentID) = win 0x2bedb0, m1 0x6b89f0, imac 0x7b2820;
    virtual void commentUploadFailed(int parentID, CommentError errorType) = win 0x2bee80, imac 0x7b2970, m1 0x6b8afc;
    virtual void updateUserScoreFinished() = win 0x2bec60, m1 0x6b8880, imac 0x7b2690;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x2bd210, imac 0x7b1a90, m1 0x6b7c34;

    void confirmReport(cocos2d::CCObject* sender) = win 0x2bccb0, m1 0x6b6858;
    int getAccountID() = win inline, imac 0x7b1900, m1 0x6b7a94, ios inline {
        if (m_levelList) return m_levelList->m_accountID;
        if (m_level) return m_level->m_accountID.value();
        return 0;
    }
    int getID() = win inline, imac 0x7b0860, m1 0x6b6af8, ios inline {
        if(m_score) return m_score->m_userID;
        if(m_levelList) return - m_levelList->m_listID;
        if(m_level) return m_level->m_levelID;
        return 0;
    }
    int getRealID() = win inline, imac 0x7b18b0, m1 0x6b7a54, ios inline {
        if (m_score) return m_score->m_userID;
        if (m_levelList) return m_levelList->m_listID;
        if (m_level) return m_level->m_levelID.value();
        return 0;
    }
    CCMenuItemSpriteExtra* getSpriteButton(char const* frame, cocos2d::SEL_MenuHandler selector, cocos2d::CCMenu* menu, float scale, cocos2d::CCPoint position) = win 0x2bc810, imac 0x7b0970, m1 0x6b6bd0;
    bool init(GJGameLevel* level, GJUserScore* score, GJLevelList* list) = win 0x2ba8d0;
    bool isCorrect(char const* key);
    void loadPage(int page, bool noSetup) = win 0x2be1b0, m1 0x2b65cc;
    void onClose(cocos2d::CCObject* sender) = win 0x2bdff0, m1 0x6b6b3c;
    void onComment(cocos2d::CCObject* sender) = win 0x2bd450, m1 0x6b6454;
    void onCopyLevelID(cocos2d::CCObject* sender) = win 0x2bd0d0, imac 0x7b1940, m1 0x6b7ac4;
    void onGetComments(cocos2d::CCObject* sender) = win 0x2bda00, imac 0x7b0ca0, m1 0x6b6f20;
    void onLevelInfo(cocos2d::CCObject* sender) = win 0x2bda10, imac 0x7b1280, m1 0x6b745c;
    void onMore(cocos2d::CCObject* sender) = win 0x2bd330, imac 0x7afde0;
    void onNextPage(cocos2d::CCObject* sender) = win 0x2bed90, imac 0x7b0950, m1 0x6b6bc0;
    void onOriginal(cocos2d::CCObject* sender) = win 0x2bd390;
    void onPrevPage(cocos2d::CCObject* sender) = win 0x2beda0, imac 0x7b0930, m1 0x6b6bb0;
    void onRefreshComments(cocos2d::CCObject* sender) = m1 0x6b79a4;
    void onSimilar(cocos2d::CCObject* sender) = win inline, ios inline {
        auto searchObject = GJSearchObject::create(SearchType::Similar, cocos2d::CCString::createWithFormat("%i", m_level->m_levelID.value())->getCString());
        cocos2d::CCDirector::sharedDirector()->replaceScene(cocos2d::CCTransitionFade::create(.5f, LevelBrowserLayer::scene(searchObject)));
        m_buttonMenu->setEnabled(false);
    }
    void reloadWindow() = win 0x2bf120, imac 0x7b2a90, m1 0x6b8c08;
    void setupCommentsBrowser(cocos2d::CCArray* comments) = win 0x2be720, imac 0x7b1070, m1 0x6b7288;
    void setupLevelInfo() = win 0x2bc950, m1 0x6b6124;
    void toggleCommentMode(cocos2d::CCObject* sender) = win 0x2bf340, imac 0x7b0a50, m1 0x6b6cb4;
    void toggleExtendedMode(cocos2d::CCObject* sender) = m1 0x6b6d94;
    void toggleSmallCommentMode(cocos2d::CCObject* sender) = win 0x2bf030, m1 0x6b6dc4;
    void updateCommentModeButtons() = win 0x2bf400, m1 0x6b6e7c;
    void updateLevelsLabel() = win inline, m1 0x6b8810 {
        auto end = m_pageEndIdx + m_pageStartIdx;
        auto count = m_itemCount;
        if (end > count) end = count;
        m_pageLabel->setString(cocos2d::CCString::createWithFormat("%i to %i of %i", m_pageStartIdx + 1, end, count)->getCString());
    }

    GJGameLevel* m_level;
    GJUserScore* m_score;
    GJLevelList* m_levelList;
    gd::string m_commentKey;
    LoadingCircle* m_loadingCircle;
    cocos2d::CCLabelBMFont* m_pageLabel;
    cocos2d::CCLabelBMFont* m_noComments;
    GJCommentListLayer* m_list;
    CCMenuItemSpriteExtra* m_rightArrow;
    CCMenuItemSpriteExtra* m_leftArrow;
    CCMenuItemSpriteExtra* m_likeBtn;
    CCMenuItemSpriteExtra* m_timeBtn;
    CCMenuItemSpriteExtra* m_reportBtn;
    CCMenuItemSpriteExtra* m_commentsBtn;
    CCMenuItemSpriteExtra* m_refreshCommentsBtn;
    int m_itemCount;
    int m_pageStartIdx;
    int m_pageEndIdx;
    int m_page;
    bool m_canUpdateUserScore;
    CommentKeyType m_mode;
}

[[link(android)]]
class InheritanceNode : cocos2d::CCObject {
    // virtual ~InheritanceNode();
    InheritanceNode() {
        m_colorID = 0;
        m_inheritanceNode = nullptr;
        m_colorAction = nullptr;
        m_unk050 = false;
        m_unk051 = false;
    }

    static InheritanceNode* create(int colorID, InheritanceNode* node) = win inline, imac 0x2d8cd0, m1 0x27333c {
        auto ret = new InheritanceNode();
        if (ret->init(colorID, node)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init(int colorID, InheritanceNode* node) = win inline, imac 0x2d8d50, m1 0x2733b4, ios inline {
        m_colorID = colorID;
        m_inheritanceNode = node;
        return true;
    }

    int m_colorID;
    InheritanceNode* m_inheritanceNode;
    ColorAction* m_colorAction;
    bool m_unk050;
    bool m_unk051;
}

[[link(android)]]
class ItemInfoPopup : FLAlertLayer {
    // virtual ~ItemInfoPopup();

    static ItemInfoPopup* create(int id, UnlockType type) = win 0x27b5c0, imac 0x36e9d0;
    static gd::string nameForUnlockType(int id, UnlockType type) = win 0x27d680, m1 0x2fc2bc;

    virtual void keyBackClicked() = win 0x846c0, m1 0x2fc668, imac 0x372b40;

    bool init(int id, UnlockType type) = win 0x27b6b0;
    bool isUnlockedByDefault(int id, UnlockType type) = win inline, imac 0x372ae0, ios inline {
        if (type == UnlockType::Cube) return id < 5;
        if (type == UnlockType::Col1 || type == UnlockType::Col2) return id < 4;
        return id < 2;
    }
    void onClose(cocos2d::CCObject* sender) = win 0x84690, imac 0x372ab0, m1 0x2fc5d0;
    void onCredit(cocos2d::CCObject* sender) = win 0x27d650, imac 0x372b10;

    int m_itemID;
    UnlockType m_unlockType;
    int m_accountID;
}

[[link(android)]]
class ItemTriggerGameObject : EffectGameObject {
    // virtual ~ItemTriggerGameObject();
    ItemTriggerGameObject() {
        m_item1Mode = 0;
        m_item2Mode = 0;
        m_targetItemMode = 1;
        m_mod1 = 1.0f;
        m_mod2 = 1.0f;
        m_resultType1 = 0;
        m_resultType2 = 1;
        m_resultType3 = 3;
        m_tolerance = 0.0f;
        m_roundType1 = 0;
        m_roundType2 = 0;
        m_signType1 = 0;
        m_signType2 = 0;
        m_persistent = false;
        m_targetAll = false;
        m_reset = false;
        m_timer = false;
    }

    static ItemTriggerGameObject* create(char const* frame) = win inline, m1 0x195df0 {
        auto ret = new ItemTriggerGameObject();
        if (ret->init(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void customSetup() = win 0x4bf940, m1 0x195f28, imac 0x1e4eb0;
    virtual void triggerObject(GJBaseGameLayer* layer, int uniqueID, gd::vector<int> const* remapKeys) = win 0x4bf980, m1 0x195f60, imac 0x1e4ef0;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4c0a60, m1 0x1999c8, imac 0x1e9d00;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x4bfae0, m1 0x1960a0, imac 0x1e5020;

    bool init(char const* frame) = win inline, m1 0x195ee0, ios inline {
        return EffectGameObject::init(frame);
    }

    // property 476
    int m_item1Mode;
    // property 477
    int m_item2Mode;
    // property 478
    int m_targetItemMode;
    // property 479
    float m_mod1;
    // property 484
    float m_mod2;
    // property 480
    int m_resultType1;
    // property 481
    int m_resultType2;
    // property 482
    int m_resultType3;
    // property 483
    float m_tolerance;
    // property 485
    int m_roundType1;
    // property 486
    int m_roundType2;
    // property 578
    int m_signType1;
    // property 579
    int m_signType2;
    // property 491
    bool m_persistent;
    // property 492
    bool m_targetAll;
    // property 493
    bool m_reset;
    // property 494
    bool m_timer;
}

[[link(android)]]
class KeybindingsLayer : FLAlertLayer {
    // virtual ~KeybindingsLayer();

    static KeybindingsLayer* create();

    virtual bool init() = win 0x2bf7f0, m1 0x52fbb0, imac 0x6098f0;
    virtual void keyBackClicked() = win 0x846c0, m1 0x531520, imac 0x60b260;

    cocos2d::CCLabelBMFont* addKeyPair(char const* action, char const* key) = win 0x2c0100, m1 0x53048c;
    int countForPage(int page) = win 0x2c04b0;
    void goToPage(int page);
    void incrementCountForPage(int page) = win inline, imac 0x60abc0 {
        m_values->setObject(cocos2d::CCString::createWithFormat("%i", this->countForPage(page) + 1), this->pageKey(page));
    }
    const char* infoKey(int index) = win inline, m1 0x5312b4 {
        return cocos2d::CCString::createWithFormat("info_%i", index)->getCString();
    }
    cocos2d::CCLayer* layerForPage(int page);
    const char* layerKey(int page) = win inline, m1 0x53128c {
        return cocos2d::CCString::createWithFormat("layer_%i", page)->getCString();
    }
    cocos2d::CCPoint nextPosition(int page) = win inline, m1 0x530da4 {
        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        return winSize * .5f + cocos2d::CCPoint { 0.f, 100.f - (this->countForPage(page) * 30 + 30) };
    }
    const char* objectKey(int page) = win inline, m1 0x531264 {
        return cocos2d::CCString::createWithFormat("object_%i", page)->getCString();
    }
    cocos2d::CCArray* objectsForPage(int page) = win inline {
        auto key = this->objectKey(page);
        auto objects = static_cast<cocos2d::CCArray*>(m_values->objectForKey(key));
        if (!objects) {
            objects = cocos2d::CCArray::create();
            m_values->setObject(objects, key);
        }
        return objects;
    }
    void onClose(cocos2d::CCObject* sender) = win 0x84690;
    void onInfo(cocos2d::CCObject* sender) = win inline {
        FLAlertLayer::create(
            nullptr,
            "Info",
            m_values->valueForKey(this->infoKey(sender->getTag()))->getCString(),
            "OK",
            nullptr,
            300.f
        )->show();
    }
    void onNextPage(cocos2d::CCObject* sender);
    void onPrevPage(cocos2d::CCObject* sender);
    void onToggle(cocos2d::CCObject* sender) = win inline, m1 0x5312dc {
        if (auto variable = static_cast<cocos2d::CCString*>(m_variables->objectForKey(sender->getTag()))) {
            GameManager::sharedState()->toggleGameVariable(variable->getCString());
        }
    }
    const char* pageKey(int page) = win inline, m1 0x531078 {
        return cocos2d::CCString::createWithFormat("page_%i", page)->getCString();
    }

    int m_page;
    int m_keyCount;
    int m_maxPage;
    cocos2d::CCDictionary* m_values;
    cocos2d::CCDictionary* m_variables;
    CCMenuItemSpriteExtra* m_prevButton;
    CCMenuItemSpriteExtra* m_nextButton;
}

[[link(android)]]
class KeybindingsManager : cocos2d::CCNode {
    // virtual ~KeybindingsManager();

    static KeybindingsManager* sharedState();

    virtual bool init() = win inline, imac 0x4e4cd0, m1 0x43fd0c { return true; }

    bool commandForKey(cocos2d::enumKeyCodes key, GJKeyGroup group, bool control, bool alt, bool shift) = imac 0x4e4ce0, m1 0x43fd14;
    bool commandForKeyMods(cocos2d::enumKeyCodes key, GJKeyGroup group) = m1 0x43fd2c;
    bool commandForKeyNoMods(cocos2d::enumKeyCodes key, GJKeyGroup group) = imac 0x4e4cf0, m1 0x43fd20;
    cocos2d::CCDictionary* commandToKeyForGroup(GJKeyGroup group);
    void dataLoaded(DS_Dictionary* dict) = win inline, imac 0x4e51d0, m1 0x4401c0 {
        auto keyToCommandDict = dict->getDictForKey("KBM_001", false);
        if (m_keyToCommandDict != keyToCommandDict) {
            CC_SAFE_RETAIN(keyToCommandDict);
            CC_SAFE_RELEASE(m_keyToCommandDict);
            m_keyToCommandDict = keyToCommandDict;
        }
        auto commandToKeyDict = dict->getDictForKey("KBM_002", false);
        if (m_commandToKeyDict != commandToKeyDict) {
            CC_SAFE_RETAIN(commandToKeyDict);
            CC_SAFE_RELEASE(m_commandToKeyDict);
            m_commandToKeyDict = commandToKeyDict;
        }
    }
    void encodeDataTo(DS_Dictionary* dict) = win inline, m1 0x44017c {
        dict->setObjectForKey("KBM_001", m_keyToCommandDict);
        dict->setObjectForKey("KBM_002", m_commandToKeyDict);
    }
    void firstSetup() = win inline, m1 0x440100 {
        auto keyToCommandDict = cocos2d::CCDictionary::create();
        if (m_keyToCommandDict != keyToCommandDict) {
            CC_SAFE_RETAIN(keyToCommandDict);
            CC_SAFE_RELEASE(m_keyToCommandDict);
            m_keyToCommandDict = keyToCommandDict;
        }
        auto commandToKeyDict = cocos2d::CCDictionary::create();
        if (m_commandToKeyDict != commandToKeyDict) {
            CC_SAFE_RETAIN(commandToKeyDict);
            CC_SAFE_RELEASE(m_commandToKeyDict);
            m_commandToKeyDict = commandToKeyDict;
        }
    }
    GJKeyGroup groupForCommand(GJKeyCommand command) = m1 0x43fd88;
    cocos2d::enumKeyCodes keyForCommand(GJKeyCommand command) = m1 0x43fd80;
    cocos2d::CCDictionary* keyToCommandForGroup(GJKeyGroup group);

    cocos2d::CCDictionary* m_keyToCommandDict;
    cocos2d::CCDictionary* m_commandToKeyDict;
}

[[link(android)]]
class KeyframeAnimTriggerObject : EffectGameObject {
    // virtual ~KeyframeAnimTriggerObject();
    KeyframeAnimTriggerObject() {
        m_timeMod = 1.0f;
        m_positionXMod = 1.0f;
        m_positionYMod = 1.0f;
        m_rotationMod = 1.0f;
        m_scaleXMod = 1.0f;
        m_scaleYMod = 1.0f;
    }

    static KeyframeAnimTriggerObject* create() = win inline, m1 0x174338 {
        auto ret = new KeyframeAnimTriggerObject();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x4b1220, m1 0x174414, imac 0x1bb2e0;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4b1690, m1 0x1750f8, imac 0x1bc390;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x4b1290, m1 0x174464, imac 0x1bb330;

    // property 520
    float m_timeMod;
    // property 521
    float m_positionXMod;
    // property 545
    float m_positionYMod;
    // property 522
    float m_rotationMod;
    // property 523
    float m_scaleXMod;
    // property 546
    float m_scaleYMod;
}

[[link(android)]]
class KeyframeGameObject : EffectGameObject {
    KeyframeGameObject() {
        m_shadowObjects = nullptr;
        m_previewSprite = nullptr;
        m_keyframeGroup = 0;
        m_keyframeIndex = 0;
        m_referenceOnly = false;
        m_proximity = false;
        m_curve = false;
        m_closeLoop = false;
        m_timeMode = 0;
        m_unk760 = 0.0f;
        m_spawnDelay = 0.0f;
        m_previewArt = false;
        m_keyframeActive = false;
        m_autoLayer = false;
        m_direction = 0;
        m_revolutions = 0;
        m_lineOpacity = 1.0f;
    }
    ~KeyframeGameObject() = win inline, m1 0x17d95c {
        CC_SAFE_RELEASE(m_shadowObjects);
    }

    static KeyframeGameObject* create() = win inline, imac 0x1c6320, m1 0x17da44 {
        auto ret = new KeyframeGameObject();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x4b50c0, m1 0x17db34, imac 0x1c6420;
    virtual void setOpacity(unsigned char opacity) = win 0x4b5380, m1 0x17de20, imac 0x1c6700;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4b5440, m1 0x17df5c, imac 0x1c6860;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x4b5880, m1 0x17e3e4, imac 0x1c6df0;

    void updateShadowObjects(GJBaseGameLayer* layer, EditorUI* ui) = win 0x4b5150, imac 0x1c6490, m1 0x17db98;

    cocos2d::CCArray* m_shadowObjects;
    cocos2d::CCSprite* m_previewSprite;
    // property 373
    int m_keyframeGroup;
    // property 374
    int m_keyframeIndex;
    // property 375
    bool m_referenceOnly;
    // property 377
    bool m_proximity;
    // property 378
    bool m_curve;
    // property 376
    bool m_closeLoop;
    // property 379
    int m_timeMode;
    float m_unk760;
    // property 557
    float m_spawnDelay;
    // property 380
    bool m_previewArt;
    bool m_keyframeActive;
    // property 459
    bool m_autoLayer;
    // property 536
    int m_direction;
    // property 537
    int m_revolutions;
    // property 524
    float m_lineOpacity;
}

[[link(android), depends(tk_spline)]]
class KeyframeObject {
    // KeyframeObject();
    // KeyframeObject(KeyframeObject const&);

    void setupSpline(gd::vector<KeyframeObject*>& objects) = win 0x2c0c60;

    double m_unk000;
    int m_unk008;
    float m_unk00c;
    bool m_unk010;
    int m_unk014;
    float m_unk018;
    bool m_unk01c;
    bool m_unk01d;
    bool m_unk01e;
    tk_spline m_spline1;
    tk_spline m_spline2;
    double m_unk170;
    double m_unk178;
    int m_unk180;
    int m_unk184;
    cocos2d::CCPoint m_unk188;
    cocos2d::CCPoint m_unk190;
    double m_unk198;
    double m_unk1a0;
    double m_unk1a8;
    double m_unk1b0;
    float m_unk1b8;
}

[[link(android)]]
class LabelGameObject : EffectGameObject {
    // virtual ~LabelGameObject();
    LabelGameObject() {
        m_label = nullptr;
        m_labelDirty = false;
        m_labelColorLocked = false;
        m_alignment = 0;
        m_showSecondsOnly = false;
        m_shownSpecial = 0;
        m_isTimeCounter = false;
        m_kerning = 0;
        m_updateLabel = false;
    }

    static LabelGameObject* create() = win inline, imac 0x1c09b0, m1 0x178988 {
        auto ret = new LabelGameObject();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x4b30e0, m1 0x178a58, imac 0x1c0aa0;
    virtual void setOpacity(unsigned char opacity) = win 0x4b3440, m1 0x178e5c, imac 0x1c0ea0;
    virtual void setupCustomSprites(gd::string frameName) = win 0x4b3120, imac 0x1c0ad0, m1 0x178a88;
    virtual void addMainSpriteToParent(bool reorder) = win 0x4b3930, m1 0x1796d8, imac 0x1c1810;
    virtual void resetObject() = win 0x4b3d50, m1 0x17a370, imac 0x1c27d0;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4b3770, imac 0x1c15a0, m1 0x179494;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x4b39a0, m1 0x179730, imac 0x1c1870;
    virtual void setObjectColor(cocos2d::ccColor3B const& color) = win 0x4b38e0, m1 0x179690, imac 0x1c17c0;
    virtual void updateTextKerning(int kerning) = win 0x4b3500, m1 0x178ee0, imac 0x1c0f20;
    virtual int getTextKerning() = win 0x495ca0, m1 0x1a1b74, imac 0x1f3880;

    void createLabel(gd::string text) = win 0x4b31c0, imac 0x1c0b90, m1 0x178b80;
    void queueUpdateLabel(gd::string text) = win inline {
        if (!m_updateLabel) {
            m_labelString = text;
            m_labelDirty = true;
        }
    }
    void removeLabel() = win 0x4b3360, m1 0x178c90;
    void unlockLabelColor() = win inline, m1 0x17a368, ios inline {
        m_labelColorLocked = false;
    }
    void updateLabel(float value) = win inline, imac 0x1c1440, ios inline {
        this->updateLabel(GameToolbox::intToString(value));
    }
    void updateLabel(gd::string text) = win 0x4b36e0;
    void updateLabelAlign(int alignment) = win 0x4b3480, imac 0x1c0df0, m1 0x178db8;
    void updateLabelIfDirty() = win inline {
        if (m_labelDirty) updateLabel(m_labelString);
    }
    void updatePreviewLabel() = win 0x4b3520, imac 0x1c0f40, m1 0x178ef4;

    cocos2d::CCLabelBMFont* m_label;
    bool m_labelDirty;
    gd::string m_labelString;
    bool m_labelColorLocked;
    // property 391
    int m_alignment;
    // property 389
    bool m_showSecondsOnly;
    // property 390
    int m_shownSpecial;
    // property 466
    bool m_isTimeCounter;
    // property 488
    int m_kerning;
    bool m_updateLabel;
}

[[link(android)]]
class LeaderboardManagerDelegate {
    virtual void updateUserScoreFinished() {}
    virtual void updateUserScoreFailed() {}
    virtual void loadLeaderboardFinished(cocos2d::CCArray* scores, char const* key) {}
    virtual void loadLeaderboardFailed(char const* key) {}
}

[[link(android)]]
class LeaderboardsLayer : cocos2d::CCLayer, LeaderboardManagerDelegate, FLAlertLayerProtocol {
    LeaderboardsLayer() {
        m_list = nullptr;
        m_userScores = nullptr;
        m_state = LeaderboardState::Default;
        m_topBtn = nullptr;
        m_globalBtn = nullptr;
        m_creatorsBtn = nullptr;
        m_friendsBtn = nullptr;
        m_circle = nullptr;
        m_noInternet = nullptr;
        m_modeButtons = nullptr;
    }
    ~LeaderboardsLayer() = win inline {
        auto glm = GameLevelManager::sharedState();
        if (glm->m_leaderboardManagerDelegate == this) glm->m_leaderboardManagerDelegate = nullptr;
    }

    static LeaderboardsLayer* create(LeaderboardState state) = win inline {
        auto ret = new LeaderboardsLayer();
        if (ret->init(state)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static cocos2d::CCScene* scene(LeaderboardState state) = win inline {
        auto scene = cocos2d::CCScene::create();
        AppDelegate::get()->m_runningScene = scene;
        auto layer = LeaderboardsLayer::create(state);
        scene->addChild(layer);
        return scene;
    }

    virtual void keyBackClicked() = win 0x2c3fb0, m1 0x46a66c, imac 0x513c30;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x2c3f00, m1 0x46a614, imac 0x513bd0;
    virtual void updateUserScoreFinished() = win 0x2c3690, imac 0x513640, m1 0x469fcc;
    virtual void updateUserScoreFailed() = win 0x2c36c0, m1 0x46a00c, imac 0x5136a0;
    virtual void loadLeaderboardFinished(cocos2d::CCArray* scores, char const* key) = win 0x2c36d0, m1 0x46a0b4, imac 0x513740;
    virtual void loadLeaderboardFailed(char const* key) = win 0x2c3790, m1 0x46a35c, imac 0x513990;

    bool init(LeaderboardState state) = win 0x2c1220;
    bool isCorrect(char const* key);
    void onBack(cocos2d::CCObject* sender) = win 0x2c3f30, m1 0x469a74;
    void onCreators(cocos2d::CCObject* sender) = imac 0x513180;
    void onGlobal(cocos2d::CCObject* sender) = imac 0x513160;
    void onInfo(cocos2d::CCObject* sender) = win 0x2c3a00, imac 0x5126c0;
    void onTop(cocos2d::CCObject* sender) = imac 0x513120;
    void onWeek(cocos2d::CCObject* sender) = win 0x2c3060, imac 0x513140;
    void refreshTabs() = win 0x2c2f60, m1 0x469ca0;
    void selectLeaderboard(LeaderboardState state);
    void setupLevelBrowser(cocos2d::CCArray* scores) = win 0x2c2e00, m1 0x469b68;
    void setupTabs();
    void toggleTabButtons();

    GJListLayer* m_list;
    cocos2d::CCArray* m_userScores;
    LeaderboardState m_state;
    CCMenuItemToggler* m_topBtn;
    CCMenuItemToggler* m_globalBtn;
    CCMenuItemToggler* m_creatorsBtn;
    CCMenuItemToggler* m_friendsBtn;
    LoadingCircle* m_circle;
    TextArea* m_noInternet;
    cocos2d::CCArray* m_tabs;
    cocos2d::CCArray* m_modeButtons;
}

[[link(android)]]
class LevelAreaInnerLayer : cocos2d::CCLayer, DialogDelegate {
    // virtual ~LevelAreaInnerLayer();
    LevelAreaInnerLayer() {
        m_nextFloorButton = nullptr;
        m_enteringLevel = false;
        m_levelID = 0;
        m_exiting = false;
    }

    static LevelAreaInnerLayer* create(bool returning) = win inline, imac 0x279780, m1 0x21bae0 {
        auto ret = new LevelAreaInnerLayer();
        if (ret->init(returning)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static cocos2d::CCScene* scene(bool returning) = win 0x2c6230, m1 0x21b898;

    virtual void keyBackClicked() = win 0x2c85b0, m1 0x21d938, imac 0x27b710;
    virtual void dialogClosed(DialogLayer* layer) = win 0x2c7a00, imac 0x27b4e0, m1 0x21d70c;
    virtual void onExit() = win 0x2c8560, m1 0x21d8e4, imac 0x27b6c0;

    bool init(bool returning) = win 0x2c6340, m1 0x21bba0;
    void onBack(cocos2d::CCObject* sender) = win 0x2c8500;
    void onDoor(cocos2d::CCObject* sender) = win 0x2c8030, imac 0x27a6f0;
    void onInfo(cocos2d::CCObject* sender) = m1 0x21cc74;
    void onNextFloor(cocos2d::CCObject* sender) = win 0x2c7320;
    void onOnlineVault(cocos2d::CCObject* sender) = win 0x2c8320, m1 0x21cbb0;
    bool playStep1() = win 0x2c81f0, m1 0x21d824;
    void showFloor1CompleteDialog() = win 0x2c7420, m1 0x21d200;
    void tryResumeTowerMusic() = win 0x2c7f90, m1 0x21cbe4;
    void tryShowAd() = win inline, m1 0x21d6ec, ios inline {
        GameManager::sharedState()->tryShowInterstitial(120, 140, 0);
    }

    CCMenuItemSpriteExtra* m_nextFloorButton;
    bool m_enteringLevel;
    int m_levelID;
    bool m_exiting;
}

[[link(android)]]
class LevelAreaLayer : cocos2d::CCLayer, DialogDelegate {
    LevelAreaLayer() {
        m_towerSprite = nullptr;
        m_godRays = nullptr;
        m_enteringTower = false;
        m_exiting = false;
    }
    ~LevelAreaLayer() = win inline {
        CC_SAFE_RELEASE(m_godRays);
    }

    static void addTorch(cocos2d::CCNode* parent, cocos2d::CCPoint position, int fireType, float scale, int zOrder, bool noTorch, int colorType, cocos2d::CCArray* nodes) = win 0x2c56f0, imac 0x278740, m1 0x21aa80;
    static LevelAreaLayer* create() = win inline, imac 0x2773a0, m1 0x219734 {
        auto ret = new LevelAreaLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static cocos2d::CCScene* scene() = win 0x2c4120, m1 0x219668;

    virtual bool init() = win 0x2c4230, m1 0x2197e8, imac 0x277470;
    virtual void keyBackClicked() = win 0x2c6220, m1 0x21b9cc, imac 0x279610;
    virtual void dialogClosed(DialogLayer* layer) = win 0x2c5410, imac 0x279370, m1 0x21b744;
    virtual void onExit() = win 0x2c61d0, m1 0x21b978, imac 0x2795c0;

    void addGodRay(float startOpacity, float midOpacity, float endOpacity, float fadeDuration, float scaleY, cocos2d::CCPoint position) = win 0x2c5d80, imac 0x278410, m1 0x21a764;
    void fadeInsideTower() = win 0x2c5590, imac 0x279390, m1 0x21b754;
    void onBack(cocos2d::CCObject* sender) = win 0x2c6120;
    void onClickDoor(cocos2d::CCObject* sender) = win 0x2c5420;
    bool onEnterTower() = win 0x2c5640, m1 0x21b800;
    void showDialog() = win 0x2c50e0, m1 0x21b4f4;

    cocos2d::CCSprite* m_towerSprite;
    cocos2d::CCArray* m_godRays;
    bool m_enteringTower;
    bool m_exiting;
}

[[link(android)]]
class LevelBrowserLayer : cocos2d::CCLayerColor, LevelManagerDelegate, FLAlertLayerProtocol, SetIDPopupDelegate, SetTextPopupDelegate, TableViewCellDelegate, ShareCommentDelegate {
    LevelBrowserLayer() = win 0x2c8630 {
        m_unk = false;
        m_allSelected = false;
        m_noInternet = nullptr;
        m_list = nullptr;
        m_rightArrow = nullptr;
        m_leftArrow = nullptr;
        m_lastBtn = nullptr;
        m_cancelSearchBtn = nullptr;
        m_refreshBtn = nullptr;
        m_levels = nullptr;
        m_searchObject = nullptr;
        m_countText = nullptr;
        m_pageText = nullptr;
        m_pageBtn = nullptr;
        m_folderText = nullptr;
        m_folderBtn = nullptr;
        m_allObjectsToggler = nullptr;
        m_itemCount = 0;
        m_pageStartIdx = 0;
        m_pageEndIdx = 0;
        m_circle = nullptr;
        m_lastPage = 0;
        m_isOverlay = false;
        m_scene = nullptr;
        m_zOffset = 0;
        m_unk2 = false;
        m_listHeight = 0;
        m_unkFloat = .0f;
        m_unkFloat2 = .0f;
        m_delegate = nullptr;
        m_cached = false;
    }
    ~LevelBrowserLayer() = win 0x2c8820, m1 0x3efcf4;

    static LevelBrowserLayer* create(GJSearchObject* object) = win 0x2c8a50, imac 0x48a8e0, m1 0x3efe90;
    static cocos2d::CCScene* scene(GJSearchObject* object) = win 0x2c8a00, m1 0x3efe44, imac 0x48a8a0;

    virtual void onEnter() = win 0x2cfaf0, m1 0x3f6690, imac 0x4916e0;
    virtual void onEnterTransitionDidFinish() = win 0x248ec0, m1 0x3f6880, imac 0x491880;
    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline, imac 0x491960, m1 0x3f6950 { return true; }
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline, imac 0x4919c0, m1 0x3f6970 {}
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline, imac 0x491980, m1 0x3f6960 {}
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline, imac 0x4919a0, m1 0x3f6968 {}
    virtual void registerWithTouchDispatcher() = win 0x2cfc30, m1 0x3f6884, imac 0x491890;
    virtual void keyBackClicked() = win 0x2ccd70, m1 0x3f5c34, imac 0x490bf0;
    virtual void keyDown(cocos2d::enumKeyCodes key, double timestamp) = win 0x2ccd90, m1 0x3f5c58, imac 0x490c30;
    virtual void loadLevelsFinished(cocos2d::CCArray* levels, char const* key, int type) = win 0x2cc280, m1 0x3f5170, imac 0x490110;
    virtual void loadLevelsFailed(char const* key, int type) = win 0x2cc3b0, imac 0x490270, m1 0x3f5298;
    virtual void setupPageInfo(gd::string info, char const* key) = win 0x2cc400, imac 0x490350, m1 0x3f5384;
    virtual void onBack(cocos2d::CCObject* sender) = win 0x2ccce0, m1 0x3f5b80, imac 0x490b40;
    virtual void shareCommentClosed(gd::string text, ShareCommentLayer* layer) = win 0x2cdf90, m1 0x3f5f88, imac 0x490f20;
    virtual void setTextPopupClosed(SetTextPopup* popup, gd::string text) = win 0x2ced00, imac 0x491000, m1 0x3f6054;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x2cf530, imac 0x4911f0, m1 0x3f61f8;
    virtual void setIDPopupClosed(SetIDPopup* popup, int value) = win 0x2cc8b0, imac 0x490a10, m1 0x3f5a70;
    virtual cocos2d::CCArray* updateResultArray(cocos2d::CCArray* results) = win 0x2c87d0, imac 0x4919e0, m1 0x3f6978;
    virtual bool cellPerformedAction(TableViewCell* cell, int listType, CellAction action, cocos2d::CCNode* parent) = win 0x2cfb90, m1 0x3f6740, imac 0x491760;

    void createNewLevel(cocos2d::CCObject* sender) = win inline, m1 0x3f5f10 {
        this->setKeypadEnabled(false);
        this->setKeyboardEnabled(false);
        GameLevelManager* glm = GameLevelManager::sharedState();
        GJGameLevel* newLevel = glm->createNewLevel();
        glm->m_returnToLocalLevels = true;
        cocos2d::CCDirector::sharedDirector()->replaceScene(cocos2d::CCTransitionFade::create(0.5f, EditLevelLayer::scene(newLevel)));
    }
    void createNewList(cocos2d::CCObject* sender) = win inline {
        if (m_isOverlay) {
            auto layer = ShareCommentLayer::create("List Name", 25, CommentType::ListName, 0, {});
            layer->m_delegate = this;
            layer->show();
        }
        else {
            this->setKeypadEnabled(false);
            this->setKeyboardEnabled(false);
            auto glm = GameLevelManager::sharedState();
            auto list = glm->createNewLevelList();
            glm->m_returnToLocalLevels = true;
            cocos2d::CCDirector::sharedDirector()->replaceScene(cocos2d::CCTransitionFade::create(0.5f, LevelListLayer::scene(list)));
        }
    }
    void createNewSmartTemplate(cocos2d::CCObject* sender) = win inline, imac 0x490d30, m1 0x3f5d34 {
        this->setKeypadEnabled(false);
        this->setKeyboardEnabled(false);
        auto glm = GameLevelManager::sharedState();
        auto smartTemplate = glm->createSmartTemplate();
        glm->m_returnToLocalLevels = true;
        SetupSmartTemplateLayer::create(smartTemplate)->show();
        this->onBack(nullptr);
    }
    void deleteSelected() = win inline, imac 0x4910d0, m1 0x3f60f8 {
        auto selected = cocos2d::CCArray::create();
        for (auto obj : geode::cocos::CCArrayExt<cocos2d::CCObject*, false>(m_levels)) {
            auto level = static_cast<GJGameLevel*>(obj);
            if (level->m_selected) selected->addObject(level);
        }
        if (selected->count() == 0) return;
        auto glm = GameLevelManager::sharedState();
        for (auto obj : geode::cocos::CCArrayExt<cocos2d::CCObject*, false>(selected)) {
            glm->deleteLevel(static_cast<GJGameLevel*>(obj));
        }
        m_allSelected = false;
        m_allObjectsToggler->toggle(false);
        this->loadPage(m_searchObject);
    }
    void exitLayer(cocos2d::CCObject* sender) = win inline, m1 0x3f5bf0 {
        cocos2d::CCDirector::sharedDirector()->getTouchDispatcher()->unregisterForcePrio(this);
        this->removeFromParentAndCleanup(true);
    }
    cocos2d::CCArray* getItemsMatchingSearch(cocos2d::CCArray* items, gd::string query, GJSearchObject* object) = win 0x2cedc0, m1 0x3f4564;
    gd::string getSearchTitle() = win 0x2cba20, imac 0x48f9d0, m1 0x3f4bc0;
    bool init(GJSearchObject* object) = win 0x2c8ac0;
    bool isCorrect(char const* key) = win 0x2ca3b0, imac 0x48f150, m1 0x3f43ac;
    void loadPage(GJSearchObject* object) = win 0x2ca580;
    void onClearSearch(cocos2d::CCObject* sender) = win 0x2ce9e0, imac 0x48de50, m1 0x3f3350;
    void onDeleteAll(cocos2d::CCObject* sender) = win 0x2ce430, imac 0x48d190;
    void onDeleteSelected(cocos2d::CCObject* sender) = win 0x2cf150, imac 0x48c880, m1 0x3f1ce0;
    void onFavorites(cocos2d::CCObject* sender) = win 0x2ce270, imac 0x48d450;
    void onGoToFolder(cocos2d::CCObject* sender) = win 0x2cc800, imac 0x48daa0, m1 0x3f2f94;
    void onGoToLastPage(cocos2d::CCObject* sender) = m1 0x3f305c;
    void onGoToPage(cocos2d::CCObject* sender) = win 0x2cc6f0, imac 0x48c770, m1 0x3f1bb0;
    void onHelp(cocos2d::CCObject* sender) = win inline, imac 0x490d20, m1 0x3f5d30, ios inline {}
    void onInfo(cocos2d::CCObject* sender) = win 0x2cce30, imac 0x48d690, m1 0x3f2b7c;
    void onLocalMode(cocos2d::CCObject* sender) = win 0x2cdeb0;
    void onMyOnlineLevels(cocos2d::CCObject* sender) = win 0x2ce0a0, imac 0x48cce0;
    void onNew(cocos2d::CCObject* sender) = win 0x2cda00;
    void onNextPage(cocos2d::CCObject* sender) = m1 0x3f1a70;
    void onPrevPage(cocos2d::CCObject* sender) = m1 0x3f1a3c;
    void onRefresh(cocos2d::CCObject* sender) = win 0x2ce8a0, m1 0x3f2a48;
    void onRemoveAllFavorites(cocos2d::CCObject* sender) = win 0x2ce5d0, imac 0x48d050, m1 0x3f24e8;
    void onSaved(cocos2d::CCObject* sender) = win 0x2ce350, imac 0x48d330;
    void onSavedMode(cocos2d::CCObject* sender) = win 0x2cddd0;
    void onSearch(cocos2d::CCObject* sender) = win 0x2cea80, m1 0x3f3094;
    void onToggleAllObjects(cocos2d::CCObject* sender) = win 0x2cf490, imac 0x48cb60, m1 0x3f1fd0;
    void reloadAllObjects() = win inline, m1 0x3f61ec, ios inline {
        static_cast<CustomListView*>(m_list->m_listView)->reloadAll();
    }
    void setSearchObject(GJSearchObject* object) = win inline, m1 0x3f19f4 {
        if (m_searchObject != object) {
            CC_SAFE_RETAIN(object);
            CC_SAFE_RELEASE(m_searchObject);
            m_searchObject = object;
        }
    }
    void setupLevelBrowser(cocos2d::CCArray* items) = win 0x2cb710, imac 0x48f6e0, m1 0x3f4920;
    void show() = m1 0x3f68cc;
    void updateLevelsLabel() = win inline, m1 0x3f59d8 {
        auto end = m_pageEndIdx + m_pageStartIdx;
        auto count = m_itemCount;
        if (end > count) end = count;
        m_countText->setString(cocos2d::CCString::createWithFormat("%i to %i of %i", m_pageStartIdx + 1, end, count)->getCString());
        m_countText->limitLabelWidth(100.f, .6f, .0f);
        this->updatePageLabel();
    }
    void updatePageLabel() = win 0x2ccab0, imac 0x48c650, m1 0x3f1aa4;

    bool m_unk;
    bool m_allSelected;
    TextArea* m_noInternet;
    GJListLayer* m_list;
    CCMenuItemSpriteExtra* m_rightArrow;
    CCMenuItemSpriteExtra* m_leftArrow;
    CCMenuItemSpriteExtra* m_lastBtn;
    CCMenuItemSpriteExtra* m_cancelSearchBtn;
    CCMenuItemSpriteExtra* m_refreshBtn;
    cocos2d::CCArray* m_levels;
    GJSearchObject* m_searchObject;
    cocos2d::CCLabelBMFont* m_countText;
    cocos2d::CCLabelBMFont* m_pageText;
    CCMenuItemSpriteExtra* m_pageBtn;
    cocos2d::CCLabelBMFont* m_folderText;
    CCMenuItemSpriteExtra* m_folderBtn;
    CCMenuItemToggler* m_allObjectsToggler;
    int m_itemCount;
    int m_pageStartIdx;
    int m_pageEndIdx;
    LoadingCircle* m_circle;
    int m_lastPage;
    bool m_isOverlay;
    cocos2d::CCScene* m_scene;
    int m_zOffset;
    bool m_unk2;
    int m_listHeight;
    float m_unkFloat;
    float m_unkFloat2;
    TableViewCellDelegate* m_delegate;
    bool m_cached;
}

[[link(android)]]
class LevelCell : TableViewCell {
    // virtual ~LevelCell();
    LevelCell(char const* identifier, float width, float height) = win 0xadfa0, m1 0x1f4fb0;

    static LevelCell* create(float width, float height) = win inline, imac 0x24e620, m1 0x1f4ea8 {
        auto ret = new LevelCell(" ", width, height);
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0xae050, imac 0x24e7d0, m1 0x1f5034;
    virtual void draw() = win 0xb1a80, m1 0x1f83b0, imac 0x251e60;

    void loadCustomLevelCell() = win 0xae250, imac 0x24f0b0;
    void loadFromLevel(GJGameLevel* level) = win 0xae070, imac 0x244340, m1 0x1eb14c;
    void loadLocalLevelCell() = win 0xb0d90, imac 0x24e800, m1 0x1f5050;
    void onClick(cocos2d::CCObject* sender) = win 0xb1820, imac 0x251cd0, m1 0x1f820c;
    void onToggle(cocos2d::CCObject* sender) = m1 0x1f81f4;
    void onViewProfile(cocos2d::CCObject* sender) = win 0xb1a40, imac 0x251e30;
    void updateBGColor(int index) = win inline, imac 0x244500, m1 0x1eb30c {
        m_backgroundLayer->setColor(index % 2 == 0 ? cocos2d::ccColor3B { 161, 88, 44 } : cocos2d::ccColor3B { 194, 114, 62 });
        m_backgroundLayer->setOpacity(255);
    }
    void updateCellMode(int mode) = win 0xb1590, imac 0x24e220, m1 0x1f4b40;
    void updateToggle() = win inline, m1 0x1f4b24, ios inline {
        if (m_level && m_toggler) m_toggler->toggle(m_level->m_selected);
    }

    CCMenuItemSpriteExtra* m_button;
    GJGameLevel* m_level;
    bool m_cellDrawn;
    CCMenuItemToggler* m_toggler;
    cocos2d::CCPoint m_point;
    cocos2d::CCMenu* m_mainMenu;
    bool m_compactView;
    int m_cellMode;
}

[[link(android)]]
class LevelCommentDelegate {
    virtual void loadCommentsFinished(cocos2d::CCArray* comments, char const* key) {}
    virtual void loadCommentsFailed(char const* key) {}
    virtual void updateUserScoreFinished() {}
    virtual void setupPageInfo(gd::string info, char const* key) {}
}

[[link(android)]]
class LevelDeleteDelegate {
    virtual void levelDeleteFinished(int id) {}
    virtual void levelDeleteFailed(int id) {}
}

[[link(android)]]
class LevelDownloadDelegate {
    virtual void levelDownloadFinished(GJGameLevel* level) {}
    virtual void levelDownloadFailed(int response) {}
}

[[link(android)]]
class LevelEditorLayer : GJBaseGameLayer, LevelSettingsDelegate {
    // virtual ~LevelEditorLayer();
    LevelEditorLayer() = win 0x2d09b0;

    static LevelEditorLayer* create(GJGameLevel* level, bool noUI) = win 0x2d1ba0;
    static LevelEditorLayer* get() {
        return GameManager::sharedState()->m_levelEditorLayer;
    }
    static cocos2d::CCScene* scene(GJGameLevel* level, bool noUI) = win inline {
        auto scene = cocos2d::CCScene::create();
        AppDelegate::get()->m_runningScene = scene;
        auto layer = LevelEditorLayer::create(level, noUI);
        scene->addChild(layer);
        scene->setObjType(cocos2d::CCObjectType::LevelEditorLayer);
        return scene;
    }
    static void updateObjectLabel(GameObject* object) = win 0x2d74c0, imac 0xe9bb0, m1 0xcdd54;

    virtual void draw() = win 0x2e8730, m1 0xdf684, imac 0x1004e0;
    virtual void postUpdate(float dt) = win 0x2e0da0, m1 0xd6008, imac 0xf3250;
    virtual void updateVisibility(float dt) = win 0x2d8cd0, imac 0xeaa60, m1 0xce938;
    virtual void playerTookDamage(PlayerObject* player) = win 0x2e0d90, imac 0xf3230, m1 0xd5ff4;
    virtual void updateColor(cocos2d::ccColor3B& color, float fadeTime, int colorID, bool blending, float opacity, cocos2d::ccHSVValue& copyHSV, int colorIDToCopy, bool copyOpacity, EffectGameObject* callerObject, int unk1, int unk2) = win 0x2dd870, imac 0xf0230, m1 0xd34ec;
    virtual void updateDebugDraw() = win 0x2e6ad0, m1 0xddea4, imac 0xfe390;
    virtual void addToGroup(GameObject* object, int groupID, bool triggerGroup) = win 0x2de860, m1 0xd3c94, imac 0xf0ab0;
    virtual void removeFromGroup(GameObject* object, int groupID) = win 0x2de9c0, m1 0xd3d4c, imac 0xf0b60;
    virtual void updateObjectSection(GameObject* object) = win 0x2df790, m1 0xd4c9c, imac 0xf1c60;
    virtual void updateDisabledObjectsLastPos(cocos2d::CCArray* objects) = win 0x2dfa40, m1 0xd4da8, imac 0xf1da0;
    virtual float timeForPos(cocos2d::CCPoint position, int order, int channel, bool songTriggers, int id) = win 0x2de650, imac 0xf0530, m1 0xd378c;
    virtual cocos2d::CCPoint posForTime(float time) = win 0x2de700, imac 0xf05c0, m1 0xd3818;
    virtual void resetSPTriggered() = win 0x2de770, imac 0xf0660, m1 0xd3858;
    virtual void didRotateGameplay() = win 0x2df720, imac 0xf1a40, m1 0xd4a9c;
    virtual void manualUpdateObjectColors(GameObject* object) = win 0x2d9cd0, m1 0xcf484, imac 0xeb620;
    virtual cocos2d::CCParticleSystemQuad* claimCustomParticle(gd::string const& key, cocos2d::ParticleStruct const& particleStruct, int zLayer, int zOrder, int uiObject, bool dontAdd) = win 0x2e1530, m1 0xd6eac, imac 0xf4190;
    virtual void unclaimCustomParticle(gd::string const& key, cocos2d::CCParticleSystemQuad* particle) = win 0x2e15f0, imac 0xf4240, m1 0xd6f7c;
    virtual void activatedAudioTrigger(SFXTriggerGameObject* object) = win 0x2e0c90, imac 0xf3150, m1 0xd5f30;
    virtual void checkpointActivated(CheckpointGameObject* object) = win 0x2e0cc0, imac 0xf3180, m1 0xd5f48;
    virtual void addKeyframe(KeyframeGameObject* object) = win 0x2e1630, imac 0xf4280, m1 0xd6fbc;
    virtual void levelSettingsUpdated() = win 0x2d3580, imac 0xdeeb0, m1 0xc4c10;

    bool activateTriggerEffect(EffectGameObject* object, float currentTime, float playTime, float boundTime, bool active) = win 0x2dcda0, imac 0xef1a0;
    void addDelayedSpawn(EffectGameObject* object, float delay) = win 0x2dd5f0, m1 0xd313c, ios inline {
        auto node = this->getDelayedSpawnNode();
        node->m_gameObject = object;
        node->m_spawnDelay = delay;
        if (m_delayedSpawnNodes.size() > 1) m_sortSpawnNodes = true;
    }
    void addExclusionList(cocos2d::CCArray* groups, cocos2d::CCDictionary* dict) = win inline {
        if (!groups || !dict) return;
        auto node = cocos2d::CCNode::create();
        for (int i = 0; i < groups->count(); i++) {
            auto group = static_cast<cocos2d::CCInteger*>(groups->objectAtIndex(i))->getValue();
            if (!dict->objectForKey(group)) dict->setObject(node, group);
        }
    }
    GameObject* addObjectFromVector(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win inline {
        auto object = GameObject::objectFromVector(values, exists, this, false);
        if (!object) return nullptr;
        if (object->m_objectID == 1329 && m_coinCount.value() > 2) return nullptr;
        if (object->m_objectID == 142) return nullptr;
        object->setVisible(false);
        this->addToSection(object);
        this->addSpecial(object);
        return object;
    }
    void addObjectsAtPosition(cocos2d::CCPoint position, cocos2d::CCArray* objects, cocos2d::CCArray* result) = win inline, imac 0x615b80, m1 0xc7708, ios inline {
        for (int i = 0; i < objects->count(); i++) {
            auto object = static_cast<GameObject*>(objects->objectAtIndex(i));
            if (this->validGroup(object, true)) {
                if (m_nonSquareRotation) {
                    if (!m_currentOBB2D->overlaps(m_obb2)) continue;
                }
                else {
                    if (!this->getObjectRect(object, false, false).containsPoint(position)) continue;
                }
                result->addObject(object);
            }
        }
    }
    void addObjectsInRect(cocos2d::CCRect rect, bool ignoreGroups, cocos2d::CCArray* objects, cocos2d::CCArray* result) = win inline, imac 0xe1eb0, m1 0xc78b8, ios inline {
        for (int i = 0; i < objects->count(); i++) {
            auto object = static_cast<GameObject*>(objects->objectAtIndex(i));
            if (ignoreGroups || this->validGroup(object, true)) {
                if (m_nonSquareRotation) {
                    if (!m_currentOBB2D->overlaps(m_obb2)) continue;
                }
                else {
                    if (!rect.intersectsRect(this->getObjectRect(object, false, false))) continue;
                }
                result->addObject(object);
            }
        }
    }
    void addObjectToGroup(GameObject* object, int group) = win inline, imac 0xf0a60, m1 0xd3c24 {
        if (object->addToGroup(group) != 1) {
            return;
        }
        this->addToGroup(object,group,false);
    }
    void addPlayer2Point(cocos2d::CCPoint point, bool newGroup) = win inline {
        if (newGroup || m_player2Points.empty()) m_player2Points.emplace_back();
        m_player2Points.back().push_back(point);
    }
    void addPlayerCollisionBlock() = win inline, ios inline {
        if (m_collisionBlocksAdded) return;
        m_collisionBlocksAdded = true;
        this->addToSection(m_player1CollisionBlock);
        this->addToSection(m_player2CollisionBlock);
    }
    void addPlayerPoint(cocos2d::CCPoint point) = win inline {
        m_playerPoints.push_back(point);
    }
    void addSpecial(GameObject* object) = win 0x2d7a20;
    void addToRedoList(UndoObject* object) = win inline {
        if (m_redoObjects->count() >= (m_increaseMaxUndoRedo ? 1000 : 200)) m_redoObjects->removeObjectAtIndex(0, true);
        m_redoObjects->addObject(object);
    }
    void addTouchPoint(cocos2d::CCPoint point) = win inline {
        m_touchPoints.push_back(point);
    }
    void addToUndoList(UndoObject* object, bool keepRedo) = win inline, imac 0xdfb50 {
        if (!keepRedo) m_redoObjects->removeAllObjects();
        if (m_undoObjects->count() >= (m_increaseMaxUndoRedo ? 1000 : 200)) m_undoObjects->removeObjectAtIndex(0, true);
        m_undoObjects->addObject(object);
    }
    void applyAttributeState(GameObject* dest, GameObject* src) = win inline, imac 0xf3b20, m1 0xd68b8, ios inline {
        dest->duplicateAttributes(src);
        dest->m_updateParents = true;
    }
    void applyGroupState(GameObject* dest, GameObject* src) = win 0x2e1230, m1 0xd6690;
    void breakApartTextObject(TextGameObject* object) = win 0x2df410;
    bool canPasteState() = win inline, imac 0xf3700, m1 0xd647c {
        return m_copyStateObject != nullptr;
    }
    void clearPlayerPoints() = win inline, imac 0xf27f0, m1 0xd56b8, ios inline {
        m_playerPoints.clear();
        m_player2Points.clear();
    }
    void clearTouchPoints() = win inline, imac 0xf2850, m1 0xd5720, ios inline {
        m_touchPoints.clear();
    }
    void copyObjectState(GameObject* object) = win 0x2e1090, imac 0xf3720, m1 0xd648c;
    void copyParticleState(ParticleGameObject* object) = win inline, imac 0xf3cf0, m1 0xd6a7c {
        if (!object) return;
        if (!m_particleObject) {
            m_particleObject = ParticleGameObject::create();
            m_particleObject->addColorSprite("edit_eCParticleBtn_001.png");
            m_particleObject->setupCustomSprites("edit_eCParticleBtn_001.png");
            m_particleObject->retain();
        }
        m_particleObject->setParticleString(object->m_particleData);
        m_particleObject->m_hasUniformObjectColor = object->m_hasUniformObjectColor;
        m_particleObject->m_animateOnTrigger = object->m_animateOnTrigger;
    }
    GameObject* createObject(int key, cocos2d::CCPoint position, bool noUndo) = win 0x2d4500, m1 0xc5e74;
    void createObjectsFromSetup(gd::string& setup) = win 0x2d3660, m1 0xc2f50;
    cocos2d::CCArray* createObjectsFromString(gd::string const& str, bool noUndo, bool noLimit) = win 0x2d3e80, m1 0xc5090;
    void dirtifyTriggers() = win inline, imac 0xf1b30 {
        m_triggersChanged = true;
        m_colorTriggersChanged = true;
        m_pulseTriggersChanged = true;
        m_alphaTriggersChanged = true;
        m_spawnTriggersChanged = true;
    }
    cocos2d::CCArray* duplicateKeyframeAnimation(int keyframeGroup) = win 0x2e16e0, imac 0xf42a0, m1 0xd6fd0;
    void fastUpdateDisabledGroups() = win inline, ios inline {}
    GameObject* findGameObject(int uniqueID) = win inline, m1 0xc7abc {
        for (auto obj : geode::cocos::CCArrayExt<cocos2d::CCObject*, false>(m_objects)) {
            auto object = static_cast<GameObject*>(obj);
            if (object->m_uniqueID == uniqueID) return object;
        }
        return nullptr;
    }
    StartPosObject* findStartPosObject() = win inline, m1 0xd4bac {
        StartPosObject* ret = nullptr;
        auto xPos = 0.0f;
        auto order = -1;
        for (auto obj : geode::cocos::CCArrayExt<cocos2d::CCObject*, false>(m_objects)) {
            auto object = static_cast<StartPosObject*>(obj);
            if (object->m_objectID == 31 && !object->m_startSettings->m_disableStartPos) {
                auto currentXPos = object->getPosition().x;
                auto currentOrder = object->m_startSettings->m_targetOrder;
                auto reverseGameplay = object->m_startSettings->m_reverseGameplay;
                if (
                    order < currentOrder ||
                    (xPos < currentXPos && !reverseGameplay && order <= currentOrder) ||
                    (currentXPos < xPos && reverseGameplay && order <= currentOrder)
                ) {
                    ret = object;
                    order = currentOrder;
                    xPos = currentXPos;
                }
            }
        }
        return ret;
    }
    void forceShowSelectedObjects(bool show) = win inline {
        if (!m_editorUI) return;
        cocos2d::CCArray* objects;
        if (m_editorUI->m_selectedObjects->count() == 0) {
            if (!m_editorUI->m_selectedObject) return;
            objects = cocos2d::CCArray::createWithObject(m_editorUI->m_selectedObject);
        }
        else {
            objects = m_editorUI->m_selectedObjects;
        }
        for (auto obj : geode::cocos::CCArrayExt<cocos2d::CCObject*, false>(objects)) {
            auto object = static_cast<GameObject*>(obj);
            if (show) {
                object->m_unk28B = object->m_isGroupDisabled;
                object->m_isGroupDisabled = false;
            }
            else {
                object->m_isGroupDisabled = object->m_unk28B;
            }
        }
    }
    void fullUpdateDisabledGroups() = win inline, ios inline {}
    cocos2d::CCArray* getAllObjects() = win inline, m1 0xc7ab4 {
        return m_objects;
    }
    DelayedSpawnNode* getDelayedSpawnNode() = win inline, m1 0xd33c8 {
        DelayedSpawnNode* ret;
        if (m_delayedSpawnNodes2.empty()) {
            ret = new DelayedSpawnNode();
            ret->m_gameObject = nullptr;
            ret->m_spawnDelay = 0.f;
        }
        else {
            ret = m_delayedSpawnNodes2.back();
            m_delayedSpawnNodes2.pop_back();
        }
        m_delayedSpawnNodes.push_back(ret);
        return ret;
    }
    cocos2d::CCPoint getGridPos(cocos2d::CCPoint position) = win inline, imac 0xe09d0, ios inline {
        return position / 30.f;
    }
    float getLastObjectX() = win 0x2de7c0, imac 0xf06b0, m1 0xd3898;
    gd::string getLevelString() = win 0x2d6ab0, imac 0xe3460;
    gd::string getLockedLayers() = win inline, imac 0xe8950, m1 0xcce74 {
        auto isFirst = true;
        fmt::memory_buffer buffer;
        for (int i = 0; i < 10000; i++) {
            if (m_lockedLayers[i]) {
                if (!isFirst) fmt::format_to(std::back_inserter(buffer), ",");
                fmt::format_to(std::back_inserter(buffer), "{}", i);
                isFirst = false;
            }
        }
        return fmt::to_string(buffer);
    }
    int getNextColorChannel();
    int getNextFreeAreaEffectID(cocos2d::CCArray* exclude);
    int getNextFreeBlockID(cocos2d::CCArray* exclude) = win inline {
        auto dict = cocos2d::CCDictionary::create();
        auto node = cocos2d::CCNode::create();
        auto objects = this->getAllObjects();
        this->addExclusionList(exclude, dict);
        for (int i = 0; i < objects->count(); i++) {
            auto object = static_cast<EffectGameObject*>(objects->objectAtIndex(i));
            if (object->m_classType == GameObjectClassType::Effect || object->m_objectID == 1816) {
                auto id = object->m_itemID;
                if (!dict->objectForKey(id)) dict->setObject(node, id);
            }
        }
        for (int i = 0; i < 1001; i++) {
            if (!dict->objectForKey(i)) return i;
        }
        return 1000;
    }
    int getNextFreeEditorLayer(cocos2d::CCArray* exclude);
    int getNextFreeEnterChannel(cocos2d::CCArray* exclude);
    int getNextFreeGradientID(cocos2d::CCArray* exclude);
    int getNextFreeGroupID(cocos2d::CCArray* exclude);
    int getNextFreeItemID(cocos2d::CCArray* exclude);
    int getNextFreeOrderChannel(cocos2d::CCArray* exclude);
    int getNextFreeSFXGroupID(cocos2d::CCArray* exclude) = win inline {
        auto dict = cocos2d::CCDictionary::create();
        auto node = cocos2d::CCNode::create();
        auto objects = this->getAllObjects();
        this->addExclusionList(exclude, dict);
        for (int i = 0; i < objects->count(); i++) {
            auto object = static_cast<SFXTriggerGameObject*>(objects->objectAtIndex(i));
            if (object->m_objectID == 3602 || object->m_objectID == 3603) {
                auto id = object->m_sfxGroup;
                if (id > 0 && !dict->objectForKey(id)) dict->setObject(node, id);
            }
        }
        for (int i = 0; i < 1001; i++) {
            if (!dict->objectForKey(i)) return i;
        }
        return 1000;
    }
    int getNextFreeSFXID(cocos2d::CCArray* exclude) = win inline {
        auto dict = cocos2d::CCDictionary::create();
        auto node = cocos2d::CCNode::create();
        auto objects = this->getAllObjects();
        this->addExclusionList(exclude, dict);
        for (int i = 0; i < objects->count(); i++) {
            auto object = static_cast<SFXTriggerGameObject*>(objects->objectAtIndex(i));
            if (object->m_objectID == 3602) {
                auto id = object->getUniqueSFXID();
                if (id > 0 && !dict->objectForKey(id)) dict->setObject(node, id);
            }
        }
        for (int i = 0; i < 1001; i++) {
            if (!dict->objectForKey(i)) return i;
        }
        return 1000;
    }
    cocos2d::CCRect getObjectRect(GameObject* object, bool forceSize, bool dontCalculate) = win 0x2d5660, imac 0xe1520;
    cocos2d::CCPoint getRelativeOffset(GameObject* object) = win inline, imac 0xe1e70, ios inline {
        return GameToolbox::getRelativeOffset(object, object->m_obUnflippedOffsetPositionFromCenter);
    }
    cocos2d::CCPoint getSavedEditorPosition(int index) = win inline, imac 0xe9630, m1 0xcd900 {
        return index < 10 ? m_savedPositions[index] : cocos2d::CCPoint { 0.f, 0.f };
    }
    gd::string getSavedEditorPositions() = win inline, imac 0xe9670, m1 0xcd928 {
        fmt::memory_buffer buffer;
        for (int i = 0; i < 10; i++) {
            if (i != 0) fmt::format_to(std::back_inserter(buffer), ",");
            fmt::format_to(std::back_inserter(buffer), "{},{}", (int)m_savedPositions[i].x, (int)m_savedPositions[i].y);
        }
        return fmt::to_string(buffer);
    }
    int getSectionCount() = win inline, imac 0xe9ab0, m1 0xcdc74 {
        return m_sections.size();
    }
    int getSelectedEditorOrder() = win inline, m1 0xd2154 {
        if (!m_playbackObject) return 0;
        if (m_playbackObject->m_objectID != 31) return m_playbackObject->m_ordValue;
        return static_cast<StartPosObject*>(m_playbackObject)->m_startSettings->m_targetOrder;
    }
    cocos2d::CCPoint getSelectedEffectPos() = win inline, imac 0xeea00, m1 0xd218c {
        if (!m_playbackObject) return cocos2d::CCPoint { 0.f, 0.f };
        if (m_playbackObject->m_objectID != 1816) return m_playbackObject->m_speedStart;
        return m_playbackObject->getRealPosition();
    }
    int getSelectedOrderChannel() = win inline, m1 0xd211c {
        if (!m_playbackObject) return 0;
        if (m_playbackObject->m_objectID != 31) return m_playbackObject->m_channelValue;
        return static_cast<StartPosObject*>(m_playbackObject)->m_startSettings->m_targetChannel;
    }
    gd::string getSFXIDs() = win 0x2d71c0, imac 0x2d75c0, m1 0xcd530;
    gd::string getSongIDs(bool& multipleSongs) = win 0x2d6e10, m1 0xcd0d8;
    cocos2d::CCArray* getTriggerGroup(int id) = win 0x2deb10, imac 0xf0330;
    void handleAction(bool undo, cocos2d::CCArray* undoObjects) = win 0x2d63b0, m1 0xc8444;
    bool hasAction(bool redo) = win inline, imac 0xe2b60 {
        if (redo) return m_redoObjects->count() != 0;
        else return m_undoObjects->count() != 0;
    }
    bool init(GJGameLevel* level, bool noUI) = win 0x2d1c30, imac 0xdaed0, m1 0xc13e0;
    bool isLayerLocked(int layer) = win inline {
        if (layer < 10000 && m_layerLockingEnabled) {
            return m_lockedLayers[layer];
        }
        return false;
    }
    GameObject* objectAtPosition(cocos2d::CCPoint position) = win 0x2d4eb0, m1 0xc6d04;
    void objectMoved(GameObject* object) = imac 0xea200;
    cocos2d::CCArray* objectsAtPosition(cocos2d::CCPoint position) = win 0x2d5270;
    cocos2d::CCArray* objectsInRect(cocos2d::CCRect rect, bool ignoreGroups) = win 0x2d5b00, imac 0x122190, m1 0xc6790;
    void onPausePlaytest() = win inline {
        auto director = cocos2d::CCDirector::sharedDirector();
        director->getKeyboardDispatcher()->setBlockRepeat(false);
        m_uiLayer->editorPlaytest(false);
        this->quickUpdateAllPositions();
        this->removePlayerCollisionBlock();
        if (m_playTestSmoothFix) {
            director->resetSmoothFixCounter();
            director->setSmoothFixCheck(false);
        }
        m_playbackMode = PlaybackMode::Paused;
        m_player1->pauseSchedulerAndActions();
        m_player2->pauseSchedulerAndActions();
        m_playtestTimeWarp = m_gameState.m_timeWarp;
        this->updateTimeWarp(1.f);
        m_playtestCameraZoom = m_gameState.m_cameraZoom;
        this->pauseAudio();
        if (m_playtestOrderChanged) this->timeObjectChanged();
    }
    void onPlaytest() = win 0x2dfb30, m1 0xd4f38;
    void onResumePlaytest();
    void onStopPlaytest() = win 0x2e0490;
    void pasteAttributeState(GameObject* object, cocos2d::CCArray* objects) = win inline, imac 0xf3a50, m1 0xd67e0 {
        if (!m_copyStateObject) return;

        if (!object) {
            for (auto obj : geode::cocos::CCArrayExt<cocos2d::CCObject*, false>(objects)) {
                this->applyAttributeState(static_cast<GameObject*>(obj), m_copyStateObject);
            }
        }
        else this->applyAttributeState(object, m_copyStateObject);

        if (!GameManager::sharedState()->getGameVariable("0156")) this->pasteGroupState(object, objects);
    }
    void pasteColorState(GameObject* object, cocos2d::CCArray* objects) = win inline {
        if (!m_copyStateObject) return;

        if (object) {
            object->duplicateColorMode(m_copyStateObject);
            object->m_updateParents = true;
        }
        else {
            for (auto obj : geode::cocos::CCArrayExt<cocos2d::CCObject*, false>(objects)) {
                auto gameObject = static_cast<GameObject*>(obj);
                gameObject->duplicateColorMode(m_copyStateObject);
                gameObject->m_updateParents = true;
            }
        }
    }
    void pasteGroupState(GameObject* object, cocos2d::CCArray* objects) = win inline, imac 0xf3b50, m1 0xd68e8 {
        if (!m_copyStateObject) return;

        if (object) return this->applyGroupState(object, m_copyStateObject);

        for (auto obj : geode::cocos::CCArrayExt<cocos2d::CCObject*, false>(objects)) {
            this->applyGroupState(static_cast<GameObject*>(obj), m_copyStateObject);
        }
    }
    void pasteParticleState(ParticleGameObject* object, cocos2d::CCArray* objects) = win inline, imac 0xf3ed0, m1 0xd6c4c {
        if (!m_particleObject) return;

        if (object) {
            object->setParticleString(m_particleObject->m_particleData);
            object->m_hasUniformObjectColor = m_particleObject->m_hasUniformObjectColor;
            object->m_animateOnTrigger = m_particleObject->m_animateOnTrigger;
            object->updateParticle();
        }
        else {
            for (auto obj : geode::cocos::CCArrayExt<cocos2d::CCObject*, false>(objects)) {
                auto gameObject = static_cast<ParticleGameObject*>(obj);
                gameObject->setParticleString(m_particleObject->m_particleData);
                gameObject->m_hasUniformObjectColor = m_particleObject->m_hasUniformObjectColor;
                gameObject->m_animateOnTrigger = m_particleObject->m_animateOnTrigger;
                gameObject->updateParticle();
            }
        }
    }
    void processLoadedMoveActions() = m1 0xd3938;
    void quickUpdateAllPositions() = win 0x2df8c0, imac 0xf1c90, m1 0x544114;
    void recreateGroups() = win 0x2deb70, m1 0xd3dd4;
    void redoLastAction() = win inline, imac 0xe3420 {
        return this->handleAction(false, m_redoObjects);
    }
    void refreshSpecial(GameObject* object) = win inline, m1 0xce610 {
        this->removeSpecial(object);
        this->addSpecial(object);
    }
    void removeAllObjects() = win inline, imac 0xe26b0 {
        m_removingAll = true;
        if (m_editorUI) m_editorUI->deselectAll();
        auto objectsCopy = cocos2d::CCArray::createWithCapacity(m_objects->count());
        objectsCopy->addObjectsFromArray(m_objects);
        for (auto obj : geode::cocos::CCArrayExt<cocos2d::CCObject*, false>(objectsCopy)) {
            this->removeObject(static_cast<GameObject*>(obj), true);
        }
        m_redoObjects->removeAllObjects();
        m_undoObjects->removeAllObjects();
        m_objectCount = 0;
        m_removingAll = false;
    }
    void removeAllObjectsOfType(int objectID) = m1 0xc80e0;
    void removeObject(GameObject* object, bool noUndo) = win 0x2d5fe0;
    void removePlayerCollisionBlock() = win inline {
        if (!m_collisionBlocksAdded) return;
        m_collisionBlocksAdded = false;
        this->removeObjectFromSection(m_player1CollisionBlock);
        this->removeObjectFromSection(m_player2CollisionBlock);
    }
    void removeSpecial(GameObject* object) = win 0x2d8170;
    void resetDelayedSpawnNodes() = win inline {
        for (auto node : m_delayedSpawnNodes) {
            m_delayedSpawnNodes2.push_back(node);
        }
        m_delayedSpawnNodes.clear();
    }
    void resetEffectTriggerOptim(GameObject* object, cocos2d::CCArray* objects) = win inline, imac 0xf17e0 {
        if (object) {
            if (object->m_dontIgnoreDuration) static_cast<EffectGameObject*>(object)->m_endPosition = cocos2d::CCPoint { 0.f, 0.f };
        }
        else {
            for (auto obj : geode::cocos::CCArrayExt<cocos2d::CCObject*, false>(objects)) {
                auto gameObject = static_cast<EffectGameObject*>(obj);
                if (gameObject->m_dontIgnoreDuration) gameObject->m_endPosition = cocos2d::CCPoint { 0.f, 0.f };
            }
        }
    }
    void resetMovingObjects() = win inline, imac 0xf0ed0, m1 0xd4028 {
        auto objects = this->getAllObjects();
        for (int i = 0; i < objects->count(); i++) {
            auto object = static_cast<GameObject*>(objects->objectAtIndex(i));
            object->resetMoveOffset();
            object->setPosition(object->getRealPosition());
            this->updateObjectSection(object);
        }
    }
    void resetObjectVector() = win inline, ios inline {
        for (int i = 0; i < 10000; i++) {
            m_objectVector[i] = nullptr;
        }
    }
    void resetPlayback() = win inline, m1 0xd21c8 {
        m_playbackOrder = 0;
        this->clearActivatedAudioTriggers();
        m_activateAudioTriggers = true;
    }
    void resetToggledGroups() = win inline, imac 0xee560, m1 0xd1db8, ios inline {
        for (int i = 0; i < 10000; i++) {
            m_toggledGroupStates[i] = 0;
            m_toggledGroups[i] = false;
        }
    }
    void resetToggledGroupsAndObjects() = win 0x2de470, imac 0xf0390, m1 0xd3648;
    void resetUnusedColorChannels() = win 0x2db2a0;
    void reverseKeyframeAnimationOrder(int keyframeGroup) = win inline, imac 0xf4380, m1 0xd70b0 {
        static_cast<cocos2d::CCArray*>(m_keyframeGroups->objectForKey(keyframeGroup))->reverseObjects();
        this->updateKeyframeOrder(keyframeGroup);
    }
    void reverseObjectChanged(EffectGameObject* object) = win inline, imac 0xf0450 {
        if (object->m_isReverse) m_drawGridLayer->addToSpeedObjects(object);
        else m_drawGridLayer->removeFromSpeedObjects(object);
    }
    float rotationForSlopeNearObject(GameObject* object) = win 0x2d4d20, imac 0xe0ae0, m1 0xc65fc;
    ColorAction* runColorEffect(EffectGameObject* object, int colorID, float delay, float interval, bool instant) = win 0x2dd6d0;
    void saveEditorPosition(cocos2d::CCPoint& position, int index) = win inline, m1 0xcd8e8 {
        if (index < 10) m_savedPositions[index] = position;
    }
    void setObjectCount(int count) {
        m_objectCount = count;
    }
    bool shouldBlend(int colorID) = win 0x2d3530;
    void sortBatchnodeChildren(float unused) = win inline {
        for (auto obj : geode::cocos::CCArrayExt<cocos2d::CCObject*, false>(m_batchNodes)) {
            static_cast<cocos2d::CCSpriteBatchNode*>(obj)->manualSortAllChildren();
        }
    }
    void spawnGroupPreview(int groupID, float xPos, float delay, float currentTime, float playTime, float boundTime, bool ordered, bool active) = win 0x2ddda0, imac 0xeed30, m1 0xd244c;
    void stopPlayback() = win inline, m1 0xd4960 {
        auto engine = FMODAudioEngine::sharedEngine();
        engine->stopAllMusic(true);
        engine->stopAllEffects();
    }
    void stopTriggersInGroup(int id, float delay) = win 0x2dd9e0, imac 0xefdf0;
    void timeObjectChanged() = win inline, imac 0xf04e0 {
        m_spawnOrderObjectsChanged = true;
    }
    void toggleBackground(bool visible) = win inline, imac 0xee6f0, m1 0xd1f24, ios inline {
        if (m_background) m_background->setVisible(visible);
    }
    void toggleGrid(bool visible) = win inline, imac 0xee720, m1 0xd1f3c, ios inline {
        m_drawGridLayer->setVisible(visible);
    }
    void toggleGround(bool enable) = win inline, imac 0xdec50 {
        m_hideGround = !enable;
        m_groundLayer->setVisible(enable);
    }
    void toggleGroupPreview(int id, bool enable) = win 0x2de1a0, m1 0xd3028;
    void toggleLockActiveLayer() = win inline {
        if (m_currentLayer < 0 || m_currentLayer > 9999 || !m_layerLockingEnabled) return;
        m_lockedLayers[m_currentLayer] = !m_lockedLayers[m_currentLayer];
    }
    void transferDefaultColors(GJEffectManager* src, GJEffectManager* dest) = win 0x2dbc40, imac 0xee740, m1 0xd1f4c;
    void triggerFollowCommand(EffectGameObject* object) = win inline, imac 0xf1990, m1 0xd4a40, ios inline {
        m_levelSettings->m_effectManager->createFollowCommand(
            object->m_followXMod,
            object->m_followYMod,
            object->m_duration,
            object->m_targetGroupID,
            object->m_centerGroupID,
            object->m_uniqueID,
            object->m_controlID
        );
    }
    void triggerPlayerFollowCommand(EffectGameObject* object) = win inline, imac 0xf19e0, m1 0xd4a6c, ios inline {
        m_levelSettings->m_effectManager->createPlayerFollowCommand(
            object->m_followYSpeed,
            object->m_followYDelay,
            object->m_followYOffset,
            object->m_followYMaxSpeed,
            object->m_duration,
            object->m_targetGroupID,
            object->m_uniqueID,
            object->m_controlID
        );
    }
    void triggerRotateCommand(EffectGameObject* object) = win inline, imac 0xf1900, m1 0xd49d4, ios inline {
        m_levelSettings->m_effectManager->createRotateCommand(
            object->m_times360 * 360.f + object->m_rotationDegrees,
            object->m_duration,
            object->m_targetGroupID,
            object->m_centerGroupID,
            (int)object->m_easingType,
            object->m_easingRate,
            object->m_lockObjectRotation,
            object->m_targetPlayer1,
            object->m_targetPlayer2,
            object->m_uniqueID,
            object->m_controlID
        );
    }
    bool tryUpdateSpeedObject(EffectGameObject* object, bool noPreview) = win 0x2d8760, m1 0xce234;
    bool typeExistsAtPosition(int objectID, cocos2d::CCPoint position, bool flipX, bool flipY, float rotation) = win 0x2d48b0;
    void undoLastAction() = win inline, imac 0xe3440 {
        return this->handleAction(true, m_undoObjects);
    }
    void unlockAllLayers() = win inline, m1 0xcdd1c {
        for (int i = 0; i < 10000; i++) {
            m_lockedLayers[i] = false;
        }
    }
    void updateAnimateOnTriggerObjects(bool animate) = win 0x2e1300;
    void updateArt(float dt) = win inline, ios inline {
        if (m_playbackMode != PlaybackMode::Not) return;
        this->updateGridLayerParent();
        m_inShaderParent->setVisible(m_inShaderParent->getChildrenCount() > 1 || m_inShaderObjectLayer->getChildrenCount() != 0);
        m_aboveShaderParent->setVisible(m_aboveShaderParent->getChildrenCount() > 1 || m_aboveShaderObjectLayer->getChildrenCount() != 0);
        this->updateGradientLayers();
        this->updateExtraGameLayers();
    }
    void updateBlendValues() = win 0x2de510, imac 0xefa90, m1 0xd2e18;
    void updateEditor(float dt);
    void updateEditorMode() = win 0x2db600, imac 0xde880;
    void updateGameObjects() = win 0x2dbf70;
    void updateGridLayer() = win inline {
        auto parent = m_shaderLayer && m_shaderLayer->m_state.m_usesShaders ? m_aboveShaderObjectLayer : m_objectLayer;
        if (m_drawGridLayer->getParent() != parent) {
            m_drawGridLayer->retain();
            m_drawGridLayer->removeFromParentAndCleanup(false);
            parent->addChild(m_drawGridLayer, m_drawGridLayer->getZOrder());
            m_drawGridLayer->release();
        }
    }
    void updateGridLayerParent() = win 0x2d3480;
    void updateKeyframeObjects() = win 0x2e1960;
    void updateKeyframeVisibility(bool visible) = win inline, ios inline {}
    void updateLevelFont(int index) = win 0x2deed0, imac 0xf0f70, m1 0xd40cc;
    void updateObjectColors(cocos2d::CCArray* gameObjects) = win 0x2d9d60, imac 0xeb650, m1 0xcf4bc;
    void updateOptions();
    void updatePreviewAnim() = win inline {
        auto previewAnimations = GameManager::sharedState()->getGameVariable("0118");
        if (m_previewAnimations == previewAnimations) return;
        m_previewAnimations = previewAnimations;
        for (int i = 0; i < m_objects->count(); i++) {
            auto object = static_cast<EnhancedGameObject*>(m_objects->objectAtIndex(i));
            if (object->m_classType == GameObjectClassType::Animated) {
                static_cast<AnimatedGameObject*>(object)->updateObjectAnimation();
            }
            if (!m_previewAnimations) {
                if (object->getHasSyncedAnimation()) object->resetSyncedAnimation();
                if (object->getHasRotateAction()) object->updateRotateAction(0.f);
            }
        }
    }
    void updatePreviewParticle(ParticleGameObject* object) = win 0x2e14a0;
    void updatePreviewParticles();
    void updateToggledGroups() = win 0x2de340, imac 0xef950, m1 0xd2d00;
    bool validGroup(GameObject* object, bool checkLockedLayers) = win inline {
        int currentLayer = m_currentLayer;
        int editorLayer = object->m_editorLayer;
        int editorLayer2 = object->m_editorLayer2;
        if (editorLayer2 == 0) editorLayer2 = -1;
        auto result = currentLayer == -1 || editorLayer2 == currentLayer || editorLayer == currentLayer;
        if (checkLockedLayers) {
            editorLayer2 = std::clamp(editorLayer2, -1, 9999);
            result = false;
            if (currentLayer == -1 || editorLayer2 == currentLayer || editorLayer == currentLayer) {
                editorLayer = std::clamp(editorLayer, 0, 9999);
                result = !m_lockedLayers[editorLayer] && (editorLayer2 == -1 || !m_lockedLayers[editorLayer2]);
            }
        }
        return result;
    }

    bool m_drawTriggerBoxes;
    bool m_showGrid;
    bool m_hideGridOnPlay;
    bool m_drawEffectLines;
    bool m_showGround;
    bool m_showDurationLines;
    bool m_increaseMaxUndoRedo;
    bool m_hideBackground;
    bool m_gv0120;
    bool m_layerLockingEnabled;
    bool m_playtestOrderChanged;
    bool m_previewParticles;
    bool m_previewAnimations;
    bool m_previewShaders;
    bool m_hideParticleIcons;
    bool m_alwaysHideParticleIcons;
    bool m_playTestSmoothFix;
    bool m_hasHighDetail;
    bool m_unk36ca;
    int m_unk36cc;
    bool m_collisionBlocksAdded;
    int m_unk36d4;
    cocos2d::CCArray* m_durationObjects;
    cocos2d::CCArray* m_pulseTriggers;
    cocos2d::CCArray* m_colorTriggers;
    cocos2d::CCArray* m_alphaTriggers;
    cocos2d::CCArray* m_spawnTriggers;
    cocos2d::CCArray* m_moveTriggers;
    cocos2d::CCArray* m_cameraGuideTriggers;
    cocos2d::CCArray* m_particleObjects;
    cocos2d::CCArray* m_keyframeObjects;
    cocos2d::CCDictionary* m_unk3720;
    cocos2d::CCArray* m_playtestTriggers;
    GameObject* m_copyStateObject;
    ParticleGameObject* m_particleObject;
    cocos2d::CCDictionary* m_unk3740;
    cocos2d::CCArray* m_unk3748;
    bool m_keepEditorLayer;
    bool m_unk3751;
    geode::SeedValueRSV m_coinCount;
    bool m_triggersChanged;
    bool m_colorTriggersChanged;
    bool m_pulseTriggersChanged;
    bool m_alphaTriggersChanged;
    bool m_spawnTriggersChanged;
    cocos2d::CCArray* m_spawnOrderObjects;
    bool m_spawnOrderObjectsChanged;
    bool m_sortSpawnNodes;
    cocos2d::CCDictionary* m_unk3778;
    cocos2d::CCDictionary* m_unk3780;
    bool m_initializing;
    short m_currentLayer;
    float m_playtestZoom;
    OBB2D* m_currentOBB2D;
    float m_playtestTimeWarp;
    float m_playtestCameraZoom;
    cocos2d::CCSprite* m_playtestDeathSprite;
    float m_trailTimer;
    bool m_soloMode;
    bool m_nonSquareRotation;
    EditorUI* m_editorUI;
    cocos2d::CCArray* m_undoObjects;
    cocos2d::CCArray* m_redoObjects;
    geode::SeedValueRSV m_objectCount;
    DrawGridLayer* m_drawGridLayer;
    bool m_updateColorSprites;
    bool m_previewMode;
    bool m_alwaysPreviewMode;
    gd::string m_levelString;
    gd::vector<GameObject*> m_objectVector;
    gd::vector<GameObject*> m_loadedMoveObjects;
    cocos2d::CCDictionary* m_triggerGroupsDict;
    gd::vector<cocos2d::CCArray*> m_triggerGroups;
    gd::vector<cocos2d::CCPoint> m_playerPoints;
    gd::vector<gd::vector<cocos2d::CCPoint>> m_player2Points;
    gd::vector<cocos2d::CCPoint> m_touchPoints;
    gd::vector<bool> m_sortedGroups;
    gd::vector<bool> m_toggledGroups;
    gd::vector<bool> m_lockedLayers;
    gd::vector<cocos2d::CCPoint> m_savedPositions;
    cocos2d::CCPoint m_previewPosition;
    gd::vector<bool> m_blendingColors;
    gd::vector<bool> m_blendingColors2;
    gd::vector<unsigned char> m_toggledGroupStates;
    gd::vector<float> m_spawnGroupDelays;
    double m_sessionTime;
    bool m_removingAll;
    EffectGameObject* m_playbackObject;
    int m_playbackOrder;
    int m_duplicateKeyframeGroup;
    gd::vector<DelayedSpawnNode*> m_delayedSpawnNodes;
    gd::vector<DelayedSpawnNode*> m_delayedSpawnNodes2;
    bool m_playbackActive;
    bool m_activateAudioTriggers;
}

[[link(android)]]
class LevelFeatureLayer : FLAlertLayer {
    // virtual ~LevelFeatureLayer();

    static LevelFeatureLayer* create(int levelID) = m1 0x45bfe8;

    virtual void keyBackClicked() = m1 0x45cb94, imac 0x505240;

    bool init(int levelID);
    void onClose(cocos2d::CCObject* sender);
    void onDown(cocos2d::CCObject* sender) = imac 0x504ff0, m1 0x45c944;
    void onDown2(cocos2d::CCObject* sender) = imac 0x5050a0, m1 0x45c9f0;
    void onRemoveValues(cocos2d::CCObject* sender) = m1 0x45cae8;
    void onSetEpicOnly(cocos2d::CCObject* sender) = m1 0x45c8f0;
    void onSetFeatured(cocos2d::CCObject* sender);
    void onToggleEpic(cocos2d::CCObject* sender) = m1 0x45cb3c;
    void onUp(cocos2d::CCObject* sender) = imac 0x505050, m1 0x45c99c;
    void onUp2(cocos2d::CCObject* sender) = imac 0x505100, m1 0x45ca48;
    void updateStars() = m1 0x45ca9c;

    cocos2d::CCLabelBMFont* m_featureLabel;
    int m_levelID;
    int m_featurePosition;
    bool m_epicOnly;
    cocos2d::CCSprite* m_epicSprite;
}

[[link(android)]]
class LevelInfoLayer : cocos2d::CCLayer, LevelDownloadDelegate, LevelUpdateDelegate, RateLevelDelegate, LikeItemDelegate, FLAlertLayerProtocol, LevelDeleteDelegate, NumberInputDelegate, SetIDPopupDelegate, TableViewCellDelegate {
    LevelInfoLayer() {
        m_isBusy = false;
        m_playBtnMenu = nullptr;
        m_level = nullptr;
        m_coins = nullptr;
        m_likeBtn = nullptr;
        m_starRateBtn = nullptr;
        m_demonRateBtn = nullptr;
        m_unk2 = nullptr;
        m_lengthLabel = nullptr;
        m_exactLengthLabel = nullptr;
        m_downloadsLabel = nullptr;
        m_likesLabel = nullptr;
        m_orbsLabel = nullptr;
        m_folderLabel = nullptr;
        m_cloneBtn = nullptr;
        m_unk3 = nullptr;
        m_likesIcon = nullptr;
        m_orbsIcon = nullptr;
        m_levelType = GJLevelType::Default;
        m_noUpdateAlert = false;
        m_enterTransitionFinished = false;
        m_circle = nullptr;
        m_difficultySprite = nullptr;
        m_starsIcon = nullptr;
        m_starsLabel = nullptr;
        m_icons = nullptr;
        m_iconOffset = 0.f;
        m_challenge = false;
        m_playScene = nullptr;
        m_playSprite = nullptr;
        m_progressTimer = nullptr;
        m_songWidget = nullptr;
    }
    ~LevelInfoLayer() = win inline, imac 0x2bcbb0, m1 0x2592fc {
        CC_SAFE_RELEASE(m_level);
        CC_SAFE_RELEASE(m_circle);
        CC_SAFE_RELEASE(m_coins);
        CC_SAFE_RELEASE(m_icons);
        auto glm = GameLevelManager::sharedState();
        if (glm->m_levelDownloadDelegate == this) glm->m_levelDownloadDelegate = nullptr;
        if (glm->m_levelUpdateDelegate == this) glm->m_levelUpdateDelegate = nullptr;
    }

    static LevelInfoLayer* create(GJGameLevel* level, bool challenge) = win 0x2f6eb0, imac 0x2bce20, m1 0x2594a8;
    static cocos2d::CCScene* scene(GJGameLevel* level, bool challenge) = win 0x2f6e60, m1 0x25944c;

    virtual void keyBackClicked() = win 0x3005a0, m1 0x260cac, imac 0x2c4980;
    virtual void keyDown(cocos2d::enumKeyCodes key, double timestamp) = win 0x3005b0, m1 0x260cb8, imac 0x2c49b0;
    virtual void numberInputClosed(NumberInputLayer* layer) = win 0x2fd420, imac 0x2c4180, m1 0x26049c;
    virtual bool cellPerformedAction(TableViewCell* cell, int listType, CellAction action, cocos2d::CCNode* parent) = win 0x2f9770, m1 0x25e9e8, imac 0x2c2610;
    virtual void levelDownloadFinished(GJGameLevel* level) = win 0x2fb7f0, imac 0x2c33b0, m1 0x25f718;
    virtual void levelDownloadFailed(int response) = win 0x2fbb60, imac 0x2c36a0, m1 0x25f9d8;
    virtual void levelUpdateFinished(GJGameLevel* level, UpdateResponse response) = win 0x2fbc90, m1 0x25fabc, imac 0x2c3790;
    virtual void levelUpdateFailed(int response) = win 0x2fbdf0, imac 0x2c3980, m1 0x25fcc4;
    virtual void levelDeleteFinished(int id) = win 0x2fbf20, m1 0x25fdac, imac 0x2c3a80;
    virtual void levelDeleteFailed(int id) = win 0x2fc060, m1 0x25fea4, imac 0x2c3b90;
    virtual void rateLevelClosed() = win 0x2fe4a0, m1 0x260994, imac 0x2c4670;
    virtual void likedItem(LikeItemType type, int id, bool liked) = win 0x2fe720, m1 0x2609a0, imac 0x2c46a0;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x2fffe0, imac 0x2c47b0, m1 0x260ac4;
    virtual void setIDPopupClosed(SetIDPopup* popup, int value) = win 0x2f9960, m1 0x25eb40, imac 0x2c2730;
    virtual void onEnterTransitionDidFinish() = win 0x2fc1a0, m1 0x260094, imac 0x2c3d70;

    void confirmClone(cocos2d::CCObject* sender) = win 0x2fd5f0, imac 0x2c1be0;
    void confirmDelete(cocos2d::CCObject* sender) = win 0x2fd760;
    void confirmMoveToBottom(cocos2d::CCObject* sender) = win 0x2ff070;
    void confirmMoveToTop(cocos2d::CCObject* sender) = win 0x2fef30;
    void confirmOwnerDelete(cocos2d::CCObject* sender) = win 0x2fd8a0, imac 0x2c19e0;
    void downloadLevel() = win 0x2f9d30, m1 0x25bfa4;
    void incrementDislikes() = win inline, ios inline {
        m_level->m_dislikes++;
        this->updateLabelValues();
    }
    void incrementLikes() = win inline, m1 0x260a14, ios inline {
        m_level->m_likes++;
        this->updateLabelValues();
    }
    bool init(GJGameLevel* level, bool challenge) = win 0x2f70e0, imac 0x2bd000, m1 0x259604;
    void loadLevelStep() = win 0x2fcff0, imac 0x2c3ee0, m1 0x26020c;
    void onAddToList(cocos2d::CCObject* sender) = win 0x2f9720, imac 0x2c25b0, m1 0x25e990;
    void onBack(cocos2d::CCObject* sender) = win 0x3004b0;
    void onClone(cocos2d::CCObject* sender) = win inline, imac 0x2c4310, m1 0x260668 {
        if (this->shouldDownloadLevel() || m_isBusy) return;
        this->setKeypadEnabled(false);
        m_isBusy = true;
        GameManager::sharedState()->m_sceneEnum = 2;
        auto level = GameLevelManager::sharedState()->createNewLevel();
        level->copyLevelInfo(m_level);
        if (m_level->m_originalLevel.value() == 0) {
            if (m_level->m_levelID.value() != 0) {
                level->m_originalLevel = m_level->m_levelID;
            }
        }
        else {
            level->m_originalLevel = m_level->m_originalLevel;
        }
        cocos2d::CCDirector::sharedDirector()->replaceScene(cocos2d::CCTransitionFade::create(0.5f, EditLevelLayer::scene(level)));
    }
    void onDelete(cocos2d::CCObject* sender) = win inline, m1 0x2607ac {
        m_playBtnMenu->setEnabled(false);
        GameLevelManager::sharedState()->deleteLevel(m_level);
        this->onBack(nullptr);
        m_isBusy = true;
    }
    void onFavorite(cocos2d::CCObject* sender) = win 0x2f99f0;
    void onFeatured(cocos2d::CCObject* sender) = win inline, ios inline {}
    void onGarage(cocos2d::CCObject* sender) = win 0x2f9b70;
    void onInfo(cocos2d::CCObject* sender) = win 0x2fd150, imac 0x2c14f0;
    void onLevelInfo(cocos2d::CCObject* sender) = win 0x2fece0;
    void onLevelLeaderboard(cocos2d::CCObject* sender) = win 0x2f9a90, imac 0x2c1520;
    void onLevelOptions(cocos2d::CCObject* sender) = win 0x2feb90;
    void onLike(cocos2d::CCObject* sender) = win 0x2fe630;
    void onOwnerDelete(cocos2d::CCObject* sender) = win inline {
        if (m_isBusy) return;
        auto glm = GameLevelManager::sharedState();
        glm->m_levelDeleteDelegate = this;
        glm->deleteServerLevel(m_level->m_levelID.value());
        m_circle->setVisible(true);
    }
    void onPlay(cocos2d::CCObject* sender) = win 0x2fc1c0, imac 0x2bf3e0;
    void onPlayReplay(cocos2d::CCObject* sender) = win inline, ios inline {
        if (m_isBusy) return;
        if (this->shouldDownloadLevel()) {
            this->downloadLevel();
        }
        else {
            auto audioEngine = FMODAudioEngine::sharedEngine();
            audioEngine->stopAllMusic(true);
            audioEngine->playEffect("playSound_01.ogg", 1.f, 0.f, .3f);
            GameManager::sharedState()->m_sceneEnum = 3;
            cocos2d::CCDirector::sharedDirector()->replaceScene(cocos2d::CCTransitionFade::create(.5f, PlayLayer::scene(m_level, true, false)));
        }
    }
    void onRate(cocos2d::CCObject* sender) = win 0x2fdcd0;
    void onRateDemon(cocos2d::CCObject* sender) = win 0x2fe4b0;
    void onRateStars(cocos2d::CCObject* sender) = win 0x2fdfb0;
    void onRateStarsMod(cocos2d::CCObject* sender);
    void onSetFolder(cocos2d::CCObject* sender) = win 0x2f98c0, imac 0x2c2510;
    void onUpdate(cocos2d::CCObject* sender) = win 0x2fea50;
    void onViewProfile(cocos2d::CCObject* sender) = win 0x2fec30, imac 0x2bf360;
    void playStep2() = m1 0x2600bc;
    void playStep3() = win 0x2fcf20, m1 0x260180;
    void playStep4() = win 0x2fd0a0, m1 0x2602bc;
    void setupLevelInfo() = win 0x2faba0, m1 0x25c088;
    void setupPlatformerStats() = win 0x2fa060, m1 0x25cbe0;
    void setupProgressBars() = win 0x2fa490, m1 0x25cf80;
    bool shouldDownloadLevel() = win 0x2f9c00;
    void showSongWarning() = win inline, imac 0x2c3ca0 {
        auto alert = FLAlertLayer::create(
            this,
            "No Song",
            "This level uses a <cl>custom song</c> that has not been <cg>downloaded</c> yet.\n"
            "Do you want to play without music?\n"
            "<cy>Download by using the bar below</c>",
            "Cancel",
            "Play",
            300.f
        );
        alert->setTag(9);
        alert->show();
    }
    void showUpdateAlert(UpdateResponse type) = win 0x2fbd00, imac 0x2c37f0, m1 0x25fb2c;
    void tryCloneLevel(cocos2d::CCObject* sender) = win 0x2fd190;
    void tryShowAd() = win inline, m1 0x25e9c8, ios inline {
        GameManager::sharedState()->tryShowInterstitial(120, 140, 0);
    }
    void updateLabelValues() = win 0x2ff1a0, imac 0x2c28d0, m1 0xc268;
    void updateSideButtons() = win 0x2fe790, m1 0x25db88;

    bool m_isBusy;
    cocos2d::CCMenu* m_playBtnMenu;
    GJGameLevel* m_level;
    cocos2d::CCArray* m_coins;
    CCMenuItemSpriteExtra* m_likeBtn;
    CCMenuItemSpriteExtra* m_starRateBtn;
    CCMenuItemSpriteExtra* m_demonRateBtn;
    void* m_unk2;
    cocos2d::CCLabelBMFont* m_lengthLabel;
    cocos2d::CCLabelBMFont* m_exactLengthLabel;
    cocos2d::CCLabelBMFont* m_downloadsLabel;
    cocos2d::CCLabelBMFont* m_likesLabel;
    cocos2d::CCLabelBMFont* m_orbsLabel;
    cocos2d::CCLabelBMFont* m_folderLabel;
    CCMenuItemSpriteExtra* m_cloneBtn;
    void* m_unk3;
    cocos2d::CCSprite* m_likesIcon;
    cocos2d::CCSprite* m_orbsIcon;
    GJLevelType m_levelType;
    bool m_noUpdateAlert;
    bool m_enterTransitionFinished;
    LoadingCircle* m_circle;
    GJDifficultySprite* m_difficultySprite;
    cocos2d::CCSprite* m_starsIcon;
    cocos2d::CCLabelBMFont* m_starsLabel;
    cocos2d::CCArray* m_icons;
    float m_iconOffset;
    cocos2d::CCPoint m_basePosition;
    float m_baseStarsY;
    bool m_challenge;
    cocos2d::CCScene* m_playScene;
    cocos2d::CCSprite* m_playSprite;
    cocos2d::CCProgressTimer* m_progressTimer;
    CustomSongWidget* m_songWidget;
}

[[link(android)]]
class LevelLeaderboard : FLAlertLayer, LeaderboardManagerDelegate, FLAlertLayerProtocol {
    // virtual ~LevelLeaderboard();

    static LevelLeaderboard* create(GJGameLevel* level, LevelLeaderboardType type, LevelLeaderboardMode mode) = win 0x300750, imac 0x3d9a60, m1 0x358b70;

    virtual void registerWithTouchDispatcher() = win 0x42660, m1 0x35a96c, imac 0x3db9f0;
    virtual void keyBackClicked() = win 0x846c0, m1 0x35a8f0, imac 0x3db980;
    virtual void show() = win 0x86810, m1 0x35ae44, imac 0x3dbf30;
    virtual void loadLeaderboardFinished(cocos2d::CCArray* scores, char const* key) = win 0x302910, imac 0x3dbc30, m1 0x35ab74;
    virtual void loadLeaderboardFailed(char const* key) = win 0x3029b0, imac 0x3dbd70, m1 0x35acc0;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x301d40, m1 0x35a568, imac 0x3db5d0;
    virtual void updateUserScoreFinished() = win 0x302360, imac 0x3db7d0, m1 0x35a760;
    virtual void updateUserScoreFailed() = win 0x302370, m1 0x35a76c, imac 0x3db800;

    void deleteLocalScores() = win inline, imac 0x3db480 {
        m_level->m_localBestTimes.clear();
        m_level->m_localBestPoints.clear();
        auto parent = this->getParent();
        this->onClose(nullptr);
        if (parent) {
            parent->addChild(TextAlertPopup::create("Local scores reset.", 1.f, .6f, 150, ""), 100);
        }
    }
    cocos2d::CCArray* getLocalScores() = win 0x301ec0, m1 0x35a600;
    CCMenuItemSpriteExtra* getSpriteButton(gd::string frame, cocos2d::SEL_MenuHandler selector, cocos2d::CCMenu* menu, float scale, cocos2d::CCPoint position, int button) = win 0x301a20, imac 0x3dac70, m1 0x359bc0;
    bool init(GJGameLevel* level, LevelLeaderboardType type, LevelLeaderboardMode mode) = win 0x300890;
    bool isCorrect(char const* key) = win 0x302710, m1 0x35a9a4;
    void loadScores() = win 0x302090, m1 0x35a03c;
    void onChangeMode(cocos2d::CCObject* sender) = win 0x302510, m1 0x359d94;
    void onChangeType(cocos2d::CCObject* sender) = m1 0x359fc8;
    void onClose(cocos2d::CCObject* sender) = win 0x84690, m1 0x359ebc;
    void onDeleteLocalScores(cocos2d::CCObject* sender) = imac 0x3dae90;
    void onUpdate(cocos2d::CCObject* sender) = m1 0x25d984;
    void reloadLeaderboard(LevelLeaderboardType type, LevelLeaderboardMode mode) = win 0x302380, imac 0x3db8a0, m1 0x35a814;
    void setupLeaderboard(cocos2d::CCArray* scores) = win 0x302ac0, m1 0x35a244;

    GJGameLevel* m_level;
    LevelLeaderboardType m_type;
    LevelLeaderboardMode m_mode;
    cocos2d::CCArray* m_scores;
    GJCommentListLayer* m_list;
    LoadingCircle* m_circle;
    TextArea* m_noInternet;
    CCMenuItemSpriteExtra* m_refreshBtn;
    CCMenuItemSpriteExtra* m_timeBtn;
    CCMenuItemSpriteExtra* m_pointsBtn;
}

[[link(android)]]
class LevelListCell : TableViewCell {
    LevelListCell(char const* identifier, float width, float height) = win 0xbec50, m1 0x1fe2fc, ios inline : TableViewCell(identifier, width, height) {
        m_levelList = nullptr;
        m_addingLevel = false;
        this->init();
    }
    ~LevelListCell() = win inline {
        CC_SAFE_RELEASE(m_levelList);
    }

    static LevelListCell* create(float width, float height) = win inline, imac 0x258ef0, m1 0x1fe260, ios inline {
        auto ret = new LevelListCell(" ", width, height);
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win inline, m1 0x1fe344, imac 0x259040 { return true; }
    virtual void draw() = win 0xade40, m1 0x1fe45c, imac 0x259180;

    void loadFromList(GJLevelList* list) = win 0xbecd0, imac 0x245120, m1 0x1ebef8;
    void onClick(cocos2d::CCObject* sender) = win 0xc0100;
    void onListInfo(cocos2d::CCObject* sender) = m1 0x1fe44c;
    void onViewProfile(cocos2d::CCObject* sender) = win 0xc0230, imac 0x259130;
    void updateBGColor(int index) = win inline, imac 0x246610, m1 0x1ed450 {
        m_backgroundLayer->setColor(index % 2 == 0 ? cocos2d::ccColor3B { 161, 88, 44 } : cocos2d::ccColor3B { 194, 114, 62 });
        m_backgroundLayer->setOpacity(255);
    }

    GJLevelList* m_levelList;
    bool m_addingLevel;
}

[[link(android)]]
class LevelListDeleteDelegate {
    virtual void levelListDeleteFinished(int id) {}
    virtual void levelListDeleteFailed(int id) {}
}

[[link(android)]]
class LevelListLayer : LevelBrowserLayer, TextInputDelegate, SelectListIconDelegate, LikeItemDelegate, LevelListDeleteDelegate {
    LevelListLayer() = m1 0x2eecf4 {
        m_buttonMenu = nullptr;
        m_levelList = nullptr;
        m_likeButton = nullptr;
        m_exiting = false;
        m_titleInput = nullptr;
        m_editMode = 0;
        m_objects = nullptr;
        m_diffSprite = nullptr;
        m_featureSprite = nullptr;
        m_exited = false;
    }
    ~LevelListLayer() = win inline, imac 0x35b520, m1 0x2e6b40 {
        GameManager::sharedState()->m_sceneEnum = 13;
        CC_SAFE_RELEASE(m_levelList);
        CC_SAFE_RELEASE(m_objects);
        auto glm = GameLevelManager::sharedState();
        if (glm->m_levelListDeleteDelegate == this) glm->m_levelListDeleteDelegate = nullptr;
    }

    static LevelListLayer* create(GJLevelList* list) = win inline, imac 0x35b7e0, m1 0x2e6d48 {
        auto ret = new LevelListLayer();
        if (ret->init(list)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static cocos2d::CCScene* scene(GJLevelList* list) = win 0x303190, m1 0x2e6ca8;

    virtual void onEnter() = win 0x304e50, m1 0x2e9e98, imac 0x35eb10;
    virtual void onExit() = win 0x304e80, m1 0x2e9ed4, imac 0x35eb40;
    virtual void loadLevelsFinished(cocos2d::CCArray* levels, char const* key, int type) = win 0x306650, m1 0x2ea290, imac 0x35ef00;
    virtual void loadLevelsFailed(char const* key, int type) = win 0x2cc3b0, m1 0x2ea4a8, imac 0x35f130;
    virtual void onBack(cocos2d::CCObject* sender) = win 0x306eb0, imac 0x35f670, m1 0x2ea910;
    virtual void shareCommentClosed(gd::string text, ShareCommentLayer* layer) = win 0x3076b0, imac 0x35fdd0, m1 0x2eb040;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x3072d0, imac 0x35f9f0, m1 0x2eac90;
    virtual void setIDPopupClosed(SetIDPopup* popup, int value) = win 0x306e00, imac 0x35f510, m1 0x2ea7c4;
    virtual cocos2d::CCArray* updateResultArray(cocos2d::CCArray* results) = win 0x306ea0, m1 0x2ea908, imac 0x35f650;
    virtual bool cellPerformedAction(TableViewCell* cell, int listType, CellAction action, cocos2d::CCNode* parent) = win 0x3069b0, m1 0x2ea4b4, imac 0x35f160;
    virtual void likedItem(LikeItemType type, int id, bool liked) = win 0x3078d0, m1 0x2eb134, imac 0x35fec0;
    virtual void iconSelectClosed(SelectListIconLayer* layer) = win 0x307b80, imac 0x360100, m1 0x2eb308;
    virtual void levelListDeleteFinished(int id) = win 0x3084a0, m1 0x2eb438, imac 0x360290;
    virtual void levelListDeleteFailed(int id) = win 0x3085d0, m1 0x2eb528, imac 0x360390;
    virtual void textInputOpened(CCTextInputNode* node) = win 0x308990, m1 0x2eb824, imac 0x360690;
    virtual void textInputClosed(CCTextInputNode* node) = win 0x308700, imac 0x360490, m1 0x2eb618;
    virtual void textChanged(CCTextInputNode* node) = win 0x308af0, imac 0x360760, m1 0x2eb928;

    void cloneList() = win 0x307f60, imac 0x35fb60;
    void confirmClone(cocos2d::CCObject* sender) = win 0x307e70;
    void confirmDelete(cocos2d::CCObject* sender) = win 0x3081f0;
    void confirmOwnerDelete(cocos2d::CCObject* sender) = win 0x308320;
    bool init(GJLevelList* list) = win 0x3033c0, m1 0x1a2ab4;
    void onClaimReward(cocos2d::CCObject* sender) = win 0x305e20, imac 0x35eb60, m1 0x2e9efc;
    void onDelete() = win inline, m1 0x2eada4 {
        m_buttonMenu->setEnabled(false);
        GameLevelManager::sharedState()->deleteLevelList(m_levelList);
        this->onBack(nullptr);
        m_exiting = true;
    }
    void onDescription(cocos2d::CCObject* sender) = win 0x3075e0, imac 0x35d960;
    void onFavorite(cocos2d::CCObject* sender) = win 0x3074b0;
    void onInfo(cocos2d::CCObject* sender) = win 0x3077b0, imac 0x35d540;
    void onLike(cocos2d::CCObject* sender) = win 0x3077f0;
    void onListInfo(cocos2d::CCObject* sender) = m1 0x2e8fd8;
    void onRefreshLevelList(cocos2d::CCObject* sender) = win 0x306490, m1 0x2e880c;
    void onSelectIcon(cocos2d::CCObject* sender) = win 0x307a30;
    void onShare(cocos2d::CCObject* sender) = win 0x307ba0;
    void onToggleEditMode(cocos2d::CCObject* sender) = win 0x307e30, imac 0x35da50, m1 0x2e8e40;
    void onViewProfile(cocos2d::CCObject* sender) = win 0x307470, imac 0x35d3f0;
    void ownerDelete() = win inline {
        auto glm = GameLevelManager::sharedState();
        glm->m_levelListDeleteDelegate = this;
        glm->deleteServerLevelList(m_levelList->m_listID);
        m_circle->setVisible(true);
    }
    void updateEditMode() = win inline, imac 0x35f320, m1 0x2ea658, ios inline {
        if (!m_list) return;
        auto listView = static_cast<CustomListView*>(m_list->m_listView);
        listView->m_cellMode = m_editMode;
        listView->reloadAll();
    }
    void updateSideButtons() = win 0x307930, imac 0x35dc40, m1 0x2e8fe0;
    void updateStatsArt() = win 0x304ea0, imac 0x35dcd0, m1 0x372b8;
    void verifyListName() = win inline, imac 0x35f840, m1 0x2eaaf0 {
        if (!m_levelList->m_listName.empty()) return;
        m_levelList->m_listName = m_levelList->m_unkString.empty() ? "Unknown" : m_levelList->m_unkString;
    }

    cocos2d::CCMenu* m_buttonMenu;
    gd::string m_searchKey1;
    GJLevelList* m_levelList;
    gd::string m_searchKey2;
    CCMenuItemSpriteExtra* m_likeButton;
    bool m_exiting;
    CCTextInputNode* m_titleInput;
    int m_editMode;
    cocos2d::CCArray* m_objects;
    cocos2d::CCSprite* m_diffSprite;
    cocos2d::CCSprite* m_featureSprite;
    cocos2d::CCPoint m_rewardPosition;
    bool m_exited;
}

[[link(android)]]
class LevelManagerDelegate {
    virtual void loadLevelsFinished(cocos2d::CCArray* levels, char const* key) {
        this->loadLevelsFinished(levels, key, 0);
    }
    virtual void loadLevelsFailed(char const* key) {
        this->loadLevelsFailed(key, 0);
    }
    virtual void loadLevelsFinished(cocos2d::CCArray* levels, char const* key, int type) {}
    virtual void loadLevelsFailed(char const* key, int type) {}
    virtual void setupPageInfo(gd::string info, char const* key) {}
}

[[link(android)]]
class LevelOptionsLayer : GJOptionsLayer {
    // virtual ~LevelOptionsLayer();
    LevelOptionsLayer() {
        m_settingsObject = nullptr;
    }

    static LevelOptionsLayer* create(LevelSettingsObject* object) = win inline {
        auto ret = new LevelOptionsLayer();
        if (ret->init(object)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void valueDidChange(int tag, float value) = win 0x324490, imac 0x271760, m1 0x214244;
    virtual float getValue(int tag) = win 0x3244b0, imac 0x271780, m1 0x21425c;
    virtual void setupOptions() = win 0x323df0, m1 0x213c18, imac 0x271010;
    virtual void didToggle(int tag) = win 0x3244d0, imac 0x2717a0, m1 0x214278;

    bool init(LevelSettingsObject* object) = win 0x323d80, imac 0x270fc0;
    void onSettings(cocos2d::CCObject* sender) = win 0x3242b0, imac 0x2714c0, m1 0x214068;

    LevelSettingsObject* m_settingsObject;
}

[[link(android)]]
class LevelOptionsLayer2 : LevelOptionsLayer {
    // virtual ~LevelOptionsLayer2();
    LevelOptionsLayer2() {}

    static LevelOptionsLayer2* create(LevelSettingsObject* object) = win inline, m1 0x2140a8 {
        auto ret = new LevelOptionsLayer2();
        if (ret->init(object)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void setupOptions() = win 0x324730, imac 0x271a60, m1 0x214528;

    bool init(LevelSettingsObject* object) = win inline, m1 0x21442c {
        if (!LevelOptionsLayer::init(object)) return false;
        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        auto titleLabel = cocos2d::CCLabelBMFont::create("Legacy Options", "goldFont.fnt");
        titleLabel->setScale(.7f);
        titleLabel->setPosition(winSize * .5f + cocos2d::CCPoint { 0.f, m_height * .5f - 20.f });
        m_mainLayer->addChild(titleLabel);
        return true;
    }
}

[[link(android)]]
class LevelPage : cocos2d::CCLayer, DialogDelegate {
    LevelPage() {
        m_isBusy = false;
        m_level = nullptr;
        m_levelMenu = nullptr;
        m_coinObject = nullptr;
        m_secretDoor = nullptr;
    }
    ~LevelPage() = win inline, m1 0x3a6fb8 {
        CC_SAFE_RELEASE(m_level);
        CC_SAFE_RELEASE(m_dynamicObjects);
        CC_SAFE_RELEASE(m_progressObjects);
        CC_SAFE_RELEASE(m_coins);
        CC_SAFE_RELEASE(m_levelObjects);
    }

    static LevelPage* create(GJGameLevel* level) = win inline, imac 0x4322e0, m1 0x3a46e8 {
        auto ret = new LevelPage();
        if (ret->init(level)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x31e010, m1 0x3a912c, imac 0x4370e0;
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline, m1 0x3a922c, imac 0x437200 {}
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline, m1 0x3a9234, imac 0x437220 {}
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x71260, m1 0x3a923c, imac 0x437240;
    virtual void registerWithTouchDispatcher() = win 0x9b7f0, m1 0x3a9258, imac 0x437280;
    virtual void dialogClosed(DialogLayer* layer) = win 0x31d520, m1 0x3a8e64, imac 0x436e30;

    void addSecretCoin() = win 0x31c120, m1 0x3a5f50;
    void addSecretDoor() = win 0x31c830, m1 0x3a8188;
    bool init(GJGameLevel* level) = win 0x3199a0;
    void onInfo(cocos2d::CCObject* sender) = win 0x31db70;
    void onMoreGames(cocos2d::CCObject* sender) = win inline, m1 0x3a82f4, ios inline {
        GameManager::sharedState()->reportAchievementWithID("geometry.ach.moreGames", 100, false);
        auto layer = GJMoreGamesLayer::create();
        cocos2d::CCDirector::sharedDirector()->getRunningScene()->addChild(layer, 100);
        layer->showLayer(false);
    }
    void onPlay(cocos2d::CCObject* sender) = win 0x31d600, imac 0x434420, m1 0x3a67b0;
    void onSecretDoor(cocos2d::CCObject* sender) = win 0x31ca40, imac 0x436630, m1 0x2558b8;
    void onTheTower(cocos2d::CCObject* sender) = win 0x31ba60, m1 0x3a7c3c;
    void playCoinEffect() = win 0x31c360, imac 0x4361e0, m1 0x3a8358;
    void playStep2();
    void playStep3() = win 0x31da70;
    void updateDynamicPage(GJGameLevel* level) = win 0x31a630;

    bool m_isBusy;
    GJGameLevel* m_level;
    cocos2d::CCMenu* m_levelMenu;
    cocos2d::extension::CCScale9Sprite* m_levelDisplay;
    cocos2d::CCLabelBMFont* m_normalProgressLabel;
    cocos2d::CCLabelBMFont* m_practiceProgressLabel;
    cocos2d::CCLabelBMFont* m_nameLabel;
    cocos2d::CCLabelBMFont* m_starsLabel;
    float m_progressWidth;
    cocos2d::CCSprite* m_normalProgressBar;
    cocos2d::CCSprite* m_practiceProgressBar;
    cocos2d::CCSprite* m_difficultySprite;
    cocos2d::CCSprite* m_starsSprite;
    cocos2d::CCSize m_levelDisplaySize;
    cocos2d::CCArray* m_coins;
    cocos2d::CCArray* m_dynamicObjects;
    cocos2d::CCArray* m_levelObjects;
    cocos2d::CCArray* m_progressObjects;
    GameObject* m_coinObject;
    cocos2d::CCSprite* m_secretDoor;
}

[[link(android)]]
class LevelSearchLayer : cocos2d::CCLayer, TextInputDelegate, FLAlertLayerProtocol, DemonFilterDelegate {
    LevelSearchLayer() {
        m_type = 0;
        m_searchInput = nullptr;
        m_starsSprite = nullptr;
        m_difficultySprites = nullptr;
        m_lengthSprites = nullptr;
        m_difficultyDict = nullptr;
        m_lastDifficultySprite = nullptr;
        m_demonTypeButton = nullptr;
    }
    ~LevelSearchLayer() = win inline, m1 0x54a3a0 {
        CC_SAFE_RELEASE(m_difficultyDict);
        CC_SAFE_RELEASE(m_difficultySprites);
        CC_SAFE_RELEASE(m_lengthSprites);
    }

    static LevelSearchLayer* create(int type) = win inline, imac 0x6273d0, m1 0x54a6c8 {
        auto ret = new LevelSearchLayer();
        if (ret->init(type)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static cocos2d::CCScene* scene(int type) = win 0x30bdc0, m1 0x54a5d0;

    virtual void keyBackClicked() = win 0x3125f0, m1 0x54f754, imac 0x62c410;
    virtual void textInputOpened(CCTextInputNode* node) = win 0x30f570, m1 0x54ece0, imac 0x62b9f0;
    virtual void textInputClosed(CCTextInputNode* node) = win 0x30f6c0, m1 0x54edc0, imac 0x62bac0;
    virtual void textChanged(CCTextInputNode* node) = win 0x30f6c0, m1 0x54eed0, imac 0x62bb90;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x30f530, m1 0x54ec48, imac 0x62b970;
    virtual void demonFilterSelectClosed(int filter) = win 0x30e060, m1 0x54e794, imac 0x62b460;

    bool checkDiff(int diff) = win 0x311c10;
    bool checkTime(int time) = win 0x3121d0;
    void clearFilters() = win 0x30e510, m1 0x54e980;
    void confirmClearFilters(cocos2d::CCObject* sender);
    char const* getDiffKey(int diff) = win inline, m1 0x54e668, ios inline {
        return cocos2d::CCString::createWithFormat("D%i", diff)->getCString();
    }
    gd::string getLevelLenKey() = win inline, m1 0x54f440 {
        return GameLevelManager::sharedState()->getLengthStr(
            this->checkTime(0),
            this->checkTime(1),
            this->checkTime(2),
            this->checkTime(3),
            this->checkTime(4),
            this->checkTime(5)
        );
    }
    gd::string getSearchDiffKey() = win inline {
        return GameLevelManager::sharedState()->getDifficultyStr(
            this->checkDiff(0),
            this->checkDiff(1),
            this->checkDiff(2),
            this->checkDiff(3),
            this->checkDiff(4),
            this->checkDiff(5),
            this->checkDiff(6),
            this->checkDiff(7)
        );
    }
    GJSearchObject* getSearchObject(SearchType type, gd::string query) = win 0x30fb00, imac 0x62bc80, m1 0x54eff4;
    char const* getTimeKey(int time) = win inline, m1 0x54f72c, ios inline {
        return cocos2d::CCString::createWithFormat("T%i", time)->getCString();
    }
    bool init(int type) = win 0x30bf10, imac 0x2fec80, m1 0x241efc;
    void onBack(cocos2d::CCObject* sender) = win 0x311970, m1 0x54e2fc;
    void onClearFreeSearch(cocos2d::CCObject* sender) = win 0x311930, imac 0x62a2f0, m1 0x54d614;
    void onClose(cocos2d::CCObject* sender) = win inline, imac 0x62bc60, m1 0x54efe0, ios inline {
        m_searchInput->onClickTrackNode(false);
    }
    void onFollowed(cocos2d::CCObject* sender) = win 0x311330, m1 0x54dac0;
    void onFriends(cocos2d::CCObject* sender) = win 0x311270, m1 0x54db2c;
    void onLatestStars(cocos2d::CCObject* sender) = win 0x3111b0;
    void onMagic(cocos2d::CCObject* sender) = win 0x311030;
    void onMoreOptions(cocos2d::CCObject* sender) = win 0x30e2f0, m1 0x54cfc0;
    void onMostDownloaded(cocos2d::CCObject* sender) = win 0x310d30;
    void onMostLikes(cocos2d::CCObject* sender) = win 0x310df0;
    void onMostRecent(cocos2d::CCObject* sender) = win 0x3110f0;
    void onSearch(cocos2d::CCObject* sender) = win 0x3114b0, imac 0x62a050, m1 0x54d354;
    void onSearchMode(cocos2d::CCObject* sender) = win 0x30e2a0, imac 0x629c80, m1 0x54cfdc;
    void onSearchUser(cocos2d::CCObject* sender) = win 0x3116f0, imac 0x62a1c0, m1 0x54d4dc;
    void onSpecialDemon(cocos2d::CCObject* sender) = win 0x30df00, m1 0x54e088;
    void onStarAward(cocos2d::CCObject* sender) = win inline, ios inline {
        this->onClose(nullptr);
        cocos2d::CCDirector::sharedDirector()->pushScene(cocos2d::CCTransitionFade::create(.5f, LevelBrowserLayer::scene(this->getSearchObject(SearchType::Sends, ""))));
    }
    void onSuggested(cocos2d::CCObject* sender) = win 0x310eb0;
    void onTrending(cocos2d::CCObject* sender) = win 0x310f70;
    void toggleDifficulty(cocos2d::CCObject* sender) = win 0x311cf0, m1 0x54db98;
    void toggleDifficultyNum(int diff, bool enabled) = win 0x312050;
    void toggleStar(cocos2d::CCObject* sender) = win 0x3119e0, m1 0x54e268;
    void toggleTime(cocos2d::CCObject* sender) = win 0x3122b0, imac 0x62ad80, m1 0x54e0c4;
    void toggleTimeNum(int time, bool enabled) = win 0x312460, imac 0x62b160, m1 0x54e4d8;
    void updateSearchLabel(char const* label) = win 0x30f790, imac 0x629cd0, m1 0x54d020;

    int m_type;
    CCTextInputNode* m_searchInput;
    cocos2d::CCSprite* m_starsSprite;
    cocos2d::CCArray* m_difficultySprites;
    cocos2d::CCArray* m_lengthSprites;
    cocos2d::CCDictionary* m_difficultyDict;
    cocos2d::CCSprite* m_lastDifficultySprite;
    CCMenuItemSpriteExtra* m_demonTypeButton;
}

[[link(android)]]
class LevelSelectLayer : cocos2d::CCLayer, BoomScrollLayerDelegate, DynamicScrollDelegate {
    // virtual ~LevelSelectLayer();
    LevelSelectLayer() {
        m_width = 0.f;
        m_backgroundSprite = nullptr;
        m_groundLayer = nullptr;
        m_scrollLayer = nullptr;
        m_unknown = 0;
        m_scrolls = 0;
        m_masterDetectiveUnlocked = false;
    }

    static LevelSelectLayer* create(int page) = win inline, m1 0x3a3b00 {
        auto ret = new LevelSelectLayer();
        if (ret->init(page)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static cocos2d::CCScene* scene(int page) = win 0x318040, m1 0x3a3a18;

    virtual void keyBackClicked() = win 0x319800, m1 0x3a65f0, imac 0x434180;
    virtual void keyDown(cocos2d::enumKeyCodes key, double timestamp) = win 0x319850, m1 0x3a6684, imac 0x434220;
    virtual void updatePageWithObject(cocos2d::CCObject* layer, cocos2d::CCObject* object) = win 0x318f80, imac 0x432520, m1 0x3a4900;
    virtual void scrollLayerMoved(cocos2d::CCPoint position) = win 0x318ff0, imac 0x433ce0, m1 0x3a6168;

    cocos2d::ccColor3B colorForPage(int page) = win 0x319310, m1 0x3a6560;
    cocos2d::ccColor3B getColorValue(int page1, int page2, float progress) = win inline, imac 0x433e50, m1 0x3a62bc {
        auto modifier = std::clamp(progress * 2.f / 3.f - .2f, 0.f, 1.f);
        auto color1 = this->colorForPage(page1);
        auto color2 = this->colorForPage(page2);
        if (modifier > .8f) modifier = 1.f;
        else if (modifier < .2f) modifier = 0.f;
        else modifier = (modifier - .2f) / .6f;
        auto complement = 1.f - modifier;
        cocos2d::ccColor3B ret;
        ret.r = color1.r * complement + color2.r * modifier;
        ret.g = color1.g * complement + color2.g * modifier;
        ret.b = color1.b * complement + color2.b * modifier;
        return ret;
    }
    bool init(int page) = win 0x318170;
    void onBack(cocos2d::CCObject* sender) = win 0x3197b0, m1 0x3a487c;
    void onDownload(cocos2d::CCObject* sender) = m1 0x3a47c4;
    void onInfo(cocos2d::CCObject* sender) = win 0x319930, m1 0x3a48c4;
    void onNext(cocos2d::CCObject* sender) = m1 0x3a484c;
    void onPlay(cocos2d::CCObject* sender) = win inline {
        if (!*reinterpret_cast<bool*>(geode::base::get() + 0x6a3048)) {
            static_cast<LevelPage*>(m_scrollLayer->getPage(m_scrollLayer->m_page))->onPlay(nullptr);
        }
    }
    void onPrev(cocos2d::CCObject* sender) = m1 0x3a481c;
    void tryShowAd() = win inline, m1 0x3a48e0, ios inline {
        GameManager::sharedState()->tryShowInterstitial(120, 140, 0);
    }

    float m_width;
    cocos2d::CCSprite* m_backgroundSprite;
    GJGroundLayer* m_groundLayer;
    BoomScrollLayer* m_scrollLayer;
    int m_unknown;
    int m_scrolls;
    bool m_masterDetectiveUnlocked;
}

[[link(android)]]
class LevelSettingsDelegate {
    virtual void levelSettingsUpdated() {}
}

[[link(android)]]
class LevelSettingsLayer : FLAlertLayer, ColorSelectDelegate, SelectArtDelegate, SelectSettingDelegate, FLAlertLayerProtocol, CustomSongLayerDelegate, TextInputDelegate {
    // virtual ~LevelSettingsLayer();

    static LevelSettingsLayer* create(LevelSettingsObject* object, LevelEditorLayer* layer) = win 0x31e5b0, imac 0x26b110, m1 0x20e538;

    virtual void registerWithTouchDispatcher() = win 0x321060, m1 0x211848, imac 0x26e890;
    virtual void keyBackClicked() = win 0x321f00, imac 0x26f1c0, m1 0x21206c;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0xc3e50, imac 0x26ed20, m1 0x211c90;
    virtual void colorSelectClosed(cocos2d::CCNode* popup) = win 0x321790, imac 0x26ec40, m1 0x211bd8;
    virtual void selectArtClosed(SelectArtLayer* layer) = win 0x321bb0, imac 0x26ef50, m1 0x211e6c;
    virtual void selectSettingClosed(SelectSettingLayer* layer) = win 0x320ee0, imac 0x26e6c0, m1 0x211694;
    virtual void textInputClosed(CCTextInputNode* node) = win 0x8b870, imac 0x26e8e0, m1 0x21189c;
    virtual void textChanged(CCTextInputNode* node) = win 0x321390, m1 0x2118b8, imac 0x26e920;

    void createToggleButton(gd::string label, cocos2d::SEL_MenuHandler selector, bool toggled, cocos2d::CCMenu* menu, cocos2d::CCPoint position) = win 0x3210e0, imac 0x26dfa0, m1 0x211060;
    bool init(LevelSettingsObject* object, LevelEditorLayer* layer) = win 0x31e7a0;
    void onBGArt(cocos2d::CCObject* sender) = win 0x321970, imac 0x26dd00, m1 0x210e04;
    void onClose(cocos2d::CCObject* sender) = win 0x321560, imac 0x26de90;
    void onCol(cocos2d::CCObject* sender) = m1 0x21090c;
    void onDisable(cocos2d::CCObject* sender) = imac 0x26e1b0, m1 0x2112b8;
    void onFGArt(cocos2d::CCObject* sender) = win 0x321a40, imac 0x26de30, m1 0x210f08;
    void onGameplayMode(cocos2d::CCObject* sender) = win 0x320cb0, imac 0x26db80, m1 0x210c84;
    void onGArt(cocos2d::CCObject* sender) = win 0x3219c0, imac 0x26dd40, m1 0x210e40;
    void onLiveEdit(cocos2d::CCObject* sender) = win 0x3216a0, imac 0x26db40, m1 0x210c40;
    void onMode(cocos2d::CCObject* sender) = win 0x320e80, imac 0x26e280, m1 0x211374;
    void onOptionToggle(cocos2d::CCObject* sender) = win 0x321350, imac 0x26e1d0;
    void onSelectFont(cocos2d::CCObject* sender) = m1 0x210f44;
    void onSelectMode(cocos2d::CCObject* sender) = imac 0x26ea20, m1 0x2119b4;
    void onSelectSpeed(cocos2d::CCObject* sender) = imac 0x26eae0, m1 0x211a74;
    void onSettings(cocos2d::CCObject* sender) = win 0x320dc0, imac 0x26e2d0, m1 0x2113b0;
    void onShowPicker(cocos2d::CCObject* sender) = win 0x3216f0, imac 0x26d750, m1 0x2108b8;
    void onSpeed(cocos2d::CCObject* sender) = win 0x320e30, imac 0x26e240, m1 0x211338;
    void showPicker(ColorAction* action) = win inline, m1 0x211ba4, ios inline {
        auto popup = ColorSelectPopup::create(action);
        popup->m_delegate = this;
        popup->show();
    }
    void updateColorSprite(ColorChannelSprite* sprite) = win 0x321810, imac 0x26ec70, m1 0x211be4;
    void updateColorSprites() = win 0x3217a0, imac 0x26d7d0, m1 0x21092c;
    void updateGameplayModeButtons() = win 0x320cf0, imac 0x26dc50, m1 0x210d54;

    SongSelectNode* m_songSelectNode;
    Speed m_speed;
    ColorChannelSprite* m_bgColorSprite;
    ColorChannelSprite* m_gColorSprite;
    ColorChannelSprite* m_g2ColorSprite;
    ColorChannelSprite* m_lineColorSprite;
    ColorChannelSprite* m_mgColorSprite;
    ColorChannelSprite* m_mg2ColorSprite;
    cocos2d::CCSprite* m_moreColorsSprite;
    cocos2d::CCSprite* m_backgroundSprite;
    cocos2d::CCSprite* m_groundSprite;
    cocos2d::CCSprite* m_middlegroundSprite;
    cocos2d::CCSprite* m_speedSprite;
    cocos2d::CCSprite* m_modeSprite;
    LevelSettingsObject* m_settingsObject;
    void* m_unkPtr;
    cocos2d::CCArray* m_modeToggles;
    cocos2d::CCArray* m_speedButtons;
    LevelSettingsDelegate* m_delegate;
    LevelEditorLayer* m_editorLayer;
    CCTextInputNode* m_orderInput;
    CCTextInputNode* m_channelInput;
    CCMenuItemSpriteExtra* m_classicButton;
    CCMenuItemSpriteExtra* m_platformerButton;
    bool m_disableInput;
}

[[link(android)]]
class LevelSettingsObject : cocos2d::CCNode {
    // virtual ~LevelSettingsObject();

    static LevelSettingsObject* create() = m1 0xc35d4;
    static LevelSettingsObject* objectFromDict(cocos2d::CCDictionary* dict) = win 0x2ec800, imac 0x102e20, m1 0xe168c;
    static LevelSettingsObject* objectFromString(gd::string const& str) = win inline, m1 0xc4fc0 {
        return objectFromDict(GameToolbox::stringSetupToDict(str, ","));
    }

    virtual bool init() = win 0x2eaab0, m1 0xe1518, imac 0x102c60;

    gd::string getSaveString() = win 0x2eadc0, imac 0x3866d0, m1 0xc8fa8;
    void setupColorsFromLegacyMode(cocos2d::CCDictionary* dict) = win 0x2ee090, imac 0x1045e0;
    bool shouldUseYSection() = win inline {
        return m_platformerMode || m_dynamicLevelHeight;
    }

    GJEffectManager* m_effectManager;
    // property kA2
    int m_startMode;
    // property kA4
    Speed m_startSpeed;
    // property kA3
    bool m_startMini;
    // property kA8
    bool m_startDual;
    // property kA28
    bool m_mirrorMode;
    // property kA29
    bool m_rotateGameplay;
    // property kA10
    bool m_twoPlayerMode;
    // property kA22
    bool m_platformerMode;
    // property kA13
    float m_songOffset;
    // property kA15
    bool m_fadeIn;
    // property kA16
    bool m_fadeOut;
    // property kA46
    bool m_dontReset;
    // property kA6
    int m_backgroundIndex;
    // property kA7
    int m_groundIndex;
    // property kA18
    int m_fontIndex;
    // property kA25
    int m_middleGroundIndex;
    // property kA9
    bool m_startsWithStartPos;
    // property kA11
    bool m_isFlipped;
    // property kA20
    bool m_reverseGameplay;
    // property kA21
    bool m_disableStartPos;
    // property kA19
    int m_targetOrder;
    // property kA26
    int m_targetChannel;
    GJGameLevel* m_level;
    // property kA14
    gd::string m_guidelineString;
    bool m_guidelinesUpdated;
    // property kS39
    int m_colorPage;
    // property kA17
    int m_groundLineIndex;
    // property kA23
    bool m_propertykA23;
    // property kA24
    bool m_propertykA24;
    // property kA43
    bool m_noTimePenalty;
    // property kA44
    int m_propertykA44;
    // property kA47
    int m_propertykA47;
    // property kA35
    bool m_resetCamera;
    // property kA36
    int m_spawnGroup;
    // property kA27
    bool m_allowMultiRotation;
    // property kA31
    bool m_enablePlayerSqueeze;
    // property kA32
    bool m_fixGravityBug;
    // property kA33
    bool m_fixNegativeScale;
    // property kA34
    bool m_fixRobotJump;
    // property kA37
    bool m_dynamicLevelHeight;
    // property kA38
    bool m_sortGroups;
    // property kA39
    bool m_fixRadiusCollision;
    // property kA40
    bool m_enable22Changes;
    // property kA41
    bool m_allowStaticRotate;
    // property kA42
    bool m_reverseSync;
    // property kA45
    bool m_decreaseBoostSlide;
}

[[link(android)]]
class LevelTools {
    static int artistForAudio(int id) = win 0x328d70, m1 0x456ae0;
    static gd::string base64DecodeString(gd::string str) = win inline, m1 0x45982c {
        return str.empty() ? str : cocos2d::ZipUtils::base64URLDecode(str);
    }
    static gd::string base64EncodeString(gd::string str) = win inline {
        return str.empty() ? str : cocos2d::ZipUtils::base64URLEncode(str);
    }
    static cocos2d::CCDictionary* createStarPackDict() = win inline, m1 0x459864 {
        auto dict = cocos2d::CCDictionary::create();
        std::string packs = "1,3,2,4,3,4,5,5,6,6,7,6,8,7,9,8,10,8,11,9,19,10,20,10,21,10,22,10,26,"
                            "10,27,10,28,10,29,10,30,10,31,10,32,4,33,5,34,6,35,8,36,8,37,5,38,5,39,"
                            "6,40,7,41,8,42,8,43,8,44,9,45,6,46,10,47,10,48,10,49,10,50,10,52,4,53,3,"
                            "54,4,55,4,56,5,57,6,58,7,59,8,60,8,61,8,62,9,63,9,64,10,65,10,66,10";
        auto parts = cocos2d::CCArray::create();
        auto start = 0;
        auto index = packs.find_first_of(",");
        auto size = packs.size();
        while (index != std::string::npos) {
            auto str = packs.substr(start, index - start);
            if (!str.empty() || start != size) {
                parts->addObject(cocos2d::CCString::create(str));
            }
            start = index + 1;
            index = packs.find_first_of(",", start);
        }
        for (int i = 1; i < parts->count(); i += 2) {
            dict->setObject(parts->stringAtIndex(i), parts->stringAtIndex(i - 1)->intValue());
        }
        return dict;
    }
    static gd::string fbURLForArtist(int id);
    static int getAudioBPM(int id) = win inline, m1 0x457de0, ios inline {
        switch (id) {
            case 0: return 160;
            case 1: return 142;
            case 2: return 163;
            case 3: return 145;
            case 4: return 142;
            case 5: return 170;
            case 6: return 178;
            case 7: return 143;
            case 8: return 140;
            case 10: return 140;
            case 12: return 170;
            default: return 130;
        }
    }
    static gd::string getAudioFileName(int id) = win 0x3281a0;
    static gd::string getAudioString(int id) = win 0x32b380, imac 0x4ffae0, m1 0x457e00;
    static gd::string getAudioTitle(int id) = win 0x327620;
    static bool getLastGameplayReversed() = win inline, imac 0x5010e0, ios inline {
        return *reinterpret_cast<bool*>(geode::base::get() + GEODE_WINDOWS(0x6a4c06) GEODE_IOS(0x85f0c0));
    }
    static bool getLastGameplayRotated() = win inline, imac 0x5010f0 {
        return *reinterpret_cast<bool*>(geode::base::get() + 0x6a4c05);
    }
    static float getLastTimewarp() = win inline, imac 0x5010d0, m1 0x459320 {
        return *reinterpret_cast<float*>(geode::base::get() + 0x69c198);
    }
    static GJGameLevel* getLevel(int id, bool noString) = win 0x324d70, imac 0x4fb360, m1 0x453f8c;
    static gd::unordered_set<int> getLevelList() = win inline {
        auto levelStart = reinterpret_cast<int*>(geode::base::get() + 0x608580);
        auto levelList = std::unordered_set<int>(levelStart, levelStart + 40);
        levelList.insert(5002);
        levelList.insert(5003);
        levelList.insert(5004);
        return levelList;
    }
    static SongInfoObject* getSongObject(int id) = win inline {
        auto artistID = artistForAudio(id);
        return SongInfoObject::create(id, getAudioTitle(id), nameForArtist(artistID), artistID, 0.f, "", "", "", 0, "", false, 0, -1);
    }
    static void moveTriggerObjectsToArray(cocos2d::CCArray* objects, cocos2d::CCDictionary* objectsDict, int index) = win 0x32d310, imac 0x501d60, m1 0x459cd4;
    static gd::string nameForArtist(int id) = win 0x328e40, imac 0x4fe410;
    static gd::string ngURLForArtist(int id) = win 0x32a460, imac 0x4ff090;
    static float offsetBPMForTrack(int id) = win inline, m1 0x4583fc, ios inline {
        return id == 11 ? .1f : id == 13 ? .07f : .0f;
    }
    static cocos2d::CCPoint posForTime(float time, cocos2d::CCArray* objects, int speed, bool platformer, int& rotateChannel) = win inline, imac 0x500ad0, m1 0x458e28 {
        return posForTimeInternal(time, objects, speed, platformer, false, false, rotateChannel, 0);
    }
    static cocos2d::CCPoint posForTimeInternal(float time, cocos2d::CCArray* objects, int speed, bool platformer, bool ignoreMinorAxis, bool ignoreWarp, int& rotateChannel, int unused) = win 0x32c8d0, imac 0x500b00, m1 0x458e38;
    static void sortChannelOrderObjects(cocos2d::CCArray* objects, cocos2d::CCDictionary* objectsDict, bool moveObjects) = win 0x32d3e0, m1 0xd4da8;
    static void sortSpeedObjects(cocos2d::CCArray* objects, GJBaseGameLayer* layer) = win 0x32d660, m1 0x45c0f0;
    static float timeForPos(cocos2d::CCPoint position, cocos2d::CCArray* objects, int speed, int order, int channel, bool songTriggers, bool platformer, bool ignoreWarp, bool ignoreRotate, int id) = win 0x32bef0;
    static void toggleDebugLogging(bool enabled) = win inline, ios inline {}
    static gd::string urlForAudio(int id) = win 0x329140, m1 0x456d50;
    static float valueForSpeedMod(int speed) = win inline, m1 0x45841c, ios inline {
        switch (speed) {
            case 1: return 251.16008f;
            case 2: return 387.42014f;
            case 3: return 468.00015f;
            case 4: return 576.00018f;
            default: return 311.5801f;
        }
    }
    static bool verifyLevelIntegrity(gd::string str, int id) = win 0x32d0f0, imac 0x501720, m1 0x45964c;
    static gd::string ytURLForArtist(int id) = win 0x32a900;
}

[[link(android)]]
class LevelUpdateDelegate {
    virtual void levelUpdateFinished(GJGameLevel* level, UpdateResponse response) {}
    virtual void levelUpdateFailed(int response) {}
}

[[link(android)]]
class LevelUploadDelegate {
    virtual void levelUploadFinished(GJGameLevel* level) {}
    virtual void levelUploadFailed(GJGameLevel* level) {}
}

[[link(android)]]
class LikeItemDelegate {
    virtual void likedItem(LikeItemType type, int id, bool liked) {}
}

[[link(android)]]
class LikeItemLayer : FLAlertLayer {
    // virtual ~LikeItemLayer();
    LikeItemLayer() {
        m_itemType = LikeItemType::Unknown;
        m_itemID = 0;
        m_commentSourceID = 0;
        m_likeDelegate = nullptr;
    }

    static LikeItemLayer* create(LikeItemType type, int id, int parentID) = win 0x32da90, imac 0x5f8650;

    virtual void keyBackClicked() = win 0x846c0, m1 0x521924, imac 0x5f8d40;

    bool init(LikeItemType type, int id, int parentID) = win 0x32db90, m1 0x1fe858;
    void onClose(cocos2d::CCObject* sender) = win 0x84690, m1 0x52177c;
    void onDislike(cocos2d::CCObject* sender) = m1 0x521830;
    void onLike(cocos2d::CCObject* sender) = win 0x32df60, m1 0x5217b8;
    void triggerLike(bool isLiked) = win 0x32df80, m1 0x5218a8;

    LikeItemType m_itemType;
    int m_itemID;
    int m_commentSourceID;
    LikeItemDelegate* m_likeDelegate;
}

[[link(android)]]
class ListButtonBar : cocos2d::CCNode {
    // virtual ~ListButtonBar();

    static ListButtonBar* create(cocos2d::CCArray* items, cocos2d::CCPoint position, int columns, int rows, float columnOffset, float rowOffset, float offset, float arrowOffset, int arrowType) = win 0x6adc0, imac 0x3ef880, m1 0x3691ac;

    int getPage() = win inline, m1 0x3698a0, ios inline {
        return m_scrollLayer->getRelativePageForNum(m_scrollLayer->m_page);
    }
    void goToPage(int page) = win 0x6b3d0;
    bool init(cocos2d::CCArray* items, cocos2d::CCPoint position, int columns, int rows, float columnOffset, float rowOffset, float offset, float arrowOffset, int arrowType) = win 0x6aed0;
    void onLeft(cocos2d::CCObject* sender) = win 0x6b480, m1 0x369798;
    void onRight(cocos2d::CCObject* sender) = win 0x6b460;

    BoomScrollLayer* m_scrollLayer;
    cocos2d::CCArray* m_pages;
    ListButtonBarDelegate* m_delegate;
    bool m_useMoveAnimation;
}

[[link(android)]]
class ListButtonBarDelegate {
    virtual void listButtonBarSwitchedPage(ListButtonBar* bar, int page) {}
}

[[link(android)]]
class ListButtonPage : cocos2d::CCLayer {
    // virtual ~ListButtonPage();

    static ListButtonPage* create(cocos2d::CCArray* items, cocos2d::CCPoint position, int columns, int rows, float columnOffset, float rowOffset, float offset) = win 0x6b4a0, imac 0x3efd90, m1 0x369690;

    bool init(cocos2d::CCArray* items, cocos2d::CCPoint position, int columns, int rows, float columnOffset, float rowOffset, float offset) = win inline, imac 0x3f0070, m1 0x369928 {
        if (!cocos2d::CCLayer::init()) return false;
        auto menu = cocos2d::CCMenu::create();
        this->addChild(menu);
        auto x = position.x;
        auto y = position.y;
        auto index = 0;
        for (int i = 0; i < items->count(); i++) {
            auto row = index / columns;
            auto item = static_cast<cocos2d::CCNode*>(items->objectAtIndex(i));
            if (item->getTag() == 2) {
                index += columns - (index % columns);
            }
            else {
                menu->addChild(item);
                item->setPosition(menu->convertToNodeSpace({
                    (columnOffset + offset) * (index % columns) + offset * .5f + (x - columns * .5f * offset - (columns - 1) * .5f * columnOffset),
                    ((rows - 1) * .5f * (rowOffset + offset) + y) - row * (rowOffset + offset)
                }));
                index++;
            }
        }
        return true;
    }
}

[[link(android)]]
class ListCell : TableViewCell {
    // virtual ~ListCell();
    ListCell(char const* identifier, float width, float height) = win inline, m1 0x29c488, ios inline : TableViewCell(identifier, width, height) {
        this->init();
    }

    virtual bool init() = win inline, m1 0x29c480, imac 0x30ce20 { return true; }
    virtual void draw() = win 0x3c750, imac 0x30ceb0, m1 0x29c4cc;

    void loadFromObject(cocos2d::CCObject* object, int id, int page, int index) = win inline, imac 0x30cde0, m1 0x29c470, ios inline {}
    void updateBGColor(int index) = win inline, imac 0x30cea0, m1 0x29c4c8, ios inline {}

    int m_unk230;
}

[[link(android)]]
class ListUploadDelegate {
    virtual void listUploadFinished(GJLevelList* list) {}
    virtual void listUploadFailed(GJLevelList* list, int response) {}
}

[[link(android)]]
class LoadingCircle : cocos2d::CCLayerColor {
    // virtual ~LoadingCircle();
    LoadingCircle() {
        m_sprite = nullptr;
        m_parentLayer = nullptr;
        m_fade = false;
    }

    static LoadingCircle* create() = win 0x6b890, m1 0x41ebac;

    virtual bool init() = win 0x6b990, imac 0x4bed10, m1 0x41eca8;
    virtual void draw() = win 0x6bc10, m1 0x41ef14, imac 0x4bef60;
    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) { return true; }
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) {}
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) {}
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) {}
    virtual void registerWithTouchDispatcher() = win 0x6bc30, m1 0x41ef28, imac 0x4bef80;

    void fadeAndRemove() = win 0x6bb70, m1 0x41ee60;
    void setFade(bool fade) {
        m_fade = fade;
    }
    void setParentLayer(cocos2d::CCLayer* layer) {
        m_parentLayer = layer;
    }
    void show() = win 0x6ba70, m1 0x41ed64;

    cocos2d::CCSprite* m_sprite;
    cocos2d::CCLayer* m_parentLayer;
    bool m_fade;
}

[[link(android)]]
class LoadingCircleSprite : cocos2d::CCSprite {
    // virtual ~LoadingCircleSprite();

    /// Create a Loading Circle Sprite with a spinning action
    /// @param spinSpeed A speed modifier, higher is faster and lower is slower
    static LoadingCircleSprite* create(float spinSpeed) = win 0x6bc80, imac 0x4befc0, m1 0x41ef60;

    cocos2d::CCAction* fadeInCircle(bool resetOpacity, float duration, float opacity) = win 0x6bd80, imac 0x4bf160, m1 0x40e28c;
    void hideCircle() = win inline, m1 0x41f168 {
        this->stopActionByTag(0);
        this->setOpacity(0);
        this->setVisible(false);
    }
    bool init(float spinSpeed) = win inline, imac 0x4bf0a0, m1 0x41f044 {
        if (!CCSprite::initWithFile("loadingCircle.png")) return false;
        this->setBlendFunc({ GL_SRC_ALPHA, GL_ONE });
        this->runAction(cocos2d::CCRepeatForever::create(cocos2d::CCRotateBy::create(1.f, spinSpeed * 360.f)));
        return true;
    }
}

[[link(android)]]
class LoadingLayer : cocos2d::CCLayer {
    LoadingLayer() {
        m_unknown = false;
        m_unknown2 = false;
        m_loadStep = 0;
        m_caption = nullptr;
        m_textArea = nullptr;
        m_sliderBar = nullptr;
        m_sliderGrooveXPos = 0.f;
        m_sliderGrooveHeight = 0.f;
        m_fromRefresh = false;
    }
    ~LoadingLayer() = win inline, m1 0x327dbc, imac 0x3a31f0 {
        CCNode::removeAllChildrenWithCleanup(true);
    }

    static LoadingLayer* create(bool refresh) = win inline, imac 0x3a2110, m1 0x326d60 {
        auto ret = new LoadingLayer();
        if (ret->init(refresh)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static cocos2d::CCScene* scene(bool refresh) = win 0x32e0e0, m1 0x326c88, imac 0x3a2010;

    const char* getLoadingString() = win 0x32f520;
    bool init(bool refresh) = win 0x32e1f0, m1 0x326e20, imac 0x3a21f0;
    void loadAssets() = win 0x32ea90, m1 0x32767c, imac 0x3a2a20;
    void loadingFinished() = win inline, imac 0x3a31c0, m1 0x327d88 {
        cocos2d::CCDirector::sharedDirector()->replaceScene(MenuLayer::scene(m_fromRefresh));
    }
    void updateProgress(int progress) = win 0x32ea10, imac 0x3a29c0, m1 0x327610;

    bool m_unknown;
    bool m_unknown2;
    int m_loadStep;
    cocos2d::CCLabelBMFont* m_caption;
    TextArea* m_textArea;
    cocos2d::CCSprite* m_sliderBar;
    float m_sliderGrooveXPos;
    float m_sliderGrooveHeight;
    bool m_fromRefresh;
}

[[link(android)]]
class LocalLevelManager : GManager {
    static LocalLevelManager* get() {
        return LocalLevelManager::sharedState();
    }
    // virtual ~LocalLevelManager();
    static LocalLevelManager* sharedState() = win 0x32fc60, imac 0x5f6270, m1 0x51f3c0;

    virtual bool init() = win 0x32fd00, m1 0x51f540, imac 0x5f6410;
    virtual void encodeDataTo(DS_Dictionary* dict) = win 0x3306d0, m1 0x520710, imac 0x5f7850;
    virtual void dataLoaded(DS_Dictionary* dict) = win 0x330730, imac 0x5f78b0, m1 0x520768;
    virtual void firstLoad() = win 0x330640, m1 0x520694, imac 0x5f77c0;

    cocos2d::CCDictionary* getAllLevelsInDict() = win 0x3300d0, m1 0x51fbb8;
    cocos2d::CCArray* getAllLevelsWithName(gd::string name) = win inline, m1 0x51fda4 {
        auto ret = cocos2d::CCArray::create();
        for (int i = 0; i < m_localLevels->count(); i++) {
            auto level = static_cast<GJGameLevel*>(m_localLevels->objectAtIndex(i));
            if (level->m_levelName == name) ret->addObject(level);
        }
        return ret;
    }
    cocos2d::CCArray* getCreatedLevels(int folder) = win inline, m1 0x520498 {
        if (folder < 1) return m_localLevels;
        auto ret = cocos2d::CCArray::create();
        for (auto obj : geode::cocos::CCArrayExt<cocos2d::CCObject*, false>(m_localLevels)) {
            if (!obj) return ret;
            if (static_cast<GJGameLevel*>(obj)->m_levelFolder == folder) ret->addObject(obj);
        }
        return ret;
    }
    cocos2d::CCArray* getCreatedLists(int folder) = win inline, m1 0x520604 {
        if (folder < 1) return m_localLists;
        auto ret = cocos2d::CCArray::create();
        for (auto obj : geode::cocos::CCArrayExt<cocos2d::CCObject*, false>(m_localLists)) {
            if (!obj) return ret;
            if (static_cast<GJLevelList*>(obj)->m_folder == folder) ret->addObject(obj);
        }
        return ret;
    }
    cocos2d::CCDictionary* getLevelsInNameGroups() = win inline, m1 0x51fa68 {
        auto dict = cocos2d::CCDictionary::create();
        for (int i = 0; i < m_localLevels->count(); i++) {
            auto level = static_cast<GJGameLevel*>(m_localLevels->objectAtIndex(i));
            auto key = level->m_levelName;
            auto arr = static_cast<cocos2d::CCArray*>(dict->objectForKey(key));
            if (!arr) {
                arr = cocos2d::CCArray::create();
                dict->setObject(arr, key);
            }
            arr->addObject(level);
        }
        return dict;
    }
    gd::string getMainLevelString(int id) = win 0x32ffc0, imac 0x5f6860;
    void markLevelsAsUnmodified() = win inline, m1 0x5203f8 {
        for (int i = 0; i < m_localLevels->count(); i++) {
            static_cast<GJGameLevel*>(m_localLevels->objectAtIndex(i))->m_hasBeenModified = false;
        }
    }
    void moveLevelToTop(GJGameLevel* level) = win inline, imac 0x5f73e0, m1 0x5202b8 {
        if (level && m_localLevels->containsObject(level)) {
            level->retain();
            m_localLevels->removeObject(level);
            m_localLevels->insertObject(level, 0);
            level->release();
            this->updateLevelOrder();
        }
    }
    void reorderLevels() = win inline, m1 0x520448 {
        if (m_localLevels->count() != 0) {
            qsort(m_localLevels->data->arr, m_localLevels->data->num, sizeof(GJGameLevel*), [](void const* a, void const* b) {
                auto la = *static_cast<GJGameLevel* const*>(a);
                auto lb = *static_cast<GJGameLevel* const*>(b);
                return lb->m_levelIndex - la->m_levelIndex;
            });
        }
    }
    void reorderLists() = win inline, m1 0x5205b4 {
        if (m_localLists->count() != 0) {
            qsort(m_localLists->data->arr, m_localLists->data->num, sizeof(GJLevelList*), [](void const* a, void const* b) {
                auto la = *static_cast<GJLevelList* const*>(a);
                auto lb = *static_cast<GJLevelList* const*>(b);
                return lb->m_listOrder - la->m_listOrder;
            });
        }
    }
    void tryLoadMainLevelString(int id) = win 0x32fd40;
    int updateLevelOrder() = win 0x3305c0, m1 0x52036c;
    void updateLevelRevision() = win 0x330230, m1 0x51fecc;
    int updateListOrder() = win inline, m1 0x520528 {
        int i = 0;
        for (; i < m_localLists->count(); i++) {
            static_cast<GJLevelList*>(m_localLists->objectAtIndex(m_localLists->count() - 1 - i))->m_listOrder = i;
        }
        return i;
    }

    cocos2d::CCArray* m_localLevels;
    cocos2d::CCArray* m_localLists;
    gd::unordered_map<int, gd::string> m_mainLevels;
}

[[link(android)]]
class MapPackCell : TableViewCell {
    MapPackCell(char const* identifier, float width, float height) = win inline, m1 0x1f867c : TableViewCell(identifier, width, height) {
        this->init();
    }
    ~MapPackCell() = win inline {
        CC_SAFE_RELEASE(m_rewardLabels);
        CC_SAFE_RELEASE(m_rewardSprites);
    }

    virtual bool init() = win 0xb1c20, m1 0x1f8708, imac 0x252300;
    virtual void draw() = win 0xade40, m1 0x1f8bc4, imac 0x2527b0;

    void loadFromMapPack(GJMapPack* pack) = win 0xb1c80, imac 0x244560, m1 0x1eb38c;
    void onClaimReward(cocos2d::CCObject* sender) = m1 0x1f8900;
    void onClick(cocos2d::CCObject* sender) = win 0xb27a0, m1 0x1f8750;
    void playCompleteEffect() = win 0xb2970, imac 0x252580;
    void reloadCell() = win inline, imac 0x24e170, m1 0x1f4ae4, ios inline {
        this->loadFromMapPack(m_mapPack);
    }
    void updateBGColor(int index) = win inline, imac 0x2450c0, m1 0x1ebe78 {
        m_backgroundLayer->setColor(index % 2 == 0 ? cocos2d::ccColor3B { 161, 88, 44 } : cocos2d::ccColor3B { 194, 114, 62 });
        m_backgroundLayer->setOpacity(255);
    }

    GJMapPack* m_mapPack;
    CCMenuItemSpriteExtra* m_viewButton;
    CCMenuItemSpriteExtra* m_rewardButton;
    cocos2d::CCArray* m_rewardLabels;
    cocos2d::CCArray* m_rewardSprites;
}

[[link(android)]]
class MapSelectLayer : cocos2d::CCLayer {
    // virtual ~MapSelectLayer();

    static MapSelectLayer* create() = m1 0x20b360;
    static cocos2d::CCScene* scene() = m1 0x20b31c;

    virtual void update(float dt) = imac 0x268a60, m1 0x20c2a8;
    virtual bool init() = m1 0x20b44c, imac 0x267b10;
    virtual void onExit() = imac 0x268d00, m1 0x20c558;
    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = imac 0x2693a0, m1 0x20cb28;
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = m1 0x20cc24, imac 0x2694b0;
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = m1 0x20cdec, imac 0x2696d0;
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = m1 0x20cefc, imac 0x2697b0;
    virtual void registerWithTouchDispatcher() = m1 0x20cf18, imac 0x2697f0;
    virtual void keyBackClicked() = m1 0x20c490, imac 0x268c40;
    virtual void scrollWheel(float y, float x) = imac 0x268820, m1 0x20c088;

    bool checkTouchMonster(cocos2d::CCPoint position) = m1 0x20c6cc;
    GJMapObject* createObjectAtPoint(cocos2d::CCPoint position) = m1 0x25230c;
    cocos2d::CCPoint getConstrainedMapPos(cocos2d::CCPoint position) = m1 0x20c224;
    void onBack(cocos2d::CCObject* sender);

    GJBigSprite* m_bigSprite;
    SimplePlayer* m_player;
    cocos2d::CCNode* m_mainLayer;
    bool m_unloadTexturesOnExit;
    bool m_backPressed;
    bool m_blockExit;
    bool m_inTouch;
    double m_lastTouchTime;
    bool m_editMode;
    cocos2d::CCPoint m_lastTouchPos;
    cocos2d::CCPoint m_mapPos;
    cocos2d::CCArray* m_monsters;
    LevelEditorLayer* m_editorLayer;
}

[[link(android), depends(GJGroundLayer), depends(GameToolbox)]]
class MenuGameLayer : cocos2d::CCLayer {
    // virtual ~MenuGameLayer();
    MenuGameLayer() {
        m_videoOptionsOpen = false;
        m_deltaCount = 0.f;
        m_isDestroyingPlayer = false;
        m_initCount = 0;
        m_playerObject = nullptr;
        m_backgroundSprite = nullptr;
        m_groundLayer = nullptr;
        m_backgroundWrapPosition = 0.f;
    }

    static MenuGameLayer* create() = win inline, m1 0x4521e8 {
        auto ret = new MenuGameLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void update(float dt) = win 0x331f70, imac 0x4fa620, m1 0x4532a4;
    virtual bool init() = win 0x331150, m1 0x4522d0, imac 0x4f9450;
    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x333330, m1 0x453794, imac 0x4fab90;
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline, m1 0x4538ac, imac 0x4facb0 {}
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline, m1 0x4538b4, imac 0x4facd0 {}
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x71260, m1 0x4538bc, imac 0x4facf0;
    virtual void registerWithTouchDispatcher() = win 0x3334e0, m1 0x4538d8, imac 0x4fad30;

    void destroyPlayer() = win 0x333070, imac 0x4fa990, m1 0x453598;
    cocos2d::ccColor3B getBGColor(int index) = win 0x3319d0, imac 0x4f98b0, m1 0x356c10;
    void resetPlayer() = win 0x332440, imac 0x4f9dd0, m1 0x452c64;
    void tryJump(float dt) = win 0x331ca0, m1 0x452808;
    void updateColor(float dt) = win 0x331880, imac 0x4f9bd0, m1 0x452a80;
    void updateColors() = win inline, imac 0x4fa5b0, m1 0x45322c {
        m_groundLayer->updateGround01Color(m_groundLayer->m_ground1Sprite->getColor());
        if (m_groundLayer->m_ground2Sprite) {
            m_groundLayer->updateGround02Color(m_groundLayer->m_ground2Sprite->getColor());
        }
    }

    bool m_videoOptionsOpen;
    float m_deltaCount;
    bool m_isDestroyingPlayer;
    int m_initCount;
    cocos2d::CCPoint m_realBackgroundPosition;
    PlayerObject* m_playerObject;
    cocos2d::CCSprite* m_backgroundSprite;
    GJGroundLayer* m_groundLayer;
    float m_backgroundWrapPosition;
}

[[link(android)]]
class MenuLayer : cocos2d::CCLayer, FLAlertLayerProtocol, GooglePlayDelegate {
    // static MenuLayer* create() = ios 0x2655a4;
    // virtual ~MenuLayer();

    static MenuLayer* get() {
        return GameManager::get()->m_menuLayer;
    }
    static cocos2d::CCScene* scene(bool isVideoOptionsOpen) = win 0x333630, m1 0x31603c, imac 0x38fb20;

    virtual bool init() = win 0x3337c0, m1 0x3161ec, imac 0x38fce0;
    virtual void keyBackClicked() = win 0x335cb0, imac 0x391c00, m1 0x318068;
    virtual void keyDown(cocos2d::enumKeyCodes key, double timestamp) = win 0x336090, m1 0x3182e4, imac 0x391ed0;
    virtual void googlePlaySignedIn() = win 0x3356b0, imac 0x391970, m1 0x317e1c;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x335e80, imac 0x391c30, m1 0x318074;

    void endGame() = win 0x336100;
    void firstNetworkTest() = win 0x335020, m1 0x317c44;
    void onAchievements(cocos2d::CCObject* sender) = win 0x335550, m1 0x317660;
    void onCreator(cocos2d::CCObject* sender) = win 0x335a60;
    void onDaily(cocos2d::CCObject* sender) = win 0x334dd0, m1 0x317be0;
    void onDiscord(cocos2d::CCObject* sender) = m1 0x3178d0;
    void onEveryplay(cocos2d::CCObject* sender) = win inline, imac 0x391a80, m1 0x317f14, ios inline {}
    void onFacebook(cocos2d::CCObject* sender) = m1 0x317840;
    void onFreeLevels(cocos2d::CCObject* sender) = m1 0x317fbc;
    void onFullVersion(cocos2d::CCObject* sender) = m1 0x317fdc;
    void onGameCenter(cocos2d::CCObject* sender) = win inline, m1 0x317cb4 {
        auto gameManager = GameManager::sharedState();
        if (gameManager->getGameVariable("0034")) {
            gameManager->syncPlatformAchievements();
            PlatformToolbox::showAchievements();
        }
        this->showGCQuestion();
    }
    void onGarage(cocos2d::CCObject* sender) = win 0x335af0;
    void onGooglePlayGames(cocos2d::CCObject* sender) = win inline, m1 0x317df4, ios inline {
        if (PlatformToolbox::isSignedInGooglePlay()) {
            GameManager::sharedState()->syncPlatformAchievements();
            PlatformToolbox::showAchievements();
        }
        else PlatformToolbox::signInGooglePlay();
    }
    void onMoreGames(cocos2d::CCObject* sender) = m1 0x3178f4, win 0x335470, imac 0x391400;
    void onMyProfile(cocos2d::CCObject* sender) = m1 0x317a50;
    void onNewgrounds(cocos2d::CCObject* sender);
    void onOptions(cocos2d::CCObject* sender) = win 0x3357a0, m1 0x3176ac;
    void onOptionsInstant() = win 0x3357b0, m1 0x316184;
    void onPlay(cocos2d::CCObject* sender) = win 0x335700;
    void onQuit(cocos2d::CCObject* sender) = win 0x335cc0;
    void onRobTop(cocos2d::CCObject* sender) = m1 0x31781c;
    void onStats(cocos2d::CCObject* sender) = win 0x335940, m1 0x3176f8;
    void onTrailer(cocos2d::CCObject* sender) = win inline, m1 0x318028, ios inline {
        PlatformToolbox::logEvent("gjl_trailer");
        if (GameToolbox::doWeHaveInternet()) {
            cocos2d::CCApplication::sharedApplication()->openURL("https://www.youtube.com/watch?v=k90y6PIzIaE");
        }
    }
    void onTwitch(cocos2d::CCObject* sender) = m1 0x3178ac;
    void onTwitter(cocos2d::CCObject* sender) = m1 0x317864;
    void onYouTube(cocos2d::CCObject* sender) = m1 0x317888;
    void openOptions(bool videoOptions) = win 0x3357c0, m1 0x317f18;
    void showGCQuestion() = win inline, imac 0x391830 {
        auto alert = FLAlertLayer::create(
            this,
            "Game Center",
            "Do you want to <cg>enable</c>\n<cy>Game Center</c>? You can change this anytime in the options menu.",
            "NO",
            "YES",
            300.f
        );
        alert->setTag(1);
        alert->m_scene = AppDelegate::get()->m_runningScene;
        alert->show();
    }
    void showMeltdownPromo() = win inline, m1 0x317c58, ios inline {}
    void showTOS() = win 0x3351f0, m1 0x317bfc;
    void syncPlatformAchievements(float dt) = win inline, m1 0x317ee8 {
        this->unschedule(schedule_selector(MenuLayer::syncPlatformAchievements));
        GameManager::sharedState()->syncPlatformAchievements();
    }
    void tryShowAd(float dt) = win inline, m1 0x317c5c, ios inline {
        auto gameManager = GameManager::sharedState();
        if (gameManager->shouldShowInterstitial(180, 140, 0)) {
            gameManager->showInterstitial();
            this->unschedule(schedule_selector(MenuLayer::tryShowAd));
        }
    }
    void updateUserProfileButton() = win 0x334f20, m1 0x317ab0;
    void videoOptionsClosed() = win inline, imac 0x391b30, m1 0x317fb0 {
        m_menuGameLayer->m_videoOptionsOpen = false;
    }
    void videoOptionsOpened() = win inline, imac 0x391b10, m1 0x317fa0 {
        m_menuGameLayer->m_videoOptionsOpen = true;
    }
    void willClose() = win 0x335de0, m1 0x315e40;

    bool m_showingTOS;
    cocos2d::CCSprite* m_gpSprite;
    cocos2d::CCSprite* m_viewProfileSprite;
    cocos2d::CCLabelBMFont* m_profileLabel;
    CCMenuItemSpriteExtra* m_profileButton;
    void* m_unknown;
    MenuGameLayer* m_menuGameLayer;
}

[[link(android)]]
class MessageListDelegate {
    virtual void loadMessagesFinished(cocos2d::CCArray* messages, char const* key) {}
    virtual void loadMessagesFailed(char const* key, GJErrorCode errorType) {}
    virtual void forceReloadMessages(bool sent) {}
    virtual void setupPageInfo(gd::string info, char const* key) {}
}

[[link(android)]]
class MessagesProfilePage : FLAlertLayer, FLAlertLayerProtocol, UploadActionDelegate, UploadPopupDelegate, MessageListDelegate {
    // virtual ~MessagesProfilePage();

    static MessagesProfilePage* create(bool sent) = win 0x3362a0, imac 0x22d450, m1 0x1d6c38;

    virtual void registerWithTouchDispatcher() = win 0x42660, m1 0x1d8570, imac 0x22ef50;
    virtual void keyBackClicked() = win 0x3378a0, m1 0x1d8564, imac 0x22ef20;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x337640, imac 0x22eb00, m1 0x1d80dc;
    virtual void onClosePopup(UploadActionPopup* popup) = win 0x13ef20, m1 0x1d816c, imac 0x22eb70;
    virtual void uploadActionFinished(int id, int response) = win 0x337670, m1 0x1d81f4, imac 0x22ebe0;
    virtual void uploadActionFailed(int id, int response) = win 0x13f0e0, m1 0x1d83b4, imac 0x22ed90;
    virtual void loadMessagesFinished(cocos2d::CCArray* messages, char const* key) = win 0x337ef0, imac 0x22f220, m1 0x1d8814;
    virtual void loadMessagesFailed(char const* key, GJErrorCode errorType) = win 0x13f8d0, imac 0x22f350, m1 0x1d8920;
    virtual void forceReloadMessages(bool sent) = win 0x338040, m1 0x1d8a4c, imac 0x22f460;
    virtual void setupPageInfo(gd::string info, char const* key) = win 0x338060, imac 0x22f4a0, m1 0x1d8a80;

    void deleteSelected() = win 0x3373c0, m1 0x1d7f08;
    bool init(bool sent) = win 0x336440;
    bool isCorrect(char const* key);
    void loadPage(int page);
    void onClose(cocos2d::CCObject* sender) = win 0x3377e0;
    void onDeleteSelected(cocos2d::CCObject* sender);
    void onNextPage(cocos2d::CCObject* sender) = win 0x338200;
    void onPrevPage(cocos2d::CCObject* sender) = win 0x338210;
    void onSentMessages(cocos2d::CCObject* sender) = win 0x337040, m1 0x1d77d0;
    void onToggleAllObjects(cocos2d::CCObject* sender) = m1 0x1d7a28;
    void onUpdate(cocos2d::CCObject* sender);
    void setupCommentsBrowser(cocos2d::CCArray* messages) = win 0x337d60, m1 0x1d86b0;
    void untoggleAll();
    void updateLevelsLabel() = win inline, m1 0x1d9084, ios inline {
        auto end = m_pageEndIdx + m_pageStartIdx;
        auto count = m_itemCount;
        if (end > count) end = count;
        m_levelsLabel->setString(cocos2d::CCString::createWithFormat("%i to %i of %i", m_pageStartIdx + 1, end, count)->getCString());
    }
    void updatePageArrows() = win inline, m1 0x1d9020, ios inline {
        m_prevButton->setVisible(m_pageStartIdx != 0);
        m_nextButton->setVisible(m_pageEndIdx + m_pageStartIdx < m_itemCount);
    }

    bool m_sentMessages;
    gd::string m_messageKey;
    cocos2d::CCLabelBMFont* m_levelsLabel;
    cocos2d::CCLabelBMFont* m_errorLabel;
    GJCommentListLayer* m_listLayer;
    LoadingCircle* m_loadingCircle;
    UploadActionPopup* m_actionPopup;
    void* m_unkPtr;
    CCMenuItemSpriteExtra* m_nextButton;
    CCMenuItemSpriteExtra* m_prevButton;
    CCMenuItemSpriteExtra* m_refreshButton;
    CCMenuItemToggler* m_toggleAllToggler;
    int m_itemCount;
    int m_pageStartIdx;
    int m_pageEndIdx;
    int m_page;
    bool m_toggledAll;
}

[[link(android)]]
class MoreOptionsLayer : FLAlertLayer, TextInputDelegate, GooglePlayDelegate, GJDropDownLayerDelegate {
    MoreOptionsLayer() {
        m_page = -1;
        m_toggleCount = 0;
        m_pageCount = 0;
        m_gpSignInBtn = nullptr;
        m_gpSignOutBtn = nullptr;
        m_categoryLabel = nullptr;
    }
    ~MoreOptionsLayer() = win inline, m1 0x6a2a48 {
        CC_SAFE_RELEASE(m_objects);
        CC_SAFE_RELEASE(m_variables);
        auto gpm = GooglePlayManager::sharedState();
        if (gpm->m_delegate2 == this) gpm->m_delegate2 = nullptr;
    }

    static MoreOptionsLayer* create() = win inline, imac 0x79ac40 {
        auto ret = new MoreOptionsLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x373470, m1 0x6a2b3c, imac 0x79b210;
    virtual void keyBackClicked() = win 0x376730, m1 0x6a5d00, imac 0x79e4e0;
    virtual void textInputShouldOffset(CCTextInputNode* node, float yOffset) = win 0x7b620, m1 0x6a5d0c, imac 0x79e510;
    virtual void textInputReturn(CCTextInputNode* node) = win 0x7b680, m1 0x6a5ddc, imac 0x79e5d0;
    virtual void googlePlaySignedIn() = win 0x376740, m1 0x6a5e94, imac 0x79e680;
    virtual void dropDownLayerWillClose(GJDropDownLayer* layer) = win 0x376290, m1 0x6a5bd4, imac 0x79e360;

    void addToggle(char const* label, char const* key, char const* description);
    int countForPage(int page) = win 0x374f10;
    void goToPage(int page) = win 0x375330;
    void incrementCountForPage(int page) = win inline {
        m_objects->setObject(cocos2d::CCString::createWithFormat("%i", this->countForPage(page) + 1), this->pageKey(page));
    }
    const char* infoKey(int index) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("info_%i", index)->getCString();
    }
    cocos2d::CCLayer* layerForPage(int page);
    const char* layerKey(int page) = win inline, m1 0x6a5bac, ios inline {
        return cocos2d::CCString::createWithFormat("layer_%i", page)->getCString();
    }
    cocos2d::CCPoint nextPosition(int page) = win inline, m1 0x6a4e74 {
        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        auto count = this->countForPage(page);
        cocos2d::CCPoint pos = winSize * .5f + cocos2d::CCPoint { count % 2 == 0 ? -160.f : 80.f, 80.f };
        if (count > 1) pos.y -= (int)(count * .5f) * 48;
        return pos;
    }
    const char* objectKey(int page) = win inline, m1 0x6a5b84, ios inline {
        return cocos2d::CCString::createWithFormat("object_%i", page)->getCString();
    }
    cocos2d::CCArray* objectsForPage(int page);
    void offsetToNextPage() = win inline, imac 0x79cb00, m1 0x6a43e0, ios inline {
        if (m_toggleCount % 10 != 0) m_toggleCount = (m_toggleCount - (m_toggleCount % 10)) + 10;
    }
    void onClose(cocos2d::CCObject* sender) = win 0x3765d0, m1 0x6a48f0;
    void onFMODDebug(cocos2d::CCObject* sender) = win 0x376140, m1 0x6a4634;
    void onGPSignIn(cocos2d::CCObject* sender) = win inline, ios inline {
        if (!PlatformToolbox::isSignedInGooglePlay()) PlatformToolbox::signInGooglePlay();
        else this->toggleGP();
    }
    void onGPSignOut(cocos2d::CCObject* sender) = win inline, m1 0x6a4814, ios inline {
        if (PlatformToolbox::isSignedInGooglePlay()) {
            PlatformToolbox::signOutGooglePlay();
            GameManager::sharedState()->m_googlePlaySignedIn = false;
            m_gpSignInBtn->setVisible(true);
            m_gpSignOutBtn->setVisible(false);
        }
        else this->toggleGP();
    }
    void onInfo(cocos2d::CCObject* sender);
    void onKeybindings(cocos2d::CCObject* sender) = m1 0x6a4e58;
    void onNextPage(cocos2d::CCObject* sender);
    void onParental(cocos2d::CCObject* sender) = m1 0x6a48d4;
    void onPrevPage(cocos2d::CCObject* sender);
    void onSongBrowser(cocos2d::CCObject* sender) = m1 0x6a45dc;
    void onToggle(cocos2d::CCObject* sender) = win 0x3758d0, m1 0x6a5138;
    const char* pageKey(int page) = win inline, m1 0x6a5b5c, ios inline {
        return cocos2d::CCString::createWithFormat("page_%i", page)->getCString();
    }
    void toggleGP() = win inline {
        if (PlatformToolbox::isSignedInGooglePlay()) {
            m_gpSignInBtn->setVisible(false);
            m_gpSignOutBtn->setVisible(true);
        }
        else {
            m_gpSignInBtn->setVisible(true);
            m_gpSignOutBtn->setVisible(false);
        }
    }

    int m_page;
    int m_toggleCount;
    int m_pageCount;
    cocos2d::CCDictionary* m_variables;
    cocos2d::CCDictionary* m_objects;
    CCMenuItemSpriteExtra* m_leftBtn;
    CCMenuItemSpriteExtra* m_rightBtn;
    CCTextInputNode* m_offsetInput;
    CCMenuItemSpriteExtra* m_gpSignInBtn;
    CCMenuItemSpriteExtra* m_gpSignOutBtn;
    cocos2d::CCLabelBMFont* m_categoryLabel;
}

[[link(android)]]
class MoreSearchLayer : FLAlertLayer, TextInputDelegate {
    MoreSearchLayer() {}
    ~MoreSearchLayer() = win inline, m1 0x54fa18 {
        CC_SAFE_RELEASE(m_commonSongNodes);
        CC_SAFE_RELEASE(m_normalSongNodes);
        CC_SAFE_RELEASE(m_customSongNodes);
    }

    static MoreSearchLayer* create() = win inline, m1 0x54e888 {
        auto ret = new MoreSearchLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x312950, m1 0x54fc58, imac 0x62ca90;
    virtual void keyBackClicked() = win 0x3176c0, imac 0x62ec10, m1 0x551c64;
    virtual void textInputShouldOffset(CCTextInputNode* node, float yOffset) = win 0x7b620, m1 0x551adc, imac 0x62eaa0;
    virtual void textInputReturn(CCTextInputNode* node) = win 0x7b680, m1 0x551bac, imac 0x62eb60;

    void audioNext(cocos2d::CCObject* sender);
    void audioPrevious(cocos2d::CCObject* sender) = m1 0x551614;
    CCMenuItemToggler* createToggleButton(gd::string label, cocos2d::SEL_MenuHandler callback, bool toggled, cocos2d::CCMenu* menu, cocos2d::CCPoint position) = win 0x317060;
    void onClose(cocos2d::CCObject* sender) = win 0x3172c0, imac 0x62de30, m1 0x550e18;
    void onCoins(cocos2d::CCObject* sender) = m1 0x551234;
    void onCompleted(cocos2d::CCObject* sender) = m1 0x5511b4;
    void onEpic(cocos2d::CCObject* sender) = m1 0x551404;
    void onFeatured(cocos2d::CCObject* sender) = m1 0x5513c4;
    void onFollowed(cocos2d::CCObject* sender) = win inline, m1 0x5517cc, ios inline {
        auto glm = GameLevelManager::sharedState();
        glm->setBoolForKey(!glm->getBoolForKey("follow_filter"), "follow_filter");
    }
    void onFriends(cocos2d::CCObject* sender) = win inline, m1 0x55180c, ios inline {
        auto glm = GameLevelManager::sharedState();
        glm->setBoolForKey(!glm->getBoolForKey("friend_filter"), "friend_filter");
    }
    void onInfo(cocos2d::CCObject* sender) = win 0x316f10, imac 0x62e6c0, m1 0x5516f0;
    void onLegendary(cocos2d::CCObject* sender) = m1 0x551444;
    void onMythic(cocos2d::CCObject* sender) = m1 0x551484;
    void onNoStar(cocos2d::CCObject* sender);
    void onOriginal(cocos2d::CCObject* sender) = m1 0x5511f4;
    void onSongFilter(cocos2d::CCObject* sender) = win 0x315bf0, imac 0x62e270, m1 0x5512b4;
    void onSongMode(cocos2d::CCObject* sender) = win 0x316910, imac 0x62e490, m1 0x5514c4;
    void onTwoPlayer(cocos2d::CCObject* sender) = m1 0x551274;
    void onUncompleted(cocos2d::CCObject* sender);
    void selectSong(int songID) = win 0x3167d0, imac 0x62e930, m1 0x551944;
    void toggleSongNodes(bool custom, bool disable) = win 0x316dd0, imac 0x62e7f0, m1 0x350f4;
    void updateAudioLabel() = win 0x3162d0, m1 0x55198c;

    cocos2d::CCLabelBMFont* m_audioTrackName;
    CCMenuItemSpriteExtra* m_songLeftBtn;
    CCMenuItemSpriteExtra* m_songRightBtn;
    CCMenuItemSpriteExtra* m_normalBtn;
    CCMenuItemSpriteExtra* m_customBtn;
    CCTextInputNode* m_enterSongID;
    cocos2d::CCArray* m_commonSongNodes;
    cocos2d::CCArray* m_normalSongNodes;
    cocos2d::CCArray* m_customSongNodes;
}

[[link(android)]]
class MoreVideoOptionsLayer : FLAlertLayer, TextInputDelegate {
    MoreVideoOptionsLayer() {
        m_page = 0;
        m_toggleCount = 0;
        m_pageCount = 0;
        m_fpsInput = nullptr;
        m_fpsNodes = nullptr;
    }
    ~MoreVideoOptionsLayer() = win inline {
        CC_SAFE_RELEASE(m_values);
        CC_SAFE_RELEASE(m_variables);
    }

    static MoreVideoOptionsLayer* create() = win inline {
        auto ret = new MoreVideoOptionsLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x378950, m1 0x6a7e24, imac 0x7a0a10;
    virtual void keyBackClicked() = win 0x37b270, imac 0x7a2b50, m1 0x6a9e50;

    void addToggle(char const* label, char const* key, char const* description);
    int countForPage(int page) = win 0x379ab0;
    void goToPage(int page);
    void incrementCountForPage(int page) = win inline {
        m_values->setObject(cocos2d::CCString::createWithFormat("%i", this->countForPage(page) + 1), this->pageKey(page));
    }
    const char* infoKey(int index) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("info_%i", index)->getCString();
    }
    cocos2d::CCLayer* layerForPage(int page);
    const char* layerKey(int page) = win inline, m1 0x6a9bec, ios inline {
        return cocos2d::CCString::createWithFormat("layer_%i", page)->getCString();
    }
    cocos2d::CCPoint nextPosition(int page) = win inline {
        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        auto count = this->countForPage(page);
        cocos2d::CCPoint pos = winSize * .5f + cocos2d::CCPoint { count % 2 == 0 ? -135.f : 35.f, 60.f };
        if (count > 1) pos.y -= (int)(count * .5f) * 48;
        return pos;
    }
    const char* objectKey(int page) = win inline, m1 0x6a9bc4, ios inline {
        return cocos2d::CCString::createWithFormat("object_%i", page)->getCString();
    }
    cocos2d::CCArray* objectsForPage(int page);
    void onApplyFPS(cocos2d::CCObject* sender) = win 0x37ad50, imac 0x7a29b0, m1 0x6a9c9c, ios inline {
        auto fps = std::max(cocos2d::CCString::createWithFormat("%.03f", atof(m_fpsInput->getString().c_str()))->floatValue(), 60.f);
        if (fps == floorf(fps)) {
            m_fpsInput->setString(cocos2d::CCString::createWithFormat("%i", (int)fps)->getCString());
        }
        else {
            m_fpsInput->setString(cocos2d::CCString::createWithFormat("%.03f", fps)->getCString());
        }
        auto gameManager = GameManager::sharedState();
        gameManager->m_customFPSTarget = fps;
        gameManager->updateCustomFPS();
    }
    void onClose(cocos2d::CCObject* sender) = win 0x37b220, imac 0x7a1420, m1 0x6a87bc;
    void onInfo(cocos2d::CCObject* sender);
    void onNextPage(cocos2d::CCObject* sender);
    void onPrevPage(cocos2d::CCObject* sender);
    void onToggle(cocos2d::CCObject* sender) = win 0x37a2e0, m1 0x6a8f04;
    const char* pageKey(int page) = win inline, m1 0x6a9b9c, ios inline {
        return cocos2d::CCString::createWithFormat("page_%i", page)->getCString();
    }
    void updateFPSButtons() = m1 0x6a9c14;

    int m_page;
    int m_toggleCount;
    int m_pageCount;
    cocos2d::CCDictionary* m_values;
    cocos2d::CCDictionary* m_variables;
    CCMenuItemSpriteExtra* m_prevButton;
    CCMenuItemSpriteExtra* m_nextButton;
    CCTextInputNode* m_fpsInput;
    cocos2d::CCArray* m_fpsNodes;
}

[[link(android)]]
class MPLobbyLayer : cocos2d::CCLayer, GJMPDelegate, UploadPopupDelegate, UploadActionDelegate, FLAlertLayerProtocol, TextInputDelegate {
    // virtual ~MPLobbyLayer();

    static MPLobbyLayer* create(int type) = m1 0x3f8338;
    static cocos2d::CCScene* scene(int type) = m1 0x3f8248;

    virtual void keyBackClicked() = m1 0x3f87b8, imac 0x493ad0;
    virtual void keyDown(cocos2d::enumKeyCodes key, double timestamp) = imac 0x4942d0, m1 0x3f8ee8;
    virtual void joinLobbyFinished(int id) = imac 0x493c50, m1 0x3f8918;
    virtual void joinLobbyFailed(int id, GJMPErrorCode errorType) = imac 0x494100, m1 0x3f8d2c;
    virtual void updateComments() = m1 0x3f8c24, imac 0x493fb0;
    virtual void didUploadMPComment(int id) = imac 0x4940e0, m1 0x3f8d14;
    virtual void textInputOpened(CCTextInputNode* node) = imac 0x494200, m1 0x3f8e40;
    virtual void textInputClosed(CCTextInputNode* node) = imac 0x494220, m1 0x3f8e48;
    virtual void textChanged(CCTextInputNode* node) = imac 0x494240, m1 0x3f8e50;
    virtual void keyUp(cocos2d::enumKeyCodes key, double timestamp) = imac 0x494310, m1 0x3f8f0c;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = imac 0x494260, m1 0x3f8e58;
    virtual void uploadActionFinished(int id, int response) = m1 0x3f8f14, imac 0x494330;
    virtual void uploadActionFailed(int id, int response) = m1 0x3f913c, imac 0x494550;
    virtual void onClosePopup(UploadActionPopup* popup) = m1 0x3f92f4, imac 0x494700;

    bool init(int type) = m1 0x3f8410;
    void onBack(cocos2d::CCObject* sender) = m1 0x3f8774;
    void onBtn1(cocos2d::CCObject* sender) = imac 0x4937f0;
    void onBtn2(cocos2d::CCObject* sender) = imac 0x4938f0, m1 0x3f8594;
    void onBtn3(cocos2d::CCObject* sender) = imac 0x493900, m1 0x3f8598;
    void onComment(cocos2d::CCObject* sender) = imac 0x493910, m1 0x3f859c;
    void onUpdateLobby();
    void postComment() = imac 0x4939b0, m1 0x3f8690;
    void tryExitLobby() = m1 0x3f8844;
    void updateLobby(float delay) = m1 0x3f8414;

    int m_lobbyID;
    cocos2d::CCLabelBMFont* m_lobbyLabel;
    UploadActionPopup* m_uploadPopup;
    GJCommentListLayer* m_listLayer;
    CCTextInputNode* m_commentInput;
    float m_lobbyDelay;
    bool m_awaitingLobby;
    bool m_lobbyJoined;
}

[[link(android)]]
class MultilineBitmapFont : cocos2d::CCSprite {
    MultilineBitmapFont() {
        m_specialDescriptors = nullptr;
        m_characters = nullptr;
        m_lines = nullptr;
        m_unkInt = 0;
        m_unkBool = false;
        m_unkPtr = nullptr;
        m_height = 0;
        m_width = 0;
        m_maxWidth = 0.f;
        m_disableColor = false;
    }
    ~MultilineBitmapFont() = win inline {
        CC_SAFE_RELEASE(m_characters);
        CC_SAFE_RELEASE(m_lines);
        CC_SAFE_RELEASE(m_specialDescriptors);
    }

    static MultilineBitmapFont* createWithFont(char const* font, gd::string text, float scale, float width, cocos2d::CCPoint anchor, int height, bool disableColor) = win inline, imac 0x486af0 {
        auto ret = new MultilineBitmapFont();
        if (ret->initWithFont(font, text, scale, width, anchor, height, disableColor)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void setOpacity(unsigned char opacity) = win 0x6c7a0, m1 0x3ee228, imac 0x488850;

    bool initWithFont(char const* font, gd::string text, float scale, float width, cocos2d::CCPoint anchor, int height, bool disableColor) = win 0x6bef0;
    void moveSpecialDescriptors(int index, int size) = win 0x6d0f0, m1 0x3ee308;
    gd::string readColorInfo(gd::string text) = win 0x6c820, imac 0x487560, m1 0x3ed074;
    gd::string stringWithMaxWidth(gd::string text, float width, float scale) = win 0x6d180, imac 0x4882b0, m1 0x3edcec;

    std::array<int, 300> m_fontWidths;
    cocos2d::CCArray* m_specialDescriptors;
    cocos2d::CCArray* m_characters;
    cocos2d::CCArray* m_lines;
    int m_unkInt;
    bool m_unkBool;
    void* m_unkPtr;
    int m_height;
    int m_width;
    cocos2d::CCPoint m_position;
    float m_maxWidth;
    bool m_disableColor;
}

[[link(android)]]
class MultiplayerLayer : cocos2d::CCLayer {
    // virtual ~MultiplayerLayer();

    static MultiplayerLayer* create() = m1 0x3202f0;
    static cocos2d::CCScene* scene() = m1 0x320234;

    virtual bool init() = m1 0x320394, imac 0x39ab00;
    virtual void keyBackClicked() = m1 0x32046c, imac 0x39abf0;

    void onBack(cocos2d::CCObject* sender) = m1 0x320428;
    void onBtn1(cocos2d::CCObject* sender) = m1 0x320398;
    void onBtn2(cocos2d::CCObject* sender) = m1 0x3203e0;
}

[[link(android)]]
class MultiTriggerPopup : SetupTriggerPopup {
    // virtual ~MultiTriggerPopup();

    static MultiTriggerPopup* create(EffectGameObject* object, cocos2d::CCArray* objects);

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x469290, imac 0x2cdc70, m1 0x4c8f6c;
}

[[link(android)]]
class MusicArtistObject : cocos2d::CCObject {
    // virtual ~MusicArtistObject();

    static MusicArtistObject* create(int id, gd::string name, gd::string url, gd::string youtube) = win 0x3477f0, imac 0x58dd20, m1 0x4d8aec;

    bool init(int id, gd::string name, gd::string url, gd::string youtube) = win inline, imac 0x59a0c0, m1 0x4e3638, ios inline {
        m_artistID = id;
        m_artistName = name;
        m_artistURL = url;
        m_artistYouTube = youtube;
        return true;
    }

    int m_artistID;
    gd::string m_artistName;
    gd::string m_artistURL;
    gd::string m_artistYouTube;
}

[[link(android)]]
class MusicBrowser : FLAlertLayer, MusicDownloadDelegate, TableViewCellDelegate, SetTextPopupDelegate, FLAlertLayerProtocol, SliderDelegate {
    // virtual ~MusicBrowser();

    static MusicBrowser* create(int songID, GJSongType songType) = win 0x338430, imac 0x60d5d0, m1 0x533208;

    virtual void update(float dt) = win 0x3391b0, m1 0x534570, imac 0x60ea50;
    virtual void registerWithTouchDispatcher() = win 0x42660, m1 0x5354ec, imac 0x60fb20;
    virtual void keyBackClicked() = win 0x33a890, m1 0x5353d0, imac 0x60f9f0;
    virtual void musicActionFinished(GJMusicAction action) = win 0x339ab0, m1 0x534df0, imac 0x60f390 {}
    virtual void musicActionFailed(GJMusicAction action) = win 0x339b20, m1 0x534eb8, imac 0x60f490;
    virtual void sliderEnded(Slider* slider) = win 0x3397f0, m1 0x5346ec, imac 0x60ebd0;
    virtual void setTextPopupClosed(SetTextPopup* popup, gd::string text) = win 0x33a600, imac 0x60f740, m1 0x535148;
    virtual bool cellPerformedAction(TableViewCell* cell, int listType, CellAction action, cocos2d::CCNode* parent) = win 0x33a350, imac 0x60f6c0, m1 0x5350e0;
    virtual int getSelectedCellIdx() = win 0x33a380, imac 0x60f720, m1 0x535138;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x33a7a0, imac 0x60f950, m1 0x535308;

    bool init(int songID, GJSongType songType) = win 0x3385e0;
    void onArtistFilters(cocos2d::CCObject* sender) = win 0x33a710;
    void onClearSearch(cocos2d::CCObject* sender) = imac 0x60e620;
    void onClose(cocos2d::CCObject* sender) = win 0x33a800, m1 0x533e38;
    void onPage(cocos2d::CCObject* sender) = win 0x33a390, imac 0x60e3f0, m1 0x533ec4;
    void onPlaybackControl(cocos2d::CCObject* sender) = win 0x339790, imac 0x60eba0, m1 0x5346b8;
    void onSearch(cocos2d::CCObject* sender) = win 0x33a4b0, imac 0x60e4f0, m1 0x533fc4;
    void onTagFilters(cocos2d::CCObject* sender) = win 0x33a6a0, imac 0x60e680;
    void onUpdateLibrary(cocos2d::CCObject* sender) = win 0x339910, m1 0x533f64;
    void setupList(MusicSearchResult* result) = win 0x339c50, imac 0x60ed40, m1 0x534838;
    void setupMusicBrowser() = win inline {
        auto mdm = MusicDownloadManager::sharedState();
        if (mdm->m_customContentURL.empty()) mdm->getCustomContentURL();
        auto searchResult = MusicSearchResult::create(m_songType);
        searchResult->setTag(m_songType == GJSongType::NCS ? 6 : 0);
        this->setupList(searchResult);
        if (!mdm->m_downloadingMusicLibrary) this->onUpdateLibrary(nullptr);
    }
    void setupSongControls() = win 0x3394b0, m1 0x534280;
    void sliderChanged(cocos2d::CCObject* sender) = m1 0x5346b0;
    void trySetupMusicBrowser();
    void updatePageLabel() = win inline, m1 0x534fcc {
        auto count = m_searchResult->m_filterObjects->count();
        if (count > 0) {
            auto start = m_searchResult->m_startIndex * 10;
            auto end = std::min<int>(start + 10, count);
            m_pageLabel->setString(cocos2d::CCString::createWithFormat("%i to %i of %i", start + 1, end, count)->getCString());
        }
        else m_pageLabel->setString("No matches");
    }

    GJSongType m_songType;
    MusicSearchResult* m_searchResult;
    GJCommentListLayer* m_listLayer;
    cocos2d::CCLabelBMFont* m_infoLabel;
    cocos2d::CCLabelBMFont* m_pageLabel;
    CCMenuItemSpriteExtra* m_prevButton;
    CCMenuItemSpriteExtra* m_nextButton;
    CCMenuItemSpriteExtra* m_refreshButton;
    CCMenuItemSpriteExtra* m_clearSearchButton;
    CCMenuItemSpriteExtra* m_tagFilterButton;
    CCMenuItemSpriteExtra* m_artistFilterButton;
    LoadingCircleSprite* m_circleSprite;
    int m_songID;
    int m_libraryVersion;
    bool m_gettingURL;
    bool m_selectedCell;
    MusicBrowserDelegate* m_delegate;
    Slider* m_playSlider;
    cocos2d::CCLabelBMFont* m_playLabel;
    CCMenuItemSpriteExtra* m_playButton;
    bool m_autoUpdating;
}

[[link(android)]]
class MusicBrowserDelegate {
    virtual void musicBrowserClosed(MusicBrowser* browser) {}
}

[[link(android)]]
class MusicDelegateHandler : cocos2d::CCNode {
    // virtual ~MusicDelegateHandler();
    MusicDelegateHandler() {
        m_delegate = nullptr;
    }

    static MusicDelegateHandler* create(MusicDownloadDelegate* delegate) = win inline, m1 0x4d4ce0 {
        auto ret = new MusicDelegateHandler();
        if (ret->init(delegate)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init(MusicDownloadDelegate* delegate) = win inline, m1 0x1b5f98, ios inline {
        if (!cocos2d::CCNode::init()) return false;
        m_delegate = delegate;
        return true;
    }

    MusicDownloadDelegate* m_delegate;
}

[[link(android)]]
class MusicDownloadDelegate {
    virtual void loadSongInfoFinished(SongInfoObject* object) {}
    virtual void loadSongInfoFailed(int id, GJSongError errorType) {}
    virtual void downloadSongFinished(int id) {}
    virtual void downloadSongFailed(int id, GJSongError errorType) {}
    virtual void songStateChanged() {}
    virtual void downloadSFXFinished(int id) {}
    virtual void downloadSFXFailed(int id, GJSongError errorType) {}
    virtual void musicActionFinished(GJMusicAction action) {}
    virtual void musicActionFailed(GJMusicAction action) {}
}

[[link(android)]]
class MusicDownloadManager : cocos2d::CCNode, PlatformDownloadDelegate {
    // virtual ~MusicDownloadManager();

    static MusicDownloadManager* sharedState() = win 0x33c930, imac 0x5899f0, m1 0x4d4ddc;

    virtual bool init() = win 0x33cf10, imac 0x58a960, m1 0x4d5c54;

    void addDLToActive(char const* tag) = win inline, m1 0x4d68dc, ios inline {
        addDLToActive(tag, cocos2d::CCNode::create());
    }
    void addDLToActive(char const* tag, cocos2d::CCObject* obj) = win 0x33ecf0;
    void addMusicDownloadDelegate(MusicDownloadDelegate* delegate) = win 0x33d0b0, m1 0x4d5dd4;
    SongInfoObject* addSongObjectFromString(gd::string str) = win 0x33d770, imac 0x45fa0, m1 0x4d6980;
    void clearSong(int songID) = win inline {
        const char* key = cocos2d::CCString::createWithFormat("%i", songID)->getCString();
        m_songObjects->removeObjectForKey(key);
    }
    void clearUnusedSongs() = win 0x33e3d0, m1 0x4d93bc;
    cocos2d::CCDictionary* createArtistsInfo(gd::string str) = win 0x33dec0, imac 0x58d280;
    void createSongsInfo(gd::string songsStr, gd::string artistsStr) = win 0x33db10, imac 0x58ce30, m1 0x4d7cd8;
    void dataLoaded(DS_Dictionary* dict) = win 0x33f750, imac 0x2d7f20, m1 0x4dac40;
    void deleteSFX(int id) = win inline, m1 0x4e0444 {
        remove(this->pathForSFX(id).c_str());
    }
    void deleteSong(int id) = win inline, m1 0x4d9168 {
        remove(this->pathForSong(id).c_str());
    }
    void downloadCustomSong(int id);
    void downloadMusicLibrary() = win 0x340670;
    void downloadSFX(int id) = win 0x341f70;
    void downloadSFXFailed(int id, GJSongError errorCode) = m1 0x4dece0;
    void downloadSFXFinished(int id) = win inline, m1 0x4ded54 {
        for (int i = 0; i < m_musicDownloadDelegates->count(); i++) {
            static_cast<MusicDelegateHandler*>(m_musicDownloadDelegates->objectAtIndex(i))->m_delegate->downloadSFXFinished(id);
        }
    }
    void downloadSFXLibrary() = win 0x342710;
    void downloadSong(int id) = win 0x33e750, imac 0x58e760, m1 0x4d9504;
    void downloadSongFailed(int id, GJSongError errorCode) = m1 0x4d9fe0;
    void downloadSongFinished(int id) = win inline, m1 0x4da054 {
        for (int i = 0; i < m_musicDownloadDelegates->count(); i++) {
            static_cast<MusicDelegateHandler*>(m_musicDownloadDelegates->objectAtIndex(i))->m_delegate->downloadSongFinished(id);
        }
    }
    void encodeDataTo(DS_Dictionary* dict) = win inline, m1 0x4dabe8 {
        dict->setDictForKey("MDLM_001", m_songObjects);
        dict->setDictForKey("MDLM_003", m_MDLM003);
        dict->setIntegerForKey("MDLM_002", m_songPriority);
    }
    cocos2d::CCArray* filterMusicByArtistID(int id, cocos2d::CCArray* songs) = win 0xcce30, imac 0x594240, m1 0x4de458;
    cocos2d::CCArray* filterMusicByTag(int id, cocos2d::CCArray* songs) = win 0x341ec0, imac 0x594460, m1 0x4de5b0;
    void firstSetup() = win inline, imac 0x590090, m1 0x4dab80 {
        if (!m_songObjects) {
            auto songObjects = cocos2d::CCDictionary::create();
            CC_SAFE_RETAIN(songObjects);
            CC_SAFE_RELEASE(m_songObjects);
            m_songObjects = songObjects;
        }
        m_songPriority = 0;
    }
    gd::string generateCustomContentURL(gd::string path) = win 0x3437d0, imac 0x5909e0, m1 0x4db458;
    void generateResourceAssetList() = win inline, imac 0x58aa50, m1 0x4d5d28 {
        auto sfxStart = reinterpret_cast<int*>(geode::base::get() + 0x608140);
        m_resourceSfxUnorderedSet.clear();
        m_resourceSfxUnorderedSet.insert(sfxStart, sfxStart + 260);

        auto songStart = reinterpret_cast<int*>(geode::base::get() + 0x608660);
        m_resourceSongUnorderedSet.clear();
        m_resourceSongUnorderedSet.insert(songStart, songStart + 8);
        m_resourceSongUnorderedSet.insert(10006555);
    }
    cocos2d::CCArray* getAllMusicArtists(OptionsObjectDelegate* delegate) = win inline, imac 0x594120, m1 0x4de34c {
        auto ret = cocos2d::CCArray::createWithCapacity(m_musicArtists->count());
        cocos2d::CCDictElement* element;
        cocos2d::CCDictElement* temp;
        if (m_musicArtists) {
            HASH_ITER(hh, m_musicArtists->m_pElements, element, temp) {
                auto object = static_cast<MusicArtistObject*>(element->getObject());
                ret->addObject(OptionsObject::create(object->m_artistID, false, object->m_artistName, delegate));
            }
        }
        if (ret->count() > 1) {
            qsort(ret->data->arr, ret->data->num, sizeof(OptionsObject*), [](void const* a, void const* b) {
                auto objA = *static_cast<OptionsObject* const*>(a);
                auto objB = *static_cast<OptionsObject* const*>(b);
                return objA->m_name.compare(objB->m_name);
            });
        }
        return ret;
    }
    cocos2d::CCArray* getAllMusicObjects(GJSongType type) = win inline, m1 0x4de150 {
        auto ret = cocos2d::CCArray::createWithCapacity(m_musicObjects->count());
        cocos2d::CCDictElement* element;
        cocos2d::CCDictElement* temp;
        if (m_musicObjects) {
            if (type == GJSongType::Music) {
                HASH_ITER(hh, m_musicObjects->m_pElements, element, temp) {
                    ret->addObject(element->getObject());
                }
            }
            else {
                HASH_ITER(hh, m_musicObjects->m_pElements, element, temp) {
                    auto musicObject = static_cast<SongInfoObject*>(element->getObject());
                    if (musicObject->m_nongType == (int)type) {
                        ret->addObject(musicObject);
                    }
                }
            }
        }
        return ret;
    }
    cocos2d::CCArray* getAllMusicTags(OptionsObjectDelegate* delegate) = win inline, imac 0x593fc0, m1 0x4de1f8 {
        auto ret = cocos2d::CCArray::createWithCapacity(m_musicTags.size());
        for (auto& tag : m_musicTags) {
            ret->addObject(OptionsObject::create(tag.first, false, tag.second, delegate));
        }
        if (ret->count() > 1) {
            qsort(ret->data->arr, ret->data->num, sizeof(OptionsObject*), [](void const* a, void const* b) {
                auto objA = *static_cast<OptionsObject* const*>(a);
                auto objB = *static_cast<OptionsObject* const*>(b);
                return objA->m_name.compare(objB->m_name);
            });
        }
        return ret;
    }
    cocos2d::CCArray* getAllSFXObjects(bool onlySFX) = win inline, m1 0x4e039c {
        auto ret = cocos2d::CCArray::create();
        cocos2d::CCDictElement* element;
        cocos2d::CCDictElement* temp;
        if (m_sfxObjects) {
            if (onlySFX) {
                HASH_ITER(hh, m_sfxObjects->m_pElements, element, temp) {
                    auto sfxObject = static_cast<SFXInfoObject*>(element->getObject());
                    if (!sfxObject->m_folder) {
                        ret->addObject(sfxObject);
                    }
                }
            }
            else {
                HASH_ITER(hh, m_sfxObjects->m_pElements, element, temp) {
                    ret->addObject(element->getObject());
                }
            }
        }
        return ret;
    }
    cocos2d::CCArray* getAllSongs() = win inline, m1 0x4d8fe4 {
        auto ret = cocos2d::CCArray::create();
        cocos2d::CCDictElement* element;
        cocos2d::CCDictElement* temp;
        if (m_songObjects) {
            HASH_ITER(hh, m_songObjects->m_pElements, element, temp) {
                ret->addObject(element->getObject());
            }
        }
        return ret;
    }
    void getCustomContentURL() = win 0x33fc40, imac 0x590790, m1 0x4db200;
    cocos2d::CCObject* getDLObject(char const* id) = win 0x39d70;
    cocos2d::CCArray* getDownloadedSongs() = win 0x33e310, m1 0x4d8ce0;
    int getDownloadProgress(int id) = win inline, m1 0x4da0c0 {
        if (auto dlObject = static_cast<cocos2d::extension::CCHttpRequest*>(this->getDLObject(this->getSongDownloadKey(id)))) {
            return dlObject->getDownloadProgress();
        }
        return -1;
    }
    MusicArtistObject* getMusicArtistForID(int id) = win inline, m1 0x4de13c {
        return m_musicArtists ? static_cast<MusicArtistObject*>(m_musicArtists->objectForKey(id)) : nullptr;
    }
    SongInfoObject* getMusicObject(int id) = win inline, ios inline {
        return m_musicObjects ? static_cast<SongInfoObject*>(m_musicObjects->objectForKey(id)) : nullptr;
    }
    char const* getSFXDownloadKey(int id) = win inline, m1 0x4da180, ios inline {
        return cocos2d::CCString::createWithFormat("sfx_%i", id)->getCString();
    }
    int getSFXDownloadProgress(int id) = win inline, m1 0x4da120 {
        if (auto dlObject = static_cast<cocos2d::extension::CCHttpRequest*>(this->getDLObject(this->getSFXDownloadKey(id)))) {
            return dlObject->getDownloadProgress();
        }
        return -1;
    }
    SFXFolderObject* getSFXFolderObjectForID(int id) = win inline, m1 0x4e0104 {
        if (auto sfxObject = sharedState()->getSFXObject(id)) {
            if (sfxObject->m_folder) return static_cast<SFXFolderObject*>(sfxObject);
            if (auto folderObject = static_cast<SFXFolderObject*>(sharedState()->getSFXObject(sfxObject->m_folderID))) {
                if (folderObject->m_folder) return folderObject;
            }
        }
        return nullptr;
    }
    gd::string getSFXFolderPathForID(int id, bool nextFolder) = win 0x3435b0, imac 0x35f160, m1 0x4e02d0;
    SFXInfoObject* getSFXObject(int id) = win inline, m1 0x4e00f0 {
        return m_sfxObjects ? static_cast<SFXInfoObject*>(m_sfxObjects->objectForKey(id)) : nullptr;
    }
    char const* getSongDownloadKey(int id) = win inline, m1 0x4d6014, ios inline {
        return cocos2d::CCString::createWithFormat("d_%i", id)->getCString();
    }
    void getSongInfo(int id, bool download) = win 0x33d300, imac 0x58b160, m1 0x4d6468;
    char const* getSongInfoKey(int id) = win inline, m1 0x4d5fec, ios inline {
        return cocos2d::CCString::createWithFormat("i_%i", id)->getCString();
    }
    SongInfoObject* getSongInfoObject(int id) = win 0x33ee70, imac 0x29c850, m1 0x4d6324;
    int getSongPriority() = win inline, imac 0x58b140, m1 0x4d6454, ios inline {
        return ++m_songPriority;
    }
    void handleIt(bool success, gd::string response, gd::string tag, GJHttpType type) = win 0x33ce20, imac 0x589fc0, m1 0x4d52f0;
    void handleItDelayed(bool success, gd::string response, gd::string tag, GJHttpType type) = win inline, ios inline {
        auto result = GJHttpResult::create(true, response, tag, type);
        result->retain();
        m_pActionManager->addAction(cocos2d::CCSequence::create(
            cocos2d::CCDelayTime::create(.1f),
            cocos2d::CCCallFuncND::create(this, callfuncND_selector(GJMultiplayerManager::handleItND), result),
            nullptr
        ), this, false);
    }
    void handleItND(cocos2d::CCNode* node, void* data) = win inline, ios inline {
        auto result = static_cast<GJHttpResult*>(data);
        this->handleIt(result->m_success, result->m_response, result->m_requestTag, result->m_httpType);
        result->release();
    }
    void incrementPriorityForSong(int id) = win inline, imac 0x58afd0, m1 0x4d62f0 {
        if (auto songObject = this->getSongInfoObject(id)) {
            songObject->m_priority = this->getSongPriority();
        }
    }
    bool isDLActive(char const* tag) = win inline, imac 0x58ad00, m1 0x4d5fd0, ios inline {
        return this->getDLObject(tag) != nullptr;
    }
    bool isMusicLibraryLoaded() = win inline, ios inline {
        return m_musicObjects && m_musicObjects->count() != 0;
    }
    bool isResourceSFX(int id) = win inline, ios inline {
        return m_resourceSfxUnorderedSet.count(id) != 0;
    }
    bool isResourceSong(int id) = win inline, ios inline {
        return m_resourceSongUnorderedSet.count(id) != 0;
    }
    bool isRunningActionForSongID(int id) = win 0x33d220, imac 0x58ac90, m1 0x4d5f48;
    bool isSFXDownloaded(int id) = win 0x33f2b0;
    bool isSFXLibraryLoaded() = win inline, ios inline {
        return m_sfxObjects && m_sfxObjects->count() != 0;
    }
    bool isSongDownloaded(int id) = win 0x33ef80;
    void limitDownloadedSongs() = win inline, m1 0x4d9034 {
        auto gameManager = GameManager::sharedState();
        auto menuSongID = gameManager->m_customMenuSongID;
        auto practiceSongID = gameManager->m_customPracticeSongID;
        auto downloadedSongs = this->getDownloadedSongs();
        while (downloadedSongs->count() > 50) {
            auto songObject = static_cast<SongInfoObject*>(downloadedSongs->lastObject());
            if (songObject->m_songID != menuSongID && songObject->m_songID != practiceSongID) {
                this->deleteSong(songObject->m_songID);
            }
            downloadedSongs->removeLastObject();
        }
    }
    void loadSongInfoFailed(int id, GJSongError errorCode) = m1 0x4d690c;
    void loadSongInfoFinished(SongInfoObject* object) = win 0x344160, m1 0x4d6870;
    void musicActionFailed(GJMusicAction action) = m1 0x4db380;
    void musicActionFinished(GJMusicAction action) = m1 0x4db3ec;
    gd::string nameForTagID(int id) = win inline {
        return m_musicTags.count(id) ? m_musicTags[id] : "";
    }
    void onDownloadMusicLibraryCompleted(cocos2d::extension::CCHttpClient* client, cocos2d::extension::CCHttpResponse* response) = win 0x340900;
    void onDownloadSFXCompleted(cocos2d::extension::CCHttpClient* client, cocos2d::extension::CCHttpResponse* response) = win 0x3421d0;
    void onDownloadSFXLibraryCompleted(cocos2d::extension::CCHttpClient* client, cocos2d::extension::CCHttpResponse* response) = win 0x342970;
    void onDownloadSongCompleted(cocos2d::extension::CCHttpClient* client, cocos2d::extension::CCHttpResponse* response) = win 0x33ea50;
    void onGetCustomContentURLCompleted(gd::string response, gd::string tag) = win 0x33feb0, m1 0x4d5a00;
    void onGetSongInfoCompleted(gd::string response, gd::string tag) = win 0x33d5e0, imac 0x58a3f0, m1 0x4d5770;
    void onProcessHttpRequestCompleted(cocos2d::extension::CCHttpClient* client, cocos2d::extension::CCHttpResponse* response);
    void onTryUpdateMusicLibraryCompleted(cocos2d::extension::CCHttpClient* client, cocos2d::extension::CCHttpResponse* response) = win 0x340540;
    void onTryUpdateSFXLibraryCompleted(cocos2d::extension::CCHttpClient* client, cocos2d::extension::CCHttpResponse* response) = win 0x3425d0;
    void parseMusicLibrary() = win 0x340ab0, imac 0x46e340;
    void parseSFXLibrary() = win 0x342b00, m1 0x4df4bc;
    gd::string pathForSFX(int id) = win 0x33f530, imac 0x58fc90, m1 0x4da7d4;
    gd::string pathForSFXFolder(int id) = win 0x33f3e0;
    gd::string pathForSong(int id) = win 0x33f200, m1 0x4d92d0;
    gd::string pathForSongFolder(int id) = win 0x33f0b0;
    cocos2d::extension::CCHttpRequest* ProcessHttpGetRequest(gd::string url, gd::string tag, cocos2d::extension::SEL_HttpResponse selector, int connectTimeout, int readTimeout) = win 0x33cc00, imac 0x589e50, m1 0x4d51d0;
    callback void ProcessHttpRequest(gd::string url, gd::string params, gd::string tag, GJHttpType type) = win 0x33cac0, m1 0x4d4ea0;
    void removeDLFromActive(char const* tag) = win 0x33edc0;
    void removeMusicDownloadDelegate(MusicDownloadDelegate* delegate) = win 0x33d190, m1 0x4d5ec8;
    cocos2d::CCDictionary* responseToDict(gd::string response, char const* delimiter) = win 0x33e0c0, m1 0x4d6c20;
    void showTOS(FLAlertLayerProtocol* delegate) = win 0x33f5f0, imac 0x58ffb0, m1 0x4daa9c;
    void songStateChanged() = win 0x33d2a0, m1 0x4d6294;
    void stopDownload(int id) = win inline, imac 0x58ad60, m1 0x4d603c {
        auto key = this->getSongDownloadKey(id);
        if (auto dlObject = static_cast<cocos2d::extension::CCHttpRequest*>(this->getDLObject(key))) {
            dlObject->setShouldCancel(true);
        }
        this->removeDLFromActive(key);
    }
    void storeMusicObject(SongInfoObject* object) = win inline, m1 0x4de130, ios inline {
        m_musicObjects->setObject(object, object->m_songID);
    }
    void storeSFXInfoObject(SFXInfoObject* object) = win inline, imac 0x595e60, m1 0x4dfe30 {
        m_sfxObjects->setObject(object, object->m_sfxID);
        if (object->m_folderID > 0) {
            if (auto folderObject = static_cast<SFXFolderObject*>(m_sfxObjects->objectForKey(object->m_folderID))) {
                if (folderObject->m_folder) folderObject->m_sfxObjects->addObject(object);
            }
        }
    }
    void tryLoadLibraries() = win inline {
        if (m_triedToLoadLibraries) return;
        m_triedToLoadLibraries = true;
        if (!this->isSFXLibraryLoaded()) this->parseSFXLibrary();
        if (!this->isMusicLibraryLoaded()) this->parseMusicLibrary();
    }
    void tryUpdateMusicLibrary() = win 0x3402b0;
    void tryUpdateSFXLibrary() = win 0x342330;

    cocos2d::CCDictionary* m_activeDownloads;
    cocos2d::CCArray* m_musicDownloadDelegates;
    cocos2d::CCDictionary* m_songObjects;
    cocos2d::CCDictionary* m_MDLM003;
    int m_songPriority;
    gd::string m_customContentURL;
    cocos2d::CCDictionary* m_sfxObjects;
    cocos2d::CCArray* m_sfxArtists;
    int m_sfxLibraryVersion;
    int m_sfxObjectCount;
    bool m_requestedSfxLibraryDownloaded;
    cocos2d::CCDictionary* m_musicObjects;
    cocos2d::CCDictionary* m_musicArtists;
    gd::map<int, gd::string> m_musicTags;
    int m_musicLibraryVersion;
    int m_musicObjectCount;
    int m_ncsSongCount;
    bool m_downloadingMusicLibrary;
    bool m_triedToLoadLibraries;
    bool m_unkBool;
    gd::unordered_set<int> m_resourceSfxUnorderedSet;
    gd::unordered_set<int> m_resourceSongUnorderedSet;
}

[[link(android)]]
class MusicSearchResult : cocos2d::CCObject, OptionsObjectDelegate {
    MusicSearchResult() = win 0x33b5b0 {
        m_filterObjects = nullptr;
        m_tagFilterObjects = nullptr;
        m_artistFilterObjects = nullptr;
        m_startIndex = 0;
        m_audioType = 0;
        m_sortType = AudioSortType::NameAscending;
        m_tagFilter = false;
        m_artistFilter = false;
        m_songType = GJSongType::Music;
    }
    ~MusicSearchResult() = win inline, m1 0x4e23f8 {
        CC_SAFE_RELEASE(m_filterObjects);
    }

    static MusicSearchResult* create(GJSongType songType) = win inline, imac 0x598bc0, m1 0x4e252c {
        auto ret = new MusicSearchResult();
        if (ret->init(songType)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void updateObjects(AudioSortType type) = win 0x347060, m1 0x4e2f10, imac 0x5998e0;
    virtual void stateChanged(OptionsObject* object) = win 0x347050, imac 0x599880, m1 0x4e2ee0;

    cocos2d::CCArray* applyArtistFilters(cocos2d::CCArray* objects) = win inline, m1 0x4e2994 {
        if (objects->count() == 0) return objects;
        auto filterObjects = cocos2d::CCArray::create();
        m_artistFilter = false;
        for (auto obj : geode::cocos::CCArrayExt<cocos2d::CCObject*, false>(m_artistFilterObjects)) {
            auto object = static_cast<OptionsObject*>(obj);
            if (object->m_enabled) {
                m_artistFilter = true;
                auto filtered = MusicDownloadManager::sharedState()->filterMusicByArtistID(object->m_optionID, objects);
                for (auto fobj : geode::cocos::CCArrayExt<cocos2d::CCObject*, false>(filtered)) {
                    filterObjects->addObject(fobj);
                }
            }
        }
        return m_artistFilter ? filterObjects : objects;
    }
    cocos2d::CCArray* applyTagFilters(cocos2d::CCArray* objects) = win 0x346f80, imac 0x598f30, m1 0x4e27cc;
    void createArtistFilterObjects() = win inline {
        if (m_artistFilterObjects) return;
        auto objects = MusicDownloadManager::sharedState()->getAllMusicArtists(this);
        if (m_artistFilterObjects != objects) {
            CC_SAFE_RETAIN(objects);
            CC_SAFE_RELEASE(m_artistFilterObjects);
            m_artistFilterObjects = objects;
        }
    }
    void createTagFilterObjects() = win inline {
        if (m_tagFilterObjects) return;
        auto objects = MusicDownloadManager::sharedState()->getAllMusicTags(this);
        if (m_tagFilterObjects != objects) {
            CC_SAFE_RETAIN(objects);
            CC_SAFE_RELEASE(m_tagFilterObjects);
            m_tagFilterObjects = objects;
        }
    }
    cocos2d::CCArray* getFilesMatchingSearch(cocos2d::CCArray* objects, gd::string query) = win 0x3475b0, imac 0x5201f0, m1 0x43afb8;
    bool init(GJSongType songType) = win inline, imac 0x598c40, m1 0x4e25a0, ios inline {
        m_songType = songType;
        return true;
    }
    void updateFutureCount(cocos2d::CCArray* objects, cocos2d::CCArray* allObjects) = win inline, imac 0x5993b0, m1 0x4e2b40 {
        auto count = objects->count();
        for (auto obj : geode::cocos::CCArrayExt<cocos2d::CCObject*, false>(m_tagFilterObjects)) {
            auto object = static_cast<OptionsObject*>(obj);
            object->m_count = object->m_enabled ? MusicDownloadManager::sharedState()->filterMusicByTag(object->m_optionID, objects)->count() : count;
        }
        auto filtered = this->applyTagFilters(allObjects);
        for (auto obj : geode::cocos::CCArrayExt<cocos2d::CCObject*, false>(m_artistFilterObjects)) {
            auto object = static_cast<OptionsObject*>(obj);
            object->m_count = MusicDownloadManager::sharedState()->filterMusicByArtistID(object->m_optionID, filtered)->count();
        }
    }
    void updateObjects() = win inline, imac 0x5998c0, m1 0x4e2f00 {
        this->updateObjects(m_sortType);
    }

    cocos2d::CCArray* m_filterObjects;
    cocos2d::CCArray* m_tagFilterObjects;
    cocos2d::CCArray* m_artistFilterObjects;
    int m_startIndex;
    int m_audioType;
    gd::string m_searchQuery;
    AudioSortType m_sortType;
    bool m_tagFilter;
    bool m_artistFilter;
    GJSongType m_songType;
}

[[link(android)]]
class NCSInfoLayer : FLAlertLayer, FLAlertLayerProtocol {
    // virtual ~NCSInfoLayer();
    NCSInfoLayer() {}

    static NCSInfoLayer* create(CustomSongLayer* layer) = win inline, m1 0x1c1224 {
        auto ret = new NCSInfoLayer();
        if (ret->init(layer)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyBackClicked() = win 0x846c0, imac 0x218430, m1 0x1c3900;

    bool init(CustomSongLayer* layer) = win 0xc6400;
    void onClose(cocos2d::CCObject* sender) = win 0x84690, imac 0x218400, m1 0x1c38c4, ios inline {
        this->setKeypadEnabled(false);
        this->removeFromParentAndCleanup(true);
    }
    void onLibrary(cocos2d::CCObject* sender) = win 0xc6c50, imac 0x218330, m1 0x1c37f4;
    void onNCS(cocos2d::CCObject* sender) = m1 0x1c3858;
    void onNCSIO(cocos2d::CCObject* sender) = m1 0x1c387c;
    void onNCSUsage(cocos2d::CCObject* sender) = m1 0x1c38a0;

    CustomSongLayer* m_songLayer;
}

[[link(android)]]
class NewgroundsInfoLayer : FLAlertLayer, FLAlertLayerProtocol {
    // virtual ~NewgroundsInfoLayer();
    NewgroundsInfoLayer() {}

    static NewgroundsInfoLayer* create() = win inline, m1 0x1c1324 {
        auto ret = new NewgroundsInfoLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0xc5670, m1 0x1c2610, imac 0x217150;
    virtual void keyBackClicked() = win 0x846c0, m1 0x1c311c, imac 0x217c30;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0xc63d0, m1 0x1c30c4, imac 0x217bd0;

    void onArtists(cocos2d::CCObject* sender) = win 0xc5fb0, m1 0x1c2e5c;
    void onChanges(cocos2d::CCObject* sender) = win 0xc6270, imac 0x217a60;
    void onClose(cocos2d::CCObject* sender) = win 0x84690, m1 0x1c2e20;
    void onGuidelines(cocos2d::CCObject* sender) = m1 0x1c2eb4;
    void onInfo(cocos2d::CCObject* sender) = win 0xc6120, imac 0x217b20, m1 0x1c2fdc;
    void onNewgrounds(cocos2d::CCObject* sender) = m1 0x1c2e90;
    void onSupporter(cocos2d::CCObject* sender) = m1 0x1c2ed8;
}

[[link(android)]]
class NodePoint : cocos2d::CCObject {
    // virtual ~NodePoint();
    NodePoint() {}

    static NodePoint* create(cocos2d::CCPoint point) = win inline, m1 0xe132c, ios inline {
        auto ret = new NodePoint();
        if (ret->init(point)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init(cocos2d::CCPoint point) = win inline, m1 0xe13e0, ios inline {
        m_point = point;
        return true;
    }

    cocos2d::CCPoint m_point;
}

[[link(android)]]
class NumberInputDelegate {
    virtual void numberInputClosed(NumberInputLayer* layer) {}
}

[[link(android)]]
class NumberInputLayer : FLAlertLayer {
    // virtual ~NumberInputLayer();
    NumberInputLayer() {
        m_okButton = nullptr;
        m_minimum = 4;
        m_maximum = 4;
        m_delegate = nullptr;
    }

    static NumberInputLayer* create() = win inline, m1 0x3f6c50 {
        auto ret = new NumberInputLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x348130, m1 0x3f6d54, imac 0x491ec0;
    virtual void registerWithTouchDispatcher() = win 0x52df0, m1 0x3f7bf0, imac 0x492dd0;
    virtual void keyBackClicked() = win 0x846c0, m1 0x3f7b74, imac 0x492d60;

    void deleteLast() = win inline, m1 0x3f7840 {
        if (!m_inputString.empty()) {
            m_inputString = m_inputString.substr(0, m_inputString.size() - 1);
            this->updateNumberState();
        }
    }
    void inputNumber(int num) = win inline, imac 0x492c60, m1 0x8b328 {
        if (m_inputString.size() < m_maximum) {
            m_inputString += cocos2d::CCString::createWithFormat("%i", num)->getCString();
            this->updateNumberState();
        }
    }
    void onClose(cocos2d::CCObject* sender) = win 0x84690, imac 0x4928e0, m1 0x3f76b4;
    void onDone(cocos2d::CCObject* sender) = win inline, imac 0x492c10, m1 0x3f7a04 {
        if (m_delegate) m_delegate->numberInputClosed(this);
        this->onClose(nullptr);
    }
    void onNumber(cocos2d::CCObject* sender) = win 0x3486e0, imac 0x492910, m1 0x3f76f0;
    void updateNumberState() = win 0x348870, imac 0x492990;

    cocos2d::CCLabelBMFont* m_inputLabel;
    CCMenuItemSpriteExtra* m_okButton;
    int m_minimum;
    int m_maximum;
    gd::string m_inputString;
    NumberInputDelegate* m_delegate;
}

[[link(android)]]
class OBB2D : cocos2d::CCNode {
    // virtual ~OBB2D();

    static OBB2D* create(cocos2d::CCPoint center, float width, float height, float rotationAngle) = win 0x6d8d0, imac 0x5f2f50, m1 0x51c5d4;

    void calculateWithCenter(cocos2d::CCPoint center, float width, float height, float rotationAngle) = win 0x6daa0, imac 0x5f3080, m1 0x51c758;
    void computeAxes() = win inline, imac 0x5f3230 {
        m_edges[0] = m_corners[1] - m_corners[0];
        m_edges[1] = m_corners[3] - m_corners[0];
        for (int i = 0; i < 2; i++) {
            m_edges[i] = m_edges[i] * (1.f / (m_edges[i].x * m_edges[i].x + m_edges[i].y * m_edges[i].y));
            m_projections[i] = m_corners[0].x * m_edges[i].x + m_corners[0].y * m_edges[i].y;
        }
    }
    cocos2d::CCRect getBoundingRect() = win 0x6e290, imac 0x5f3930, m1 0x36d8c4;
    bool init(cocos2d::CCPoint center, float width, float height, float rotationAngle) = win inline {
        if (!CCNode::init()) return false;
        this->calculateWithCenter(center, width, height, rotationAngle);
        return true;
    }
    void orderCorners() = win 0x6ddc0, imac 0x5f3390, m1 0x51c9d0;
    bool overlaps(OBB2D* other) = win inline, imac 0x5f3710, m1 0x1ca190 {
        return this->overlaps1Way(other) && other->overlaps1Way(this);
    }
    bool overlaps1Way(OBB2D* other) = win 0x6e150, imac 0x5f3740, m1 0x51cda0;

    std::array<cocos2d::CCPoint, 4> m_corners;
    std::array<cocos2d::CCPoint, 4> m_positions;
    std::array<cocos2d::CCPoint, 4> m_edges;
    std::array<double, 2> m_projections;
    cocos2d::CCPoint m_center;
}

[[link(android)]]
class ObjectControlGameObject : EffectGameObject {
    // virtual ~ObjectControlGameObject();
    ObjectControlGameObject() {}

    static ObjectControlGameObject* create() = win inline, m1 0x19d5ec {
        auto ret = new ObjectControlGameObject();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x4c29f0, m1 0x19d6ac, imac 0x1ee4e0;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4c2bd0, m1 0x19db60, imac 0x1eea60;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x4c2a60, m1 0x19d6fc, imac 0x1ee530;
}

[[link(android)]]
class ObjectManager : cocos2d::CCNode {
    static ObjectManager* instance() = win 0x6e420, imac 0x4778e0, m1 0x69d38c;
    static cocos2d::CCDictionary* replaceAllOccurencesOfString(cocos2d::CCString* target, cocos2d::CCString* replacement, cocos2d::CCDictionary* dict) = win 0x6f1f0, imac 0x795eb0, m1 0x69e128;

    // virtual ~ObjectManager();
    virtual bool init() = win 0x6e4b0, m1 0x69d454, imac 0x795160;

    bool animLoaded(char const* anim) = win inline {
        return m_loadedAnimations->objectForKey(anim) != nullptr;
    }
    cocos2d::CCDictionary* getDefinition(char const* definitionKey);
    cocos2d::CCDictionary* getGlobalAnimCopy(char const* anim) = win inline, imac 0x795da0 {
        return static_cast<cocos2d::CCDictionary*>(static_cast<cocos2d::CCDictionary*>(m_objectDefinitions->objectForKey("GlobalAnimations"))->objectForKey(anim));
    }
    void loadCopiedAnimations() = win 0x6e850, m1 0x69d4a4;
    void loadCopiedSets() = win 0x6eda0, m1 0x69d910;
    void purgeObjectManager() = win inline, m1 0x69d428 {
        auto objectManager = reinterpret_cast<ObjectManager**>(geode::base::get() + 0x6a4e30);
        if (*objectManager) {
            (*objectManager)->release();
            *objectManager = nullptr;
        }
    }
    void setLoaded(char const* objectName) = win inline {
        m_loadedAnimations->setObject(cocos2d::CCNode::create(), objectName);
    }
    void setup() = win 0x6e510, m1 0x69dc5c;

    cocos2d::CCDictionary* m_objectDefinitions;
    cocos2d::CCDictionary* m_loadedAnimations;
}

[[link(android)]]
class ObjectToolbox : cocos2d::CCNode {
    // virtual ~ObjectToolbox();

    static ObjectToolbox* sharedState() = win 0x3489e0, m1 0x588af0;

    virtual bool init() = win 0x348aa0, m1 0x588c18, imac 0x669fb0;

    cocos2d::CCArray* allKeys() = win inline, imac 0x719df0, m1 0x631838, ios inline {
        return nullptr;
    }
    float gridNodeSizeForKey(int key) = win 0x3708d0, imac 0x719ed0, m1 0x631924;
    const char* intKeyToFrame(int key) = win 0x3708a0, imac 0x719e00, m1 0x631840;
    const char* perspectiveBlockFrame(int key) = win 0x3712f0, m1 0x631a08;

    gd::map<int, gd::string> m_allKeys;
}

[[link(android)]]
class OnlineListDelegate {
    virtual void loadListFinished(cocos2d::CCArray* objects, char const* key) {}
    virtual void loadListFailed(char const* key) {}
    virtual void setupPageInfo(gd::string info, char const* key) {}
}

[[link(android)]]
class OpacityEffectAction {
    void step(float delta) = win inline {
        if (m_disabled || m_finished) return;

        m_deltaTime += delta;
        auto currentTime = m_deltaTime + m_deltaTimeRelated;
        float factor;
        if (currentTime < m_duration) {
            if (currentTime > 0.f) factor = currentTime / m_duration;
            else factor = 0.f;
        }
        else factor = 1.f;
        m_finished = currentTime >= m_duration;
        m_currentValue = (m_toValue - m_fromValue) * factor + m_fromValue;
    }

    float m_duration;
    float m_fromValue;
    float m_toValue;
    bool m_finished;
    bool m_disabled;
    float m_deltaTime;
    int m_targetGroupID;
    float m_currentValue;
    int m_triggerUniqueID;
    int m_controlID;
    float m_deltaTimeRelated;
    float m_durationRelated;
}

[[link(android)]]
class OptionsCell : TableViewCell {
    // virtual ~OptionsCell();
    OptionsCell(char const* identifier, float width, float height) = win inline, m1 0x1fa204 : TableViewCell(identifier, width, height) {
        m_optionsObject = nullptr;
        this->init();
    }

    void loadFromObject(OptionsObject* object) = win 0xb5190, imac 0x243d80, m1 0x1eaaf0;
    void onToggleOption(cocos2d::CCObject* sender) = win 0xb5530, m1 0x1fa270;
    void updateBGColor(int index) = win inline, imac 0x244110, m1 0x1eaec8 {
        m_backgroundLayer->setColor(index % 2 == 0 ? cocos2d::ccColor3B { 161, 88, 44 } : cocos2d::ccColor3B { 194, 114, 62 });
        m_backgroundLayer->setOpacity(255);
    }

    OptionsObject* m_optionsObject;
}

[[link(android)]]
class OptionsLayer : GJDropDownLayer, FLAlertLayerProtocol {
    // virtual ~OptionsLayer();
    OptionsLayer() {
        m_optionsMenu = nullptr;
        m_unknown = nullptr;
        m_layerChoice = 0;
        m_recordReplays = false;
        m_lastVaultDialog = -1;
    }

    static OptionsLayer* create() = win inline, m1 0x6a14b4 {
        auto ret = new OptionsLayer();
        if (ret->init("Settings")) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void customSetup() = win 0x371a40, m1 0x6a164c, imac 0x799bf0;
    virtual void layerHidden() = win 0x373290, imac 0x79b000, m1 0x6a29b4;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win inline, imac 0x79b070, m1 0x6a2a40 {}

    CCMenuItemToggler* createToggleButton(gd::string text, cocos2d::SEL_MenuHandler selector, bool toggled, cocos2d::CCMenu* menu, cocos2d::CCPoint position) = win inline, ios inline {
        auto onSprite = cocos2d::CCSprite::createWithSpriteFrameName("GJ_checkOn_001.png");
        auto offSprite = cocos2d::CCSprite::createWithSpriteFrameName("GJ_checkOff_001.png");
        onSprite->setScale(.8f);
        offSprite->setScale(.8f);
        auto toggler = CCMenuItemToggler::create(offSprite, onSprite, this, selector);
        toggler->toggle(toggled);
        menu->addChild(toggler);
        toggler->setPosition(menu->convertToNodeSpace(position));
        toggler->setSizeMult(1.5f);
        auto label = cocos2d::CCLabelBMFont::create(text.c_str(), "bigFont.fnt");
        m_mainLayer->addChild(label);
        label->setAnchorPoint({ .0f, .5f });
        label->setPosition(position + cocos2d::CCPoint { onSprite->getContentSize().width * .5f + 6.4f, 0.f });
        auto width = label->getContentSize().width;
        if (width > 120.f) label->setScale(120.f / width);
        label->setScale(std::min(label->getScale(), .35f));
        return toggler;
    }
    void exitLayer() = win inline, m1 0x6a267c, ios inline {
        GJDropDownLayer::exitLayer(nullptr);
    }
    void musicSliderChanged(cocos2d::CCObject* sender) = win 0x3726c0, imac 0x79ab40, m1 0x6a2594;
    void onAccount(cocos2d::CCObject* sender) = win 0x3731b0, imac 0x79a5f0, m1 0x6a200c;
    void onHelp(cocos2d::CCObject* sender) = win 0x373160, m1 0x6a201c;
    void onMenuMusic(cocos2d::CCObject* sender) = win 0x3725b0, m1 0x6a2644;
    void onOptions(cocos2d::CCObject* sender) = win 0x3728a0, imac 0x79a630, m1 0x6a2038;
    void onProgressBar(cocos2d::CCObject* sender) = win inline, m1 0x6a28b4, ios inline {
        auto gameManager = GameManager::sharedState();
        gameManager->m_showProgressBar = !gameManager->m_showProgressBar;
    }
    void onRate(cocos2d::CCObject* sender) = win 0x373200, m1 0x6a2070;
    void onRecordReplays(cocos2d::CCObject* sender) = win inline, m1 0x6a231c, ios inline {
        auto gameManager = GameManager::sharedState();
        gameManager->m_recordGameplay = !gameManager->m_recordGameplay;
    }
    void onSecretVault(cocos2d::CCObject* sender) = win 0x372a00;
    void onSoundtracks(cocos2d::CCObject* sender) = m1 0x6a2084;
    void onSupport(cocos2d::CCObject* sender) = imac 0x79a6b0, m1 0x6a2094;
    void onVideo(cocos2d::CCObject* sender) = m1 0x6a2054, ios inline {
        VideoOptionsLayer::create()->show();
    }
    void sfxSliderChanged(cocos2d::CCObject* sender) = win 0x3727c0, m1 0x6a2604;
    void tryEnableRecord() = win inline, imac 0x79af40, m1 0x6a28e4, ios inline {
        m_recordReplays = false;
        FLAlertLayer::create(
            nullptr,
            "Unavailable",
            "Gameplay recording is not supported on this device.",
            "OK",
            nullptr,
            300.f
        )->show();
    }

    cocos2d::CCMenu* m_optionsMenu;
    void* m_unknown;
    int m_layerChoice;
    bool m_recordReplays;
    Slider* m_musicSlider;
    Slider* m_sfxSlider;
    int m_lastVaultDialog;
}

[[link(android)]]
class OptionsObject : cocos2d::CCObject {
    // virtual ~OptionsObject();

    static OptionsObject* create(int id, bool enabled, gd::string name, OptionsObjectDelegate* delegate) = win 0x29e500, imac 0xe1cb0, m1 0x24e27c;

    bool init(int id, bool enabled, gd::string name, OptionsObjectDelegate* delegate) = win inline, imac 0x2b0260, m1 0x24e378, ios inline {
        m_optionID = id;
        m_enabled = enabled;
        m_name = name;
        m_delegate = delegate;
        return true;
    }
    void toggleState() = win inline, imac 0x2b0290, m1 0x24e3b4 {
        m_enabled = !m_enabled;
        if (m_delegate) m_delegate->stateChanged(this);
    }

    int m_optionID;
    bool m_enabled;
    gd::string m_name;
    OptionsObjectDelegate* m_delegate;
    int m_count;
}

[[link(android)]]
class OptionsObjectDelegate {
    virtual void stateChanged(OptionsObject* object) {}
}

[[link(android)]]
class OptionsScrollLayer : FLAlertLayer, TableViewCellDelegate {
    // virtual ~OptionsScrollLayer();

    static OptionsScrollLayer* create(cocos2d::CCArray* objects, bool recreate, int minimum) = win 0x33a8a0, imac 0x60f7e0, m1 0x5351dc;

    virtual void registerWithTouchDispatcher() = win 0x42660, m1 0x535cb4, imac 0x610420;
    virtual void keyBackClicked() = win 0x33ad50, m1 0x535b90, imac 0x6102f0;
    virtual bool cellPerformedAction(TableViewCell* cell, int listType, CellAction action, cocos2d::CCNode* parent) = win 0x33ad60, imac 0x610460, m1 0x535cec;

    cocos2d::CCArray* getRelevantObjects(cocos2d::CCArray* objects) = win inline, m1 0x535b00 {
        auto relevantObjects = cocos2d::CCArray::create();
        for (auto obj : geode::cocos::CCArrayExt<cocos2d::CCObject*, false>(objects)) {
            auto object = static_cast<OptionsObject*>(obj);
            if (object->m_count > m_minCount || object->m_enabled) {
                relevantObjects->addObject(object);
            }
        }
        return relevantObjects;
    }
    bool init(cocos2d::CCArray* objects, bool recreate, int minimum) = win inline {
        if (!FLAlertLayer::init(150)) return false;
        m_noElasticity = true;
        m_recreateList = recreate;
        m_minCount = minimum;
        if (objects) {
            m_optionObjects = objects;
            objects->retain();
        }
        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        m_buttonMenu = cocos2d::CCMenu::create();
        m_mainLayer->addChild(m_buttonMenu, 10);
        m_joystickConnected = -1;
        auto closeButton = CCMenuItemSpriteExtra::create(cocos2d::CCSprite::createWithSpriteFrameName("GJ_closeBtn_001.png"), this, menu_selector(OptionsScrollLayer::onClose));
        closeButton->setSizeMult(1.6f);
        closeButton->setPosition(m_buttonMenu->convertToNodeSpace(winSize * .5f + cocos2d::CCPoint { -210.f, 135.f }));
        this->setupList(m_optionObjects);
        return true;
    }
    void onClose(cocos2d::CCObject* sender) = win 0x33acc0, m1 0x5358dc;
    void setupList(cocos2d::CCArray* objects) = win 0x33aaf0, imac 0x6100d0, m1 0x53596c;

    cocos2d::CCArray* m_optionObjects;
    GJCommentListLayer* m_listLayer;
    bool m_recreateList;
    int m_minCount;
}

[[link(android)]]
class ParentalOptionsLayer : FLAlertLayer {
    ParentalOptionsLayer() {
        m_page = -1;
        m_toggleCount = 0;
        m_maxPage = 0;
    }
    ~ParentalOptionsLayer() = win inline {
        CC_SAFE_RELEASE(m_variables);
        CC_SAFE_RELEASE(m_values);
    }

    static ParentalOptionsLayer* create() = win inline {
        auto ret = new ParentalOptionsLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x37b2c0, m1 0x6aa16c, imac 0x7a2f80;
    virtual void keyBackClicked() = win 0x846c0, imac 0x7a4790, m1 0x6ab8bc;

    void addToggle(char const* label, char const* variable, char const* info) = win 0x37b710;
    int countForPage(int page) = win 0x2c04b0;
    void goToPage(int page);
    void incrementCountForPage(int page) = win inline {
        m_values->setObject(cocos2d::CCString::createWithFormat("%i", this->countForPage(page) + 1), this->pageKey(page));
    }
    const char* infoKey(int index) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("info_%i", index)->getCString();
    }
    cocos2d::CCLayer* layerForPage(int page);
    const char* layerKey(int page) = win inline, m1 0x6ab894, ios inline {
        return cocos2d::CCString::createWithFormat("layer_%i", page)->getCString();
    }
    cocos2d::CCPoint nextPosition(int page) = win inline {
        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        auto count = this->countForPage(page);
        cocos2d::CCPoint pos = winSize * .5f + cocos2d::CCPoint { count % 2 == 0 ? -135.f : 35.f, 60.f };
        if (count > 1) pos.y -= (int)(count * .5f) * 48;
        return pos;
    }
    const char* objectKey(int page) = win inline, m1 0x6ab86c, ios inline {
        return cocos2d::CCString::createWithFormat("object_%i", page)->getCString();
    }
    cocos2d::CCArray* objectsForPage(int page);
    void onClose(cocos2d::CCObject* sender) = win 0x84690;
    void onInfo(cocos2d::CCObject* sender) = win inline {
        FLAlertLayer::create(
            nullptr,
            "Info",
            m_values->valueForKey(this->infoKey(sender->getTag()))->getCString(),
            "OK",
            nullptr,
            300.f
        )->show();
    }
    void onNextPage(cocos2d::CCObject* sender);
    void onPrevPage(cocos2d::CCObject* sender);
    void onToggle(cocos2d::CCObject* sender) = win 0x37beb0, m1 0x6ab1cc;
    const char* pageKey(int page) = win inline, m1 0x6ab844, ios inline {
        return cocos2d::CCString::createWithFormat("page_%i", page)->getCString();
    }

    int m_page;
    int m_toggleCount;
    int m_maxPage;
    cocos2d::CCDictionary* m_values;
    cocos2d::CCDictionary* m_variables;
    CCMenuItemSpriteExtra* m_prevButton;
    CCMenuItemSpriteExtra* m_nextButton;
}

[[link(android)]]
class ParticleGameObject : EnhancedGameObject {
    // virtual ~ParticleGameObject();
    ParticleGameObject() {
        m_updatedParticleData = false;
        m_hasUniformObjectColor = false;
        m_popupPage = 0;
        m_shouldQuickStart = false;
        m_respawnResult = -1.f;
        m_startingRespawn = false;
        m_notPreviewing = false;
    }

    static ParticleGameObject* create() = win 0x49f790, imac 0x1b1150, m1 0x16b7ac;

    virtual bool init() = win 0x49f8b0, m1 0x16b90c, imac 0x1b1330;
    virtual void setScaleX(float scaleX) = win 0x4a0c70, m1 0x16c914, imac 0x1b2390;
    virtual void setScaleY(float scaleY) = win 0x4a0cf0, m1 0x16c988, imac 0x1b2400;
    virtual void setScale(float scale) = win 0x4a0d70, m1 0x16c9fc, imac 0x1b2470;
    virtual void setRotation(float rotation) = win 0x4a0860, m1 0x16c824, imac 0x1b22d0;
    virtual void setRotationX(float rotationX) = win 0x4a08a0, m1 0x16c874, imac 0x1b2310;
    virtual void setRotationY(float rotationY) = win 0x4a0a10, m1 0x16c8c4, imac 0x1b2350;
    virtual void setChildColor(cocos2d::ccColor3B const& color) = win 0x4a0f20, m1 0x16cb6c, imac 0x1b25d0;
    virtual void customSetup() = win 0x49fb00, m1 0x16bb2c, imac 0x1b1600;
    virtual void addMainSpriteToParent(bool reorder) = win 0x49fbd0, m1 0x16bbdc, imac 0x1b16d0;
    virtual void resetObject() = win 0x4a1170, m1 0x16cd28, imac 0x1b27a0;
    virtual void deactivateObject(bool deactivate) = win 0x4a1130, m1 0x16ccec, imac 0x1b2760;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x49f910, imac 0x1b1360, m1 0x16b944;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x4a13c0, imac 0x1b29a0, m1 0x16cf34;
    virtual void claimParticle() = win 0x49fcc0, imac 0x1b17b0, m1 0x16bcc0;
    virtual void unclaimParticle() = win 0x4a0280, m1 0x16c24c, imac 0x1b1d20;
    virtual void particleWasActivated() = win 0x4a0360, m1 0x16c2b4, imac 0x1b1da0;
    virtual void setObjectColor(cocos2d::ccColor3B const& color) = win 0x4a0df0, m1 0x16ca70, imac 0x1b24e0;
    virtual void blendModeChanged() = win 0x49fb90, imac 0x1b1690, m1 0x16bba8;
    virtual void updateParticleColor(cocos2d::ccColor3B const& color) {}
    virtual void updateParticleOpacity(unsigned char opacity) {}
    virtual void updateMainParticleOpacity(unsigned char opacity) = win 0x4a1050, m1 0x16cc68, imac 0x1b26c0;
    virtual void updateSecondaryParticleOpacity(unsigned char opacity) = win 0x4a10d0, m1 0x16ccac, imac 0x1b2710;
    virtual void updateSyncedAnimation(float totalTime, int frameIndex) = win 0x4a11d0, imac 0x1b2800, m1 0x16cd90;
    virtual void updateAnimateOnTrigger(bool animate) = win 0x4a1340, m1 0x16cedc, imac 0x1b2950;

    void applyParticleSettings(cocos2d::CCParticleSystemQuad* particle) = win 0x49fec0;
    void createAndAddCustomParticle() = win inline {
        if (!m_particleData.empty()) {
            m_hasParticles = true;
            this->updateParticleStruct();
            m_hasParticles = true;
        }
    }
    void createParticlePreviewArt() = win 0x4a0650, m1 0x16c61c;
    void setParticleString(gd::string str) = win 0x4a0420, imac 0x1b1ee0, m1 0x16c40c;
    void updateParticle() = win 0x4a04b0, imac 0x1b1f70, m1 0x16c4a0;
    void updateParticleAngle(float angle, cocos2d::CCParticleSystemQuad* particle) = win 0x4a0b40, imac 0x1b1c10, m1 0x16c130;
    void updateParticlePreviewArtOpacity(float opacity) = win 0x4a07e0, imac 0x1b2250, m1 0x16c7a0;
    void updateParticleScale(float scale) = win inline {
        if (m_particle) {
            this->updateParticleAngle(this->getRotation(), m_particle);
            m_particle->loadScaledDefaults(std::abs(scale));
        }
    }
    void updateParticleStruct() = win inline {
        if (!m_updatedParticleData) return;
        m_updatedParticleData = false;
        GameToolbox::particleStringToStruct(m_particleData, m_particleStruct);
    }

    // property 145
    gd::string m_particleData;
    bool m_updatedParticleData;
    cocos2d::ParticleStruct m_particleStruct;
    // property 147
    bool m_hasUniformObjectColor;
    int m_popupPage;
    // property 211
    bool m_shouldQuickStart;
    float m_respawnResult;
    bool m_startingRespawn;
    bool m_notPreviewing;
}

[[link(android)]]
class ParticlePreviewLayer : cocos2d::CCLayerColor {
    // virtual ~ParticlePreviewLayer();
    ParticlePreviewLayer() {
        m_particleMode = 0;
        m_particleSystem = nullptr;
        m_gravityMode = false;
    }

    static ParticlePreviewLayer* create(cocos2d::CCParticleSystemQuad* particleSystem) = win inline, imac 0x472970, m1 0x3d9f20 {
        auto ret = new ParticlePreviewLayer();
        if (ret->init(particleSystem)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void draw() = win 0x4355b0, m1 0x3de274, imac 0x477320;
    virtual void visit() = win 0x4354d0, imac 0x4771a0, m1 0x3de0ec;

    bool init(cocos2d::CCParticleSystemQuad* particleSystem) = win inline, m1 0x3de074 {
        if (!cocos2d::CCLayerColor::initWithColor({ 0, 0, 0, 255 }, 120.f, 180.f)) return false;
        m_particleSystem = particleSystem;
        this->addChild(particleSystem, 100);
        return true;
    }
    void postVisit() = win inline, ios inline {
        glDisable(GL_SCISSOR_TEST);
    }
    void preVisitWithClippingRect(cocos2d::CCRect rect) = win inline, imac 0x477270, m1 0x3de1cc, ios inline {
        if (this->isVisible()) {
            glEnable(GL_SCISSOR_TEST);
            auto position = this->getParent()->convertToWorldSpace(this->getPosition() + rect.origin);
            cocos2d::CCEGLView::sharedOpenGLView()->setScissorInPoints(position.x, position.y, rect.size.width, rect.size.height);
        }
    }

    int m_particleMode;
    int m_drawMode;
    cocos2d::CCParticleSystemQuad* m_particleSystem;
    bool m_gravityMode;
}

[[link(android)]]
class PauseLayer : CCBlockLayer, FLAlertLayerProtocol {
    // virtual ~PauseLayer();
    PauseLayer() {
        m_unfocused = false;
        m_tryingQuit = false;
    }

    static PauseLayer* create(bool unfocused) = win inline, imac 0x3d5780, m1 0x354d90 {
        auto ret = new PauseLayer();
        if (ret && ret->init(unfocused)) {
            ret->autorelease();
            return ret;
        }
        CC_SAFE_DELETE(ret);
        return nullptr;
    }

    virtual void keyBackClicked() = win 0x37eb10, imac 0x3d7730, m1 0x356cec;
    virtual void keyDown(cocos2d::enumKeyCodes key, double timestamp) = win 0x37ea40, m1 0x356c10, imac 0x3d7630;
    virtual void customSetup() = win 0x37c5a0, m1 0x354e64, imac 0x3d5890;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x37e880, imac 0x3d7570, m1 0x356b2c;
    virtual void keyUp(cocos2d::enumKeyCodes key, double timestamp) = win inline, imac 0x3d7710, m1 0x356ce4 {}

    void createToggleButton(gd::string label, cocos2d::SEL_MenuHandler selector, bool toggled, cocos2d::CCMenu* menu, cocos2d::CCPoint position) = win inline, imac 0x3d7160, m1 0x3566f0, ios inline {
        auto onSprite = cocos2d::CCSprite::createWithSpriteFrameName("GJ_checkOn_001.png");
        auto offSprite = cocos2d::CCSprite::createWithSpriteFrameName("GJ_checkOff_001.png");
        onSprite->setScale(.6f);
        offSprite->setScale(.6f);
        auto toggler = CCMenuItemToggler::create(offSprite, onSprite, this, selector);
        toggler->toggle(toggled);
        menu->addChild(toggler);
        toggler->setPosition(menu->convertToNodeSpace(position));
        toggler->setSizeMult(1.5f);
        auto labelNode = cocos2d::CCLabelBMFont::create(label.c_str(), "bigFont.fnt");
        this->addChild(labelNode);
        labelNode->setAnchorPoint({ .0f, .5f });
        labelNode->setPosition(position + cocos2d::CCPoint { onSprite->getContentSize().width * .5f + 3.6f, 0.f });
        labelNode->limitLabelWidth(80.f, .4f, .0f);
    }
    void goEdit() = win 0x37e620, m1 0x3569f4;
    bool init(bool unfocused) = win inline, ios inline {
        m_unfocused = unfocused;
        return CCBlockLayer::init();
    }
    void musicSliderChanged(cocos2d::CCObject* sender) = win 0x37de60, m1 0x356638;
    void onEdit(cocos2d::CCObject* sender) = win 0x37e430, m1 0x356918;
    void onHelp(cocos2d::CCObject* sender) = m1 0x356a5c;
    void onNormalMode(cocos2d::CCObject* sender) = win 0x37dfd0, m1 0x356454;
    void onPracticeMode(cocos2d::CCObject* sender) = win 0x37def0, m1 0x3563fc;
    void onQuit(cocos2d::CCObject* sender) = win 0x37e8f0, m1 0x356a78;
    void onRecordReplays(cocos2d::CCObject* sender) = m1 0x3568e8;
    void onReplay(cocos2d::CCObject* sender);
    void onRestart(cocos2d::CCObject* sender) = win 0x37e140, m1 0x3565d8;
    void onRestartFull(cocos2d::CCObject* sender) = win 0x37e1e0, m1 0x3563c0;
    void onResume(cocos2d::CCObject* sender) = win 0x37e0b0, m1 0x3564a0;
    void onSettings(cocos2d::CCObject* sender) = win 0x37d270, m1 0x356614;
    void onTime(cocos2d::CCObject* sender);
    void onTryEdit(cocos2d::CCObject* sender) = win 0x37e280, m1 0x3562b4;
    void setupProgressBars() = win 0x37d420, m1 0x355934;
    void sfxSliderChanged(cocos2d::CCObject* sender) = win 0x3727c0, m1 0x356678;
    void tryQuit(cocos2d::CCObject* sender) = win 0x37e6f0, m1 0x3564d8;
    void tryShowBanner(float dt) = m1 0x3566b8;

    bool m_unfocused;
    bool m_tryingQuit;
}

[[link(android)]]
class PlatformDownloadDelegate {
    virtual void downloadFinished(char const* key) {}
    virtual void downloadFailed(char const* key) {}
}

[[link(android)]]
class PlatformToolbox {
    static void activateGameCenter() = win inline, imac 0x4c3860, m1 0x42328c {}
    static bool copyToClipboard(gd::string str) = win 0x787b0;
    static bool doesFileExist(gd::string path) = win inline, m1 0x4235f0 {
        return false;
    }
    static void downloadAndSavePromoImage(gd::string url, gd::string path) = win inline, imac 0x3e6270, m1 0x4236a8, ios inline {}
    static void gameDidSave() = win inline, imac 0x4c4560, m1 0x423d64 {
        cocos2d::CCApplication::sharedApplication()->gameDidSave();
    }
    static float getDeviceRefreshRate() {
        return 60.f;
    }
    static cocos2d::CCSize getDisplaySize() = win 0x78720, imac 0x4c46b0, m1 0x423e30;
    static gd::string getRawPath(char const* path) = win inline, imac 0x4c43b0, m1 0x423bf8 {
        return "";
    }
    static gd::string getUniqueUserID() = win 0x78530, imac 0x4c36b0, m1 0x423174;
    static gd::string getUserID() = win inline, imac 0x4c3790, m1 0x423250 {
        return PlatformToolbox::getUniqueUserID();
    }
    static void hideCursor() = win inline, m1 0x4232e0 {
        cocos2d::CCEGLView::sharedOpenGLView()->showCursor(false);
    }
    static bool isControllerConnected() = win inline, imac 0x4c47f0, m1 0x423ef4 {
        return cocos2d::CCApplication::sharedApplication()->getControllerConnected();
    }
    static bool isHD() = win inline, m1 0x4235cc {
        return false;
    }
    static bool isLocalPlayerAuthenticated() = win inline, imac 0x4c3870, m1 0x423290 {
        return false;
    }
    static bool isLowMemoryDevice() = win inline, imac 0x4c37c0, m1 0x42325c {
        return false;
    }
    static bool isNetworkAvailable() = win inline, imac 0x4c37b0, m1 0x423254 {
        return true;
    }
    static bool isSignedInGooglePlay() = win inline, imac 0x4c3880, m1 0x423298 {
        return false;
    }
    static void loadAndDecryptFileToString(char const* dirPath, char const* fileName, gd::string& str) = imac 0x4c3b40, m1 0x42349c;
    static void logEvent(char const* event) = win inline, imac 0x4c3850, m1 0x423288 {}
    static void onGameLaunch() = win inline, imac 0x4c3820, m1 0x423278, ios inline {}
    static void onNativePause() = win inline, imac 0x4c37e0, m1 0x423268 {}
    static void onNativeResume() = win inline, imac 0x4c37f0, m1 0x42326c {}
    static void onToggleKeyboard() = win inline, imac 0x4c3800, m1 0x423270 {}
    static void openAppPage() = win inline, m1 0x423314 {}
    static void platformShutdown() = imac 0x4c4710, m1 0x423e74;
    static void refreshWindow();
    static void reportAchievementWithID(char const* key, int percent) = imac 0x4c38b0, m1 0x17245c;
    static void reportLoadingFinished() = win inline, imac 0x4c37d0, m1 0x423264 {}
    static void resizeWindow(float width, float height) = win inline, imac 0x4c4620, m1 0x423de8 {
        auto view = cocos2d::CCEGLView::sharedOpenGLView();
        view->resizeWindow(width, height);
        view->centerWindow();
    }
    static void saveAndEncryptStringToFile(gd::string& str, char const* dirPath, char const* fileName) = m1 0x423318;
    static void sendMail(char const* title, char const* content, char const* address) = win inline, m1 0x4232dc {}
    static void setBlockBackButton(bool block) = win inline, imac 0x4c3830, m1 0x42327c, ios inline {}
    static void setKeyboardState(bool state) = win inline, imac 0x4c3810, m1 0x423274 {}
    static bool shouldResumeSound() = win inline, imac 0x4c3840, m1 0x423280 {
        return true;
    }
    static void showAchievements() = win inline, m1 0x4232d8 {}
    static void showCursor() = win inline, m1 0x4232f8 {
        cocos2d::CCEGLView::sharedOpenGLView()->showCursor(true);
    }
    static void signInGooglePlay() = win inline, imac 0x4c3890, m1 0x4232a0, ios inline {}
    static void signOutGooglePlay() = win inline, imac 0x4c38a0, m1 0x4232a4, ios inline {}
    static cocos2d::CCSprite* spriteFromSavedFile(gd::string path) = m1 0x4236ac;
    static void toggleCallGLFinish(bool enable) = win inline, imac 0x4c4860, m1 0x423f1c, ios inline {}
    static void toggleCPUSleepMode(bool enable) = win inline, imac 0x4c4840, m1 0x423f14, ios inline {}
    static void toggleForceTimer(bool enable) = win inline, imac 0x4c4870, m1 0x423f20 {
        cocos2d::CCApplication::sharedApplication()->setForceTimer(enable);
    }
    static void toggleFullScreen(bool fullscreen, bool borderless, bool fix) = win inline, imac 0x4c45b0, m1 0x423d94 {
        cocos2d::CCEGLView::sharedOpenGLView()->toggleFullScreen(fullscreen, borderless, fix);
    }
    static void toggleLockCursor(bool isLocked) = win inline, imac 0x4c4610, m1 0x423de4 {
        cocos2d::CCEGLView::sharedOpenGLView()->toggleLockCursor(isLocked);
    }
    static void toggleMouseControl(bool enable) = win inline, imac 0x4c47a0, m1 0x423ec4 {
        cocos2d::CCApplication::sharedApplication()->toggleMouseControl(enable);
    }
    static void toggleSmoothFix(bool enable) = win inline, m1 0x423f24 {
        cocos2d::CCDirector::sharedDirector()->setSmoothFix(enable);
    }
    static void toggleVerticalSync(bool enable) = win inline, imac 0x4c4850, m1 0x423f18 {
        cocos2d::CCApplication::sharedApplication()->toggleVerticalSync(enable);
    }
    static void tryShowRateDialog(gd::string gameName) = win inline, m1 0x126dfc {}
    static void updateMouseControl() = win inline, imac 0x4c4760, m1 0x423ea4, ios inline {
        #ifdef GEODE_IS_WINDOWS
        cocos2d::CCApplication::sharedApplication()->updateMouseControl();
        #endif
    }
    static void updateWindowedSize(float width, float height) = win inline, imac 0x4c46a0, m1 0x423e2c, ios inline {
        #ifdef GEODE_IS_WINDOWS
        cocos2d::CCEGLView::sharedOpenGLView()->setWindowedSize({ width, height });
        #endif
    }
}

class PlayerButtonCommand {
    PlayerButton m_button;
    bool m_isPush;
    bool m_isPlayer2;
    int m_step;
    double m_timestamp;
}

[[link(android)]]
class PlayerCheckpoint : cocos2d::CCNode {
    // virtual ~PlayerCheckpoint();
    PlayerCheckpoint() {
        m_yVelocity = 0.f;
        m_isUpsideDown = false;
        m_isSideways = false;
        m_isShip = false;
        m_isBall = false;
        m_isBird = false;
        m_isSwing = false;
        m_isDart = false;
        m_isRobot = false;
        m_isSpider = false;
        m_isOnGround = false;
        m_ghostType = GhostType::Disabled;
        m_miniMode = false;
        m_speed = 0.f;
        m_hidden = false;
        m_goingLeft = false;
        m_reverseSpeed = 0.f;
        m_dashing = false;
        m_dashX = 0.f;
        m_dashY = 0.f;
        m_dashAngle = 0.f;
        m_dashStartTime = 0.f;
        m_dashRingObject = nullptr;
        m_platformerCheckpoint = false;
        m_lastFlipTime = 0.0;
        m_gravityMod = 1.f;
        m_decreaseBoostSlide = false;
        m_followRelated = 0;
        m_followRelated2 = 0.f;
    }

    static PlayerCheckpoint* create();

    virtual bool init() = win 0x3baed0, m1 0xac358, imac 0xbf8e0;

    cocos2d::CCPoint m_position;
    cocos2d::CCPoint m_lastPosition;
    float m_yVelocity;
    bool m_isUpsideDown;
    bool m_isSideways;
    bool m_isShip;
    bool m_isBall;
    bool m_isBird;
    bool m_isSwing;
    bool m_isDart;
    bool m_isRobot;
    bool m_isSpider;
    bool m_isOnGround;
    GhostType m_ghostType;
    bool m_miniMode;
    float m_speed;
    bool m_hidden;
    bool m_goingLeft;
    float m_reverseSpeed;
    bool m_dashing;
    float m_dashX;
    float m_dashY;
    float m_dashAngle;
    float m_dashStartTime;
    DashRingObject* m_dashRingObject;
    bool m_platformerCheckpoint;
    double m_lastFlipTime;
    float m_gravityMod;
    bool m_decreaseBoostSlide;
    int m_followRelated;
    gd::vector<float> m_playerFollowFloats;
    float m_followRelated2;
}

[[link(android)]]
class PlayerControlGameObject : EffectGameObject {
    // virtual ~PlayerControlGameObject();
    PlayerControlGameObject() {
        m_stopJump = false;
        m_stopMove = false;
        m_stopRotation = false;
        m_stopSlide = false;
    }

    static PlayerControlGameObject* create() = win inline {
        auto ret = new PlayerControlGameObject();
        if (ret && ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x4c2440, m1 0x19c7bc, imac 0x1ed2d0;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4c2870, m1 0x19d488, imac 0x1ee240;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x4c24b0, m1 0x19c80c, imac 0x1ed320;

    // property 540
    bool m_stopJump;
    // property 541
    bool m_stopMove;
    // property 542
    bool m_stopRotation;
    // property 543
    bool m_stopSlide;
}

[[link(android)]]
class PlayerFireBoostSprite : cocos2d::CCSprite {
    // virtual ~PlayerFireBoostSprite();

    static PlayerFireBoostSprite* create() = win 0x3a3a30, imac 0x3fbdf0, m1 0x374608;

    virtual bool init() = win 0x3a3ad0, m1 0x391c0c, imac 0x41d600;

    void animateFireIn() = win inline, m1 0x38c9f0 {
        this->stopAllActions();

        auto scaleto = cocos2d::CCScaleTo::create(0.06f, m_size * 0.6f, m_size * 1.5f);
        auto callfunc = cocos2d::CCCallFunc::create(this, callfunc_selector(PlayerFireBoostSprite::loopFireAnimation));
        auto sequence = cocos2d::CCSequence::create(scaleto, callfunc, nullptr);
        this->runAction(sequence);
    }
    void animateFireOut() = win inline, m1 0x38ca70 {
        this->stopAllActions();
        auto action = cocos2d::CCScaleTo::create(0.4f, 0.01f, 0.01f);
        this->runAction(action);
    }
    void loopFireAnimation() = win 0x3a3b30, m1 0x38c720;

    float m_size;
}

[[link(android), depends(GJPointDouble)]]
class PlayerObject : GameObject, AnimatedSpriteDelegate {
    // virtual ~PlayerObject();
    PlayerObject() = m1 0x391c78 {

        #if defined(__clang__)
        # pragma clang diagnostic push
        # pragma clang diagnostic ignored "-Winvalid-offsetof"
        #endif
        // Almost all members are initialized to zeros, so we can cheat here to avoid unnecessary code
        auto selfSize = sizeof(PlayerObject) - offsetof(PlayerObject, m_mainLayer);
        memset((void*)((uintptr_t)this + offsetof(PlayerObject, m_mainLayer)), 0, selfSize);

        #if defined(__clang__)
        # pragma clang diagnostic pop
        #endif

        m_lastCollisionBottom = -1;
        m_lastCollisionTop = -1;
        m_lastCollisionLeft = -1;
        m_lastCollisionRight = -1;
        m_unk50C = -1;
        m_unk510 = -1;
        new (&m_rotateObjectsRelated) decltype(m_rotateObjectsRelated)();
        new (&m_potentialSlopeMap) decltype(m_potentialSlopeMap)();
        m_rotateSpeed = 1.0f;
        new (&m_ringRelatedSet) decltype(m_ringRelatedSet)();
        m_playerSpeed = 0.9f;
        m_platformerVelocityRelated = 1.0f;
        new (&m_touchedRings) decltype(m_touchedRings)();
        m_gravityMod = 1.0f;
        new (&m_jumpPadRelated) decltype(m_jumpPadRelated)();
        new (&m_holdingButtons) decltype(m_holdingButtons)();
        new (&m_currentRobotAnimation) gd::string("run");
    }
    ~PlayerObject() = win 0x3861d0, imac 0x3f9ec0, m1 0x372a70;

    static PlayerObject* create(int player, int ship, GJBaseGameLayer* gameLayer, cocos2d::CCLayer* layer, bool playLayer) = win 0x386400, imac 0x3fa1a0, m1 0x372c64;

    virtual void update(float dt) = win 0x388ab0, m1 0x3752b8, imac 0x3fcab0;
    virtual void setScaleX(float scale) = win 0x3a35c0, m1 0x3916ac, imac 0x41d010;
    virtual void setScaleY(float scale) = win 0x3a35d0, m1 0x3916b0, imac 0x41d020;
    virtual void setScale(float scale) = win 0x3a35e0, m1 0x3916b4, imac 0x41d030;
    virtual void setPosition(cocos2d::CCPoint const& position) = win 0x39c2d0, m1 0x38dd34, imac 0x418ce0;
    virtual void setVisible(bool visible) = win 0x3a35f0, m1 0x3916b8, imac 0x41d040;
    virtual void setRotation(float rotation) = win 0x3a34f0, m1 0x39163c, imac 0x41cf80;
    virtual void setOpacity(unsigned char opacity) = win 0x39d780, m1 0x38edc8, imac 0x419ee0;
    virtual void setColor(cocos2d::ccColor3B const& color) = win 0x39cfa0, m1 0x38e7ec, imac 0x4198c0;
    virtual void setFlipX(bool flipX) = win 0x3a3500, m1 0x391640, imac 0x41cf90;
    virtual void setFlipY(bool flipY) = win 0x198240, m1 0x3916a8, imac 0x41d000;
    virtual void resetObject() = win 0x396b70, m1 0x38738c, imac 0x4119e0;
    virtual cocos2d::CCPoint getRealPosition() = win 0x39d8b0, imac 0x41a0b0, m1 0x38efc4;
    virtual OBB2D* getOrientedBox() = win 0x3a02e0, imac 0x41b3d0, m1 0x39019c;
    virtual float getObjectRotation() = win 0x3a0300, imac 0x41b3f0, m1 0x3901c8;
    virtual void animationFinished(char const* key) = win 0x3a3610, imac 0x41d130, m1 0x391788;

    void activateStreak() = win 0x39fd20;
    void addAllParticles() = win 0x3883a0, imac 0x3fc720, m1 0x374f60;
    void addToTouchedRings(RingObject* object) = win inline, imac 0x4152e0 {
        if (!m_touchingRings->containsObject(object)) {
            m_touchingRings->addObject(object);
        }
        m_touchedRings.insert(object->m_uniqueID);
    }
    void addToYVelocity(double yVelocity, int type) = win inline, ios inline {
        this->setYVelocity(m_yVelocity + yVelocity, type);
    }
    void animatePlatformerJump(float scale) = win 0x38c9b0;
    void boostPlayer(float yVelocity) = win 0x39fb70, imac 0x406010, m1 0x37d560;
    void bumpPlayer(float bumpMod, int objectType, bool noEffects, GameObject* object) = win 0x39f330;
    bool buttonDown(PlayerButton button) = win inline, ios inline {
        return button == PlayerButton::Jump || m_jumpBuffered;
    }
    bool canStickToGround() = win inline {
        return (!m_isShip && !m_isDart) || !m_stateRingJump;
    }
    void checkSnapJumpToObject(GameObject* object) = m1 0x279290;
    bool collidedWithObject(float dt, GameObject* object) = win inline, imac 0x40c850, m1 0x382a30 {
        return this->collidedWithObject(dt, object, { 0.f, 0.f, 0.f, 0.f }, false);
    }
    bool collidedWithObject(float dt, GameObject* object, cocos2d::CCRect rect, bool skipCheck) = win 0x391640;
    bool collidedWithObjectInternal(float dt, GameObject* object, cocos2d::CCRect rect, bool skipCheck) = win 0x391700;
    void collidedWithSlope(float dt, GameObject* object, bool skipPre) = win inline {
        if (m_isSideways) {
            this->handleRotatedSlopeCollision(dt, object, skipPre);
        } else {
            this->collidedWithSlopeInternal(dt, object, skipPre);
        }
    }
    void collidedWithSlopeInternal(float dt, GameObject* object, bool forced) = win 0x38f4a0, imac 0x406a30;
    float convertToClosestRotation(float rotation) = win 0x38ce30;
    void copyAttributes(PlayerObject* player) = win 0x3a0130, imac 0x41b050, m1 0x38fea0;
    void createFadeOutDartStreak() = win 0x3982f0, m1 0x38a750;
    void createRobot(int frame) = win 0x387c20, imac 0x25afb0, m1 0x374398;
    void createSpider(int frame) = win 0x387fe0, imac 0x3fbec0;
    void deactivateParticle() = win inline {
        if (m_hasGroundParticles) m_playerGroundParticles->stopSystem();
        m_hasGroundParticles = false;
    }
    void deactivateStreak(bool stop) = win inline, m1 0x3750f8 {
        if (!m_alwaysShowStreak || stop) m_regularTrail->stopStroke();
        if (m_fadeOutStreak) {
            m_fadeOutStreak = false;
            this->fadeOutStreak2(m_playEffects ? .2f : .6f);
        }
    }
    bool destroyFromHitHead() = win inline, imac 0x418c80 {
        return !this->isFlying() && !m_isBall && !m_isSpider && m_stateHitHead < 1;
    }
    void didHitHead() = win 0x3938c0;
    void disableCustomGlowColor() = win inline, imac 0x419a10, m1 0x38e91c, ios inline {
        m_hasCustomGlowColor = false;
    }
    void disablePlayerControls() = win 0x39f040, imac 0x41a2c0, m1 0x38f1bc;
    void disableSwingFire() = win 0x39ab90, m1 0x388e30;
    void doReversePlayer(bool reverse) = win 0x3981a0, imac 0x401fc0, m1 0x379bd4;
    void enableCustomGlowColor(cocos2d::ccColor3B const& color) = win inline, imac 0x4199e0, m1 0x38e8fc {
        m_hasCustomGlowColor = true;
        m_glowColor = color;
    }
    void enablePlayerControls() = win 0x39f190, imac 0x41a320, m1 0x38f218;
    void exitPlatformerAnimateJump() = win 0x38cc60, imac 0x402160, m1 0x379dfc;
    void fadeOutStreak2(float duration) = win 0x39fe20, imac 0x413740, m1 0x388d94;
    void flashPlayer(float flashDuration, float flashDelay, cocos2d::ccColor3B mainColor, cocos2d::ccColor3B secondColor) = win inline, imac 0x40e750, m1 0x3845dc, ios inline {
        m_flashMainColor = mainColor;
        m_flashSecondColor = secondColor;
        this->setColor(m_flashMainColor);
        this->setSecondColor(m_flashSecondColor);
        m_flashTime = m_totalTime;
        m_flashDuration = flashDuration;
        m_flashDelay = flashDelay;
    }
    void flipGravity(bool flip, bool noEffects) = win 0x399e60;
    int flipMod() = win inline, ios inline {
        return m_isUpsideDown ? -1 : 1;
    }
    void gameEventTriggered(int gameEvent, int material) = win inline, imac 0x403760, m1 0x37b2cc, ios inline {
        if (this->m_gameLayer) {
            this->m_gameLayer->gameEventTriggered(static_cast<GJGameEvent>(gameEvent), material, static_cast<int>(this->m_uniqueID));
        }
    }
    GameObjectType getActiveMode() = win inline, imac 0x415cd0 {
        if (this->isFlying()) return GameObjectType::ShipPortal;
        else if (m_isBall) return GameObjectType::BallPortal;
        else if (m_isSpider) return GameObjectType::SpiderPortal;
        else return GameObjectType::CubePortal;
    }
    double getCurrentXVelocity() = win inline {
        return m_isPlatformer ? m_platformerXVelocity : m_playerSpeed * m_speedMultiplier;
    }
    float getModifiedSlopeYVel() = win inline, imac 0x403340, m1 0x37aedc, ios inline {
        auto diff = m_totalTime - m_slopeStartTime;
        if (diff > 0.1) {
            if (diff * 10.0 > 0.4) return m_slopeVelocity * diff;
            else return m_slopeVelocity * .4f;
        }
        else return m_slopeVelocity * 1.f;
    }
    float getOldPosition(float dt) = win inline, imac 0x402790, m1 0x37a3c0 {
        if (dt <= 0.f) return m_obPosition.y;
        auto index = m_followRelated % 200 - std::clamp<int>(dt / .01f, 0, 199);
        return m_playerFollowFloats[index + (index < 0 ? 200 : 0)];
    }
    cocos2d::ccColor3B getSecondColor() = win inline, imac 0x4199b0, m1 0x38e8d0 {
        return m_iconSpriteSecondary->getColor();
    }
    double getYVelocity() = win inline, m1 0x375268 {
        return m_yVelocity;
    }
    void gravityDown() = win inline, imac 0x41d090, m1 0x3916e8, ios inline {
        m_gravity -= .001;
        this->logValues();
    }
    void gravityUp() = win inline, imac 0x41d060, m1 0x3916c4, ios inline {
        m_gravity += .001;
        this->logValues();
    }
    void handlePlayerCommand(int command) = win inline, m1 0x3792e4 {
        if (command == 543) {
            m_isAccelerating = false;
            m_affectedByForces = false;
        }
    }
    bool handleRotatedCollisionInternal(float dt, GameObject* object, cocos2d::CCRect rect, bool skipCheck, bool skipPre, bool slope) = win 0x38edd0, imac 0x406540;
    bool handleRotatedObjectCollision(float dt, GameObject* object, cocos2d::CCRect rect, bool skipCheck) = win inline, imac 0x4064e0, m1 0x37da50, ios inline {
        return this->handleRotatedCollisionInternal(dt, object, rect, skipCheck, false, false);
    }
    void handleRotatedSlopeCollision(float dt, GameObject* object, bool skipPre) = win inline, imac 0x4066a0, m1 0x37dc1c, ios inline {
        this->handleRotatedCollisionInternal(dt, object, { 0.f, 0.f, 0.f, 0.f }, false, skipPre, true);
    }
    void hardFlipGravity() = win inline, m1 0x382ffc {
        this->flipGravity(!m_isUpsideDown, true);
        this->setYVelocity(this->flipMod() * -2, 42);
    }
    void hitGround(GameObject* object, bool notFlipped) = win 0x39bbc0, imac 0x2e2210, m1 0x3819d4;
    void hitGroundNoJump(GameObject* object, bool notFlipped) = win 0x39bb60, imac 0x40ccb0, m1 0x382e58, ios inline {
        auto isOnGround = m_isOnGround;
        auto isOnGround2 = m_isOnGround2;
        auto lastLandTime = m_lastLandTime;
        this->hitGround(nullptr, notFlipped);
        m_isOnGround = isOnGround;
        m_isOnGround2 = isOnGround2;
        m_lastLandTime = lastLandTime;
    }
    void incrementJumps() = win 0x38c8d0;
    bool init(int player, int ship, GJBaseGameLayer* gameLayer, cocos2d::CCLayer* layer, bool playLayer) = win 0x3864a0, imac 0x3fa230, m1 0x372d1c;
    bool isBoostValid(float yVelocity) = win inline {
        if (m_isUpsideDown) {
            if (!m_isCurrentSlopeTop && m_slopeFlipGravityRelated) return yVelocity > m_yVelocity;
            else return yVelocity < m_yVelocity;
        }
        else {
            if (!m_isCurrentSlopeTop || !m_slopeFlipGravityRelated) return yVelocity > m_yVelocity;
            else return yVelocity < m_yVelocity;
        }
    }
    bool isFlying() = win inline {
        return m_isShip || m_isBird || m_isDart || m_isSwing;
    }
    bool isInBasicMode() = win inline {
        return !this->isFlying() && !m_isBall && !m_isSpider;
    }
    bool isInNormalMode() = win inline {
        return !this->isFlying() && !m_isBall && !m_isRobot && !m_isSpider;
    }
    bool isSafeFlip(float flipTime) = win inline, imac 0x40b660, m1 0x3819a8 {
        return m_lastFlipTime != 0.0 && m_totalTime - m_lastFlipTime < flipTime;
    }
    bool isSafeHeadTest() = win inline, imac 0x41aee0, m1 0x38fd78 {
        return this->isSafeFlip(0.2f) || this->isSafeMode(0.2f) || m_stateHitHead > 0;
    }
    bool isSafeMode(float changeTime) = win inline, imac 0x40b620, m1 0x38197c, ios inline {
        return m_gameModeChangedTime != 0.0 && m_totalTime - m_gameModeChangedTime < changeTime;
    }
    bool isSafeSpiderFlip(float flipTime) = win inline, imac 0x40d080, m1 0x3831ac, ios inline {
        return m_lastSpiderFlipTime != 0.0 && m_totalTime - m_lastSpiderFlipTime < flipTime;
    }
    void levelFlipFinished() = win 0x38b480, imac 0x403110, m1 0x37accc;
    bool levelFlipping() = win 0x39b180;
    void levelWillFlip() = win 0x38b400, imac 0x4030d0, m1 0x37ac84;
    void limitDashRotation(float& rotation) = win inline, imac 0x410cb0, m1 0x386780 {
        float offset;
        if (m_isSideways) {
            if (m_isGoingLeft) offset = 90.f;
            else offset = -90.f;
            rotation += offset;
            if (rotation > 180.f) rotation -= 360.f;
            else if (rotation < -180.f) rotation += 360.f;
        }
        else {
            if (m_isGoingLeft) {
                offset = 180.f;
                rotation += offset;
                if (rotation > 180.f) rotation -= 360.f;
                else if (rotation < -180.f) rotation += 360.f;
            }
            else offset = 0.f;
        }
        if (std::abs(rotation) > 90.f) {
            if (rotation > 0.f) rotation += 180.f;
            else rotation -= 180.f;
            if (rotation > 180.f) rotation -= 360.f;
            else if (rotation < -180.f) rotation += 360.f;
        }
        if (rotation > 70.f || rotation < -70.f) {
            if (rotation > 0.f) {
                if (rotation <= 70.f || rotation >= 180.f) rotation = -70.f;
            }
            else if (rotation < 70.f || rotation > -180.f) {
                rotation = -70.f;
            }
            else {
                rotation = 70.f;
            }
        }
        if (offset != 0.f) {
            rotation -= offset;
            if (rotation > 180.f) rotation -= 360.f;
            else if (rotation < -180.f) rotation += 360.f;
        }
    }
    void loadFromCheckpoint(PlayerCheckpoint* object);
    void lockPlayer() = win 0x39ef60;
    void logValues() = win inline, imac 0x41d080, m1 0x3916e4, ios inline {}
    void modeDidChange() = win inline {
        this->updatePlayerArt();
        this->updateDashArt();
    }
    void performSlideCheck() = win inline {
        if (m_currentSlope2 && (m_isOnSlope || m_wasOnSlope) && !m_maybeUpsideDownSlope && !m_currentSlope2->m_isGripSlope && std::abs(m_slopeAngle * (180.f / M_PI)) > 40.f) {
            auto movingLeft = m_platformerMovingLeft;
            auto movingRight = m_platformerMovingRight;
            if (m_slopeSlidingMaybeRotated) {
                m_platformerMovingLeft = !m_isUpsideDown;
                m_platformerMovingRight = m_isUpsideDown;
            }
            else {
                m_platformerMovingLeft = m_isUpsideDown;
                m_platformerMovingRight = !m_isUpsideDown;
            }
            if (m_platformerMovingLeft != movingLeft || m_platformerMovingRight != movingRight) {
                m_changedDirectionsTime = m_totalTime;
            }
            m_maybeChangedDirectionAngle = std::abs(m_slopeAngle * (180.f / M_PI));
            m_maybeGoingCorrectSlopeDirection = true;
        }
        else {
            m_platformerMovingLeft = false;
            m_platformerMovingRight = false;
        }
    }
    void placeStreakPoint() = win 0x3a0310;
    void playBumpEffect(int objectType, GameObject* player) = win 0x39f6e0;
    void playBurstEffect() = win inline {
        if (!this->levelFlipping() && !m_isHidden) {
            m_ufoClickParticles->resumeSystem();
            this->stopActionByTag(7);
            auto action = cocos2d::CCSequence::create(
                cocos2d::CCDelayTime::create(.12f),
                cocos2d::CCCallFunc::create(this, callfunc_selector(PlayerObject::stopBurstEffect)),
                nullptr
            );
            action->setTag(7);
            this->runAction(action);
        }
    }
    void playCompleteEffect(bool noEffects, bool instant) = win 0x383d50, imac 0x213bf0, m1 0x1bf3c4;
    void playDeathEffect() = win 0x37ec40, m1 0x6ce3ec;
    void playDynamicSpiderRun() = win 0x3a1160;
    void playerDestroyed(bool noEffects) = win 0x3979d0;
    bool playerIsFalling(float yVelocity) = win inline, ios inline {
        return m_isUpsideDown ? -yVelocity < m_yVelocity : yVelocity > m_yVelocity;
    }
    bool playerIsFallingBugged() = win 0x39a0c0, imac 0x403aa0;
    bool playerIsMovingUp() = win inline, m1 0x37b674, ios inline {
        return m_isUpsideDown ? m_yVelocity < 0.0 : m_yVelocity > 0.0;
    }
    void playerTeleported() = win inline, imac 0x415ab0, m1 0x38ad6c {
        m_isOnGround2 = false;
        m_lastGroundedPos = cocos2d::CCPoint { 0.f, 0.f };
        this->placeStreakPoint();
    }
    void playingEndEffect() = win inline {
        if (m_isSpider) m_spiderSprite->tweenToAnimation("fall_loop", .4f);
    }
    void playSpawnEffect() = win 0x397110, imac 0x412e80;
    void playSpiderDashEffect(cocos2d::CCPoint from, cocos2d::CCPoint to) = win 0x394e00;
    void postCollision(float dt) = win 0x38d2b0, imac 0x404350;
    void preCollision() = win inline, imac 0x4041c0, m1 0x37bc64 {
        m_wasTeleported = false;
        m_ringJumpRelated = false;
        m_collidedTopMinY = 0.0;
        m_collidedBottomMaxY = 0.0;
        m_collidedLeftMaxX = 0.0;
        m_collidedRightMinX = 0.0;
        m_wasOnSlope = m_isOnSlope;
        m_isOnSlope = false;
        m_isOnGround4 = m_isOnGround2;
        if (m_isOnGround2 && !m_platformerMovingLeft && !m_platformerMovingRight && m_maybeSlidingTime > 0) {
            m_maybeSlidingTime = 0;
            m_maybeSlidingStartTime = m_totalTime;
        }
        if (!m_unk669) m_unk669 = true;
        else m_currentPotentialSlope = nullptr;
        m_potentialSlopeMap.clear();
        if (auto slope = m_currentPotentialSlope) {
            m_potentialSlopeMap[slope->m_uniqueID] = slope;
        }
        if (auto slope = m_currentSlope) {
            m_potentialSlopeMap[slope->m_uniqueID] = slope;
        }
    }
    bool preSlopeCollision(float dt, GameObject* object) = win 0x38ef70;
    void propellPlayer(float yVelocity, bool noEffects, int objectType) = win 0x39f4e0, imac 0x41a8d0, m1 0x38f7e0;
    bool pushButton(PlayerButton button) = win 0x397bd0, imac 0x413a90;
    void pushDown() = win inline, imac 0x41af50, m1 0x38fdf0 {
        this->setYVelocity(0.0, 46);
        m_isOnGround2 = false;
        m_isOnGround = false;
    }
    void pushPlayer(float yVelocity) = win inline, ios inline {
        this->addToYVelocity(yVelocity, 68);
    }
    void redirectDash(float rotation) = win inline {
        if (!m_isDashing) return;
        cocos2d::CCPoint dashPos = { (float)m_dashX, (float)m_dashY };
        auto direction = GJBaseGameLayer::convertToClosestDirection(rotation * (M_PI / 180.f) - atan2f(dashPos.y, dashPos.x), M_PI);
        if (direction != 0.f) {
            auto cosDir = cosf(direction);
            auto sinDir = sinf(direction);
            dashPos.x = dashPos.x * cosDir - dashPos.y * sinDir;
            dashPos.y = dashPos.x * sinDir + dashPos.y * cosDir;
        }
        auto angle = ((int)-(atan2f(dashPos.y, dashPos.x) * (180.f / M_PI)) + (m_isSideways ? 90 : 0)) % 360;
        m_dashAngle = -(angle + (angle < 0 ? 360 : 0));
        m_dashX = m_isSideways ? dashPos.y : dashPos.x;
        m_dashY = m_isSideways ? dashPos.x : dashPos.y;
        if (m_dashX < 0.0) this->doReversePlayer(!m_isSideways);
        else if (m_dashX > 0.0) this->doReversePlayer(m_isSideways);
        this->updateDashArt();
    }
    void redirectPlayerForce(float rotation, float modifier, float minimum, float maximum) = win 0x39f8f0, imac 0x41aca0;
    void releaseAllButtons() = win 0x39ed90, m1 0x38f024;
    bool releaseButton(PlayerButton button) = win 0x397e60, imac 0x414e10, m1 0xd898c;
    void removeAllParticles() = win inline, m1 0x375080 {
        for (int i = 0; i < m_particleSystems->count(); i++) {
            auto particle = static_cast<cocos2d::CCParticleSystem*>(m_particleSystems->objectAtIndex(i));
            particle->resetSystem();
            particle->stopSystem();
            particle->removeFromParentAndCleanup(true);
        }
    }
    void removePendingCheckpoint() = win 0x3a2f00, imac 0x4126c0, m1 0x387e20;
    void removePlacedCheckpoint() = win inline {
        if (m_checkpointTimeout) {
            GameManager::sharedState()->m_playLayer->removeCheckpoint(false);
            m_checkpointTimeout = false;
        }
    }
    void resetAllParticles() = win 0x38b510, m1 0x37a9d4;
    void resetCollisionLog(bool full) = win inline, m1 0x37bb50 {
        m_collisionLogTop->removeAllObjects();
        m_collisionLogBottom->removeAllObjects();
        m_collisionLogLeft->removeAllObjects();
        m_collisionLogRight->removeAllObjects();
        if (full) {
            m_unk50C = -1;
            m_unk510 = -1;
        }
        else {
            m_unk50C = m_lastCollisionBottom;
            m_unk510 = m_lastCollisionTop;
        }
        m_lastCollisionBottom = -1;
        m_lastCollisionTop = -1;
        m_lastCollisionLeft = -1;
        m_lastCollisionRight = -1;
    }
    void resetCollisionValues() = win inline, imac 0x40d150, m1 0x383260, ios inline {
        m_collidedTopMinY = 0.0;
        m_collidedBottomMaxY = 0.0;
        m_collidedLeftMaxX = 0.0;
        m_collidedRightMinX = 0.0;
    }
    void resetPlayerIcon() = win 0x39af70;
    void resetStateVariables() = win inline, imac 0x4123a0, m1 0x387c34 {
        m_stateOnGround = 0;
        m_stateNoAutoJump = 0;
        m_stateDartSlide = 0;
        m_stateHitHead = 0;
        m_stateFlipGravity = 0;
        m_stateBoostX = 0;
        m_stateBoostY = 0;
        m_maybeStateForce2 = 0;
        m_stateScale = 0;
        m_stateForce = 0;
        m_stateForceVector = cocos2d::CCPoint { 0.f, 0.f };
        m_jumpPadRelated.clear();
    }
    void resetStreak();
    void resetTouchedRings(bool removeAll) = win 0x397f70, imac 0x412420, m1 0x387c98;
    int reverseMod() = win inline, ios inline {
        return (m_isGoingLeft ? -1 : 1);
    }
    void reversePlayer(EffectGameObject* object) = win 0x3980c0;
    void ringJump(RingObject* object, bool skipCheck) = win 0x398890, imac 0x413e80, m1 0x389450;
    void rotateGameplay(int moveDirection, int groundDirection, bool editVelocity, float velocityModX, float velocityModY, bool overrideVelocity, bool dontSlide) = win 0x3999e0, imac 0x411f90, m1 0x3877c8;
    void rotateGameplayObject(GameObject* object) = win 0x391080, imac 0x24bdf0;
    void rotateGameplayOnly(bool sideways) = win inline, m1 0x38ad64 {
        m_isSideways = sideways;
        this->updatePlayerArt();
    }
    void rotatePreSlopeObjects() = win inline, imac 0x4069f0, ios inline {
        for (auto& pair : m_potentialSlopeMap) {
            this->rotateGameplayObject(pair.second);
        }
    }
    void runBallRotation(float speed) = win 0x38d080;
    void runBallRotation2() = win 0x38d1b0;
    void runNormalRotation() = win inline, ios inline {
        this->runNormalRotation(false, 1.0f);
    }
    void runNormalRotation(bool notNormalMode, float speed) = win 0x38cf50, m1 0x377acc;
    void runRotateAction(bool ground, int type) = win inline {
        if (!m_isLocked && !m_isDashing) {
            this->stopRotation(ground, 22);
            if (m_isBall) this->runBallRotation(1.f);
            else this->runNormalRotation();
        }
    }
    void saveToCheckpoint(PlayerCheckpoint* checkpoint);
    void setSecondColor(cocos2d::ccColor3B const& color) = win 0x39d030, imac 0x3fdbe0, m1 0x3761e4;
    void setupStreak() = win 0x3884f0, m1 0x374bbc;
    void setYVelocity(double velocity, int type) = win 0x388a40, m1 0x374940;
    void spawnCircle();
    void spawnCircle2() = win inline, ios inline {
        if (GameManager::sharedState()->m_performanceMode) return;
        auto circleWave = CCCircleWave::create(5.f, 50.f, .3f, false);
        circleWave->m_color = m_playerColor1;
        circleWave->setPosition(this->getPosition());
        m_parentLayer->addChild(circleWave, 0);
    }
    void spawnDualCircle() = win 0x397800, imac 0x413400;
    void spawnFromPlayer(PlayerObject* player, bool flip) = win inline, imac 0x41b240, m1 0x390030 {
        this->setVisible(true);
        this->setOpacity(255);
        this->copyAttributes(player);
        if (flip) {
            this->flipGravity(!player->m_isUpsideDown, true);
            this->setYVelocity(-player->getYVelocity(), 49);
        }
        else {
            this->flipGravity(player->m_isUpsideDown, true);
            this->setYVelocity(player->getYVelocity(), 49);
        }
        m_isOnGround = false;
        m_isOnGround2 = false;
        this->toggleVisibility(!player->m_isHidden);
        if (m_isDart) this->placeStreakPoint();
    }
    void spawnPortalCircle(cocos2d::ccColor3B color, float startRadius) = win 0x3973f0;
    void spawnScaleCircle() = win 0x397600, imac 0x4132b0;
    void specialGroundHit() = win inline, ios inline {
        this->setYVelocity(this->flipMod() * -5, 47);
        if (!m_isBall && !this->isFlying()) this->stopRotation(false, 21);
        m_maybeSpriteRelated = true;
    }
    void speedDown() = win inline, imac 0x41d0d0, m1 0x391728, ios inline {
        m_speedMultiplier -= .005;
        this->logValues();
    }
    void speedUp() = win inline, imac 0x41d0b0, m1 0x391708, ios inline {
        m_speedMultiplier += .005;
        this->logValues();
    }
    void spiderTestJump(bool dynamic) = win 0x393fd0, m1 0x37ae24;
    void spiderTestJumpInternal(bool dynamic) = win 0x394080;
    void spiderTestJumpX(bool dynamic);
    void spiderTestJumpY(bool dynamic);
    void startDashing(DashRingObject* object) = win 0x3955a0;
    void stopBurstEffect() = win 0x39b170, m1 0x38d0cc;
    void stopDashing() = win 0x3962e0;
    void stopParticles() = win 0x38b590;
    void stopPlatformerJumpAnimation() = win 0x38cd90;
    void stopRotation(bool ground, int type) = win inline, imac 0x403d00, m1 0x37b808 {
        m_isRotating = false;
        m_isBallRotating2 = false;
        m_isBallRotating = false;
        m_rotationSpeed = 0.f;
    }
    void stopStreak2() = win inline, imac 0x41aea0, m1 0x38fd38 {
        m_waveTrail->stopActionByTag(8);
        m_waveTrail->setOpacity(0);
        m_waveTrail->stopStroke();
    }
    void storeCollision(PlayerCollisionDirection direction, int id) = win inline, ios inline {
        switch (direction) {
            case PlayerCollisionDirection::Top: {
                if (m_lastCollisionTop != id) {
                    m_lastCollisionTop = id;
                    if (m_collisionLogTop) m_collisionLogTop->setObject(m_maybeLastGroundObject, id);
                }
                break;
            }
            case PlayerCollisionDirection::Bottom: {
                if (m_lastCollisionBottom != id) {
                    m_lastCollisionBottom = id;
                    if (m_collisionLogBottom) m_collisionLogBottom->setObject(m_maybeLastGroundObject, id);
                }
                break;
            }
            case PlayerCollisionDirection::Left: {
                if (m_lastCollisionLeft != id) {
                    m_lastCollisionLeft = id;
                    if (m_collisionLogLeft) m_collisionLogLeft->setObject(m_maybeLastGroundObject, id);
                }
                break;
            }
            case PlayerCollisionDirection::Right: {
                if (m_lastCollisionRight != id) {
                    m_lastCollisionRight = id;
                    if (m_collisionLogRight) m_collisionLogRight->setObject(m_maybeLastGroundObject, id);
                }
                break;
            }
        }
    }
    bool switchedDirTo(PlayerButton button) = win 0x397ac0, imac 0x413860;
    void switchedToMode(GameObjectType type) = win 0x39bac0, imac 0x412710, m1 0x387e6c;
    bool testForMoving(float dt, GameObject* object) = win inline, imac 0x4063d0, m1 0x44198 {
        auto lastPosition = object->getLastPosition();
        auto realPosition = object->getRealPosition();
        if (realPosition.x == lastPosition.x) {
            if (realPosition.y == lastPosition.y) return false;
            if (m_isUpsideDown) {
                if (realPosition.y < lastPosition.y) return false;
            }
            else {
                if (realPosition.y > lastPosition.y) return false;
            }
        }
        auto objectRect = object->getObjectRect();
        objectRect.size.height += dt * 5.f;
        if (m_isUpsideDown) objectRect.origin.y -= dt * 5.f;
        if (this->getObjectRect().intersectsRect(objectRect)) {
            m_collidedObject = object;
            return true;
        }
        else {
            return false;
        }
    }
    void toggleBirdMode(bool enable, bool noEffects) = win 0x39a4b0, imac 0x416830;
    void toggleDartMode(bool enable, bool noEffects) = win 0x39ac20;
    void toggleFlyMode(bool enable, bool noEffects) = win 0x39a180;
    void toggleGhostEffect(GhostType type) = win 0x39eac0, imac 0x412d00, m1 0x3883c8;
    void togglePlatformerMode(bool val) = win inline, imac 0x3fc710, m1 0x374f58 {
        m_isPlatformer = val;
    }
    void togglePlayerScale(bool enable, bool noEffects) = win 0x3a0390;
    void toggleRobotMode(bool enable, bool noEffects) = win 0x39b380, imac 0x5eb7c0, m1 0x38d490;
    void toggleRollMode(bool enable, bool noEffects) = win 0x39b200, imac 0x417ff0, m1 0x38d0d4;
    void toggleSpiderMode(bool enable, bool noEffects) = win 0x39b700, imac 0x418830, m1 0x38d8c0;
    void toggleSwingMode(bool enable, bool noEffects) = win 0x39a7b0, imac 0x416f30, m1 0x38c0e8;
    void toggleVisibility(bool visible) = win 0x38b170, imac 0x402be0, m1 0x37a7c8;
    void touchedObject(GameObject* object) = win inline, imac 0x41ccc0, m1 0x39139c {
        switch (object->m_objectID) {
            case 1755: {
                m_stateDartSlide = 2;
                break;
            }
            case 1813: {
                m_stateNoAutoJump = 2;
                break;
            }
            case 1829: {
                if (m_isDashing) {
                    this->stopDashing();
                    m_jumpBuffered = false;
                }
            }
            case 1859: {
                m_stateHitHead = 2;
                break;
            }
            case 2069: case 3845: {
                m_stateForce = 2;
                auto forceObject = static_cast<ForceBlockGameObject*>(object);
                auto forceID = forceObject->m_forceID;
                if (forceID > 0) {
                    if (m_jumpPadRelated[forceID]) break;
                    m_jumpPadRelated[forceID] = true;
                }
                m_stateForceVector = m_stateForceVector + forceObject->calculateForceToTarget(this);
                auto magnitude = sqrtf(m_stateForceVector.x * m_stateForceVector.x + m_stateForceVector.y * m_stateForceVector.y);
                if (magnitude > 9999.f) {
                    m_stateForceVector = m_stateForceVector * (9999.f / magnitude);
                }
                break;
            }
            case 2866: {
                m_stateFlipGravity = 2;
                break;
            }
        }
    }
    void tryPlaceCheckpoint() = win 0x3a2f80, m1 0x37a524;
    void unrotateGameplayObject(GameObject* object) = win 0x391370;
    void unrotatePreSlopeObjects() = win inline, ios inline {
        for (auto& pair : m_potentialSlopeMap) {
            this->unrotateGameplayObject(pair.second);
        }
    }
    void updateCheckpointMode(bool enable) = win inline, imac 0x3fc700, m1 0x374f50 {
        m_quickCheckpointMode = enable;
    }
    void updateCheckpointTest() = win inline {
        if (m_canPlaceCheckpoint) {
            this->tryPlaceCheckpoint();
            m_canPlaceCheckpoint = false;
        }
        if (this->isFlying() && m_uniqueID == 1) {
            if (m_onFlyCheckpointTries + 1 < 20) {
                m_onFlyCheckpointTries++;
            }
            else {
                m_onFlyCheckpointTries = 0;
                this->tryPlaceCheckpoint();
            }
        }
        if (m_checkpointTimeout) {
            __timeb64 current;
            _ftime64_s(&current);
            auto currentTime = ((current.time & 0xfffff) * 1000 + current.millitm) / 1000.0;
            if (currentTime - m_lastCheckpointTime > .1f) m_checkpointTimeout = false;
        }
    }
    void updateCollide(PlayerCollisionDirection direction, GameObject* object) = win 0x393c80, imac 0x40bde0, m1 0x382054;
    void updateCollideBottom(float y, GameObject* object) = win inline {
        auto id = object ? object->m_uniqueID : 0;
        if (m_collidedBottomMaxY == 0.0) {
            m_collidedBottomMaxY = y;
        }
        else {
            m_collidedBottomMaxY = m_isUpsideDown ? std::min<double>(m_collidedBottomMaxY, y) : std::max<double>(m_collidedBottomMaxY, y);
        }
        if (id != 0) this->storeCollision(PlayerCollisionDirection::Bottom, id);
    }
    void updateCollideLeft(float x, GameObject* object) = win 0x393e90;
    void updateCollideRight(float x, GameObject* object) = win 0x393f30;
    void updateCollideTop(float y, GameObject* object) = win inline {
        auto id = object ? object->m_uniqueID : 0;
        if (m_collidedTopMinY == 0.0) {
            m_collidedTopMinY = y;
        }
        else {
            m_collidedTopMinY = m_isUpsideDown ? std::max<double>(m_collidedTopMinY, y) : std::min<double>(m_collidedTopMinY, y);
        }
        if (id != 0) this->storeCollision(PlayerCollisionDirection::Top, id);
    }
    void updateDashAnimation() = win 0x3969b0, imac 0x401340, m1 0x378fec;
    void updateDashArt() = win 0x395e50;
    void updateEffects(float param) = win inline, m1 0x37a3b8 {
        m_waveTrail->updateStroke(param);
    }
    void updateGlowColor() = win 0x39d0c0, imac 0x419a20;
    void updateInternalActions(float dt) = win 0x3a3bc0, m1 0x391c6c;
    void updateJump(float dt) = win 0x38b630, imac 0x3fdc50, m1 0x37624c;
    void updateJumpVariables() = win inline, imac 0x401500, m1 0x379198, ios inline {
        m_stateJumpBuffered = m_jumpBuffered;
        m_stateRingJump2 = m_stateRingJump;
        m_touchedRing = false;
        m_touchedCustomRing = false;
        m_touchedGravityPortal = false;
        m_maybeTouchedBreakableBlock = false;
    }
    void updateLastGroundObject(GameObject* object) = win inline, ios inline {
        if (!object) return;
        m_lastGroundObject = object;
        if (m_isDontBoostY) m_stateBoostX = 2;
        if (m_isDontBoostX) m_stateBoostY = 2;
    }
    void updateMove(float dt) = win 0x389df0, m1 0x377bb8;
    void updatePlayerArt() = win 0x3984f0, imac 0x415690, m1 0x38a9ec;
    void updatePlayerBirdFrame(int frame) = win 0x39df70, imac 0x416c80, m1 0x38be64;
    void updatePlayerDartFrame(int frame) = win 0x39e670, imac 0x417d90, m1 0x38ce9c;
    void updatePlayerForce(cocos2d::CCPoint velocity, bool additive) = win inline, imac 0x411970 {
        if (additive) {
            m_yVelocity += velocity.y;
            if (m_isPlatformer) {
                m_platformerXVelocity += velocity.x;
                m_affectedByForces = true;
            }
        }
        else {
            m_yVelocity = velocity.y;
            if (m_isPlatformer) {
                m_platformerXVelocity = velocity.x;
                m_affectedByForces = true;
            }
        }
    }
    void updatePlayerFrame(int frame) = win 0x39d8e0, imac 0x417640, m1 0x38c7b8;
    void updatePlayerGlow() = win 0x39ff30, m1 0x38a82c;
    void updatePlayerJetpackFrame(int frame) = win 0x39dd40, imac 0x4163d0, m1 0x38b648;
    void updatePlayerRobotFrame(int frame) = win inline, imac 0x41a0e0, m1 0x38eff4 {
        this->createRobot(std::clamp(frame, 1, 68));
    }
    void updatePlayerRollFrame(int frame) = win 0x39e210, imac 0x418180, m1 0x38d264;
    void updatePlayerScale() = win 0x39feb0, imac 0x415b60, m1 0x38ae18, ios inline {
        m_actionManager->stopInternalAction(6);
        this->setScaleX(m_vehicleSize);
        this->setScaleY(m_vehicleSize);
    }
    void updatePlayerShipFrame(int frame) = win 0x39db10, imac 0x416180, m1 0x38b418;
    void updatePlayerSpiderFrame(int frame) = win inline, imac 0x41a100, m1 0x38f00c {
        this->createSpider(std::clamp(frame, 1, 30));
    }
    void updatePlayerSpriteExtra(gd::string frameName) = m1 0x3741d0;
    void updatePlayerSwingFrame(int frame) = win 0x39e440, imac 0x417370, m1 0x38c4f0;
    void updateRobotAnimationSpeed() = win 0x3a0d70, imac 0x41b440, m1 0x390244;
    void updateRotation(float dt) = win 0x390cb0;
    void updateRotation(float dt, float rotation) = win 0x390ef0;
    void updateShipRotation(float dt) = win 0x3908d0;
    void updateShipSpriteExtra(gd::string frameName) = m1 0x3742b4;
    void updateSlopeRotation(float dt) = win 0x390850;
    void updateSlopeYVelocity(float yVelocity) = win inline, ios inline {}
    void updateSpecial(float dt) = win inline, imac 0x4026f0, m1 0x37a340 {
        m_unk838 += dt;
        if (m_unk838 >= .01f) {
            m_followRelated++;
            m_unk838 -= .01f;
        }
        m_playerFollowFloats[m_followRelated % 200] = m_obPosition.y;
    }
    void updateStateVariables() = win inline, imac 0x401520, m1 0x3791b4 {
        m_stateNoAutoJump--;
        m_stateDartSlide--;
        m_stateFlipGravity--;
        m_stateHitHead--;
        m_stateOnGround--;
        m_stateBoostX--;
        m_stateBoostY--;
        m_maybeStateForce2--;
        m_stateScale--;
        m_stateForce--;
        m_stateForceVector = cocos2d::CCPoint { 0.f, 0.f };
        m_jumpPadRelated.clear();
    }
    void updateStaticForce(float rotation, float staticForce, bool additive) = win inline, imac 0x41ab40 {
        if (staticForce != 0.f || additive) {
            auto point = cocos2d::ccpForAngle(rotation * (M_PI / 180.f));
            auto factor = sqrtf(point.x * point.x + point.y * point.y);
            if (factor > 0.f) {
                point = point * (staticForce / factor);
                if (m_isSideways) std::swap(point.x, point.y);
                this->updatePlayerForce(point, additive);
            }
        }
        else {
            m_yVelocity = 0.0;
            if (m_isPlatformer) {
                m_platformerXVelocity = 0.0;
                m_affectedByForces = false;
            }
        }
    }
    void updateStreakBlend(bool blend) = win 0x3889d0, imac 0x3fc9a0, m1 0x3751cc;
    void updateStreaks(float dt) = win inline, imac 0x3fca10, m1 0x375250, ios inline {
        if (m_shipStreak) m_shipStreak->update(dt);
    }
    void updateSwingFire() = win 0x39aa60, imac 0x415bb0, m1 0x38ae64;
    void updateTimeMod(float speed, bool noEffects) = win 0x3a09e0;
    bool usingWallLimitedMode() = win inline, ios inline {
        return this->isFlying() || m_isBall || m_isSpider;
    }
    void yStartDown() = win inline, imac 0x41d110, m1 0x391768, ios inline {
        m_yStart -= .01;
        this->logValues();
    }
    void yStartUp() = win inline, imac 0x41d0f0, m1 0x391748, ios inline {
        m_yStart += .01;
        this->logValues();
    }

    cocos2d::CCNode* m_mainLayer;
    bool m_wasTeleported;
    bool m_fixGravityBug;
    bool m_reverseSync;
    double m_yVelocityBeforeSlope;
    double m_dashX;
    double m_dashY;
    double m_dashAngle;
    double m_dashStartTime;
    DashRingObject* m_dashRing;
    double m_slopeStartTime;
    bool m_justPlacedStreak;
    cocos2d::CCNode* m_maybeLastGroundObject;
    cocos2d::CCDictionary* m_collisionLogTop;
    cocos2d::CCDictionary* m_collisionLogBottom;
    cocos2d::CCDictionary* m_collisionLogLeft;
    cocos2d::CCDictionary* m_collisionLogRight;
    int m_lastCollisionBottom;
    int m_lastCollisionTop;
    int m_lastCollisionLeft;
    int m_lastCollisionRight;
    int m_unk50C;
    int m_unk510;
    GameObject* m_currentSlope2;
    GameObject* m_preLastGroundObject;
    float m_slopeAngle;
    bool m_slopeSlidingMaybeRotated;
    bool m_quickCheckpointMode;
    GameObject* m_collidedObject;
    GameObject* m_lastGroundObject;
    GameObject* m_collidingWithLeft;
    GameObject* m_collidingWithRight;
    int m_maybeSavedPlayerFrame;
    double m_scaleXRelated2;
    double m_groundYVelocity;
    double m_yVelocityRelated;
    double m_scaleXRelated3;
    double m_scaleXRelated4;
    double m_scaleXRelated5;
    bool m_isCollidingWithSlope;
    cocos2d::CCSprite* m_dashFireSprite;
    bool m_isBallRotating;
    bool m_unk669;
    GameObject* m_currentPotentialSlope;
    GameObject* m_currentSlope;
    double unk_584;
    int m_collidingWithSlopeId;
    bool m_slopeFlipGravityRelated;
    cocos2d::CCArray* m_particleSystems;
    float m_slopeAngleRadians;
    gd::unordered_map<int, GJPointDouble> m_rotateObjectsRelated;
    gd::unordered_map<int, GameObject*> m_potentialSlopeMap;
    float m_rotationSpeed;
    float m_rotateSpeed;
    bool m_isRotating;
    bool m_isBallRotating2;
    bool m_hasGlow;
    bool m_isHidden;
    GhostType m_ghostType;
    GhostTrailEffect* m_ghostTrail;
    cocos2d::CCSprite* m_iconSprite;
    cocos2d::CCSprite* m_iconSpriteSecondary;
    cocos2d::CCSprite* m_iconSpriteWhitener;
    cocos2d::CCSprite* m_iconGlow;
    cocos2d::CCSprite* m_vehicleSprite;
    cocos2d::CCSprite* m_vehicleSpriteSecondary;
    cocos2d::CCSprite* m_birdVehicle;
    cocos2d::CCSprite* m_vehicleSpriteWhitener;
    cocos2d::CCSprite* m_vehicleGlow;
    PlayerFireBoostSprite* m_swingFireMiddle;
    PlayerFireBoostSprite* m_swingFireBottom;
    PlayerFireBoostSprite* m_swingFireTop;
    cocos2d::CCSprite* m_dashSpritesContainer;
    cocos2d::CCMotionStreak* m_regularTrail;
    cocos2d::CCMotionStreak* m_shipStreak;
    HardStreak* m_waveTrail;
    double m_speedMultiplier;
    double m_yStart;
    double m_gravity;
    float m_trailingParticleLife;
    float m_unk648;
    double m_gameModeChangedTime;
    bool m_padRingRelated;
    bool m_maybeReducedEffects;
    bool m_maybeIsFalling;
    bool m_shouldTryPlacingCheckpoint;
    bool m_playEffects;
    bool m_maybeCanRunIntoBlocks;
    bool m_hasGroundParticles;
    bool m_hasShipParticles;
    bool m_isOnGround3;
    bool m_checkpointTimeout;
    double m_lastCheckpointTime;
    double m_lastJumpTime;
    double m_lastFlipTime;
    double m_flashTime;
    float m_flashDuration;
    float m_flashDelay;
    cocos2d::ccColor3B m_flashMainColor;
    cocos2d::ccColor3B m_flashSecondColor;
    double m_lastSpiderFlipTime;
    bool m_unkBool5;
    bool m_maybeIsVehicleGlowing;
    bool m_switchWaveTrailColor;
    bool m_practiceDeathEffect;
    double m_accelerationOrSpeed;
    double m_snapDistance;
    bool m_ringJumpRelated;
    gd::unordered_set<int> m_ringRelatedSet;
    GameObject* m_objectSnappedTo;
    CheckpointObject* m_pendingCheckpoint;
    int m_onFlyCheckpointTries;
    GJRobotSprite* m_robotSprite;
    GJSpiderSprite* m_spiderSprite;
    bool m_maybeSpriteRelated;
    cocos2d::CCParticleSystemQuad* m_playerGroundParticles;
    cocos2d::CCParticleSystemQuad* m_trailingParticles;
    cocos2d::CCParticleSystemQuad* m_shipClickParticles;
    cocos2d::CCParticleSystemQuad* m_vehicleGroundParticles;
    cocos2d::CCParticleSystemQuad* m_ufoClickParticles;
    cocos2d::CCParticleSystemQuad* m_robotBurstParticles;
    cocos2d::CCParticleSystemQuad* m_dashParticles;
    cocos2d::CCParticleSystemQuad* m_swingBurstParticles1;
    cocos2d::CCParticleSystemQuad* m_swingBurstParticles2;
    bool m_useLandParticles0;
    cocos2d::CCParticleSystemQuad* m_landParticles0;
    cocos2d::CCParticleSystemQuad* m_landParticles1;
    float m_landParticlesAngle;
    float m_landParticleRelatedY;
    int m_playerStreak;
    float m_streakStrokeWidth;
    bool m_disableStreakTint;
    bool m_alwaysShowStreak;
    ShipStreak m_shipStreakType;
    double m_slopeRotation;
    double m_currentSlopeYVelocity;
    double m_unk3d0;
    double m_blackOrbRelated;
    bool m_unk3e0;
    bool m_unk3e1;
    bool m_isAccelerating;
    bool m_isCurrentSlopeTop;
    double m_collidedTopMinY;
    double m_collidedBottomMaxY;
    double m_collidedLeftMaxX;
    double m_collidedRightMinX;
    bool m_fadeOutStreak;
    bool m_canPlaceCheckpoint;
    cocos2d::ccColor3B m_originalMainColor;
    cocos2d::ccColor3B m_originalSecondColor;
    bool m_hasCustomGlowColor;
    cocos2d::ccColor3B m_glowColor;
    bool m_maybeIsColliding;
    bool m_jumpBuffered;
    bool m_stateRingJump;
    bool m_wasJumpBuffered;
    bool m_wasRobotJump;
    unsigned char m_stateJumpBuffered;
    bool m_stateRingJump2;
    bool m_touchedRing;
    bool m_touchedCustomRing;
    bool m_touchedGravityPortal;
    bool m_maybeTouchedBreakableBlock;
    geode::SeedValueRSV m_jumpRelatedAC2;
    bool m_touchedPad;
    double m_yVelocity;
    double m_fallSpeed;
    bool m_isOnSlope;
    bool m_wasOnSlope;
    float m_slopeVelocity;
    bool m_maybeUpsideDownSlope;
    bool m_isShip;
    bool m_isBird;
    bool m_isBall;
    bool m_isDart;
    bool m_isRobot;
    bool m_isSpider;
    bool m_isUpsideDown;
    bool m_isDead;
    bool m_isOnGround;
    bool m_isGoingLeft;
    bool m_isSideways;
    bool m_isSwing;
    int m_reverseRelated;
    double m_maybeReverseSpeed;
    double m_maybeReverseAcceleration;
    float m_xVelocityRelated2;
    bool m_isDashing;
    int m_unk9e8;
    int m_groundObjectMaterial;
    float m_vehicleSize;
    float m_playerSpeed;
    cocos2d::CCPoint m_shipRotation;
    cocos2d::CCPoint m_lastPortalPos;
    float m_unkUnused3;
    bool m_isOnGround2;
    double m_lastLandTime;
    float m_platformerVelocityRelated;
    bool m_maybeIsBoosted;
    double m_scaleXRelatedTime;
    bool m_decreaseBoostSlide;
    bool m_unkA29;
    bool m_isLocked;
    bool m_controlsDisabled;
    cocos2d::CCPoint m_lastGroundedPos;
    cocos2d::CCArray* m_touchingRings;
    gd::unordered_set<int> m_touchedRings;
    GameObject* m_lastActivatedPortal;
    bool m_hasEverJumped;
    bool m_hasEverHitRing;
    cocos2d::ccColor3B m_playerColor1;
    cocos2d::ccColor3B m_playerColor2;
    cocos2d::CCPoint m_position;
    bool m_isSecondPlayer;
    bool m_unkA99;
    double m_totalTime;
    bool m_isBeingSpawnedByDualPortal;
    float m_audioScale;
    float m_unkAngle1;
    float m_yVelocityRelated3;
    bool m_defaultMiniIcon;
    bool m_swapColors;
    bool m_switchDashFireColor;
    int m_followRelated;
    gd::vector<float> m_playerFollowFloats;
    float m_unk838;
    int m_stateOnGround;
    unsigned char m_stateUnk;
    unsigned char m_stateNoStickX;
    unsigned char m_stateNoStickY;
    unsigned char m_stateUnk2;
    int m_stateBoostX;
    int m_stateBoostY;
    int m_maybeStateForce2;
    int m_stateScale;
    double m_platformerXVelocity;
    bool m_holdingRight;
    bool m_holdingLeft;
    bool m_leftPressedFirst;
    double m_scaleXRelated;
    bool m_maybeHasStopped;
    float m_xVelocityRelated;
    bool m_maybeGoingCorrectSlopeDirection;
    bool m_isSliding;
    double m_maybeSlopeForce;
    bool m_isOnIce;
    double m_physDeltaRelated;
    bool m_isOnGround4;
    int m_maybeSlidingTime;
    double m_maybeSlidingStartTime;
    double m_changedDirectionsTime;
    double m_slopeEndTime;
    bool m_isMoving;
    bool m_platformerMovingLeft;
    bool m_platformerMovingRight;
    bool m_isSlidingRight;
    double m_maybeChangedDirectionAngle;
    double m_unkUnused2;
    bool m_isPlatformer;
    int m_stateNoAutoJump;
    int m_stateDartSlide;
    int m_stateHitHead;
    int m_stateFlipGravity;
    float m_gravityMod;
    int m_stateForce;
    cocos2d::CCPoint m_stateForceVector;
    bool m_affectedByForces;
    gd::map<int, bool> m_jumpPadRelated;
    float m_somethingPlayerSpeedTime;
    float m_playerSpeedAC;
    bool m_fixRobotJump;
    gd::map<int, bool> m_holdingButtons;
    bool m_inputsLocked;
    gd::string m_currentRobotAnimation;
    bool m_gv0123;
    int m_iconRequestID;
    cocos2d::CCSpriteBatchNode* m_robotBatchNode;
    cocos2d::CCSpriteBatchNode* m_spiderBatchNode;
    cocos2d::CCArray* m_unk958;
    PlayerFireBoostSprite* m_robotFire;
    int m_unkUnused;
    GJBaseGameLayer* m_gameLayer;
    cocos2d::CCLayer* m_parentLayer;
    GJActionManager* m_actionManager;
    bool m_isOutOfBounds;
    float m_fallStartY;
    bool m_disablePlayerSqueeze;
    bool m_robotAnimation1Enabled;
    bool m_robotAnimation2Enabled;
    bool m_spiderAnimationEnabled;
    bool m_ignoreDamage;
    bool m_enable22Changes;
}

[[link(android), depends(DynamicBitset), depends(SavedActiveObjectState), depends(SavedObjectStateRef), depends(SavedSpecialObjectState)]]
class PlayLayer : GJBaseGameLayer, CCCircleWaveDelegate, CurrencyRewardDelegate, DialogDelegate {
    PlayLayer() = win 0x3a4a50;
    ~PlayLayer() = win 0x3a5460, imac 0xabd40;

    static PlayLayer* create(GJGameLevel* level, bool useReplay, bool dontCreateObjects) = win 0x3a5700 {
        auto ret = new PlayLayer();
        if (ret->init(level, useReplay, dontCreateObjects)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static PlayLayer* get() {
        return GameManager::get()->m_playLayer;
    }
    static cocos2d::CCScene* scene(GJGameLevel* level, bool useReplay, bool dontCreateObjects) = win 0x3a5700;

    virtual void onEnterTransitionDidFinish() = win 0x3bac30, m1 0xac214, imac 0xbf750;
    virtual void onExit() = win 0x3bac60, m1 0xac24c, imac 0xbf780;
    virtual void postUpdate(float dt) = win 0x3b4840, m1 0xa843c, imac 0xbaec0;
    virtual void checkForEnd() = win 0x3b4990, m1 0xa84a8, imac 0xbaf20;
    virtual void testTime() {}
    virtual void updateVerifyDamage() = win 0x3b4b50, m1 0xa859c, imac 0xbb010;
    virtual void updateAttemptTime(float attemptTime) = win 0x3b4c00, m1 0xa864c, imac 0xbb0c0;
    virtual void updateVisibility(float dt) = win 0x3af050, imac 0xb7010, m1 0xa4b80;
    virtual float opacityForObject(GameObject* object) = win 0x3aff90, m1 0xa69e0, imac 0xb9220;
    virtual void updateColor(cocos2d::ccColor3B& color, float fadeTime, int colorID, bool blending, float opacity, cocos2d::ccHSVValue& copyHSV, int colorIDToCopy, bool copyOpacity, EffectGameObject* callerObject, int unk1, int unk2) = win 0x3b1c40, m1 0xa6aa4, imac 0xb9300;
    virtual void activateEndTrigger(int targetID, bool reverse, bool lockPlayerY) = win inline, m1 0xa3bf8, imac 0xb5f40 {}
    virtual void activatePlatformerEndTrigger(EndTriggerGameObject* object, gd::vector<int> const& remapKeys) = win 0x3abf80, imac 0xb6430, m1 0xa402c;
    virtual void toggleGlitter(bool visible) = win 0x3b3550, m1 0xa750c, imac 0xb9df0;
    virtual void destroyPlayer(PlayerObject* player, GameObject* object) = win 0x3b3670, imac 0xb9ec0, m1 0xa75e0;
    virtual void toggleGroundVisibility(bool visible) = win 0x3b33a0, m1 0xa7404, imac 0xb9d00;
    virtual void toggleMGVisibility(bool visible) = win 0x3b3420, imac 0xb9d30, m1 0xa7434;
    virtual void toggleHideAttempts(bool hide) = win 0x3b3460, m1 0xa7444, imac 0xb9d50;
    virtual float timeForPos(cocos2d::CCPoint position, int order, int channel, bool songTriggers, int id) = win 0x3b3270, imac 0xb9be0, m1 0xa7334;
    virtual cocos2d::CCPoint posForTime(float time) = win 0x3b3300, imac 0xb9c60, m1 0xa73a8;
    virtual void resetSPTriggered() = win 0x3b3360, m1 0xa73c8, imac 0xb9cb0;
    virtual void updateTimeWarp(float timeWarp) = win 0x3ab650, m1 0xa3b10, imac 0xb5e30;
    virtual void playGravityEffect(bool flip) = win 0x3b1d00, m1 0xa6b08, imac 0xb9370;
    virtual void manualUpdateObjectColors(GameObject* object) = win 0x3affa0, m1 0xa69e8, imac 0xb9230;
    virtual void checkpointActivated(CheckpointGameObject* object) = win 0x3b4c40, m1 0xa86c0, imac 0xbb130;
    virtual void flipArt(bool flip) = win 0x3b26e0, imac 0xb9b60, m1 0xa72d0;
    virtual void updateTimeLabel(int seconds, int centiseconds, bool decimals) = win 0x3b2210, imac 0xb97b0, m1 0xa6efc;
    virtual void checkSnapshot() = win inline, m1 0xaab68, imac 0xbdf10 {}
    virtual void toggleProgressbar() = win 0x3b2410, m1 0xa70d8, imac 0xb9980;
    virtual void toggleInfoLabel() = win 0x3b31f0, m1 0xa72f0, imac 0xb9ba0;
    virtual void removeAllCheckpoints() = win 0x3b7ce0, m1 0xaa7f0, imac 0xbdb00;
    virtual void toggleMusicInPractice() = win 0x3b25b0, m1 0xa7244, imac 0xb9b00;
    virtual void currencyWillExit(CurrencyRewardLayer* layer) = win 0x3b43d0, m1 0xa804c, imac 0xbaa20;
    virtual void circleWaveWillBeRemoved(CCCircleWave* circleWave) = win 0x3b4590, m1 0xa80dc, imac 0xbaae0;
    virtual void dialogClosed(DialogLayer* layer) = win 0x3b43f0, m1 0xa8090, imac 0xbaa70;

    void addCircle(CCCircleWave* cw) = win inline, m1 0xa80d4 {
        m_circleWaveArray->addObject(cw);
    }
    void addObject(GameObject* object) = win 0x3ada20, m1 0xa02e8, imac 0xb1fa0;
    void addToGroupOld(GameObject* object) = win inline, ios inline {
        for (int i = 0; i < object->m_groupCount; i++) {
            auto id = object->getGroupID(i);
            auto group = this->getGroup(id);
            if (!group->containsObject(object)) group->addObject(object);
            if (object->m_objectType == GameObjectType::Decoration) {
                auto optimizedGroup = this->getOptimizedGroup(id);
                if (!optimizedGroup->containsObject(object)) optimizedGroup->addObject(object);
            }
            else {
                auto staticGroup = this->getStaticGroup(id);
                if (!staticGroup->containsObject(object)) staticGroup->addObject(object);
            }
        }
    }
    void applyCustomEnterEffect(GameObject* object, bool isRight) = win 0x3b0620;
    void applyEnterEffect(GameObject* object, int enterType, bool isRight) = win 0x3b1310;
    bool canPauseGame() = win inline {
        return !m_hasCompletedLevel && !m_levelEndAnimationStarted;
    }
    CheckpointObject* checkpointWithID(int id) = win inline, m1 0xaa54c, ios inline {
        for (int i = 0; i < m_checkpointArray->count(); i++) {
            auto checkpoint = static_cast<CheckpointObject*>(m_checkpointArray->objectAtIndex(i));
            if (checkpoint->m_uniqueID == id) return checkpoint;
        }
        return nullptr;
    }
    void colorObject(int id, cocos2d::ccColor3B color) = win inline, imac 0xb6e50, m1 0xa49ac, ios inline {}
    void commitJumps() = m1 0xa201c, ios inline {
        GameStatsManager::sharedState()->incrementStat("1", m_uncommittedJumps);
        m_uncommittedJumps = 0;
    }
    void compareStateSnapshot() = win inline, m1 0xaab70, ios inline {}
    CheckpointObject* createCheckpoint() = win 0x3b4c60;
    void createObjectsFromSetupFinished() = win 0x3ad580, imac 0xb69f0, m1 0xa4558;
    void delayedFullReset() = win inline, m1 0xaab74 {
        if (m_isPlatformer) {
            m_started = false;
            m_platformerRestart = true;
        }
        this->runAction(cocos2d::CCSequence::create(
            cocos2d::CCDelayTime::create(.5f),
            cocos2d::CCCallFunc::create(this, callfunc_selector(PlayLayer::fullReset)),
            nullptr
        ));
    }
    void delayedResetLevel() = win 0x3b8990;
    void fullReset() = win 0x3b8890, m1 0xaabe8;
    float getCurrentPercent() = win 0x3b35f0;
    int getCurrentPercentInt() = win inline, ios inline { // i love this
        return static_cast<int>(this->getCurrentPercent());
    }
    cocos2d::CCPoint getEndPosition() = win inline, imac 0xb3370 {
        return !m_isPlatformer && m_endPortal && !m_platformerEndTrigger ? m_endPortal->getPosition() : m_endPosition;
    }
    CheckpointObject* getLastCheckpoint() = win inline, m1 0xa985c {
        if (m_checkpointArray->count() != 0) {
            return static_cast<CheckpointObject*>(m_checkpointArray->lastObject());
        }
        return nullptr;
    }
    float getRelativeMod(cocos2d::CCPoint position, float right, float left, float offset) = win inline, imac 0xb9290, ios inline {
        auto result = m_halfCameraWidth;
        auto xPos = position.x;
        if (xPos > result + m_gameState.m_cameraPosition2.x) {
            result = (result - (xPos - offset - m_gameState.m_cameraPosition2.x - result)) * right;
        }
        else {
            result = (result - (result + m_gameState.m_cameraPosition2.x - xPos - offset)) * left;
        }
        return std::clamp(result, 0.f, 1.f);
    }
    float getRelativeModNew(cocos2d::CCPoint position, float mod, float offset, bool unused, bool isRight) = win inline, imac 0xb7e30, m1 0xa57dc, ios inline {
        auto result = isRight ? (m_cameraWidth + m_gameState.m_cameraPosition2.x - position.x + offset) : (position.x - m_gameState.m_cameraPosition2.x - offset);
        return cocos2d::clampf(result / mod, 0.f, 1.f);
    }
    double getTempMilliTime() = win inline, m1 0x37a780 {
        __timeb64 current;
        _ftime64_s(&current);
        return ((current.time & 0xfffff) * 1000 + current.millitm) / 1000.0;
    }
    void gravityEffectFinished() = win 0x3b2050, imac 0xb9720, m1 0xa6e70;
    void incrementJumps() = win inline, imac 0xbf230 {
        m_uncommittedJumps++;
        m_jumps++;
        m_level->m_jumps = m_level->m_jumps.value() + 1;
    }
    bool init(GJGameLevel* level, bool useReplay, bool dontCreateObjects) = win 0x3a57b0;
    bool isGameplayActive() = win inline {
        return !m_hasCompletedLevel && m_started && !m_player1->m_isDead;
    }
    void levelComplete() = win 0x3a7730, m1 0x1a95a4;
    void loadActiveSaveObjects(gd::vector<SavedActiveObjectState>& activeObjects, gd::vector<SavedSpecialObjectState>& specialObjects) = win inline, imac 0xbda50, m1 0xaa708 {
        for (auto& state : activeObjects) {
            auto object = static_cast<EnhancedGameObject*>(state.m_gameObject);
            object->m_activatedByPlayer1 = state.m_activatedByPlayer1;
            object->m_activatedByPlayer2 = state.m_activatedByPlayer2;
        }
        for (auto& state : specialObjects) {
            auto object = state.m_gameObject;
            if (object->m_classType == GameObjectClassType::Animated) {
                static_cast<AnimatedGameObject*>(object)->playAnimation(state.m_animationID);
            }
            else if (object->m_objectID == 1615) {
                static_cast<LabelGameObject*>(object)->m_updateLabel = true;
            }
        }
    }
    void loadDefaultColors() = win 0x3b1900, imac 0xb1bf0, m1 0x9ff80;
    void loadDynamicSaveObjects(gd::vector<SavedObjectStateRef>& dynamicObjects) = win inline, imac 0xbd900, m1 0xaa5c8 {
        for (auto& state : dynamicObjects) {
            auto object = state.m_gameObject;
            object->m_positionX = state.m_positionX;
            object->m_positionY = state.m_positionY;
            object->m_rotationXOffset = state.m_rotationXOffset;
            object->m_rotationYOffset = state.m_rotationYOffset;
            object->addToCustomScaleX(state.m_addToCustomScaleX);
            object->addToCustomScaleY(state.m_addToCustomScaleY);
            object->setRRotation(0.f);
            object->setRScale(1.f);
            object->m_unk4C4 = -1;
            object->m_unk4CC = -1;
            object->setPosition(object->getRealPosition());
            object->setLastPosition(object->getRealPosition());
            object->setObjectRectDirty(true);
            object->m_isDirty = true;
            object->setOrientedRectDirty(true);
            this->updateObjectSection(object);
        }
    }
    void loadFromCheckpoint(CheckpointObject* object) = m1 0xaa040, win 0x3b72e0;
    CheckpointObject* loadLastCheckpoint() = win inline, m1 0xa9fe8 {
        if (m_checkpointArray->count() != 0) {
            auto checkpoint = static_cast<CheckpointObject*>(m_checkpointArray->lastObject());
            this->loadFromCheckpoint(checkpoint);
            return checkpoint;
        }
        return nullptr;
    }
    CheckpointObject* markCheckpoint() = win 0x3b7210;
    void onQuit() = win 0x3ba850, m1 0xa0fe4;
    void optimizeColorGroups() = win 0x3ae880;
    void optimizeOpacityGroups() = win 0x3aeb10;
    void pauseGame(bool unfocused) = win 0x3b9d80, m1 0xabdb0;
    void playEndAnimationToPos(cocos2d::CCPoint position) = win 0x3ab6b0, m1 0xa3bfc;
    void playPlatformerEndAnimationToPos(cocos2d::CCPoint position, bool instant) = win 0x3ac090;
    void playReplay(gd::string inputs);
    void prepareCreateObjectsFromSetup(gd::string& levelString) = win 0x3acaf0;
    void prepareMusic(bool dontWait) = win 0x3ba580;
    void processCreateObjectsFromSetup() = win 0x3acda0;
    void processLoadedMoveActions() = win 0x3aee80, imac 0xb6e80, m1 0xa49d8;
    void queueCheckpoint() = win inline, imac 0xbd2c0 {
        m_tryPlaceCheckpoint = true;
    }
    void removeAllObjects() = win 0x3baa50, imac 0xb3070, m1 0xa114c;
    void removeCheckpoint(bool first) = win 0x3b7ba0, m1 0xa9ef4;
    void removeFromGroupOld(GameObject* object) = win inline, ios inline {
        for (int i = 0; i < object->m_groupCount; i++) {
            this->getGroup(object->getGroupID(i))->removeObject(object);
        }
    }
    void resetLevel() = win 0x3b8b50, m1 0x2f6a44;
    void resetLevelFromStart() = m1 0xaa2c, win 0x3b89b0;
    void resume() = win 0x3ba2e0;
    void resumeAndRestart(bool fromStart) = win 0x3ba060, m1 0xabee8;
    void saveActiveSaveObjects(gd::vector<SavedActiveObjectState>& activeObjects, gd::vector<SavedSpecialObjectState>& specialObjects) = win 0x3b8690, m1 0xa9ab8;
    void saveDynamicSaveObjects(gd::vector<SavedObjectStateRef>& dynamicObjects) = win 0x3b8380;
    void scanActiveSaveObjects() = win inline {
        for (auto obj : geode::cocos::CCArrayExt<cocos2d::CCObject*, false>(m_objects)) {
            auto object = static_cast<GameObject*>(obj);
            if (object->canAllowMultiActivate()) {
                if (!object->canMultiActivate(m_isPlatformer)) {
                    m_activeSaveObjects1.push_back(object);
                }
            }
            else if (object->m_classType == GameObjectClassType::Animated) {
                if (static_cast<AnimatedGameObject*>(object)->m_notGrounded) m_activeSaveObjects2.push_back(object);
            }
        }
    }
    void scanDynamicSaveObjects() = win 0x3b7d30;
    void screenFlipObject(GameObject* object) = win 0x3b0400, imac 0xb8fd0, m1 0xa67c0 {
        auto factor = m_gameState.m_levelFlipping;
        if (m_cameraFlip == -1.f) factor = 1.f - factor;
        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        auto objectPos = object->getPosition();
        auto xDiff = objectPos.x - m_gameState.m_cameraPosition.x;
        object->setPosition(objectPos + cocos2d::CCPoint { (winSize.width / m_gameState.m_cameraZoom - (xDiff + xDiff)) * factor, 0.f });
        auto angle = std::abs(object->getRotation());
        auto rotated = angle == 90.f || angle == 270.f;
        auto flip = m_cameraFlip;
        auto flipping = m_gameState.m_levelFlipping;
        if ((flip != 1.f && flipping > .5f) || (flip == 1.f && flipping < .5f)) {
            if (!m_gameState.m_unkBool11) return;
            auto sign = flip == 1.f ? 1 : -1;
            if (rotated) object->setFlipY(object->m_startFlipY * sign != 0);
            else object->setFlipX(object->m_startFlipX * sign != 0);
            if ((int)angle % 90 != 0) object->setRotation(object->m_startRotationX * sign);
        }
        else {
            if (rotated) object->setFlipY(!object->m_startFlipY);
            else object->setFlipX(!object->m_startFlipX);
            if ((int)angle % 90 != 0) object->setRotation(-object->m_startRotationX);
        }
    }
    void setDamageVerifiedIdx(int idx);
    void setupHasCompleted() = win 0x3a6380;
    bool shouldBlend(int colorID) = win inline, m1 0xa4550 {
        return m_effectManager->shouldBlend(colorID);
    }
    void showCompleteEffect() = win 0x3a8be0, m1 0xa2124;
    void showCompleteText() = win 0x3a85b0, imac 0xb4680, m1 0xa24d4;
    void showEndLayer() = win 0x3ac3b0;
    void showHint() = win 0x3b4410, imac 0xba890;
    void showNewBest(bool newReward, int orbs, int diamonds, bool demonKey, bool noRetry, bool noTitle) = win 0x3a9200, m1 0xfa648;
    void showRetryLayer() = win 0x3ac5b0;
    void showTwoPlayerGuide() = win 0x3ac750, m1 0x9fa14;
    void spawnCircle() = win 0x3abbb0, m1 0xa2050;
    void spawnFirework() = win 0x3abca0, m1 0xa2dd4;
    void startGame() = win 0x3a76d0, m1 0xa0f88;
    void startGameDelayed() = win 0x3a7720;
    void startMusic() = win 0x3ba700;
    void startRecording() = win inline, imac 0xbf1b0, m1 0x4f8294, ios inline {
        m_recordingStopped = false;
    }
    void startRecordingDelayed() = win inline, imac 0xbf1c0, m1 0xabca0, ios inline {
        auto action = cocos2d::CCSequence::create(
            cocos2d::CCDelayTime::create(2.f),
            cocos2d::CCCallFunc::create(this, callfunc_selector(PlayLayer::startRecording)),
            nullptr
        );
        action->setTag(31);
        this->runAction(action);
    }
    void stopRecording() = win inline, imac 0xacc90, m1 0x9b930 {
        this->stopActionByTag(31);
    }
    void storeCheckpoint(CheckpointObject* checkpoint) = win 0x3b7140, m1 0xa9e50;
    void takeStateSnapshot() = win inline, m1 0xaab6c, ios inline {}
    void toggleBGEffectVisibility(bool enabled) = win inline, imac 0xbf170 {
        m_bgEffectDisabled = !enabled;
        if (!enabled) m_glitterParticles->stopSystem();
        else if (m_glitterEnabled) m_glitterParticles->resumeSystem();
    }
    void toggleDebugDraw(bool enabled) = win inline {
        m_isDebugDrawEnabled = enabled;
        m_debugDrawNode->clear();
        m_debugDrawNode->setVisible(m_isDebugDrawEnabled && m_isPracticeMode);
    }
    void toggleGhostEffect(int type) = win inline {
        m_player1->toggleGhostEffect((GhostType)type);
        if (m_gameState.m_isDualMode) m_player2->toggleGhostEffect((GhostType)type);
    }
    void toggleIgnoreDamage(bool value) = win inline, imac 0xace10 {
        this->m_ignoreDamage = value;
        if (value) this->m_isIgnoreDamageEnabled = true;
        this->m_player1->m_maybeCanRunIntoBlocks = value;
        this->m_player2->m_maybeCanRunIntoBlocks = value;
        this->updateTestModeLabel();
    }
    void togglePracticeMode(bool practiceMode) = win 0x3b9af0, imac 0xbe100;
    void tryStartRecord() = win inline, imac 0xbf0f0, ios inline {
        this->stopActionByTag(31);
        this->startRecording();
    }
    void updateAttempts() = win 0x3b9840, imac 0xbef60, m1 0xaba50;
    void updateEffectPositions() = win inline, m1 0xa80f4 {
        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        m_glitterParticles->setPosition(winSize * .5f / m_gameState.m_cameraZoom + m_gameState.m_cameraPosition);
        for (int i = 0; i < m_circleWaveArray->count(); i++) {
            auto wave = static_cast<CCCircleWave*>(m_circleWaveArray->objectAtIndex(i));
            if (wave->m_target) wave->setPosition(wave->m_target->getPosition());
        }
    }
    void updateInfoLabel() = win 0x3b2710, imac 0xafad0, m1 0x9e40c;
    void updateInvisibleBlock(GameObject* object, float rightFadeBound, float leftFadeBound, float rightFadeWidth, float leftFadeWidth, cocos2d::ccColor3B const& lbgColor) = win 0x3b0060, imac 0xb7e80 {
        auto realPosition = object->getRealPosition();
        if (realPosition.x > m_cameraUnzoomedX) realPosition.x -= object->m_fadeMargin;
        else realPosition.x += object->m_fadeMargin;
        auto relativeMod = this->getRelativeMod(realPosition, .02f, 1.f / 70.f, .0f) * 255.f;
        auto cameraX = m_gameState.m_cameraPosition2.x;
        float factor;
        if (realPosition.x > cameraX + rightFadeBound) {
            factor = realPosition.x - cameraX - rightFadeBound;
        }
        else {
            factor = factor + leftFadeBound - realPosition.x;
            rightFadeWidth = leftFadeWidth;
        }
        rightFadeWidth = std::max(rightFadeWidth, 1.f);
        factor = std::clamp(factor / rightFadeWidth, 0.f, 1.f);
        object->setOpacity(std::min(relativeMod, (factor * .95f + .05f) * 255.f));
        object->setGlowOpacity(std::min(relativeMod, (factor * .85f + .15f) * 255.f));
        auto opacity = object->getOpacity() / 255.f;
        if (opacity > 0.8f) {
            object->setGlowColor(GJEffectManager::getMixedColor(m_lightBGColor, lbgColor, (1.f - (opacity - .8f) / .2f) * .3f + .7f));
        }
        else {
            object->setGlowColor(m_lightBGColor);
        }
    }
    void updateProgressbar() = win 0x3b2070, m1 0x9fdc4;
    void updateScreenRotation(int rotation, bool add, bool convert, float duration, int easingType, float easingRate, int uniqueID, int controlID) = win inline, m1 0xa3b28, ios inline {
        float angle = add ? m_gameState.m_targetCameraAngle + rotation : rotation;
        if (convert) convertToClosestDirection(angle, 180.f);
        if (angle != m_gameState.m_targetCameraAngle) m_calculateTargetHeightOffset = true;
        GJBaseGameLayer::updateScreenRotation(angle, add, convert, duration, easingType, easingRate, uniqueID, controlID);
    }
    void updateTestModeLabel() = win 0x3a7640;
    void updateTimeWarp(EffectGameObject* object, float timeWarp) = win inline, ios inline {
        this->updateTimeWarp(timeWarp);
    }

    int m_unk36c8;
    bool m_unk36cc;
    bool m_unk36cd;
    bool m_unk36ce;
    bool m_unk36cf;
    bool m_damageVerified;
    gd::vector<gd::string> m_objectStrings;
    cocos2d::CCArray* m_coinArray;
    bool m_passedIntegrity;
    int m_objectsCreated;
    gd::vector<GameObject*> m_dynamicSaveObjects;
    gd::vector<GameObject*> m_activeSaveObjects1;
    gd::vector<GameObject*> m_activeSaveObjects2;
    gd::vector<SavedObjectStateRef> m_dynamicSaveObjects2;
    int m_unk3768;
    bool m_platformerRestart;
    bool m_unk376d;
    bool m_isIgnoreDamageEnabled;
    cocos2d::CCLabelBMFont* m_statusLabel;
    float m_unk3778;
    int m_unk377c;
    float m_unk3780;
    float m_unk3784;
    int m_unk3788;
    int m_unk378c;
    bool m_endChecked;
    float m_endXPosition;
    CheckpointObject* m_currentCheckpoint;
    cocos2d::CCArray* m_checkpointArray;
    cocos2d::CCArray* m_speedObjects;
    bool m_unk37b0;
    bool m_unk37b1;
    cocos2d::CCPoint m_enterEffectPosition;
    cocos2d::CCArray* m_unk37c0;
    bool m_isSilent;
    int m_unk37cc;
    cocos2d::CCArray* m_circleWaveArray;
    cocos2d::CCArray* m_collectibles;
    bool m_unk37e0;
    int m_pulseRodIndex;
    float m_maxObjectX;
    cocos2d::CCLabelBMFont* m_attemptLabel;
    cocos2d::CCLabelBMFont* m_percentageLabel;
    bool m_decimalPercentage;
    bool m_hintShown;
    cocos2d::CCSprite* m_progressBar;
    cocos2d::CCSprite* m_progressFill;
    float m_progressWidth;
    float m_progressHeight;
    int m_totalGravityEffects;
    int m_activeGravityEffects;
    int m_gravityEffectIndex;
    cocos2d::CCArray* m_gravityEffects;
    bool m_doNot;
    float m_unk383c;
    bool m_skipAudioStep;
    gd::unordered_set<int> m_blendingColors;
    int m_jumps;
    bool m_hasJumped;
    int m_uncommittedJumps;
    bool m_showLeaderboardPercentage;
    bool m_hasCompletedLevel;
    bool m_inResetDelay;
    int m_lastAttemptPercent;
    bool m_endLayerStars;
    int m_orbs;
    int m_diamonds;
    bool m_secretKey;
    bool m_recordingStopped;
    double m_unk38b0;
    double m_unk38b8;
    double m_unk38c0;
    bool m_unk38c8;
    float m_unk38cc;
    int m_unk38d0;
    double m_attemptTime;
    double m_bestAttemptTime;
    double m_pauseTime;
    double m_currentTime;
    double m_pauseDelta;
    float m_unk3900;
    bool m_glitterEnabled;
    bool m_bgEffectDisabled;
    bool m_unk3906;
    bool m_isPaused;
    bool m_disableGravityEffect;
    cocos2d::CCLabelBMFont* m_infoLabel;
    cocos2d::CCPoint m_unk3918;
    cocos2d::CCPoint m_unk3920;
    cocos2d::CCDictionary* m_colorKeyDict;
    gd::vector<cocos2d::ccColor3B> m_keyColors;
    gd::vector<float> m_keyOpacities;
    DynamicBitset m_keyPulses;
    int m_nextColorKey;
    bool m_tryPlaceCheckpoint;
    CheckpointGameObject* m_activatedCheckpoint;
    bool m_musicPrepared;
    cocos2d::CCPoint m_endPosition;
    EndTriggerGameObject* m_platformerEndTrigger;
}

[[link(android)]]
class PointNode : cocos2d::CCObject {
    // virtual ~PointNode();
    PointNode() {}

    static PointNode* create(cocos2d::CCPoint point) = win inline, m1 0x8e314 {
        auto ret = new PointNode();
        if (ret->init(point)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init(cocos2d::CCPoint point) = win inline, m1 0x8e650, ios inline {
        m_point = point;

        return true;
    }

    cocos2d::CCPoint m_point;
}

[[link(android)]]
class PriceLabel : cocos2d::CCNode {
    // virtual ~PriceLabel();

    static PriceLabel* create(int price) = imac 0x4bf280, m1 0x41f214;

    bool init(int price) = imac 0x4bf3a0, m1 0x41f338;
    void setColor(cocos2d::ccColor3B color) = imac 0x4bf5e0, m1 0x41f554;
    void setOpacity(float opacity) = imac 0x4bf630, m1 0x41f5ac;
    void setPrice(int price) = imac 0x4bf480, m1 0x41f420;

    cocos2d::CCLabelBMFont* m_priceLabel;
    cocos2d::CCSprite* m_coinSprite;
}

[[link(android)]]
class ProfilePage : FLAlertLayer, FLAlertLayerProtocol, LevelCommentDelegate, CommentUploadDelegate, UserInfoDelegate, UploadActionDelegate, UploadPopupDelegate, LeaderboardManagerDelegate {
    // virtual ~ProfilePage();
    // ProfilePage() = ios 0x1a9c90;

    static ProfilePage* create(int accountID, bool ownProfile) = win 0x3be300, imac 0x7b7f90, m1 0x6bddf0;

    virtual void registerWithTouchDispatcher() = win 0x42660, m1 0x6c5e7c, imac 0x7c0980;
    virtual void keyBackClicked() = win 0x3c4dc0, m1 0x6c486c, imac 0x7bf340;
    virtual void show() = win 0x3c5050, m1 0x6c4a9c, imac 0x7bf5c0;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x3c4790, imac 0x7bedf0, m1 0x6c42e0;
    virtual void updateUserScoreFinished() = win 0x3c4f10, m1 0x6c4960, imac 0x7bf450;
    virtual void updateUserScoreFailed() = win 0x3c5000, imac 0x7bf520, m1 0x6c49f4;
    virtual void getUserInfoFinished(GJUserScore* score) = win 0x3c5b80, m1 0x6c4d7c, imac 0x7bf8e0;
    virtual void getUserInfoFailed(int id) = win 0x3c5c70, m1 0x6c512c, imac 0x7bfcd0;
    virtual void userInfoChanged(GJUserScore* score) = win 0x3c5cc0, imac 0x7bfd90, m1 0x6c51fc;
    virtual void loadCommentsFinished(cocos2d::CCArray* comments, char const* key) = win 0x3c62c0, m1 0x6c5410, imac 0x7bffa0;
    virtual void loadCommentsFailed(char const* key) = win 0x3c6340, m1 0x6c551c, imac 0x7c0090;
    virtual void setupPageInfo(gd::string info, char const* key) = win 0x3c63a0, m1 0x6c55f0, imac 0x7c0160;
    virtual void commentUploadFinished(int parentID) = win 0x3c65a0, m1 0x6c5b9c, imac 0x7c0690;
    virtual void commentUploadFailed(int parentID, CommentError errorType) = win 0x3c65f0, m1 0x6c5c3c, imac 0x7c0720;
    virtual void commentDeleteFailed(int id, int parentID) = win 0x3c6710, imac 0x7c07f0, m1 0x6c5d14;
    virtual void onClosePopup(UploadActionPopup* popup) = win 0x3c4a80, m1 0x6c4494, imac 0x7befd0;
    virtual void uploadActionFinished(int id, int response) = win 0x3c4ad0, m1 0x6c451c, imac 0x7bf050;
    virtual void uploadActionFailed(int id, int response) = win 0x3c4c90, m1 0x6c470c, imac 0x7bf220;

    void blockUser() = win inline {
        if (GameLevelManager::sharedState()->blockUser(m_score->m_accountID)) {
            m_popupDelegate = UploadActionPopup::create(this, "Blocking user...");
            m_popupDelegate->show();
        }
    }
    bool init(int accountID, bool ownProfile) = win 0x3be4e0, imac 0x2ec1d0;
    bool isCorrect(char const* key) = m1 0x6c5308;
    bool isOnWatchlist(int id) = win inline, imac 0x7b8c50, m1 0x6be9a4, ios inline { return false; }
    void loadPage(int page) = win 0x3c5e70, m1 0x6c4e30;
    void loadPageFromUserInfo(GJUserScore* score) = win 0x3bfb20;
    void onBlockUser(cocos2d::CCObject* sender) = m1 0x6c2ee8;
    void onClose(cocos2d::CCObject* sender) = win 0x3c4d40, m1 0x6be9ac;
    void onComment(cocos2d::CCObject* sender) = win 0x3c39c0, m1 0x6c379c;
    void onCommentHistory(cocos2d::CCObject* sender) = win 0x3c3930, imac 0x7bc980, m1 0x6c211c;
    void onCopyName(cocos2d::CCObject* sender) = win 0x3c2f50, imac 0x7bd200, m1 0x6c2840;
    void onFollow(cocos2d::CCObject* sender) = win 0x3c41c0, m1 0x6bec1c;
    void onFriend(cocos2d::CCObject* sender) = win 0x3c3b80, imac 0x7bd550, m1 0x6c2b8c;
    void onFriends(cocos2d::CCObject* sender);
    void onInfo(cocos2d::CCObject* sender) = imac 0x7bc9c0, m1 0x6c2154;
    void onMessages(cocos2d::CCObject* sender);
    void onMyLevels(cocos2d::CCObject* sender) = win 0x3c3620, imac 0x7bdc60;
    void onMyLists(cocos2d::CCObject* sender) = win 0x3c37d0;
    void onNextPage(cocos2d::CCObject* sender) = win 0x3c6580, m1 0x6c42d4;
    void onPrevPage(cocos2d::CCObject* sender) = win 0x3c6590, m1 0x6c42c8;
    void onRequests(cocos2d::CCObject* sender) = m1 0x6c36f0;
    void onSendMessage(cocos2d::CCObject* sender) = m1 0x6c2a80;
    void onSettings(cocos2d::CCObject* sender) = win 0x3c5980, m1 0x34792c;
    void onStatInfo(cocos2d::CCObject* sender) = win 0x3c2d80, imac 0x7bc180, m1 0x6c1894;
    void onTwitch(cocos2d::CCObject* sender);
    void onTwitter(cocos2d::CCObject* sender);
    void onUpdate(cocos2d::CCObject* sender) = win 0x3bf490, imac 0x7b9160, m1 0x3ea64c;
    void onYouTube(cocos2d::CCObject* sender);
    void setupComments() = win inline, m1 0x6bea24 {
        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        auto leftSprite = cocos2d::CCSprite::createWithSpriteFrameName("GJ_arrow_01_001.png");
        leftSprite->setScale(.8f);
        m_leftArrow = CCMenuItemSpriteExtra::create(leftSprite, this, menu_selector(ProfilePage::onPrevPage));
        m_buttonMenu->addChild(m_leftArrow);
        m_leftArrow->setPosition(m_buttonMenu->convertToNodeSpace(winSize / 2.f + cocos2d::CCPoint { -195.f, -53.f }));
        m_leftArrow->setSizeMult(2.f);
        auto rightSprite = cocos2d::CCSprite::createWithSpriteFrameName("GJ_arrow_01_001.png");
        rightSprite->setFlipX(true);
        rightSprite->setScale(.8f);
        m_rightArrow = CCMenuItemSpriteExtra::create(rightSprite, this, menu_selector(ProfilePage::onNextPage));
        m_buttonMenu->addChild(m_rightArrow);
        m_rightArrow->setPosition(m_buttonMenu->convertToNodeSpace(winSize / 2.f + cocos2d::CCPoint { 195.f, -53.f }));
        m_rightArrow->setSizeMult(2.f);
        m_leftArrow->setVisible(false);
        m_rightArrow->setVisible(false);
    }
    void setupCommentsBrowser(cocos2d::CCArray* comments) = win 0x3c6160, m1 0x6bf0ec;
    void showNoAccountError() = win 0x3c4dd0, imac 0x7bec30, m1 0x6c4158;
    void toggleMainPageVisibility(bool visible) = win inline, imac 0x7bf700, m1 0x6c4bf0, ios inline {
        for (auto obj : geode::cocos::CCArrayExt<cocos2d::CCObject*, false>(m_arrayWithUsernameLabel)) {
            static_cast<cocos2d::CCNode*>(obj)->setVisible(visible);
        }
        for (auto obj : geode::cocos::CCArrayExt<cocos2d::CCObject*, false>(m_buttons)) {
            static_cast<cocos2d::CCNode*>(obj)->setVisible(visible);
        }
        if (m_list) m_list->setVisible(visible);
        if (visible) this->updatePageArrows();
        m_rightArrow->setVisible(false);
        m_leftArrow->setVisible(false);
    }
    void toggleShip(cocos2d::CCObject* sender) = win 0x3c2cd0, imac 0x7bc4b0, m1 0x6c1b94;
    void updateLevelsLabel() = win inline, imac 0x7c0680, m1 0x6c5b98, ios inline {}
    void updatePageArrows() = win 0x3c6510, ios inline {
        m_leftArrow->setVisible(m_pageStartIdx != 0);
        m_rightArrow->setVisible(m_itemCount > m_pageEndIdx + m_pageStartIdx);
    }

    GJUserScore* m_score;
    int m_accountID;
    bool m_ownProfile;
    gd::string m_profileKey;
    cocos2d::CCLabelBMFont* m_somethingWentWrong;
    cocos2d::CCLabelBMFont* m_usernameLabel;
    GJCommentListLayer* m_list;
    CCMenuItemSpriteExtra* m_rightArrow;
    CCMenuItemSpriteExtra* m_leftArrow;
    CCMenuItemSpriteExtra* m_followBtn;
    bool m_unk;
    cocos2d::CCArray* m_buttons;
    cocos2d::CCArray* m_arrayWithUsernameLabel;
    int m_itemCount;
    int m_pageStartIdx;
    int m_pageEndIdx;
    int m_page;
    LoadingCircle* m_circle;
    UploadActionPopup* m_popupDelegate;
    CCMenuItemSpriteExtra* m_refreshBtn;
    int m_unk2;
}

[[link(android)]]
class PromoInterstitial : FLAlertLayer {
    // virtual ~PromoInterstitial();

    static PromoInterstitial* create(bool fullVersion) = m1 0x26ed00;

    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = m1 0x26f274, imac 0x2d4530;
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = m1 0x26f4dc, imac 0x2d4760;
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = m1 0x26f3a4, imac 0x2d4630;
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = m1 0x26f464, imac 0x2d46e0;
    virtual void keyBackClicked() = m1 0x26f0e0, imac 0x2d4390;
    virtual void show() = m1 0x26f0b4, imac 0x2d4360;

    bool init(bool fullVersion);
    void onClick(cocos2d::CCObject* sender) = m1 0x26f1f8;
    void onClose(cocos2d::CCObject* sender) = m1 0x26f140;
    void setup() = imac 0x2d4100;

    bool m_fullVersion;
    cocos2d::CCMenu* m_closeMenu;
    bool m_promoTouched;
    gd::string m_marketLink;
    bool m_showAdBanner;
}

[[link(android)]]
class PulseEffectAction {
    bool isFinished() = win inline, imac 0x2d8ff0, m1 0x273628, ios inline {
        return m_fadeInTime + m_holdTime + m_fadeOutTime <= m_deltaTime + m_startTime;
    }
    void step(float delta) = win inline {
        if (m_disabled) return;
        m_deltaTime += delta;
        m_currentValue = this->valueForDelta(m_deltaTime + m_startTime, m_fadeInTime, m_holdTime, m_fadeOutTime);
    }
    float valueForDelta(float currentTime, float fadeInTime, float holdTime, float fadeOutTime) = win inline, imac 0x2d8f90, m1 0x174118, ios inline {
        if (currentTime < fadeInTime) return currentTime / fadeInTime;
        if (currentTime > fadeInTime + holdTime) {
            if (fadeOutTime > 0.f) return 1.f - (currentTime - fadeInTime - holdTime) / fadeOutTime;
            return 0.f;
        }
        return 1.f;
    }

    bool m_disabled;
    float m_fadeInTime;
    float m_holdTime;
    float m_fadeOutTime;
    float m_deltaTime;
    int m_targetGroupID;
    float m_currentValue;
    cocos2d::ccColor3B m_color;
    PulseEffectType m_pulseEffectType;
    cocos2d::ccHSVValue m_hsv;
    int m_colorIndex;
    bool m_mainOnly;
    bool m_detailOnly;
    bool m_isDynamicHsv;
    int m_triggerUniqueID;
    int m_controlID;
    float m_startTime;
}

[[link(android)]]
class PurchaseItemPopup : FLAlertLayer {
    // virtual ~PurchaseItemPopup();
    // PurchaseItemPopup();

    static PurchaseItemPopup* create(GJStoreItem* item) = m1 0x2b2864;

    virtual void keyBackClicked() = win 0x846c0, m1 0x2b53c4, imac 0x328170;

    bool init(GJStoreItem* item) = win 0x2aeae0;
    void onClose(cocos2d::CCObject* sender) = win 0x84690, m1 0x2b5314;
    void onPurchase(cocos2d::CCObject* sender) = win 0x2af990, m1 0x2b5350;

    GJStoreItem* m_storeItem;
    GJPurchaseDelegate* m_delegate;
}

[[link(android)]]
class RandTriggerGameObject : ChanceTriggerGameObject {
    // virtual ~RandTriggerGameObject();
    RandTriggerGameObject() {}

    static RandTriggerGameObject* create() = win inline, m1 0x17a860 {
        auto ret = new RandTriggerGameObject();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x4b3e50, m1 0x17a92c, imac 0x1c2c30;
    virtual void triggerObject(GJBaseGameLayer* layer, int uniqueID, gd::vector<int> const* remapKeys) = win 0x4b3e70, imac 0x1c2ec0, m1 0x17ac80;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4b4040, imac 0x1c3130, m1 0x17af34;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x4b4240, m1 0x17b580, imac 0x1c3740;

    int getRandomGroupID() = win inline, imac 0x1c2d60, m1 0x17aab0 {
        int num = this->getTotalChance() * GameToolbox::fast_rand_0_1();
        auto chance = 0;
        for (auto& obj : m_chanceObjects) {
            chance += obj.m_chance;
            if (num <= chance) return obj.m_groupID;
        }
        return 0;
    }
    int getTotalChance() = win inline {
        auto total = 0;
        for (auto& obj : m_chanceObjects) {
            total += obj.m_chance;
        }
        return total;
    }
}

[[link(android)]]
class RateDemonLayer : FLAlertLayer, UploadPopupDelegate, UploadActionDelegate {
    RateDemonLayer() {
        m_uploadFinished = false;
        m_submitButton = nullptr;
        m_demons = nullptr;
        m_unkPtr = nullptr;
        m_levelID = 0;
        m_demonRate = 0;
        m_moderator = false;
        m_popup = nullptr;
        m_delegate = nullptr;
    }
    ~RateDemonLayer() = win inline {
        auto glm = GameLevelManager::sharedState();
        if (glm->m_uploadActionDelegate == this) glm->m_uploadActionDelegate = nullptr;
        CC_SAFE_RELEASE(m_demons);
    }

    static RateDemonLayer* create(int levelID) = win inline, m1 0x225080 {
        auto ret = new RateDemonLayer();
        if (ret->init(levelID)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyBackClicked() = win 0x3c92f0, m1 0x225de8, imac 0x2842d0;
    virtual void uploadActionFinished(int id, int response) = win 0x3c90d0, imac 0x283f90, m1 0x225a24;
    virtual void uploadActionFailed(int id, int response) = win 0x3c9160, imac 0x284080, m1 0x225b74;
    virtual void onClosePopup(UploadActionPopup* popup) = win 0x3c9230, m1 0x225cf4, imac 0x2841f0;

    bool init(int levelID) = win 0x3c87e0;
    void onClose(cocos2d::CCObject* sender) = m1 0x22589c;
    void onRate(cocos2d::CCObject* sender) = win 0x3c8f30, m1 0x2258f8;
    void selectRating(cocos2d::CCObject* sender) = win 0x3c8db0, m1 0x225790;

    bool m_uploadFinished;
    CCMenuItemSpriteExtra* m_submitButton;
    cocos2d::CCArray* m_demons;
    void* m_unkPtr;
    int m_levelID;
    int m_demonRate;
    bool m_moderator;
    UploadActionPopup* m_popup;
    RateLevelDelegate* m_delegate;
}

[[link(android)]]
class RateLevelDelegate {
    virtual void rateLevelClosed() {}
}

[[link(android)]]
class RateLevelLayer : FLAlertLayer {
    RateLevelLayer() {
        m_submitButton = nullptr;
        m_difficulties = nullptr;
        m_levelID = 0;
        m_levelRate = 0;
        m_delegate = nullptr;
    }
    ~RateLevelLayer() = win inline {
        CC_SAFE_RELEASE(m_difficulties);
    }

    static RateLevelLayer* create(int levelID) = win inline, m1 0x4b5ef8 {
        auto ret = new RateLevelLayer();
        if (ret->init(levelID)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyBackClicked() = win 0x3c9b00, m1 0x4b6878, imac 0x567f30;

    bool init(int levelID) = win 0x3c9410;
    void onClose(cocos2d::CCObject* sender) = imac 0x567e90, m1 0x4b67b4;
    void onRate(cocos2d::CCObject* sender) = win 0x3c9a70, imac 0x567ee0;
    void selectRating(cocos2d::CCObject* sender) = win 0x3c9920, imac 0x567db0, m1 0x4b6698;

    CCMenuItemSpriteExtra* m_submitButton;
    cocos2d::CCArray* m_difficulties;
    int m_levelID;
    int m_levelRate;
    RateLevelDelegate* m_delegate;
}

[[link(android)]]
class RateStarsLayer : FLAlertLayer, UploadPopupDelegate, UploadActionDelegate {
    // virtual ~RateStarsLayer();

    static RateStarsLayer* create(int levelID, bool platformer, bool moderator) = win 0x3c9c90, imac 0x28b330, m1 0x22c01c;

    virtual void keyBackClicked() = win 0x3cab80, imac 0x28c660, m1 0x22d308;
    virtual void uploadActionFinished(int id, int response) = win 0x3ca980, imac 0x28c320, m1 0x22cf74;
    virtual void uploadActionFailed(int id, int response) = win 0x3caa00, imac 0x28c410, m1 0x22d0b4;
    virtual void onClosePopup(UploadActionPopup* popup) = win 0x3caac0, m1 0x22d214, imac 0x28c580;

    CCMenuItemSpriteExtra* getStarsButton(int stars, cocos2d::SEL_MenuHandler selector, cocos2d::CCMenu* menu, float scale) = m1 0x22cb3c, ios inline {
        auto button = CCMenuItemSpriteExtra::create(
            ButtonSprite::create(cocos2d::CCString::createWithFormat("%i", stars)->getCString(), 20, 0, .5f, true, "bigFont.fnt", "GJ_button_01.png", 30.f),
            this, selector
        );
        button->setScale(scale);
        button->m_baseScale = scale;
        if (menu) menu->addChild(button);
        return button;
    }
    bool init(int levelID, bool platformer, bool moderator);
    void onClose(cocos2d::CCObject* sender) = imac 0x28c140;
    void onFeature(cocos2d::CCObject* sender) = win 0x3ca570, imac 0x28c110, m1 0x22a5e4;
    void onRate(cocos2d::CCObject* sender) = win 0x3ca790, imac 0x28c190;
    void onToggleCoins(cocos2d::CCObject* sender) = win inline, m1 0x22cf1c, ios inline {
        m_coinsToggled = !m_coinsToggled;
        m_coinSprite->setColor(m_coinsToggled ? cocos2d::ccColor3B { 255, 255, 255 } : cocos2d::ccColor3B { 50, 50, 50 });
    }
    void selectRating(cocos2d::CCObject* sender) = win 0x2f6660, m1 0x22cc04;

    bool m_uploadFinished;
    bool m_moderator;
    CCMenuItemSpriteExtra* m_submitButton;
    cocos2d::CCArray* m_buttons;
    int m_levelID;
    int m_starsRate;
    bool m_coinsToggled;
    cocos2d::CCSprite* m_coinSprite;
    UploadActionPopup* m_popup;
    GJDifficultySprite* m_difficultySprite;
    int m_featureState;
    RateLevelDelegate* m_delegate;
}

[[link(android)]]
class RetryLevelLayer : GJDropDownLayer, RewardedVideoDelegate {
    RetryLevelLayer() {
        m_mainMenu = nullptr;
        m_exitingMenu = false;
        m_unk1e9 = false;
    }
    ~RetryLevelLayer() = win inline, m1 0x450cd4 {
        auto gm = GameManager::sharedState();
        if (gm->m_rewardedVideoDelegate == this) gm->m_rewardedVideoDelegate = nullptr;
    }

    static RetryLevelLayer* create() = win inline, m1 0x450b7c {
        auto ret = new RetryLevelLayer();
        if (ret->init(" ", 230.f, true)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyBackClicked() = win 0x3cbc40, m1 0x452110, imac 0x4f9200;
    virtual void keyDown(cocos2d::enumKeyCodes key, double timestamp) = win 0x3cbad0, m1 0x452074, imac 0x4f9130;
    virtual void customSetup() = win 0x3cacf0, m1 0x450fd0, imac 0x4f8030;
    virtual void showLayer(bool instant) = win 0x3cb890, m1 0x451b68, imac 0x4f8bf0;
    virtual void enterAnimFinished() = win 0x3cb9b0, m1 0x451c78, imac 0x4f8cf0;
    virtual void rewardedVideoFinished() = win 0x3cb9f0, imac 0x4f9110, m1 0x452064;
    virtual bool shouldOffsetRewardCurrency() { return true; }
    virtual void keyUp(cocos2d::enumKeyCodes key, double timestamp) = win inline, imac 0x4f91e0, m1 0x452108 {}

    const char* getEndText() = win inline, m1 0x451b0c, ios inline {
        auto index = rand() % 5;
        switch (index) {
            case 2: return "Good Job!";
            case 3: return "Well Done!";
            case 4: return "Impressive!";
            default: return "Awesome!";
        }
    }
    void onEveryplay(cocos2d::CCObject* sender) = win inline, ios inline {}
    void onMenu(cocos2d::CCObject* sender) = win 0x3cbb20, m1 0x451a50;
    void onReplay(cocos2d::CCObject* sender) = m1 0x4519fc;
    void onRewardedVideo(cocos2d::CCObject* sender);
    void setupLastProgress() = win 0x3cb450, m1 0x451694;

    cocos2d::CCMenu* m_mainMenu;
    bool m_exitingMenu;
    bool m_unk1e9;
}

[[link(android)]]
class RewardedVideoDelegate {
    virtual void rewardedVideoFinished() {}
    virtual bool shouldOffsetRewardCurrency() { return false; }
}

[[link(android)]]
class RewardsPage : FLAlertLayer, FLAlertLayerProtocol, GJRewardDelegate {
    RewardsPage() {
        m_leftLabel = nullptr;
        m_rightLabel = nullptr;
        m_leftChest = nullptr;
        m_rightChest = nullptr;
        m_leftOpen = false;
        m_rightOpen = false;
        m_openLayer = nullptr;
    }
    ~RewardsPage() = win inline, m1 0x1c4bf4 {
        auto glm = GameLevelManager::sharedState();
        if (glm->m_GJRewardDelegate == this) glm->m_GJRewardDelegate = nullptr;
    }

    static RewardsPage* create() = win inline, m1 0x1c4f10 {
        auto ret = new RewardsPage();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static char const* getRewardFrame(int type, int state) = win inline, imac 0x21ab90, m1 0x1c5cbc, ios inline {
        return cocos2d::CCString::createWithFormat("chest_%02d_%02d_001.png", type, state)->getCString();
    }

    virtual bool init() = win 0x3cc120, m1 0x1c5024, imac 0x219df0;
    virtual void registerWithTouchDispatcher() = win 0x42660, m1 0x1c67e0, imac 0x21b670;
    virtual void keyBackClicked() = win 0x846c0, m1 0x1c6764, imac 0x21b600;
    virtual void show() = win 0x3c5050, m1 0x1c6608, imac 0x21b4a0;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win inline, imac 0x21b5e0, m1 0x1c675c {}
    virtual void rewardsStatusFinished(int type) = win 0x3cd120, imac 0x21b120, m1 0x1c6294;
    virtual void rewardsStatusFailed() = win 0x3cd370, m1 0x1c6504, imac 0x21b3b0;

    void onClose(cocos2d::CCObject* sender) = win 0x84690, m1 0x1c5c54;
    void onFreeStuff(cocos2d::CCObject* sender) = m1 0x1c5c90;
    void onReward(cocos2d::CCObject* sender) = win 0x3ccfe0, m1 0x1c5ce4;
    void tryGetRewards() = m1 0x1c6578;
    void unlockLayerClosed(RewardUnlockLayer* layer) = win inline, imac 0x21b6b0, m1 0x1c6818, ios inline {
        if (m_openLayer == layer) m_openLayer = nullptr;
    }
    callback void updateTimers(float dt) = win 0x3cd470, m1 0x1c5e04;

    cocos2d::CCLabelBMFont* m_leftLabel;
    cocos2d::CCLabelBMFont* m_rightLabel;
    CCMenuItemSpriteExtra* m_leftChest;
    CCMenuItemSpriteExtra* m_rightChest;
    bool m_leftOpen;
    bool m_rightOpen;
    RewardUnlockLayer* m_openLayer;
}

[[link(android)]]
class RewardUnlockLayer : FLAlertLayer, CurrencyRewardDelegate {
    // virtual ~RewardUnlockLayer();

    static RewardUnlockLayer* create(int type, RewardsPage* page) = win 0x3cd950, imac 0x21afb0, m1 0x1c6164;

    virtual void keyBackClicked() = win inline, m1 0x1ca16c, imac 0x21f3c0 {}
    virtual void currencyWillExit(CurrencyRewardLayer* layer) = win 0x3d1210, imac 0x21f380, m1 0x1ca144;

    void connectionTimeout() = win 0x3ce850;
    bool init(int type, RewardsPage* page) = win 0x3cda80;
    void labelEnterFinishedO(cocos2d::CCObject* object) = win inline, imac 0x21f370, m1 0x1ca140 {}
    void onClose(cocos2d::CCObject* sender) = win 0x3d1220, imac 0x21ca50, m1 0x1c79f4;
    void playDropSound() = win 0x3ce8b0, m1 0x1c7898;
    void playLabelEffect(int count, int type, cocos2d::CCSprite* sprite, cocos2d::CCPoint position, float delay) = win 0x3d0180, imac 0x21ec20, m1 0x1c99fc;
    void playRewardEffect() = win 0x3cea70, imac 0x57dca0, m1 0x4ccaa8;
    bool readyToCollect(GJRewardItem* item) = win inline, m1 0x1c6410, ios inline {
        return item ? m_chestType == (int)item->m_rewardType : false;
    }
    void showCloseButton() = win 0x3d0110, imac 0x21f2f0, m1 0x1ca0c8;
    bool showCollectReward(GJRewardItem* item) = win 0x3ce790, imac 0x21b2e0;
    void step2() = win 0x3ce950, m1 0x1c7924;
    void step3() = win 0x3cea50;

    cocos2d::CCArray* m_backgroundObjects;
    RewardsPage* m_rewardsPage;
    GJChestSprite* m_chestSprite;
    int m_chestType;
    bool m_rewardCollected;
    bool m_animationPlayed;
    GJRewardItem* m_rewardItem;
    cocos2d::CCLabelBMFont* m_wrongLabel;
    CCMenuItemSpriteExtra* m_closeBtn;
    CCMenuItemSpriteExtra* m_rewardBtn;
    float m_unkFloat;
}

[[link(android)]]
class RingObject : EffectGameObject {
    // virtual ~RingObject();
    RingObject() {
        m_claimTouch = false;
        m_isSpawnOnly = false;
    }

    static RingObject* create(char const* frame) = win 0x4a18e0;

    virtual void setScale(float scale) = win 0x4a1c60, m1 0x16e180, imac 0x1b3f70;
    virtual void setRotation(float rotation) = win 0x3a34f0, m1 0x16e1e0, imac 0x1b3fd0;
    virtual void resetObject() = win 0x4a1c40, m1 0x16e154, imac 0x1b3f50;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4a1d20, m1 0x16e1f4, imac 0x1b4000;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x4a1e40, m1 0x16e300, imac 0x1b4150;
    virtual void setRScale(float scale) = win 0x4a1c90, m1 0x16e1b0, imac 0x1b3fa0;
    virtual void triggerActivated(float xPosition) = win 0x4a1990, imac 0x1b3df0, m1 0x16e008;
    virtual bool shouldDrawEditorHitbox() = win 0x4a1d10, imac 0x1b3fe0, m1 0x16e1e4;
    virtual void powerOnObject(int state) = win 0x4a19a0, m1 0x16e014, imac 0x1b3e00;

    bool init(char const* frame) = win inline, m1 0x16dfb8, ios inline {
        if (!EffectGameObject::init(frame)) return false;
        m_customGlowColor = true;
        m_isTouchTriggered = true;
        return true;
    }
    void spawnCircle() = win 0x4a1a40;

    bool m_claimTouch;
    // property 504
    bool m_isSpawnOnly;
}

[[link(android)]]
class RotateGameplayGameObject : EffectGameObject {
    // virtual ~RotateGameplayGameObject();
    RotateGameplayGameObject() {
        m_moveDirection = 0;
        m_groundDirection = 0;
        m_editVelocity = false;
        m_overrideVelocity = false;
        m_velocityModX = 1.f;
        m_velocityModY = 1.f;
        m_changeChannel = false;
        m_channelOnly = false;
        m_targetChannelID = 0;
        m_instantOffset = false;
        m_dontSlide = false;
    }

    static RotateGameplayGameObject* create() = win inline, m1 0x1a0008 {
        auto ret = new RotateGameplayGameObject();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x4c3b80, m1 0x1a00e8, imac 0x1f17f0;
    virtual void updateStartValues() = win 0x4c44a0, m1 0x1a188c, imac 0x1f3550;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4c4210, m1 0x1a15a0, imac 0x1f31e0;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x4c3bf0, m1 0x1a0138, imac 0x1f1840;

    void updateGameplayRotation() = win inline {
        this->determineSlopeDirection();
        switch (m_slopeDirection) {
            case 1:
                m_moveDirection = 1;
                m_groundDirection = 4;
                break;
            case 2:
                m_moveDirection = 2;
                m_groundDirection = 3;
                break;
            case 3:
                m_moveDirection = 1;
                m_groundDirection = 3;
                break;
            case 4:
                m_moveDirection = 3;
                m_groundDirection = 2;
                break;
            case 5:
                m_moveDirection = 4;
                m_groundDirection = 1;
                break;
            case 6:
                m_moveDirection = 3;
                m_groundDirection = 1;
                break;
            case 7:
                m_moveDirection = 4;
                m_groundDirection = 2;
                break;
            default:
                m_moveDirection = 2;
                m_groundDirection = 4;
                break;
        }
    }

    // property 166
    int m_moveDirection;
    // property 167
    int m_groundDirection;
    // property 169
    bool m_editVelocity;
    // property 584
    bool m_overrideVelocity;
    // property 582
    float m_velocityModX;
    // property 583
    float m_velocityModY;
    // property 171
    bool m_changeChannel;
    // property 172
    bool m_channelOnly;
    // property 173
    int m_targetChannelID;
    // property 368
    bool m_instantOffset;
    // property 585
    bool m_dontSlide;
}

[[link(android)]]
class ScrollingLayer : cocos2d::CCLayerColor {
    // virtual ~ScrollingLayer();
    ScrollingLayer() = m1 0x6335c8 {
        m_scrollFactor = 0.f;
        m_touchID = -1;
        m_contentLayer = nullptr;
        m_parentLayer = nullptr;
    }

    static ScrollingLayer* create(cocos2d::CCSize size, cocos2d::CCPoint position, float factor) = win inline, imac 0x720090, m1 0x632ee8 {
        auto ret = new ScrollingLayer();
        if (ret->init(size, position, factor)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void draw() = win 0x70f30, imac 0x720350, m1 0x633174;
    virtual void visit() = win 0x70ff0, m1 0x633218, imac 0x720420;
    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x71040, imac 0x720570, m1 0x63332c;
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x71130, imac 0x720710, m1 0x633484;
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x71240, imac 0x720830, m1 0x633574;
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x71260, imac 0x720870, m1 0x6335ac;

    cocos2d::CCRect getViewRect() = win 0x70e40, imac 0x720260, m1 0x6330b8;
    bool init(cocos2d::CCSize size, cocos2d::CCPoint position, float factor) = win inline {
        if (!cocos2d::CCLayerColor::initWithColor({ 0, 0, 0, 0 })) return false;
        m_scrollFactor = factor;
        this->addChild(cocos2d::CCLayerColor::create({ 0, 0, 0, 50 }), -2);
        m_contentLayer = cocos2d::CCLayer::create();
        this->addChild(m_contentLayer, -1);
        m_size = size;
        return true;
    }
    void setStartOffset(cocos2d::CCPoint offset) = win inline, imac 0x720530, m1 0x6332f4 {
        m_startOffset = offset;
        m_contentLayer->setPosition(offset);
    }

    cocos2d::CCPoint m_position;
    cocos2d::CCSize m_size;
    cocos2d::CCPoint m_touchStartPosition;
    cocos2d::CCPoint m_touchPosition;
    cocos2d::CCPoint m_startOffset;
    float m_scrollFactor;
    int m_touchID;
    cocos2d::CCLayer* m_contentLayer;
    cocos2d::CCLayer* m_parentLayer;
}

[[link(android)]]
class SearchButton : cocos2d::CCSprite {
    // virtual ~SearchButton();

    static SearchButton* create(char const* background, char const* label, float scale, char const* icon) = win 0x312600, imac 0x62a340, m1 0x54d684;

    bool init(char const* background, char const* label, float scale, char const* icon) = win 0x3126d0;

    cocos2d::CCLabelBMFont* m_label;
    cocos2d::CCSprite* m_icon;
}

[[link(android)]]
class SearchSFXPopup : SetTextPopup {
    // virtual ~SearchSFXPopup();
    SearchSFXPopup() {}

    static SearchSFXPopup* create(gd::string query) = win inline, m1 0x3b1bd0 {
        auto ret = new SearchSFXPopup();
        if (ret->init(query)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init(gd::string query) = win 0x4809b0, imac 0x440970, m1 0x3b2070;
    void onSearchFolders(cocos2d::CCObject* sender);
}

[[link(android)]]
class SecretGame01Layer : cocos2d::CCLayer {
    // virtual ~SecretGame01Layer() = m1 0x3dc158, imac 0x46cd20;

    static SecretGame01Layer* create() = m1 0x3e4e88;

    virtual void update(float dt) = m1 0x3e6670, imac 0x480470;
    virtual bool init() = m1 0x3e58bc, imac 0x47f630;

    void didSelectCorrectObject(CCMenuItemSpriteExtra* button) = imac 0x4802b0, m1 0x42f9c;
    void gameStep01() = imac 0x47f9e0;
    void gameStep02() = imac 0x47fcb0, m1 0x21dea8;
    int getCountForDifficulty(int difficulty) = imac 0x47f820, m1 0x3e5aa0;
    gd::string getFrameForDifficulty(int difficulty) = imac 0x47f850;
    int getRowsForDifficulty(int difficulty) = m1 0x3e5a7c;
    int getTimeForDifficulty(int difficulty) = m1 0x3e5b9c;
    void onSelectButton(cocos2d::CCObject* sender) = imac 0x47f910, m1 0x3e5bc0;
    void resetGame() = imac 0x47eb50, m1 0x3e4fa8;
    void resetGameTimer() = imac 0x47fe10, m1 0x3e6060;
    void scaleOutGame(bool won) = imac 0x47fea0, m1 0x3e60d8;
    void showGameOver() = imac 0x47fe80, m1 0x3e60cc;
    void showGameWon() = imac 0x480290, m1 0x3e6484;

    cocos2d::CCArray* m_gameObjects;
    cocos2d::CCArray* m_requiredObjects;
    cocos2d::CCMenu* m_mainMenu;
    int m_selectedObject;
    int m_gameDifficulty;
    bool m_gameActive;
    float m_timeElapsed;
    float m_gameTime;
    cocos2d::CCSprite* m_timeBarSprite;
}

[[link(android)]]
class SecretLayer : cocos2d::CCLayer, TextInputDelegate, FLAlertLayerProtocol {
    SecretLayer() {
        m_basicMessageIndex = -1;
        m_selectedThread = 0;
        m_threadMessageIndex = 0;
        m_basicMessageCount = 0;
        m_doomedIndex = 0;
        m_searchInput = nullptr;
        m_messageLabel = nullptr;
        m_messageThreads = nullptr;
        m_threadTag = -1;
    }
    ~SecretLayer() = win inline, m1 0x522a0c {
        CC_SAFE_RELEASE(m_messageThreads);
    }

    static SecretLayer* create() = win inline, m1 0x522d08 {
        auto ret = new SecretLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static cocos2d::CCScene* scene() = win inline, m1 0x522c1c {
        auto scene = cocos2d::CCScene::create();
        AppDelegate::get()->m_runningScene = scene;
        auto layer = SecretLayer::create();
        scene->addChild(layer);
        return scene;
    }

    virtual bool init() = win 0x3dc700, m1 0x522ddc, imac 0x5fa410;
    virtual void keyBackClicked() = win 0x3e1bb0, m1 0x526758, imac 0x5fe260;
    virtual void textInputOpened(CCTextInputNode* node) = win 0x3df4b0, m1 0x525924, imac 0x5fd330;
    virtual void textInputClosed(CCTextInputNode* node) = win 0x3df600, m1 0x525a04, imac 0x5fd400;
    virtual void textChanged(CCTextInputNode* node) = win 0x3df600, m1 0x525b14, imac 0x5fd4d0;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win inline, m1 0x52591c, imac 0x5fd310 {}

    gd::string getBasicMessage();
    gd::string getMessage() = win 0x3dfa50;
    gd::string getThreadMessage() = win 0x3dfc40, imac 0x5fd690;
    cocos2d::CCNode* nodeWithTag(int tag) = win inline, ios inline {
        auto node = cocos2d::CCNode::create();
        node->setTag(tag);
        return node;
    }
    void onBack(cocos2d::CCObject* sender) = win 0x3e1b10, m1 0x523ca0;
    void onSubmit(cocos2d::CCObject* sender) = win 0x3dda40, m1 0x523d0c;
    void playCoinEffect();
    void selectAThread() = win inline {
        auto keys = m_messageThreads->allKeys();
        if (m_threadTag < 0) m_threadTag = (float)(keys->count() - 1) * (float)rand() / (float)RAND_MAX;
        else m_threadTag++;
        if (keys->count() <= m_threadTag) m_threadTag = 0;
        if (m_messageThreads->count() != 0) {
            auto key = static_cast<cocos2d::CCInteger*>(keys->objectAtIndex(m_threadTag));
            m_selectedThread = m_messageThreads->objectForKey(key->getValue())->getTag();
        }
    }
    void updateMessageLabel(gd::string text);
    void updateSearchLabel(char const* text);

    int m_basicMessageIndex;
    int m_selectedThread;
    int m_threadMessageIndex;
    int m_basicMessageCount;
    int m_doomedIndex;
    CCTextInputNode* m_searchInput;
    cocos2d::CCLabelBMFont* m_messageLabel;
    CCMenuItemSpriteExtra* m_submitButton;
    cocos2d::CCDictionary* m_messageThreads;
    int m_threadTag;
}

[[link(android)]]
class SecretLayer2 : cocos2d::CCLayer, TextInputDelegate, FLAlertLayerProtocol, DialogDelegate {
    SecretLayer2() {
        m_threadTag = -1;
        m_basicMessageIndex = -1;
        m_selectedThread = 0;
        m_threadMessageIndex = 0;
        m_basicMessageCount = 0;
        m_errorMessageIndex = -1;
        m_searchInput = nullptr;
        m_messageLabel = nullptr;
        m_messageThreads = nullptr;
        m_exiting = false;
        m_doorDialogIndex = -1;
        m_secretLevelButton = nullptr;
        m_secretLevelLabels = nullptr;
        m_secretDoorButton = nullptr;
    }
    ~SecretLayer2() = win inline, m1 0x400a18 {
        CC_SAFE_RELEASE(m_messageThreads);
        CC_SAFE_RELEASE(m_secretLevelLabels);
    }

    static SecretLayer2* create() = win inline, m1 0x400cd8 {
        auto ret = new SecretLayer2();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static cocos2d::CCScene* scene() = win 0x3e1df0, m1 0x400c94;

    virtual bool init() = win 0x3e1f70, m1 0x400dc0, imac 0x49cc40;
    virtual void onExit() = win 0x3e95a0, m1 0x40693c, imac 0x4a2c00;
    virtual void keyBackClicked() = win 0x3e9590, m1 0x406850, imac 0x4a2b10;
    virtual void textInputOpened(CCTextInputNode* node) = win 0x3e6a10, m1 0x4057d4, imac 0x4a1b90;
    virtual void textInputClosed(CCTextInputNode* node) = win 0x3e6b60, m1 0x4058b4, imac 0x4a1c60;
    virtual void textChanged(CCTextInputNode* node) = win 0x3e6b60, m1 0x4059c4, imac 0x4a1d30;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win inline, m1 0x4057cc, imac 0x4a1b70 {}
    virtual void dialogClosed(DialogLayer* layer) = win 0x3e4250, m1 0x404374, imac 0x4a06e0;

    gd::string getBasicMessage() = win 0x3e7880, imac 0x4a1ef0, m1 0x405ba4;
    gd::string getErrorMessage() = win 0x3e83e0;
    gd::string getMessage();
    gd::string getThreadMessage() = win 0x3e7190, imac 0x4a25d0;
    cocos2d::CCNode* nodeWithTag(int tag) = win inline, ios inline {
        auto node = cocos2d::CCNode::create();
        node->setTag(tag);
        return node;
    }
    void onBack(cocos2d::CCObject* sender) = m1 0x401f5c;
    void onDoor(cocos2d::CCObject* sender) = win 0x3e45a0, m1 0x40342c;
    void onSecretLevel(cocos2d::CCObject* sender) = win 0x3e42f0, m1 0x403688;
    void onSubmit(cocos2d::CCObject* sender) = win 0x3e4f00, m1 0x401fd0;
    void playCoinEffect();
    void selectAThread() = win inline {
        auto keys = m_messageThreads->allKeys();
        if (m_threadTag < 0) m_threadTag = (float)(keys->count() - 1) * (float)rand() / (float)RAND_MAX;
        else m_threadTag++;
        if (keys->count() <= m_threadTag) m_threadTag = 0;
        if (m_messageThreads->count() != 0) {
            auto key = static_cast<cocos2d::CCInteger*>(keys->objectAtIndex(m_threadTag));
            m_selectedThread = m_messageThreads->objectForKey(key->getValue())->getTag();
        }
    }
    void showCompletedLevel() = win 0x3e35a0, m1 0x40384c;
    void showSecretLevel() = win 0x3e3430, m1 0x404260;
    void updateMessageLabel(gd::string text);
    void updateSearchLabel(char const* text);

    int m_threadTag;
    int m_basicMessageIndex;
    int m_selectedThread;
    int m_threadMessageIndex;
    int m_basicMessageCount;
    int m_errorMessageIndex;
    CCTextInputNode* m_searchInput;
    cocos2d::CCLabelBMFont* m_messageLabel;
    CCMenuItemSpriteExtra* m_submitButton;
    cocos2d::CCDictionary* m_messageThreads;
    bool m_exiting;
    int m_doorDialogIndex;
    CCMenuItemSpriteExtra* m_secretLevelButton;
    cocos2d::CCArray* m_secretLevelLabels;
    CCMenuItemSpriteExtra* m_secretDoorButton;
}

[[link(android)]]
class SecretLayer3 : cocos2d::CCLayer, DialogDelegate {
    SecretLayer3() {
        m_lockInput = false;
        m_locksArray = nullptr;
        m_demonEyes = nullptr;
        m_demonBody = nullptr;
        m_secretChest = nullptr;
    }
    ~SecretLayer3() = win inline {
        CC_SAFE_RELEASE(m_locksArray);
    }

    static SecretLayer3* create() = win inline, m1 0x406bcc {
        auto ret = new SecretLayer3();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static cocos2d::CCScene* scene() = win inline, m1 0x40443c {
        auto scene = cocos2d::CCScene::create();
        AppDelegate::get()->m_runningScene = scene;
        auto layer = SecretLayer3::create();
        scene->addChild(layer);
        return scene;
    }

    virtual bool init() = win 0x3e9b20, imac 0x4a30a0, m1 0x406c84;
    virtual void onExit() = win 0x3ef430, m1 0x40b6a8, imac 0x4a7f20;
    virtual void keyBackClicked() = win 0x3ef420, m1 0x40b69c, imac 0x4a7ef0;
    virtual void dialogClosed(DialogLayer* layer) = win 0x3eee20, imac 0x4a7bd0, m1 0x40b364;

    void animateEyes() = win 0x3eb480;
    void firstInteractionStep1() = win inline, m1 0x409440 {
        m_lockInput = true;
        m_demonEyes->stopAllActions();
        m_demonEyes->setScale(1.f);
        m_demonEyes->setOpacity(0);
        m_demonEyes->setVisible(true);
        m_demonEyes->runAction(cocos2d::CCFadeIn::create(1.f));
        this->runAction(cocos2d::CCSequence::create(
            cocos2d::CCDelayTime::create(2.f),
            cocos2d::CCCallFunc::create(this, callfunc_selector(SecretLayer3::firstInteractionStep2)),
            nullptr
        ));
    }
    void firstInteractionStep2() = win 0x3eb5a0, m1 0x4094fc;
    void firstInteractionStep3() = win inline {
        for (int i = 0; i < m_locksArray->count(); i++) {
            auto lock = static_cast<cocos2d::CCMenuItemSprite*>(m_locksArray->objectAtIndex(i));
            lock->setEnabled(true);
            lock->setVisible(true);
            auto lockSprite = static_cast<cocos2d::CCNodeRGBA*>(lock->getNormalImage());
            lockSprite->setScale(2.f);
            lockSprite->setOpacity(0);
            lockSprite->runAction(cocos2d::CCSequence::create(
                cocos2d::CCDelayTime::create((i + 1) * .1f),
                cocos2d::CCSpawn::createWithTwoActions(
                    cocos2d::CCEaseBounceOut::create(cocos2d::CCScaleTo::create(.5f, 1.f)),
                    cocos2d::CCFadeIn::create(.15f)
                ),
                nullptr
            ));
        }
        this->runAction(cocos2d::CCSequence::create(
            cocos2d::CCDelayTime::create(2.f),
            cocos2d::CCCallFunc::create(this, callfunc_selector(SecretLayer3::firstInteractionStep4)),
            nullptr
        ));
    }
    void firstInteractionStep4() = m1 0x2aeb3c, win 0x3ebb20;
    void onBack(cocos2d::CCObject* sender) = win 0x3ef2b0;
    void onChest01(cocos2d::CCObject* sender);
    void onChest02(cocos2d::CCObject* sender);
    void onClick(cocos2d::CCObject* sender) = win 0x3ec090, m1 0x4083f8;
    void revealStep1() = win 0x3ed8b0, imac 0x4a64c0, m1 0x409e08;
    void revealStep2() = imac 0x4a6ad0, m1 0x40a3dc;
    void revealStep3() = win inline, imac 0x4a6df0, m1 0x40a6e4 {
        m_demonBody->setOpacity(0);
        m_demonBody->setVisible(true);
        m_demonBody->runAction(cocos2d::CCEaseInOut::create(cocos2d::CCFadeIn::create(3.f), 1.5f));
        this->runAction(cocos2d::CCSequence::create(
            cocos2d::CCDelayTime::create(4.f),
            cocos2d::CCCallFunc::create(this, callfunc_selector(SecretLayer3::revealStep4)),
            nullptr
        ));
    }
    void revealStep4() = win 0x3edf30, imac 0x5e86c0, m1 0x40a780;
    void revealStep5() = win 0x3ee780, imac 0x320e70, m1 0x40aeac;
    void showUnlockDialog() = win 0x3ed3a0, m1 0x409e70;

    DungeonBarsSprite* m_dungeonBars;
    bool m_lockInput;
    cocos2d::CCArray* m_locksArray;
    cocos2d::CCSprite* m_demonEyes;
    cocos2d::CCSprite* m_demonBody;
    CCMenuItemSpriteExtra* m_secretChest;
}

[[link(android)]]
class SecretLayer4 : cocos2d::CCLayer, TextInputDelegate, FLAlertLayerProtocol, DialogDelegate {
    SecretLayer4() {
        m_threadTag = -1;
        m_basicMessageIndex = -1;
        m_selectedThread = 0;
        m_threadMessageIndex = 0;
        m_basicMessageCount = 0;
        m_errorMessageIndex = -1;
        m_searchInput = nullptr;
        m_messageLabel = nullptr;
        m_messageThreads = nullptr;
        m_exiting = false;
    }
    ~SecretLayer4() = win inline, m1 0x333550 {
        CC_SAFE_RELEASE(m_messageThreads);
    }

    static SecretLayer4* create() = win inline, m1 0x3337cc {
        auto ret = new SecretLayer4();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static cocos2d::CCScene* scene() = win inline, m1 0x333788 {
        auto scene = cocos2d::CCScene::create();
        AppDelegate::get()->m_runningScene = scene;
        auto layer = SecretLayer4::create();
        scene->addChild(layer);
        return scene;
    }

    virtual bool init() = win 0x3ef7b0, m1 0x3338a4, imac 0x3b07e0;
    virtual void onExit() = win 0x3e95a0, m1 0x337b1c, imac 0x3b4ca0;
    virtual void keyBackClicked() = win 0x3f33b0, m1 0x337a28, imac 0x3b4bb0;
    virtual void textInputOpened(CCTextInputNode* node) = win 0x3e6a10, m1 0x336a94, imac 0x3b3cc0;
    virtual void textInputClosed(CCTextInputNode* node) = win 0x3e6b60, m1 0x336b74, imac 0x3b3d90;
    virtual void textChanged(CCTextInputNode* node) = win 0x3e6b60, m1 0x336c84, imac 0x3b3e60;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win inline, m1 0x336a8c, imac 0x3b3ca0 {}
    virtual void dialogClosed(DialogLayer* layer) = win inline, imac 0x3b3460, m1 0x33621c {}

    gd::string getBasicMessage();
    gd::string getErrorMessage() = win 0x3e83e0;
    gd::string getMessage();
    gd::string getThreadMessage() = win 0x3f20d0, imac 0x3b4440;
    cocos2d::CCNode* nodeWithTag(int tag) = win inline, m1 0x3344d8, ios inline {
        auto node = cocos2d::CCNode::create();
        node->setTag(tag);
        return node;
    }
    void onBack(cocos2d::CCObject* sender) = m1 0x334c20;
    void onChest01(cocos2d::CCObject* sender) = win 0x3f0870, imac 0x3b2a10, m1 0x335924;
    void onSubmit(cocos2d::CCObject* sender) = win 0x3f09e0, imac 0x3b1c60, m1 0x334c98;
    void playCoinEffect();
    void selectAThread() = win inline {
        auto keys = m_messageThreads->allKeys();
        if (m_threadTag < 0) m_threadTag = (float)(keys->count() - 1) * (float)rand() / (float)RAND_MAX;
        else m_threadTag++;
        if (keys->count() <= m_threadTag) m_threadTag = 0;
        if (m_messageThreads->count() != 0) {
            auto key = static_cast<cocos2d::CCInteger*>(keys->objectAtIndex(m_threadTag));
            m_selectedThread = m_messageThreads->objectForKey(key->getValue())->getTag();
        }
    }
    void showDialog(int index);
    void showFirstDialog() = win 0x3f24f0, m1 0x334510;
    void updateMessageLabel(gd::string text);
    void updateSearchLabel(char const* text);

    int m_threadTag;
    int m_basicMessageIndex;
    int m_selectedThread;
    int m_threadMessageIndex;
    int m_basicMessageCount;
    int m_errorMessageIndex;
    CCTextInputNode* m_searchInput;
    cocos2d::CCLabelBMFont* m_messageLabel;
    CCMenuItemSpriteExtra* m_submitButton;
    cocos2d::CCDictionary* m_messageThreads;
    bool m_exiting;
}

[[link(android)]]
class SecretLayer5 : cocos2d::CCLayer, TextInputDelegate, FLAlertLayerProtocol, DialogDelegate, GJOnlineRewardDelegate {
    SecretLayer5() {
        m_threadTag = -1;
        m_basicMessageIndex = -1;
        m_selectedThread = 0;
        m_threadMessageIndex = 0;
        m_basicMessageCount = 0;
        m_errorMessageIndex = -1;
        m_textInput = nullptr;
        m_messageLabel = nullptr;
        m_exiting = false;
        m_torchFires = nullptr;
        m_loading = false;
        m_rewardStatus = 0;
        m_uiLocked = false;
        m_chatIndex = -1;
    }
    ~SecretLayer5() = win inline, m1 0x3e0434 {
        CC_SAFE_RELEASE(m_torchFires);
        auto glm = GameLevelManager::sharedState();
        if (glm->m_GJOnlineRewardDelegate == this) glm->m_GJOnlineRewardDelegate = nullptr;
    }

    static SecretLayer5* create() = win inline, m1 0x3e0570 {
        auto ret = new SecretLayer5();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static cocos2d::CCScene* scene() = win inline, m1 0x3e052c {
        auto scene = cocos2d::CCScene::create();
        AppDelegate::get()->m_runningScene = scene;
        auto layer = SecretLayer5::create();
        scene->addChild(layer);
        return scene;
    }

    virtual bool init() = win 0x3f3cc0, m1 0x3e067c, imac 0x479ae0;
    virtual void onExit() = win 0x3e95a0, m1 0x3e48d4, imac 0x47e3b0;
    virtual void updateTweenActionInt(float value, int tag) = win 0x3f53d0, m1 0x3e286c, imac 0x47c120;
    virtual void keyBackClicked() = win 0x3f7c90, m1 0x3e47c8, imac 0x47e2c0;
    virtual void textInputOpened(CCTextInputNode* node) = win 0x3f6fe0, m1 0x3e4490, imac 0x47e020;
    virtual void textInputClosed(CCTextInputNode* node) = win 0x3f7130, m1 0x3e4570, imac 0x47e0f0;
    virtual void textChanged(CCTextInputNode* node) = win 0x3f7130, m1 0x3e4680, imac 0x47e1c0;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win inline, m1 0x3e4488, imac 0x47e000 {}
    virtual void dialogClosed(DialogLayer* layer) = win inline, imac 0x47dfe0, m1 0x3e4480 {}
    virtual void onlineRewardStatusFinished(gd::string key) = win 0x3f66b0, m1 0x3e39ec, imac 0x47d3e0;
    virtual void onlineRewardStatusFailed() = win 0x3f6820, imac 0x47d530, m1 0x3e3b5c;

    void animateHead() = win 0x3f5060, m1 0x3e255c;
    void claimOnlineReward() = win 0x3f6490;
    void fadeInMessage() = win inline, imac 0x47bc30, m1 0x3e23cc {
        auto labels = m_messageArea->getChildren()->data;
        CCObject* obj;
        CCARRAYDATA_FOREACH(labels, obj) {
            auto characters = static_cast<cocos2d::CCLabelBMFont*>(obj)->getChildren()->data;
            CCObject* charObj;
            CCARRAYDATA_FOREACH(characters, charObj) {
                static_cast<cocos2d::CCSprite*>(charObj)->setColor({ (uint8_t)(((float)rand() / (float)RAND_MAX) * 25.f + 150.f), 0, 255 });
            }
        }
        auto duration = m_messageArea->fadeInCharacters(.6f, .06f, false, TextFadeInStyle::Scale);
        this->runAction(cocos2d::CCSequence::create(
            cocos2d::CCDelayTime::create(duration + .6f),
            cocos2d::CCCallFunc::create(this, callfunc_selector(SecretLayer5::fadeOutMessage)),
            nullptr
        ));
    }
    void fadeInSubmitMessage() = win 0x3f4e60, imac 0x47bbb0, m1 0x3e2338;
    void fadeOutMessage() = win 0x3f5030, imac 0x47bd90, m1 0x3e2534;
    void finishLoadingState() = win 0x3f5420, imac 0x47c140, m1 0x3e2880;
    gd::string getMessage() = win inline, imac 0x47abd0, m1 0x3e156c, ios inline {
        return " ";
    }
    void handleSecretResponse() = win 0x3f5440, imac 0x47c160, m1 0x3e2894;
    void hideTextInput() = win inline, m1 0x3e3bf4 {
        m_textInput->setTouchEnabled(false);
        m_textInput->onClickTrackNode(false);
        m_textInput->setVisible(false);
        m_messageArea->stopAllActions();
        m_messageArea->runAction(cocos2d::CCFadeTo::create(.5f, 0));
    }
    void incrementChatIdx() = win inline, imac 0x47ba80, m1 0x3e2228 {
        m_chatIndex++;
        if (m_chatIndex > m_soundEffects.size() - 1) {
            auto effectID = m_soundEffects[m_chatIndex - 1];
            std::mt19937 rng(rand());
            std::shuffle(m_soundEffects.begin(), m_soundEffects.end(), rng);
            m_chatIndex = m_soundEffects[0] == effectID ? 1 : 0;
        }
    }
    cocos2d::CCNode* nodeWithTag(int tag) = win inline, ios inline {
        auto ret = cocos2d::CCNode::create();
        ret->setTag(tag);
        return ret;
    }
    void onBack(cocos2d::CCObject* sender) = win 0x3f7c10;
    void onSubmit(cocos2d::CCObject* sender) = win 0x3f68c0;
    void playWinSFX() = win 0x3f6400, m1 0x3e36e0;
    void showDialog(int index);
    void showFailAnimation() = win 0x3f54a0, imac 0x47cb20, m1 0x3e3194;
    void showFirstDialog() = win 0x3f74f0, m1 0x3e1d1c;
    void showSuccessAnimation() = win 0x3f5a60;
    void showTextInput() = win 0x3f6860, m1 0x3e3674;
    void unlockUI() = win 0x3f66a0, imac 0x47d370, m1 0x3e397c;
    void updateMessageLabel(gd::string text) = win inline, m1 0x3e1518 {
        m_messageLabel->setString(text.c_str());
        m_messageLabel->limitLabelWidth(320.f, .6f, 0.f);
    }
    void updateSearchLabel(char const* text);

    int m_threadTag;
    int m_basicMessageIndex;
    int m_selectedThread;
    int m_threadMessageIndex;
    int m_basicMessageCount;
    int m_errorMessageIndex;
    CCTextInputNode* m_textInput;
    cocos2d::CCLabelBMFont* m_messageLabel;
    CCMenuItemSpriteExtra* m_wraithButton;
    bool m_exiting;
    void* m_unk1f0;
    cocos2d::CCArray* m_torchFires;
    bool m_loading;
    int m_rewardStatus; // 0 invalid, 1 valid, 2 claimed
    gd::string m_chestID;
    bool m_uiLocked;
    CCSpriteWithHue* m_wraithSprite;
    CCSpriteGrayscale* m_wraithGraySprite;
    cocos2d::CCSprite* m_eyesSprite;
    cocos2d::CCSprite* m_background;
    cocos2d::CCSprite* m_lockSprite;
    gd::vector<int> m_soundEffects;
    int m_chatIndex;
    cocos2d::extension::CCScale9Sprite* m_inputBackground;
    LoadingCircleSprite* m_circleSprite;
    TextArea* m_messageArea;
}

[[link(android)]]
class SecretLayer6 : cocos2d::CCLayer {
    // virtual ~SecretLayer6() = m1 0x3db294, imac 0x64bc50;

    static SecretLayer6* create() = m1 0x3e4a20;
    static cocos2d::CCScene* scene() = m1 0x3e4964;

    virtual bool init() = m1 0x3e4ac4, imac 0x47e610;
    virtual void keyBackClicked() = m1 0x3e5600, imac 0x47f280;

    void onBack(cocos2d::CCObject* sender) = m1 0x3e4f48;
    void startGame01() = imac 0x47eb30, m1 0x3e4f98;

    SecretGame01Layer* m_gameLayer;
}

[[link(android)]]
class SecretNumberLayer : cocos2d::CCLayer {
    // virtual ~SecretNumberLayer();

    static SecretNumberLayer* create() = win 0x3e95f0;

    virtual bool init() = win 0x3ed20, m1 0x4069cc, imac 0x4a2ce0;

    void playNumberEffect(int secretNumber) = win 0x3e96b0;
}

[[link(android)]]
class SecretRewardsLayer : cocos2d::CCLayer, DialogDelegate, BoomScrollLayerDelegate {
    SecretRewardsLayer() {
        m_mainLayer = nullptr;
        m_secondaryLayer = nullptr;
        m_chestCounter = nullptr;
        m_chestCounters = nullptr;
        m_backSprite = nullptr;
        m_unkSize4_2 = 0;
        m_secondaryScrollLayer = nullptr;
        m_scratchDialogIndex = 0;
        m_potborDialogIndex = 0;
        m_diamondDialogIndex = 0;
        m_mechanicDialogIndex = 0;
        m_inMainLayer = false;
        m_rewardType = GJRewardType::Unknown;
        m_lockedDialogIndex = 0;
    }
    ~SecretRewardsLayer() = win inline, m1 0x5525b0 {
        CC_SAFE_RELEASE(m_chestCounters);
    }

    static SecretRewardsLayer* create(bool fromShop) = win inline, m1 0x55280c {
        auto ret = new SecretRewardsLayer();
        if (ret->init(fromShop)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static cocos2d::CCScene* scene(bool fromShop) = win 0x3d21a0, m1 0x5527c0;

    virtual void onExit() = win 0x3d7aa0, m1 0x55b98c, imac 0x639e90;
    virtual void keyBackClicked() = win 0x3d7a90, m1 0x55b8c0, imac 0x639dc0;
    virtual void dialogClosed(DialogLayer* layer) = win 0x3d6570, imac 0x639bd0, m1 0x55b6b0;
    virtual void scrollLayerMoved(cocos2d::CCPoint position) = win 0x3d4a10, m1 0x55518c, imac 0x632490;

    void createSecondaryLayer(int chestType) = win 0x3d4f70, m1 0x1c3198;
    void fadeInMusic() = win inline, m1 0x55b814 {
        FMODAudioEngine::sharedEngine()->fadeMusic(1.f, 0, 1.f, .2f);
        this->runAction(cocos2d::CCSequence::create(
            cocos2d::CCDelayTime::create(3.2f),
            cocos2d::CCCallFunc::create(this, callfunc_selector(SecretRewardsLayer::fadeInOutMusic)),
            nullptr
        ));
    }
    void fadeInOutMusic() = win 0x3d76c0, m1 0x55b894;
    cocos2d::CCArray* generateChestItems(int chestType) = win 0x3d53c0, imac 0x633500;
    cocos2d::ccColor3B getPageColor(int page) = win inline, m1 0x555354, ios inline {
        if (page == 1) return cocos2d::ccc3(50, 50, 50);
        else if (page == 2) return cocos2d::ccc3(70, 0, 120);
        else return cocos2d::ccc3(70, 0, 75);
    }
    void goToPage(int page) = win inline, m1 0x26f3b4 {
        if (m_inMainLayer) m_mainScrollLayer->moveToPage(page);
        else m_secondaryScrollLayer->moveToPage(page);
    }
    bool init(bool fromShop) = win 0x3d2300;
    void moveToMainLayer(cocos2d::CCObject* sender) = win inline {
        if (m_inMainLayer) return;
        m_inMainLayer = true;
        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        m_mainLayer->runAction(cocos2d::CCEaseInOut::create(cocos2d::CCMoveTo::create(.4f, { 0.f, 0.f }), 2.f));
        if (m_secondaryLayer) {
            m_secondaryScrollLayer->setTouchEnabled(false);
            m_secondaryScrollLayer = nullptr;
            m_chestCounter = nullptr;
            m_secondaryLayer->runAction(cocos2d::CCSequence::create(
                cocos2d::CCEaseInOut::create(cocos2d::CCMoveTo::create(.4f, { 0.f, winSize.height + 50.f }), 2.f),
                cocos2d::CCCallFunc::create(m_secondaryLayer, callfunc_selector(cocos2d::CCNode::removeMeAndCleanup)),
                nullptr
            ));
            m_secondaryLayer = nullptr;
        }
        this->updateBackButton();
    }
    void moveToSecondaryLayer(int page) = win inline {
        if (!m_inMainLayer) return;
        m_inMainLayer = false;
        m_rewardType = (GJRewardType)page;
        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        m_mainScrollLayer->setTouchEnabled(false);
        m_mainLayer->runAction(cocos2d::CCEaseBounceOut::create(cocos2d::CCMoveTo::create(.5f, { 0.f, -winSize.height - 100.f })));
        this->createSecondaryLayer(page);
        m_secondaryLayer->setPosition({ 0.f, winSize.height });
        m_secondaryLayer->runAction(cocos2d::CCEaseBounceOut::create(cocos2d::CCMoveTo::create(.5f, { 0.f, 0.f })));
        this->updateBackButton();
    }
    void onBack(cocos2d::CCObject* sender) = win 0x3d78b0;
    void onChestType(cocos2d::CCObject* sender) = win 0x3d4ce0, imac 0x631bb0, m1 0x554820;
    void onGoldChest(cocos2d::CCObject* sender) = win 0x3d7020, m1 0x554b80;
    void onSelectItem(cocos2d::CCObject* sender) = win 0x3d5dd0, m1 0x51f580;
    void onShop(cocos2d::CCObject* sender) = win 0x3d6360, imac 0x632290;
    void onSpecialItem(cocos2d::CCObject* sender) = win 0x3d6760, imac 0x6326b0, m1 0x1408c0;
    void onSwitchPage(cocos2d::CCObject* sender) = win 0x3d4950, m1 0x5550ac;
    void showDialog01() = win 0x3d7ae0, imac 0x3f05d0, m1 0x557068;
    void showDialog03() = imac 0x6362f0, m1 0x558844;
    void showDialogDiamond() = m1 0x55ab4c;
    void showDialogMechanic() = win 0x3da6f0, imac 0x637890, m1 0x5599e0;
    void showLockedChest() = imac 0x632bc0, m1 0x555880;
    void showShop(int shop) = win inline, m1 0x55b640 {
        if (cocos2d::CCDirector::sharedDirector()->replaceScene(cocos2d::CCTransitionMoveInT::create(0.5f, GJShopLayer::scene((ShopType)shop)))) this->setKeypadEnabled(false);
    }
    void switchToOpenedState(CCMenuItemSpriteExtra* button) = win 0x3d6b80, imac 0x631bf0, m1 0x554874;
    void updateBackButton() = win 0x3d4e30, m1 0x555b30;
    void updateUnlockedGoldLabel() = win 0x3d7730, m1 0x554e8c;
    void updateUnlockedLabel() = win 0x3d6c60, m1 0x554954;

    cocos2d::CCLayer* m_mainLayer;
    cocos2d::CCLayer* m_secondaryLayer;
    cocos2d::CCLabelBMFont* m_chestLabel;
    cocos2d::CCLabelBMFont* m_chestCounter;
    cocos2d::CCSprite* m_goldPriceSprite;
    cocos2d::CCDictionary* m_chestCounters;
    cocos2d::CCLabelBMFont* m_keysLabel;
    cocos2d::CCLabelBMFont* m_goldKeysLabel;
    cocos2d::CCSprite* m_keySprite;
    cocos2d::CCSprite* m_goldKeySprite;
    void* m_unknown;
    CCMenuItemSpriteExtra* m_leftButton;
    CCMenuItemSpriteExtra* m_rightButton;
    cocos2d::CCSprite* m_backSprite;
    int m_unkSize4_1;
    int m_unkSize4_2;
    BoomScrollLayer* m_mainScrollLayer;
    BoomScrollLayer* m_secondaryScrollLayer;
    cocos2d::CCSprite* m_backgroundSprite;
    int m_scratchDialogIndex;
    int m_potborDialogIndex;
    int m_diamondDialogIndex;
    int m_mechanicDialogIndex;
    bool m_inMainLayer;
    GJRewardType m_rewardType;
    int m_lockedDialogIndex;
}

[[link(android)]]
class SelectArtDelegate {
    virtual void selectArtClosed(SelectArtLayer* layer) {}
}

[[link(android)]]
class SelectArtLayer : FLAlertLayer {
    // virtual ~SelectArtLayer();

    static SelectArtLayer* create(SelectArtType type, int index) = win 0x321f10, imac 0x26ed40, m1 0x211cb0;

    virtual void keyBackClicked() = win 0x322e40, imac 0x270180, m1 0x212e68;

    bool init(SelectArtType type, int index) = win 0x322020, imac 0x26f570;
    void onClose(cocos2d::CCObject* sender) = imac 0x270070, m1 0x212d60;
    void onSelectCustom(cocos2d::CCObject* sender) = win 0x322d30, imac 0x2700c0, m1 0x212dc0;
    void selectArt(cocos2d::CCObject* sender) = win 0x322c70, imac 0x26ffa0, m1 0x212c78;
    void updateSelectedCustom(int idx) = win inline, imac 0x26eeb0, m1 0x211ddc {
        if (m_lineSprites) {
            m_line = idx;
            this->onSelectCustom(nullptr);
        }
    }

    cocos2d::CCArray* m_artSprites;
    cocos2d::CCArray* m_lineSprites;
    int m_art;
    int m_line;
    SelectArtType m_type;
    SelectArtDelegate* m_delegate;
}

[[link(android)]]
class SelectEventLayer : SetupTriggerPopup {
    SelectEventLayer() {
        m_eventLinkPopup = nullptr;
        m_eventsChanged = false;
        m_unk3b4 = 0;
        m_toggleCount = 0;
        m_maxPage = 0;
    }
    ~SelectEventLayer() = win inline {
        CCNode::removeAllChildrenWithCleanup(true);
    }

    static SelectEventLayer* create(SetupEventLinkPopup* popup, gd::set<int>& eventIDs) = win inline {
        auto ret = new SelectEventLayer();
        if (ret->init(popup, eventIDs)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyBackClicked() = win 0x2f6c60, imac 0x57a050, m1 0x4c7240;
    virtual void onClose(cocos2d::CCObject* sender) = win 0x467330, m1 0x4c7188, imac 0x579f80;
    virtual void onCustomToggleTriggerValue(cocos2d::CCObject* sender) = win 0x4671e0, m1 0x4c6f54, imac 0x579d70;

    void addToggle(int id, gd::string info) = win 0x4673f0, m1 0x506f68;
    bool init(SetupEventLinkPopup* popup, gd::set<int>& eventIDs) = win 0x466370, imac 0x577d30, m1 0x4c54cc;
    cocos2d::CCPoint nextPosition() = win inline, m1 0x4c7264 {
        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        auto count = (m_toggleCount - 1) % 12;
        cocos2d::CCPoint pos = winSize * .5f + cocos2d::CCPoint { count < 6 ? -140.f : 40.f, 90.f };
        pos.y -= (count % 6) * 34;
        return pos;
    }
    void onInfo(cocos2d::CCObject* sender) = win 0x467830, imac 0x57a1b0, m1 0x4c7370;

    SetupEventLinkPopup* m_eventLinkPopup;
    bool m_eventsChanged;
    int m_unk3b4;
    int m_toggleCount;
    int m_maxPage;
    gd::map<int, gd::string> m_eventInfos;
    gd::set<int> m_eventIDs;
}

[[link(android)]]
class SelectFontLayer : FLAlertLayer {
    SelectFontLayer() {
        m_font = -1;
        m_editorLayer = nullptr;
        m_fontLabel = nullptr;
    }
    ~SelectFontLayer() = win inline, m1 0x239664 {
        CCNode::removeAllChildrenWithCleanup(true);
    }

    static SelectFontLayer* create(LevelEditorLayer* editorLayer) = win inline, m1 0x23987c {
        auto ret = new SelectFontLayer();
        if (ret->init(editorLayer)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyBackClicked() = win 0x846c0, m1 0x23a130, imac 0x29a290;

    bool init(LevelEditorLayer* layer) = win 0x28e370;
    void onChangeFont(cocos2d::CCObject* sender) = win 0x28eb90, imac 0x29a0d0, m1 0x239f9c;
    void onClose(cocos2d::CCObject* sender) = win 0x84690, imac 0x29a0a0, m1 0x239f60;
    void updateFontLabel() = win 0x28e990, imac 0x29a170, m1 0x23a030;

    int m_font;
    LevelEditorLayer* m_editorLayer;
    cocos2d::CCLabelBMFont* m_fontLabel;
}

[[link(android)]]
class SelectListIconDelegate {
    virtual void iconSelectClosed(SelectListIconLayer* layer) {}
}

[[link(android)]]
class SelectListIconLayer : FLAlertLayer {
    SelectListIconLayer() {
        m_difficulties = nullptr;
        m_currentDifficulty = 0;
        m_delegate = nullptr;
    }
    ~SelectListIconLayer() = win inline {
        CC_SAFE_RELEASE(m_difficulties);
    }

    static SelectListIconLayer* create(int difficulty) = win inline, imac 0x35ffb0 {
        auto ret = new SelectListIconLayer();
        if (ret->init(difficulty)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyBackClicked() = win 0x309850, imac 0x361540, m1 0x2ec6f0;

    bool init(int difficulty) = win 0x308f60;
    void onClose(cocos2d::CCObject* sender) = imac 0x3614f0, m1 0x2ec698;
    void onSelect(cocos2d::CCObject* sender) = win 0x309750, m1 0x2ec5a0;

    cocos2d::CCArray* m_difficulties;
    int m_currentDifficulty;
    SelectListIconDelegate* m_delegate;
}

[[link(android)]]
class SelectPremadeDelegate {
    virtual void selectPremadeClosed(SelectPremadeLayer* layer, int type) {}
}

[[link(android)]]
class SelectPremadeLayer : FLAlertLayer {
    // virtual ~SelectPremadeLayer();
    SelectPremadeLayer() {}

    static SelectPremadeLayer* create() = win inline, m1 0x2993a8 {
        auto ret = new SelectPremadeLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x406840, m1 0x299800, imac 0x309ae0;
    virtual void keyBackClicked() = win 0x846c0, imac 0x309fe0, m1 0x299d48;

    void onClose(cocos2d::CCObject* sender) = win 0x84690, imac 0x309fb0, m1 0x299d0c;
    void onSelectPremade(cocos2d::CCObject* sender) = win 0x406e50, imac 0x309f50, m1 0x299c9c;

    SelectPremadeDelegate* m_delegate;
}

[[link(android)]]
class SelectSettingDelegate {
    virtual void selectSettingClosed(SelectSettingLayer* layer) {}
}

[[link(android)]]
class SelectSettingLayer : FLAlertLayer {
    // virtual ~SelectSettingLayer();

    static SelectSettingLayer* create(SelectSettingType type, int value) = win 0x322e90, imac 0x26e560, m1 0x21157c;
    static gd::string frameForItem(SelectSettingType type, int index) = win 0x3236f0, m1 0x4573b0;
    static gd::string frameForValue(SelectSettingType type, int value) = win inline, m1 0x211310 {
        return frameForItem(type, valueToIdx(type, value));
    }
    static int idxToValue(SelectSettingType type, int idx) = win inline, m1 0x213a90, ios inline {
        if (type != SelectSettingType::StartingSpeed) return idx;

        switch (idx) {
            case 0: return 1;
            case 1: return 0;
            case 2: case 3: case 4: return idx;
            default: return 0;
        }
    }
    static int valueToIdx(SelectSettingType type, int value) = win inline, ios inline {
        if (type != SelectSettingType::StartingSpeed) return value;

        switch (value) {
            case 0: return 1;
            case 1: return 0;
            case 2: case 3: case 4: return value;
            default: return 1;
        }
    }

    virtual void keyBackClicked() = win 0x323c90, imac 0x270e80, m1 0x213abc;

    gd::string getSelectedFrame() = win inline, imac 0x26e840, m1 0x211830 {
        return frameForValue(m_type, m_settingID);
    }
    int getSelectedValue() = win inline, imac 0x26e810 {
        return idxToValue(m_type, m_settingID);
    }
    bool init(SelectSettingType type, int value) = win 0x322fa0;
    void onClose(cocos2d::CCObject* sender) = m1 0x213a30;
    void onSelect(cocos2d::CCObject* sender) = win 0x323b90, imac 0x270d50, m1 0x213958;

    cocos2d::CCArray* m_settingSprites;
    int m_settingID;
    SelectSettingType m_type;
    SelectSettingDelegate* m_delegate;
}

[[link(android)]]
class SelectSFXSortDelegate {
    virtual void sortSelectClosed(SelectSFXSortLayer* layer) {}
}

[[link(android)]]
class SelectSFXSortLayer : FLAlertLayer {
    // virtual ~SelectSFXSortLayer();
    SelectSFXSortLayer() {
        m_sortType = AudioSortType::NameAscending;
        m_delegate = nullptr;
    }

    static SelectSFXSortLayer* create(AudioSortType sortType) = win inline, imac 0x440270, m1 0x3b1a1c {
        auto ret = new SelectSFXSortLayer();
        if (ret->init(sortType)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyBackClicked() = win 0x846c0, m1 0x3b2874, imac 0x441150;

    bool init(AudioSortType sortType) = win 0x480cc0, imac 0x360f30;
    void onClose(cocos2d::CCObject* sender) = win 0x84690, imac 0x4410c0, m1 0x3b27cc;
    void onSelect(cocos2d::CCObject* sender) = win 0x481340, imac 0x4410f0, m1 0x3b2808;

    AudioSortType m_sortType;
    SelectSFXSortDelegate* m_delegate;
}

[[link(android)]]
class SequenceTriggerGameObject : ChanceTriggerGameObject {
    // virtual ~SequenceTriggerGameObject();
    SequenceTriggerGameObject() {
        m_sequenceMode = 0;
        m_minInt = 0.f;
        m_resetMode = 0;
        m_reset = 0.f;
        m_sequenceTotalCount = 0;
        m_uniqueRemap = false;
    }

    static SequenceTriggerGameObject* create() = win inline, imac 0x1c4080, m1 0x17bd08 {
        auto ret = new SequenceTriggerGameObject();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x4b44b0, m1 0x17bdfc, imac 0x1c4190;
    virtual void resetObject() = win 0x4b44d0, m1 0x17be4c, imac 0x1c41e0;
    virtual void triggerObject(GJBaseGameLayer* layer, int uniqueID, gd::vector<int> const* remapKeys) = win 0x4b4500, imac 0x1c43b0, m1 0x17c018;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4b4920, m1 0x17c4fc, imac 0x1c4910;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x4b4c50, m1 0x17c968, imac 0x1c4d90;

    void addCount(int index, int count) = win inline, imac 0x1c61b0, m1 0x17d910 {
        if (index < 0 || index >= m_chanceObjects.size()) return;
        auto& object = m_chanceObjects[index];
        object.m_chance = std::max(object.m_chance + count, 1);
        m_sequenceTotalCount = -1;
    }
    void addTarget(int groupID, int count) = win inline {
        count = std::max(count, 1);
        m_chanceObjects.emplace_back(groupID, count);
        m_sequenceTotalCount = -1;
    }
    void deleteTarget(int index) = win inline {
        if (index < 0 || index >= m_chanceObjects.size()) return;
        m_chanceObjects.erase(m_chanceObjects.begin() + index);
        m_sequenceTotalCount = -1;
    }
    bool reorderTarget(int index, bool left) = win inline {
        int size = m_chanceObjects.size();
        if (index >= size) return false;
        if (left) {
            if (index == 0) return false;
            std::swap(m_chanceObjects[index], m_chanceObjects[index - 1]);
            return true;
        }
        else {
            if (index == size - 1) return false;
            std::swap(m_chanceObjects[index], m_chanceObjects[index + 1]);
            return true;
        }
    }
    void updateSequenceTotalCount() = win inline, ios inline {
        auto total = 0;
        for (auto& obj : m_chanceObjects) {
            total += obj.m_chance;
            m_sequenceTotalCount = total;
        }
    }

    SequenceTriggerState m_sequenceState;
    // property 437
    float m_minInt;
    // property 436
    int m_sequenceMode;
    // property 439
    int m_resetMode;
    // property 438
    float m_reset;
    int m_sequenceTotalCount;
    // property 505
    bool m_uniqueRemap;
}

[[link(android)]]
class SetColorIDPopup : SetIDPopup, GJSpecialColorSelectDelegate {
    // virtual ~SetColorIDPopup();
    SetColorIDPopup() {}

    static SetColorIDPopup* create(int id) = win inline, imac 0x2ac860, m1 0x24af18 {
        auto ret = new SetColorIDPopup();
        if (ret->init(id)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void colorSelectClosed(GJSpecialColorSelect* select, int id) = win 0x29c1b0, imac 0x2acca0, m1 0x24b2fc;

    bool init(int id) = win 0x29bf60, imac 0x2ac9e0, m1 0x24b040;
    void onSelectSpecialColor(cocos2d::CCObject* sender) = imac 0x2acc50, m1 0x24b298;
}

[[link(android)]]
class SetFolderPopup : SetIDPopup, SetTextPopupDelegate {
    // virtual ~SetFolderPopup();

    static SetFolderPopup* create(int value, bool isCreated, gd::string title) = win 0x29c350, imac 0x2ad730, m1 0x24bb24;

    virtual void valueChanged() = win 0x29c710, m1 0x24c150, imac 0x2addb0;
    virtual void setTextPopupClosed(SetTextPopup* popup, gd::string text) = win 0x29ca50, imac 0x2ae270, m1 0x24c5bc;

    bool init(int value, bool isCreated, gd::string title) = win 0x29c490;
    void onSetFolderName(cocos2d::CCObject* sender) = win 0x29c850, imac 0x2adbc0, m1 0x24bf4c;

    bool m_isCreated;
    cocos2d::CCLabelBMFont* m_titleLabel;
}

[[link(android)]]
class SetGroupIDLayer : FLAlertLayer, TextInputDelegate, ConfigureValuePopupDelegate {
    SetGroupIDLayer() {
        m_targetObject = nullptr;
        m_targetObjects = nullptr;
        m_editorLayerInput = nullptr;
        m_editorLayer2Input = nullptr;
        m_zOrderInput = nullptr;
        m_groupIDInput = nullptr;
        m_orderInput = nullptr;
        m_channelInput = nullptr;
        m_showChannelOrder = false;
        m_channelValue = 0;
        m_channelUpdated = false;
        m_groupIDValue = 0;
        m_editorLayerValue = 0;
        m_editorLayer2Value = 0;
        m_zOrderValue = -1000;
        m_zLayerValue = ZLayer::Default;
        m_orderValue = 0;
        m_channelOrderEdited = false;
        m_editorLayerEdited = false;
        m_removeGroupsLock = false;
        m_addedGroup = false;
        m_reverseChanged = false;
        m_unk2ff = false;
        m_unk300 = false;
        m_nextFreeID = 0;
        m_parentGroups = nullptr;
    }
    ~SetGroupIDLayer() = win inline {
        CC_SAFE_RELEASE(m_targetObjects);
        CC_SAFE_RELEASE(m_zLayerButtons);
        CC_SAFE_RELEASE(m_groupIDObjects);
        CC_SAFE_RELEASE(m_parentGroups);
    }

    static SetGroupIDLayer* create(GameObject* object, cocos2d::CCArray* objects) = win inline, m1 0x2a1024 {
        auto ret = new SetGroupIDLayer();
        if (ret->init(object, objects)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyBackClicked() = win 0x3fdbb0, m1 0x2a62b4, imac 0x317820;
    virtual void textInputClosed(CCTextInputNode* node) = win 0x8b870, m1 0x2a61e4, imac 0x317720;
    virtual void textChanged(CCTextInputNode* node) = win 0x3fb840, m1 0x2a5b40, imac 0x316fb0;

    void addGroupID(int id) = win inline, imac 0x317630 {
        m_addedGroup = true;
        if (m_targetObject) {
            if (m_targetObject->addToGroup(id) == 1) {
                GameManager::sharedState()->m_levelEditorLayer->addToGroup(m_targetObject, id, false);
            }
        }
        else {
            for (int i = 0; i < m_targetObjects->count(); i++) {
                auto obj = static_cast<GameObject*>(m_targetObjects->objectAtIndex(i));
                if (obj->addToGroup(id) == 1) {
                    GameManager::sharedState()->m_levelEditorLayer->addToGroup(obj, id, false);
                }
            }
        }
    }
    void callRemoveFromGroup(float dt) = win 0x3fc470;
    CCTextInputNode* createTextInput(cocos2d::CCPoint position, int tag, int length, gd::string placeholder, float width, int arrow) = win 0x3fa8f0;
    void determineStartValues() = win 0x3faf90, imac 0x315000, m1 0x2a3ea8;
    bool init(GameObject* obj, cocos2d::CCArray* objs) = win 0x3f8270;
    void onAddGroup(cocos2d::CCObject* sender) = win 0x3fc720, m1 0x2a3d14;
    void onAddGroupParent(cocos2d::CCObject* sender) = win 0x3fc890, imac 0x314e50, m1 0x2a3d1c;
    void onAnim(cocos2d::CCObject* sender) = m1 0x29734;
    void onArrow(int tag, int increment) = win 0x3fae20, imac 0x316510;
    void onArrowLeft(cocos2d::CCObject* sender) = win 0x3fadc0, imac 0x3164b0, m1 0x2a51ec;
    void onArrowRight(cocos2d::CCObject* sender) = win 0x3fadf0, imac 0x3164e0, m1 0x2a5224;
    void onClose(cocos2d::CCObject* sender) = win 0x3fd7f0, m1 0x2a31d4;
    void onCopy(cocos2d::CCObject* sender) = m1 0x2a4fb4;
    void onExtra(cocos2d::CCObject* sender) = win 0x3fb510, m1 0x2a50bc;
    void onExtra2(cocos2d::CCObject* sender) = win 0x3fb690, imac 0x316390, m1 0x2a50e4;
    void onNextFreeEditorLayer1(cocos2d::CCObject* sender);
    void onNextFreeEditorLayer2(cocos2d::CCObject* sender);
    void onNextFreeOrderChannel(cocos2d::CCObject* sender);
    void onNextGroupID1(cocos2d::CCObject* sender);
    void onPaste(cocos2d::CCObject* sender) = win 0x3fb370, m1 0x2a4fdc;
    void onRemoveFromGroup(cocos2d::CCObject* sender);
    void onSmoothEase(cocos2d::CCObject* sender) = win inline, m1 0x2a629c, ios inline {
        if (auto teleportObject = static_cast<TeleportPortalObject*>(m_targetObject)) {
            teleportObject->m_teleportEase = !teleportObject->m_teleportEase;
        }
    }
    void onToggleGuide(cocos2d::CCObject* sender) = m1 0x2a513c;
    void onToggleSelectedOrder(cocos2d::CCObject* sender) = m1 0x2a51c0;
    void onZLayer(cocos2d::CCObject* sender) = win 0x3fc990, imac 0x314ee0, m1 0x2a3da0;
    void onZLayerShift(cocos2d::CCObject* sender) = win 0x3fca50, imac 0x3153a0, m1 0x2a4190;
    void removeGroupID(int id) = win inline, imac 0x317560 {
        m_addedGroup = true;
        if (m_targetObject) {
            m_targetObject->removeFromGroup(id);
            GameManager::sharedState()->m_levelEditorLayer->removeFromGroup(m_targetObject, id);
        }
        else {
            for (int i = 0; i < m_targetObjects->count(); i++) {
                auto obj = static_cast<GameObject*>(m_targetObjects->objectAtIndex(i));
                obj->removeFromGroup(id);
                GameManager::sharedState()->m_levelEditorLayer->removeFromGroup(obj, id);
            }
        }
        this->updateGroupIDButtons();
    }
    void updateEditorLabel();
    void updateEditorLabel2();
    void updateEditorLayerID() = m1 0x2a55bc;
    void updateEditorLayerID2() = m1 0x2a562c;
    void updateEditorOrder();
    void updateEditorOrderLabel();
    void updateGroupIDButtons() = win 0x3fbdb0, imac 0x316a0, m1 0x2a4b18;
    void updateGroupIDLabel();
    void updateOrderChannel();
    void updateOrderChannelLabel();
    void updateZLayerButtons() = win 0x3fd5c0, m1 0x2a4a88;
    void updateZOrder() = win 0x3fd0f0, imac 0x316b60, m1 0x2a57ec;
    void updateZOrderLabel() = win 0x3fd2a0, imac 0x315b70;

    GameObject* m_targetObject;
    cocos2d::CCArray* m_targetObjects;
    cocos2d::CCArray* m_zLayerButtons;
    cocos2d::CCArray* m_groupIDObjects;
    CCTextInputNode* m_editorLayerInput;
    CCTextInputNode* m_editorLayer2Input;
    CCTextInputNode* m_zOrderInput;
    CCTextInputNode* m_groupIDInput;
    CCTextInputNode* m_orderInput;
    CCTextInputNode* m_channelInput;
    bool m_showChannelOrder;
    int m_channelValue;
    bool m_channelUpdated;
    int m_groupIDValue;
    int m_editorLayerValue;
    int m_editorLayer2Value;
    int m_zOrderValue;
    ZLayer m_zLayerValue;
    int m_orderValue;
    bool m_channelOrderEdited;
    bool m_editorLayerEdited;
    bool m_removeGroupsLock;
    int m_groupToRemove;
    bool m_addedGroup;
    bool m_reverseChanged;
    bool m_hasTargetObjects;
    bool m_unk2ff;
    bool m_unk300;
    int m_nextFreeID;
    cocos2d::CCDictionary* m_parentGroups;
}

[[link(android)]]
class SetIDPopup : FLAlertLayer, TextInputDelegate {
    SetIDPopup() {
        m_inputNode = nullptr;
        m_value = 0;
        m_disableDelegate = false;
        m_cancelled = false;
        m_minimum = 0;
        m_maximum = 1000;
        m_default = 0;
        m_delegate = nullptr;
    }
    ~SetIDPopup() = win 0x29afd0;

    static SetIDPopup* create(int current, int begin, int end, gd::string title, gd::string button, bool resetButton, int defaultValue, float offset, bool numberInput, bool arrows) = win 0x29b070, imac 0x2ab400, m1 0x249c28;

    virtual void keyBackClicked() = win 0x29bf50, imac 0x2ac3e0, m1 0x24aba4;
    virtual void show() = win 0x29bd80, m1 0x24ab20, imac 0x2ac360;
    virtual void textInputClosed(CCTextInputNode* node) = win 0x8b870, m1 0x24a9d0, imac 0x2ac200;
    virtual void textChanged(CCTextInputNode* node) = win 0x29bbd0, m1 0x24a9ec, imac 0x2ac240;
    virtual void valueChanged() = win inline, m1 0x24ab1c, imac 0x2ac350 {}

    bool init(int current, int begin, int end, gd::string title, gd::string button, bool resetButton, int defaultValue, float offset, bool numberInput, bool arrows) = win 0x29b1a0;
    void onCancel(cocos2d::CCObject* sender) = win 0x29be10, imac 0x2ac020, m1 0x24a800;
    void onClose(cocos2d::CCObject* sender) = win 0x29beb0, imac 0x2abf20;
    void onItemIDArrow(cocos2d::CCObject* sender) = win 0x29bb60, imac 0x2abfd0, m1 0x24a7a4;
    void onResetValue(cocos2d::CCObject* sender) = win 0x29bbb0, imac 0x2abfb0, m1 0x24a798;
    void updateTextInputLabel() = win 0x29bcd0, imac 0x2ac0c0, m1 0x24a8a0;

    CCTextInputNode* m_inputNode;
    int m_value;
    bool m_disableDelegate;
    bool m_cancelled;
    int m_minimum;
    int m_maximum;
    int m_default;
    SetIDPopupDelegate* m_delegate;
}

[[link(android)]]
class SetIDPopupDelegate {
    virtual void setIDPopupClosed(SetIDPopup* popup, int value) {}
}

[[link(android)]]
class SetItemIDLayer : SetupTriggerPopup {
    // virtual ~SetItemIDLayer();
    SetItemIDLayer() {}

    static SetItemIDLayer* create(EffectGameObject* object, cocos2d::CCArray* objects) = win inline {
        auto ret = new SetItemIDLayer();
        if (ret->init(object, objects)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void onClose(cocos2d::CCObject* sender) = win 0x4017e0, m1 0x8d684, imac 0x9cbb0;
    virtual void valueDidChange(int tag, float value) = win 0x4016f0, m1 0x8d5a0, imac 0x9cac0;
    virtual void onCustomToggleTriggerValue(cocos2d::CCObject* sender) = win 0x401550, imac 0x9c9a0, m1 0x8d498;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x400df0, imac 0x797450, m1 0x3206e4;
    void updateEditorLabel() = win inline, m1 0x8d634 {
        auto objects = this->getObjects();
        for (int i = 0; i < objects->count(); i++) {
            static_cast<LabelGameObject*>(objects->objectAtIndex(i))->updatePreviewLabel();
        }
    }
}

[[link(android)]]
class SetLevelOrderPopup : SetIDPopup {
    // virtual ~SetLevelOrderPopup();
    SetLevelOrderPopup() {
        m_levelID = 0;
    }

    static SetLevelOrderPopup* create(int levelID, int order, int amount) = win inline, imac 0x35f350, m1 0x2ea678 {
        auto ret = new SetLevelOrderPopup();
        if (ret->init(levelID, order, amount)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init(int levelID, int order, int amount) = win 0x308c50, imac 0x3608d0, m1 0xd92f8;
    void onOrderButton(cocos2d::CCObject* sender) = win 0x308f20, imac 0x360bc0, m1 0x2ebddc;

    int m_levelID;
}

[[link(android)]]
class SetTargetIDLayer : SetupTriggerPopup {
    // virtual ~SetTargetIDLayer();

    static SetTargetIDLayer* create(EffectGameObject* object, cocos2d::CCArray* objects, gd::string title, gd::string label, int minimum, int maximum, int objectID) = imac 0x2b9730, m1 0x256b70;

    virtual void determineStartValues() = win 0x28f0a0, m1 0x257188, imac 0x2b9e60;
    virtual void valueDidChange(int tag, float value) = win 0x401f90, imac 0x2b9e70, m1 0x25718c;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects, gd::string title, gd::string label, int minimum, int maximum, int objectID) = win 0x401af0, imac 0x2b9a60, m1 0x256dfc;

    int m_objectID;
    int m_minimumID;
    int m_maximumID;
}

[[link(android)]]
class SetTextPopup : FLAlertLayer, TextInputDelegate {
    SetTextPopup() {
        m_input = nullptr;
        m_disableDelegate = false;
        m_cancelled = false;
        m_delegate = nullptr;
    }
    ~SetTextPopup() = win 0x29cbe0, m1 0x24c678;

    static SetTextPopup* create(gd::string value, gd::string placeholder, int maxLength, gd::string title, gd::string okBtnText, bool showResetBtn, float offset) = win 0x29cc90, imac 0x2adf00, m1 0x24c2c0;

    virtual void keyBackClicked() = win 0x29d950, m1 0x24d48c, imac 0x2af270;
    virtual void show() = win 0x8bb10, m1 0x24d440, imac 0x2af210;
    virtual void textInputClosed(CCTextInputNode* node) = win 0x8b870, imac 0x2af0f0, m1 0x24d304;
    virtual void textChanged(CCTextInputNode* node) = win 0x29d740, m1 0x24d320, imac 0x2af130;

    bool init(gd::string value, gd::string placeholder, int maxLength, gd::string title, gd::string okBtnText, bool showResetBtn, float offset) = win 0x29ce00;
    void onCancel(cocos2d::CCObject* sender) = win 0x29d830, imac 0x2af030, m1 0x24d248;
    void onClose(cocos2d::CCObject* sender) = win 0x29d8c0, imac 0x2aeea0, m1 0x24d094;
    void onResetValue(cocos2d::CCObject* sender) = win 0x29d6e0, imac 0x2aef80, m1 0x24d17c;
    void updateTextInputLabel() = win inline, imac 0x2af050, m1 0x24d254 {
        m_disableDelegate = true;
        m_input->setString(m_value);
        m_disableDelegate = false;
    }

    CCTextInputNode* m_input;
    bool m_disableDelegate;
    bool m_cancelled;
    gd::string m_value;
    SetTextPopupDelegate* m_delegate;
}

[[link(android)]]
class SetTextPopupDelegate {
    virtual void setTextPopupClosed(SetTextPopup* popup, gd::string text) {}
}

[[link(android)]]
class SetupAdvFollowEditPhysicsPopup : SetupTriggerPopup {
    // virtual ~SetupAdvFollowEditPhysicsPopup();

    static SetupAdvFollowEditPhysicsPopup* create(AdvancedFollowEditObject* object, cocos2d::CCArray* objects);

    virtual void valueDidChange(int tag, float value) = win 0x407d50, imac 0x30b0f0, m1 0x29ab5c;

    bool init(AdvancedFollowEditObject* object, cocos2d::CCArray* objects) = win 0x406fc0, imac 0x580550;
}

[[link(android)]]
class SetupAdvFollowPopup : SetupTriggerPopup, SelectPremadeDelegate {
    // virtual ~SetupAdvFollowPopup();

    static SetupAdvFollowPopup* create(AdvancedFollowTriggerObject* object, cocos2d::CCArray* objects) = m1 0x2956d0;

    virtual void onClose(cocos2d::CCObject* sender) = win 0x28f0b0, m1 0x2997c0, imac 0x309a40;
    virtual void updateDefaultTriggerValues() = win 0x405260, m1 0x298e6c, imac 0x309110;
    virtual void valueDidChange(int tag, float value) = win 0x405350, imac 0x309250, m1 0x29900c;
    virtual void onCustomToggleTriggerValue(cocos2d::CCObject* sender) = win 0x405690, imac 0x3094c0, m1 0x299290;
    virtual void selectPremadeClosed(SelectPremadeLayer* layer, int type) = win 0x405940, m1 0x299498, imac 0x3096f0;

    bool init(AdvancedFollowTriggerObject* object, cocos2d::CCArray* objects) = win 0x4021a0;
    void onMode(cocos2d::CCObject* sender) = imac 0x309040, m1 0x298d88;
    void onPremade(cocos2d::CCObject* sender) = win 0x405810, m1 0x298e3c;
    void updateMode(int mode) = win 0x405770, imac 0x309530, m1 0x299308;
}

[[link(android)]]
class SetupAdvFollowRetargetPopup : SetupTriggerPopup {
    // virtual ~SetupAdvFollowRetargetPopup();

    static SetupAdvFollowRetargetPopup* create(AdvancedFollowEditObject* object, cocos2d::CCArray* objects);

    virtual void updateDefaultTriggerValues() = win 0x405260, m1 0x29b2a4, imac 0x30b990;
    virtual void valueDidChange(int tag, float value) = win 0x408570, imac 0x30bad0, m1 0x29b444;

    bool init(AdvancedFollowEditObject* object, cocos2d::CCArray* objects) = win 0x407f30;
}

[[link(android)]]
class SetupAnimationPopup : SetupTriggerPopup {
    // virtual ~SetupAnimationPopup();

    static SetupAnimationPopup* create(EffectGameObject* object, cocos2d::CCArray* objects);

    virtual void determineStartValues() = win 0x4097e0, m1 0x35492c, imac 0x3d5210;
    virtual void onClose(cocos2d::CCObject* sender) = win 0x409d90, m1 0x354c98, imac 0x3d5630;
    virtual void textChanged(CCTextInputNode* node) = win 0x409970, m1 0x354b0c, imac 0x3d5440;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x4089f0, imac 0x3d42e0, m1 0x353af8;
    void onAnimationIDArrow(cocos2d::CCObject* sender) = win 0x4098e0, imac 0x3d4f30, m1 0x354684;
    void onTargetIDArrow(cocos2d::CCObject* sender) = win 0x409920, imac 0x3d4e70, m1 0x3545dc;
    void updateAnimationID() = win 0x409cf0, m1 0x354a08;
    void updateAnimationTextInputLabel();
    void updateTargetID();
    void updateTextInputLabel();

    CCTextInputNode* m_targetIDInput;
    CCTextInputNode* m_animationIDInput;
    int m_targetID;
    int m_animationID;
}

[[link(android)]]
class SetupAnimSettingsPopup : SetupTriggerPopup {
    // virtual ~SetupAnimSettingsPopup();

    static SetupAnimSettingsPopup* create(EffectGameObject* object, cocos2d::CCArray* objects);

    virtual void onClose(cocos2d::CCObject* sender) = win 0x40a7a0, imac 0x9b500, m1 0x8c2b0;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x409f20;
    void updateAnimSettings() = win inline, m1 0x8c24c {
        if (m_gameObject) m_gameObject->setupAnimationVariables();
        else {
            for (int i = 0; i < m_gameObjects->count(); i++) {
                static_cast<EnhancedGameObject*>(m_gameObjects->objectAtIndex(i))->setupAnimationVariables();
            }
        }
    }
}

[[link(android)]]
class SetupAreaAnimTriggerPopup : SetupAreaTintTriggerPopup {
    // virtual ~SetupAreaAnimTriggerPopup();
    SetupAreaAnimTriggerPopup() {}

    static SetupAreaAnimTriggerPopup* create(EnterEffectObject* object, cocos2d::CCArray* objects, int id) = win inline, imac 0x4d9cc0, m1 0x436850 {
        auto ret = new SetupAreaAnimTriggerPopup();
        if (ret->init(object, objects, id)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void updateDefaultTriggerValues() = win 0x412450, m1 0x438468, imac 0x4dbc90;
    virtual void valueDidChange(int tag, float value) = win 0x412620, m1 0x438624, imac 0x4dbe30;

    void createValueControlAdvancedAnim(int property, gd::string label, cocos2d::CCPoint position, float scale, bool noSlider, InputValueType valueType, int length, bool arrows, float min, float max, int page, int group, GJInputStyle inputStyle) = win 0x412260, imac 0x4dba30;
    bool init(EnterEffectObject* object, cocos2d::CCArray* objects, int id) = win 0x410af0;
    void onDeactivateAnimValue(cocos2d::CCObject* sender) = win 0x4125b0, imac 0x4dbc10, m1 0x4383bc;
    void updateTargetIDLabel() = win 0x412530, imac 0x4dbdc0, m1 0x4385b0;
}

[[link(android)]]
class SetupAreaFadeTriggerPopup : SetupAreaMoveTriggerPopup {
    // virtual ~SetupAreaFadeTriggerPopup();
    SetupAreaFadeTriggerPopup() {}

    static SetupAreaFadeTriggerPopup* create(EnterEffectObject* object, cocos2d::CCArray* objects) = win inline {
        auto ret = new SetupAreaFadeTriggerPopup();
        if (ret->init(object, objects)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init(EnterEffectObject* object, cocos2d::CCArray* objects) = win 0x40ed80;
}

[[link(android)]]
class SetupAreaMoveTriggerPopup : SetupTriggerPopup {
    SetupAreaMoveTriggerPopup() {
        m_modeButtons = nullptr;
        m_targetButtons = nullptr;
    }
    ~SetupAreaMoveTriggerPopup() = win 0x40b090, imac 0x4d1500, m1 0x42f978;

    static SetupAreaMoveTriggerPopup* create(EnterEffectObject* object, cocos2d::CCArray* objects) = win inline {
        auto ret = new SetupAreaMoveTriggerPopup();
        if (ret->init(object, objects)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void updateInputValue(int tag, float& value) = win 0x40dd40, imac 0x4d4890, m1 0x4325f0;
    virtual void updateDefaultTriggerValues() = win 0x40d630, m1 0x432184, imac 0x4d4420;
    virtual void updateInputNode(int tag, float value) = win 0x40dd10, m1 0x4325bc, imac 0x4d4860;
    virtual void valueDidChange(int tag, float value) = win 0x40db90, m1 0x432498, imac 0x4d4730;
    virtual float triggerValueFromSliderValue(int tag, float value) = win 0x40dcb0, m1 0x432534, imac 0x4d47f0;
    virtual float triggerSliderValueFromValue(int tag, float value) = win 0x40dce0, m1 0x432588, imac 0x4d4830;

    void addAreaDefaultControls(int objectID) = win 0x40c000, imac 0x358890;
    void getModeValues(int mode, int& direction, bool& inbound, bool& twoDirections) = win inline, imac 0x4d4230, m1 0x431f74, ios inline {
        if (mode > 1 && mode < 6) direction = 1;
        else if (mode < 2) direction = 0;
        else direction = 2;
        inbound = (mode == 1 || mode == 3 || mode == 5 || mode == 7 || mode == 8);
        twoDirections = (mode == 2 || mode == 3 || mode == 6 || mode == 7);
    }
    bool init(EnterEffectObject* object, cocos2d::CCArray* objects) = win 0x40b160;
    void onMode(cocos2d::CCObject* sender) = win 0x40da30, imac 0x4d4290, m1 0x431fc8;
    void onNextFreeEffectID(cocos2d::CCObject* sender);
    void onSpecialTarget(cocos2d::CCObject* sender) = win 0x40d730, imac 0x4d4160, m1 0x431ea4;
    void updateEnterTargetIDState() = win 0x40d7d0, imac 0x4d4470, m1 0x4321d8;

    cocos2d::CCArray* m_modeButtons;
    cocos2d::CCArray* m_targetButtons;
}

[[link(android)]]
class SetupAreaRotateTriggerPopup : SetupAreaMoveTriggerPopup {
    // virtual ~SetupAreaRotateTriggerPopup();
    SetupAreaRotateTriggerPopup() {}

    static SetupAreaRotateTriggerPopup* create(EnterEffectObject* object, cocos2d::CCArray* objects) = win inline {
        auto ret = new SetupAreaRotateTriggerPopup();
        if (ret->init(object, objects)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init(EnterEffectObject* object, cocos2d::CCArray* objects) = win 0x40e630, m1 0x432a90;
}

[[link(android)]]
class SetupAreaTintTriggerPopup : SetupAreaMoveTriggerPopup, HSVWidgetDelegate {
    // virtual ~SetupAreaTintTriggerPopup();
    SetupAreaTintTriggerPopup() = win 0x40aba0 {
        m_hsvButton = nullptr;
        m_hsvChanged = false;
    }

    static SetupAreaTintTriggerPopup* create(EnterEffectObject* object, cocos2d::CCArray* objects) = win inline, m1 0x434adc {
        auto ret = new SetupAreaTintTriggerPopup();
        if (ret->init(object, objects)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void determineStartValues() = win 0x410190, m1 0x43588c, imac 0x4d8840;
    virtual void onClose(cocos2d::CCObject* sender) = win 0x4104a0, m1 0x435b7c, imac 0x4d8b70;
    virtual void valueDidChange(int tag, float value) = win 0x40ffd0, m1 0x4357ac, imac 0x4d8760;
    virtual void hsvPopupClosed(HSVWidgetPopup* popup, cocos2d::ccHSVValue value) = win 0x4103b0, m1 0x4359d0, imac 0x4d89f0;

    bool init(EnterEffectObject* object, cocos2d::CCArray* objects) = win 0x40f590;
    void onHSV(cocos2d::CCObject* sender);
    void updateHSVButton();

    CCMenuItemSpriteExtra* m_hsvButton;
    cocos2d::ccHSVValue m_hsvValue;
    bool m_hsvChanged;
}

[[link(android)]]
class SetupAreaTransformTriggerPopup : SetupAreaMoveTriggerPopup {
    // virtual ~SetupAreaTransformTriggerPopup();
    SetupAreaTransformTriggerPopup() {}

    static SetupAreaTransformTriggerPopup* create(EnterEffectObject* object, cocos2d::CCArray* objects) = win inline {
        auto ret = new SetupAreaTransformTriggerPopup();
        if (ret->init(object, objects)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init(EnterEffectObject* object, cocos2d::CCArray* objects) = win 0x40dd70, m1 0x4c7dec;
}

[[link(android)]]
class SetupAreaTriggerPopup : SetupAreaMoveTriggerPopup {
    // virtual ~SetupAreaTriggerPopup();
    SetupAreaTriggerPopup() {}

    static SetupAreaTriggerPopup* create(EnterEffectObject* object, cocos2d::CCArray* objects) = win inline {
        auto ret = new SetupAreaTriggerPopup();
        if (ret->init(object, objects)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init(EnterEffectObject* object, cocos2d::CCArray* objects) = win 0x410550;
}

[[link(android)]]
class SetupArtSwitchPopup : SetupTriggerPopup, SelectArtDelegate {
    // virtual ~SetupArtSwitchPopup();

    static SetupArtSwitchPopup* create(ArtTriggerGameObject* object, cocos2d::CCArray* objects, int id) = win 0x471410, m1 0x4d0d90;

    virtual void selectArtClosed(SelectArtLayer* layer) = win 0x4720d0, imac 0x585980, m1 0x4d1558;

    bool init(ArtTriggerGameObject* object, cocos2d::CCArray* objects, int id) = win 0x4716d0, imac 0x585340, m1 0x1a6d4c;
    void onArt(cocos2d::CCObject* sender) = win 0x472080, imac 0x585930, m1 0x4d1510;

    SelectArtType m_artType;
    cocos2d::CCSprite* m_artSprite;
}

[[link(android)]]
class SetupAudioLineGuidePopup : SetupTriggerPopup, SelectSettingDelegate {
    // virtual ~SetupAudioLineGuidePopup();
    SetupAudioLineGuidePopup() {
        m_speedSprite = nullptr;
    }

    static SetupAudioLineGuidePopup* create(AudioLineGuideGameObject* object, cocos2d::CCArray* objects) = win inline, m1 0x4cf600 {
        auto ret = new SetupAudioLineGuidePopup();
        if (ret->init(object, objects)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void selectSettingClosed(SelectSettingLayer* layer) = win 0x4703a0, imac 0x583eb0, m1 0x4cfe38;

    bool init(AudioLineGuideGameObject* object, cocos2d::CCArray* objects) = win 0x46fc40;
    void onSpeed(cocos2d::CCObject* sender) = win 0x470350, imac 0x583e60, m1 0x4cfdf0;

    cocos2d::CCSprite* m_speedSprite;
}

[[link(android)]]
class SetupAudioTriggerPopup : SetupTriggerPopup {
    // virtual ~SetupAudioTriggerPopup();

    virtual void valueDidChange(int tag, float value) = win 0x446330, m1 0x4182dc, imac 0x4b7500;

    void addProxVolControls(int page) = win 0x445350;
    void addTimeControls(int page, float yOffset) = win 0x444f90, m1 0x3e8620;
    void onProxMode(cocos2d::CCObject* sender) = win 0x4461e0, imac 0x4b73c0, m1 0x41818c;
    void updateSpecialGroup() = win 0x4462b0, imac 0x4b7480, m1 0x418258;

    cocos2d::CCArray* m_proximityButtons;
}

[[link(android)]]
class SetupBGSpeedTrigger : SetupTriggerPopup {
    // virtual ~SetupBGSpeedTrigger();

    static SetupBGSpeedTrigger* create(EffectGameObject* object, cocos2d::CCArray* objects, int id) = win 0x428640, imac 0x50a1d0;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects, int id) = win 0x428760, imac 0x50a400;
}

[[link(android)]]
class SetupCameraEdgePopup : SetupTriggerPopup {
    // virtual ~SetupCameraEdgePopup();

    static SetupCameraEdgePopup* create(CameraTriggerGameObject* object, cocos2d::CCArray* objects);

    virtual void determineStartValues() = win 0x413660, m1 0x4d4014, imac 0x588b80;
    virtual void onClose(cocos2d::CCObject* sender) = win 0x413b50, m1 0x4d424c, imac 0x588e20;
    virtual void textChanged(CCTextInputNode* node) = win 0x413910, m1 0x4d4174, imac 0x588d10;

    bool init(CameraTriggerGameObject* object, cocos2d::CCArray* objects) = win 0x412920, imac 0x587b20, m1 0x4d3128;
    void onCameraEdge(cocos2d::CCObject* sender) = win 0x413760, m1 0x4d3ea8;
    void onTargetIDArrow(cocos2d::CCObject* sender) = win 0x4138c0, imac 0x5887e0, m1 0x4d3cfc;
    void onUnlockEdge(cocos2d::CCObject* sender) = win 0x413890, imac 0x588ae0, m1 0x4d3f98;
    void updateTargetID();
    void updateTextInputLabel();

    CCTextInputNode* m_targetIDInput;
    int m_targetID;
    int m_edgeDirection;
    cocos2d::CCArray* m_directionToggles;
}

[[link(android)]]
class SetupCameraGuidePopup : SetupTriggerPopup {
    // virtual ~SetupCameraGuidePopup();

    static SetupCameraGuidePopup* create(CameraTriggerGameObject* object, cocos2d::CCArray* objects);

    bool init(CameraTriggerGameObject* object, cocos2d::CCArray* objects);
}

[[link(android)]]
class SetupCameraModePopup : SetupTriggerPopup {
    // virtual ~SetupCameraModePopup();

    static SetupCameraModePopup* create(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x413cb0;

    virtual void determineStartValues() = win 0x414880, m1 0x40ca58, imac 0x4a96a0;
    virtual void onClose(cocos2d::CCObject* sender) = win 0x28f0b0, m1 0x40cd04, imac 0x4a99e0;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x413dd0, imac 0x1633d0;
    void onEditCameraSettings(cocos2d::CCObject* sender) = win 0x414af0;
    void onUnboundMode(cocos2d::CCObject* sender) = win 0x414a40, m1 0x4c1288;
    void sliderChanged(cocos2d::CCObject* sender);
    void updateCameraEasing() = win 0x414d80, m1 0x40cc1c;
    void updateCameraEasingLabel() = win 0x414d20;
    void updateCameraPadding() = m1 0x40cc94;
    void updateCameraPaddingLabel();
    void updateItemVisibility() = win 0x414ba0;

    cocos2d::CCArray* m_freeModeObjects;
    cocos2d::CCArray* m_cameraSettingsObjects;
    Slider* m_cameraEasingSlider;
    cocos2d::CCLabelBMFont* m_cameraEasingLabel;
    int m_cameraEasing;
    Slider* m_cameraPaddingSlider;
    cocos2d::CCLabelBMFont* m_cameraPaddingLabel;
    float m_cameraPadding;
    bool m_freeMode;
    bool m_cameraSettingsEnabled;
    bool m_cameraModeObjects;
}

[[link(android)]]
class SetupCameraOffsetTrigger : SetupTriggerPopup {
    // virtual ~SetupCameraOffsetTrigger();

    static SetupCameraOffsetTrigger* create(CameraTriggerGameObject* object, cocos2d::CCArray* objects) = win 0x414fe0, imac 0x660da0, m1 0x580914;

    virtual void determineStartValues() = win 0x416340, m1 0x58268c, imac 0x662d20;
    virtual void onClose(cocos2d::CCObject* sender) = win 0x4175e0, m1 0x5830c4, imac 0x6638e0;
    virtual void textChanged(CCTextInputNode* node) = win 0x417050, m1 0x582e5c, imac 0x6635b0;
    virtual void valuePopupClosed(ConfigureValuePopup* popup, float value) = win 0x416750, m1 0x582aa0, imac 0x663180;

    bool init(CameraTriggerGameObject* object, cocos2d::CCArray* objects) = win 0x415100;
    void onEasing(cocos2d::CCObject* sender) = win 0x416b10;
    void onEasingRate(cocos2d::CCObject* sender);
    void onTargetMode(cocos2d::CCObject* sender) = win 0x416f70, imac 0x662900, m1 0x582264;
    int posFromSliderValue(float value) = win inline, ios inline {
        return (int)((value - .5f) * 200.f) * 3.f;
    }
    void sliderChanged(cocos2d::CCObject* sender) = win 0x271b30;
    float sliderValueFromPos(int pos) = win inline, imac 0x662890, m1 0x582210, ios inline {
        return std::clamp((int)((float)pos / 3.f) / 200.f + .5f, 0.f, 1.f);
    }
    void sliderXChanged(cocos2d::CCObject* sender) = m1 0x582160;
    void sliderYChanged(cocos2d::CCObject* sender) = m1 0x5821b8;
    void toggleEasingRateVisibility();
    void updateDuration();
    void updateDurLabel(bool decimals) = win inline {
        m_disableTextDelegate = true;
        auto moveTime = m_moveTime;
        if (moveTime == -99999.f) {
            m_moveTimeInput->setString("Mixed");
        }
        else if (decimals || moveTime - (int)moveTime != 0.f) {
            m_moveTimeInput->setString(cocos2d::CCString::createWithFormat("%.02f", moveTime)->getCString());
        }
        else {
            m_moveTimeInput->setString(cocos2d::CCString::createWithFormat("%i", (int)moveTime)->getCString());
        }
        m_disableTextDelegate = false;
    }
    void updateEasingLabel();
    void updateEasingRateLabel();
    void updateMoveCommandEasing() = win inline {
        if (m_gameObject) m_gameObject->m_easingType = m_cameraEasingType;
        else {
            for (int i = 0; i < m_gameObjects->count(); i++) {
                static_cast<EffectGameObject*>(m_gameObjects->objectAtIndex(i))->m_easingType = m_cameraEasingType;
            }
        }
    }
    void updateMoveCommandEasingRate() = win inline {
        if (m_gameObject) m_gameObject->m_easingRate = m_cameraEasingRate;
        else {
            for (int i = 0; i < m_gameObjects->count(); i++) {
                static_cast<EffectGameObject*>(m_gameObjects->objectAtIndex(i))->m_easingRate = m_cameraEasingRate;
            }
        }
    }
    void updateMoveCommandPosX() = win 0x417400;
    void updateMoveCommandPosY();
    void updateValueXLabel();
    void updateValueYLabel();

    CCTextInputNode* m_moveTimeInput;
    Slider* m_moveTimeSlider;
    float m_moveTime;
    cocos2d::CCLabelBMFont* m_cameraEasingLabel;
    EasingType m_cameraEasingType;
    float m_cameraEasingRate;
    CCMenuItemSpriteExtra* m_cameraEasingRateButton;
    cocos2d::CCLabelBMFont* m_cameraEasingRateLabel;
    CCTextInputNode* m_offsetXInput;
    CCTextInputNode* m_offsetYInput;
    Slider* m_offsetXSlider;
    Slider* m_offsetYSlider;
    int m_offsetX;
    int m_offsetY;
    int m_targetMode;
    CCMenuItemToggler* m_xOnlyToggler;
    CCMenuItemToggler* m_yOnlyToggler;
}

[[link(android)]]
class SetupCameraRotatePopup : SetupTriggerPopup {
    // virtual ~SetupCameraRotatePopup();

    static SetupCameraRotatePopup* create(EffectGameObject* object, cocos2d::CCArray* objects);

    virtual void determineStartValues() = m1 0x41dd94, imac 0x4bdb50;
    virtual void onClose(cocos2d::CCObject* sender) = m1 0x41e47c, imac 0x4be380;
    virtual void textChanged(CCTextInputNode* node) = m1 0x41e274, imac 0x4be110;
    virtual void valuePopupClosed(ConfigureValuePopup* popup, float value) = m1 0x41dff8, imac 0x4bde40;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects);
    void onEasing(cocos2d::CCObject* sender);
    void onEasingRate(cocos2d::CCObject* sender);
    void sliderChanged(cocos2d::CCObject* sender);
    void sliderDegreesChanged(cocos2d::CCObject* sender) = m1 0x41dac8;
    void toggleEasingRateVisibility();
    void updateCommandDegrees();
    void updateDegreesLabel();
    void updateDuration();
    void updateDurLabel(bool decimals);
    void updateEasingLabel() = m1 0x41dca4;
    void updateEasingRateLabel();
    void updateMoveCommandEasing();
    void updateMoveCommandEasingRate();

    CCTextInputNode* m_moveTimeInput;
    Slider* m_moveTimeSlider;
    float m_moveTime;
    cocos2d::CCLabelBMFont* m_cameraEasingLabel;
    EasingType m_cameraEasingType;
    float m_cameraEasingRate;
    CCMenuItemSpriteExtra* m_cameraEasingRateButton;
    cocos2d::CCLabelBMFont* m_cameraEasingRateLabel;
    CCTextInputNode* m_degreesInput;
    Slider* m_degreesSlider;
    float m_degrees;
}

[[link(android)]]
class SetupCameraRotatePopup2 : SetupTriggerPopup {
    // virtual ~SetupCameraRotatePopup2();

    static SetupCameraRotatePopup2* create(EffectGameObject* object, cocos2d::CCArray* objects);

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x417790;
}

[[link(android)]]
class SetupCheckpointPopup : SetupTriggerPopup {
    // virtual ~SetupCheckpointPopup();
    SetupCheckpointPopup() {}

    static SetupCheckpointPopup* create(CheckpointGameObject* object, cocos2d::CCArray* objects) = win inline {
        auto ret = new SetupCheckpointPopup();
        if (ret->init(object, objects)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init(CheckpointGameObject* object, cocos2d::CCArray* objects) = win 0x468c20, m1 0x4c76fc;
}

[[link(android)]]
class SetupCoinLayer : SetupTriggerPopup {
    // virtual ~SetupCoinLayer();
    SetupCoinLayer() {}

    static SetupCoinLayer* create(EffectGameObject* object, cocos2d::CCArray* objects) = win inline {
        auto ret = new SetupCoinLayer();
        if (ret->init(object, objects)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x46f200;
}

[[link(android)]]
class SetupCollisionStateTriggerPopup : SetupInstantCollisionTriggerPopup {
    // virtual ~SetupCollisionStateTriggerPopup();
    SetupCollisionStateTriggerPopup() {}

    static SetupCollisionStateTriggerPopup* create(EffectGameObject* object, cocos2d::CCArray* objects) = win inline {
        auto ret = new SetupCollisionStateTriggerPopup();
        if (ret->init(object, objects)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x41a650, imac 0x397ab0, m1 0x31d628;
}

[[link(android)]]
class SetupCollisionTriggerPopup : SetupTriggerPopup {
    // virtual ~SetupCollisionTriggerPopup();

    static SetupCollisionTriggerPopup* create(EffectGameObject* object, cocos2d::CCArray* objects);

    virtual void determineStartValues() = win 0x418e30, m1 0x31c430, imac 0x396530;
    virtual void onClose(cocos2d::CCObject* sender) = win 0x419aa0, m1 0x31c978, imac 0x396ba0;
    virtual void textChanged(CCTextInputNode* node) = win 0x419420, m1 0x31c734, imac 0x3968d0;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x417fc0;
    void onActivateOnExit(cocos2d::CCObject* sender);
    void onEnableGroup(cocos2d::CCObject* sender);
    void onItemID2Arrow(cocos2d::CCObject* sender) = win 0x419350, m1 0x31bc50;
    void onItemIDArrow(cocos2d::CCObject* sender) = win 0x419390, m1 0x31bbb0;
    void onTargetIDArrow(cocos2d::CCObject* sender) = win 0x4193d0, m1 0x31bcf0;
    void onTargetP1(cocos2d::CCObject* sender) = win 0x419050;
    void onTargetP2(cocos2d::CCObject* sender) = win 0x419110;
    void onTargetPP(cocos2d::CCObject* sender) = win 0x4191d0;
    void updateItemID();
    void updateItemID2() = m1 0x31c5b0;
    void updateItemID2InputLabel() = win 0x419770, m1 0x31bed8;
    void updateItemIDInputLabel() = win 0x4196a0, m1 0x31bd98;
    void updateTargetID();
    void updateTargetIDInputLabel();

    CCTextInputNode* m_blockAInput;
    CCTextInputNode* m_blockBInput;
    CCTextInputNode* m_targetIDInput;
    int m_blockAID;
    int m_blockBID;
    int m_targetID;
    bool m_activateGroup;
    bool m_triggerOnExit;
    bool m_targetP1;
    bool m_targetP2;
    bool m_targetPP;
}

[[link(android)]]
class SetupCountTriggerPopup : SetupTriggerPopup {
    // virtual ~SetupCountTriggerPopup();

    static SetupCountTriggerPopup* create(EffectGameObject* object, cocos2d::CCArray* objects);

    virtual void determineStartValues() = win 0x41bcf0, m1 0x258d70, imac 0x2bc540;
    virtual void onClose(cocos2d::CCObject* sender) = win 0x41c490, m1 0x259214, imac 0x2bcac0;
    virtual void textChanged(CCTextInputNode* node) = win 0x41bfb0, m1 0x259024, imac 0x2bc870;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects);
    void onEnableGroup(cocos2d::CCObject* sender);
    void onItemIDArrow(cocos2d::CCObject* sender) = win 0x41bf20;
    void onMultiActivate(cocos2d::CCObject* sender);
    void onTargetCountArrow(cocos2d::CCObject* sender) = win 0x41bee0, m1 0x258898;
    void onTargetIDArrow(cocos2d::CCObject* sender) = win 0x41bf70, imac 0x2bc0a0, m1 0x258928;
    void updateCountTextInputLabel();
    void updateItemID() = m1 0x258f20;
    void updateItemIDInputLabel();
    void updateTargetCount();
    void updateTargetID() = win 0x41c330, m1 0x258fa0;
    void updateTargetIDInputLabel();

    CCTextInputNode* m_itemIDInput;
    CCTextInputNode* m_targetIDInput;
    CCTextInputNode* m_targetCountInput;
    int m_itemID;
    int m_targetID;
    int m_targetCount;
    bool m_activateGroup;
    bool m_multiActivate;
}

[[link(android)]]
class SetupDashRingPopup : SetupTriggerPopup {
    // virtual ~SetupDashRingPopup();
    SetupDashRingPopup() {}

    static SetupDashRingPopup* create(DashRingObject* object, cocos2d::CCArray* objects) = win inline {
        auto ret = new SetupDashRingPopup();
        if (ret->init(object, objects)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init(DashRingObject* object, cocos2d::CCArray* objects) = win 0x472e80;
}

[[link(android)]]
class SetupEndPopup : SetupTriggerPopup {
    // virtual ~SetupEndPopup();

    static SetupEndPopup* create(EffectGameObject* object, cocos2d::CCArray* objects);

    virtual void determineStartValues() = win 0x41d210, m1 0x588120, imac 0x669270;
    virtual void onClose(cocos2d::CCObject* sender) = win 0x413b50, m1 0x588390, imac 0x669590;
    virtual void textInputClosed(CCTextInputNode* node) = win 0x8b870, m1 0x58829c, imac 0x669440;
    virtual void textChanged(CCTextInputNode* node) = win 0x41d4c0, m1 0x5882b8, imac 0x669480;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x41c850, m1 0x4e53c4;
    void onLockY(cocos2d::CCObject* sender);
    void onMultiActivate(cocos2d::CCObject* sender) = win 0x41d320, imac 0x4984e0, m1 0x588014;
    void onReversed(cocos2d::CCObject* sender);
    void onTargetIDArrow(cocos2d::CCObject* sender);
    void updateTargetID() = m1 0x588218;
    void updateTextInputLabel();

    CCTextInputNode* m_groupIDInput;
    bool m_reversed;
    bool m_lockY;
    int m_groupID;
    bool m_multiActivate;
}

[[link(android)]]
class SetupEnterEffectPopup : SetupTriggerPopup, HSVWidgetDelegate {
    // virtual ~SetupEnterEffectPopup();
    SetupEnterEffectPopup() {
        m_objectID = 0;
        m_enterOnlyToggler = nullptr;
        m_exitOnlyToggler = nullptr;
        m_enterType = 0;
        m_hsvButton = nullptr;
        m_hsvChanged = false;
    }

    static SetupEnterEffectPopup* create(EnterEffectObject* object, cocos2d::CCArray* objects, int id) = win inline, imac 0x3f0360, m1 0x369b84 {
        auto ret = new SetupEnterEffectPopup();
        if (ret->init(object, objects, id)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void determineStartValues() = win 0x41fee0, m1 0x36c104, imac 0x3f3070;
    virtual void onClose(cocos2d::CCObject* sender) = win 0x420500, imac 0x3f34a0, m1 0x36c4d8;
    virtual void updateInputValue(int tag, float& value) = win 0x40dd40, imac 0x3f3640, m1 0x36c658;
    virtual void updateInputNode(int tag, float value) = win 0x40dd10, m1 0x36c624, imac 0x3f3610;
    virtual void valueDidChange(int tag, float value) = win 0x4200b0, m1 0x36c274, imac 0x3f3260;
    virtual float triggerValueFromSliderValue(int tag, float value) = win 0x40dcb0, m1 0x36c59c, imac 0x3f35a0;
    virtual float triggerSliderValueFromValue(int tag, float value) = win 0x40dce0, m1 0x36c5f0, imac 0x3f35e0;
    virtual void hsvPopupClosed(HSVWidgetPopup* popup, cocos2d::ccHSVValue value) = win 0x420410, m1 0x36c32c, imac 0x3f3320;

    bool init(EnterEffectObject* object, cocos2d::CCArray* objects, int id) = win 0x41ded0;
    void onEnterType(cocos2d::CCObject* sender) = m1 0x36c030;
    void onHSV(cocos2d::CCObject* sender);
    void onNextFreeEnterChannel(cocos2d::CCObject* sender);
    void onNextFreeEnterEffectID(cocos2d::CCObject* sender);
    void updateHSVButton();

    int m_objectID;
    CCMenuItemToggler* m_enterOnlyToggler;
    CCMenuItemToggler* m_exitOnlyToggler;
    int m_enterType;
    CCMenuItemSpriteExtra* m_hsvButton;
    cocos2d::ccHSVValue m_hsvValue;
    bool m_hsvChanged;
}

[[link(android)]]
class SetupEnterTriggerPopup : SetupTriggerPopup {
    // virtual ~SetupEnterTriggerPopup();
    SetupEnterTriggerPopup() {
        m_enterOnlyToggler = nullptr;
        m_exitOnlyToggler = nullptr;
        m_enterType = 0;
    }

    static SetupEnterTriggerPopup* create(EnterEffectObject* object, cocos2d::CCArray* objects) = win inline {
        auto ret = new SetupEnterTriggerPopup();
        if (ret->init(object, objects)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void determineStartValues() = win 0x28f640, m1 0x23ae00, imac 0x29b1a0;

    bool init(EnterEffectObject* object, cocos2d::CCArray* objects) = win 0x28f0c0, imac 0x2b8260;
    void onEnterType(cocos2d::CCObject* sender) = m1 0x23ad2c;

    CCMenuItemToggler* m_enterOnlyToggler;
    CCMenuItemToggler* m_exitOnlyToggler;
    int m_enterType;
}

[[link(android)]]
class SetupEventLinkPopup : SetupTriggerPopup {
    // virtual ~SetupEventLinkPopup();

    static SetupEventLinkPopup* create(EventLinkTrigger* object, cocos2d::CCArray* objects);

    bool init(EventLinkTrigger* object, cocos2d::CCArray* objects) = win 0x465be0, imac 0x57a630, m1 0x4c8948;
    void onSelectEvent(cocos2d::CCObject* sender) = win 0x466150, imac 0x577570, m1 0x20cb28;
    void updateEventIDs(gd::set<int>& eventIDs) = win inline, imac 0x5778c0, m1 0x4c51cc {
        auto objects = m_gameObject ? cocos2d::CCArray::createWithObject(m_gameObject) : m_gameObjects;
        for (auto obj : geode::cocos::CCArrayExt<cocos2d::CCObject*, false>(objects)) {
            static_cast<EventLinkTrigger*>(obj)->m_eventIDs = eventIDs;
        }
    }
}

[[link(android)]]
class SetupForceBlockPopup : SetupTriggerPopup {
    // virtual ~SetupForceBlockPopup();

    static SetupForceBlockPopup* create(ForceBlockGameObject* object, cocos2d::CCArray* objects);

    virtual void valueDidChange(int tag, float value) = win 0x4713a0, imac 0x585080, m1 0x4d0d3c;

    bool init(ForceBlockGameObject* object, cocos2d::CCArray* objects) = imac 0x2c92d0;
}

[[link(android)]]
class SetupGameplayOffsetPopup : SetupTriggerPopup {
    // virtual ~SetupGameplayOffsetPopup();
    SetupGameplayOffsetPopup() {}

    static SetupGameplayOffsetPopup* create(EffectGameObject* object, cocos2d::CCArray* objects) = win inline {
        auto ret = new SetupGameplayOffsetPopup();
        if (ret->init(object, objects)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void updateInputValue(int tag, float& value) = win 0x4425d0, imac 0x798b20, m1 0x6a0738;
    virtual void updateInputNode(int tag, float value) = win 0x4425b0, m1 0x6a0720, imac 0x798b00;
    virtual float triggerValueFromSliderValue(int tag, float value) = win 0x442560, m1 0x6a06d0, imac 0x798ab0;
    virtual float triggerSliderValueFromValue(int tag, float value) = win 0x442590, m1 0x6a0708, imac 0x798ae0;
    virtual void onCustomToggleTriggerValue(cocos2d::CCObject* sender) = win 0x4424b0, m1 0x6a063c, imac 0x798a10;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x441cd0;
    void onDefaultValues(cocos2d::CCObject* sender) = win 0x442400, imac 0x7989d0, m1 0x6a05f8;
}

[[link(android)]]
class SetupGradientPopup : SetupTriggerPopup {
    SetupGradientPopup() {
        m_blendingMode = 0;
        m_layerButtons = nullptr;
        m_blendingLayer = 0;
        m_gradientLabels = nullptr;
    }
    ~SetupGradientPopup() = win inline {
        CC_SAFE_RELEASE(m_layerButtons);
    }

    static SetupGradientPopup* create(GradientTriggerObject* object, cocos2d::CCArray* objects) = win inline {
        auto ret = new SetupGradientPopup();
        if (ret->init(object, objects)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void determineStartValues() = win 0x421810, m1 0x51c198, imac 0x5f2b00;
    virtual void onPlusButton(cocos2d::CCObject* sender) = win 0x421920, m1 0x51c2c8, imac 0x5f2c20;
    virtual void updateToggleItem(int value, bool toggled) = win 0x4219e0, m1 0x51c37c, imac 0x5f2ce0;
    virtual void valueDidChange(int tag, float value) = win 0x421df0, imac 0x5f2ea0, m1 0x51c52c;

    bool init(GradientTriggerObject* object, cocos2d::CCArray* objects) = win 0x4206b0;
    void onBlending(cocos2d::CCObject* sender) = win 0x421ca0, imac 0x5f2830, m1 0x51beec;
    void onZLayer(cocos2d::CCObject* sender) = win 0x421b80, imac 0x5f2950, m1 0x51c01c;
    void sliderChanged(cocos2d::CCObject* sender) = win inline, m1 0x51c48c, ios inline {}
    void updateBlending() = win inline, m1 0x51c4bc {
        if (m_gameObject) static_cast<GradientTriggerObject*>(m_gameObject)->m_blendingMode = m_blendingMode;
        else {
            for (int i = 0; i < m_gameObjects->count(); i++) {
                static_cast<GradientTriggerObject*>(m_gameObjects->objectAtIndex(i))->m_blendingMode = m_blendingMode;
            }
        }
    }
    void updateBlendingLabel() = win 0x421d60, imac 0x5f27a0, m1 0x51be38;
    void updateGradientLabels(bool vertex) = win 0x421a70;
    void updateZLayerButtons() = win 0x421c10, m1 0x51c108;

    cocos2d::CCLabelBMFont* m_blendingLabel;
    int m_blendingMode;
    cocos2d::CCArray* m_layerButtons;
    int m_blendingLayer;
    cocos2d::CCArray* m_gradientLabels;
}

[[link(android)]]
class SetupGravityModPopup : FLAlertLayer, TextInputDelegate {
    // virtual ~SetupGravityModPopup();

    static SetupGravityModPopup* create(EffectGameObject* object, cocos2d::CCArray* objects, bool gravityTrigger) = imac 0x3d7c90, m1 0x357120;

    virtual void keyBackClicked() = imac 0x3d91d0, m1 0x358474;
    virtual void show() = m1 0x358428, imac 0x3d9170;
    virtual void textInputClosed(CCTextInputNode* node) = m1 0x35833c, imac 0x3d9030;
    virtual void textChanged(CCTextInputNode* node) = m1 0x358358, imac 0x3d9070;

    void determineStartValues() = imac 0x3d8a20;
    bool init(EffectGameObject* object, cocos2d::CCArray* objects, bool gravityTrigger);
    void onClose(cocos2d::CCObject* sender) = imac 0x3d8b40, m1 0x357ee4;
    void onItemIDArrow(cocos2d::CCObject* sender) = m1 0x3580ac;
    void sliderChanged(cocos2d::CCObject* sender) = imac 0x3d8ba0, m1 0x357f40;
    void updateItemID() = m1 0x3582bc;
    void updateTextInputLabel() = m1 0x35814c;
    void updateValue() = m1 0x358250;
    void updateValueLabel() = m1 0x35803c;

    EffectGameObject* m_gameObject;
    cocos2d::CCArray* m_gameObjects;
    cocos2d::CCLabelBMFont* m_gravityModLabel;
    Slider* m_gravityModSlider;
    float m_gravityMod;
    bool m_gravityTrigger;
    float m_minValue;
    float m_maxValue;
    CCTextInputNode* m_itemIDInput;
    int m_itemID;
    bool m_disableDelegate;
}

[[link(android)]]
class SetupGravityTriggerPopup : SetupTriggerPopup {
    // virtual ~SetupGravityTriggerPopup();

    static SetupGravityTriggerPopup* create(EffectGameObject* object, cocos2d::CCArray* objects);

    virtual void valueDidChange(int tag, float value) = win 0x429360, imac 0x4c5070, m1 0x4245d4;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x428ee0;
}

[[link(android)]]
class SetupInstantCollisionTriggerPopup : SetupTriggerPopup {
    // virtual ~SetupInstantCollisionTriggerPopup();
    SetupInstantCollisionTriggerPopup() {}

    static SetupInstantCollisionTriggerPopup* create(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x419b40;

    virtual void updateDefaultTriggerValues() = win 0x41a520, m1 0x31d478, imac 0x397860;
    virtual void valueDidChange(int tag, float value) = win 0x41a2f0, imac 0x397550, m1 0x31d17c;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x419bd0, imac 0x2cc210;
    void updateSpecialNodes() = win 0x41a310, imac 0x397580, m1 0x31d1a0;
}

[[link(android)]]
class SetupInstantCountPopup : SetupTriggerPopup {
    // virtual ~SetupInstantCountPopup();

    static SetupInstantCountPopup* create(CountTriggerGameObject* object, cocos2d::CCArray* objects) = win 0x421f00;

    virtual void determineStartValues() = win 0x422f70, m1 0x513be4, imac 0x5e9a80;
    virtual void onClose(cocos2d::CCObject* sender) = win 0x419aa0, m1 0x5140d4, imac 0x5ea070;
    virtual void textChanged(CCTextInputNode* node) = win 0x423120, m1 0x513e8c, imac 0x5e9da0;

    bool init(CountTriggerGameObject* object, cocos2d::CCArray* objects) = win 0x422040, imac 0x2d2ce0;
    void onCountType(cocos2d::CCObject* sender) = win 0x423470, imac 0x5e99a0, m1 0x513b28;
    void onEnableGroup(cocos2d::CCObject* sender);
    void onTargetCountArrow(cocos2d::CCObject* sender) = win 0x41bee0, m1 0x513674;
    void onTargetID2Arrow(cocos2d::CCObject* sender) = win 0x4230e0, m1 0x513704;
    void onTargetIDArrow(cocos2d::CCObject* sender) = win 0x41bf20;
    void updateCountTextInputLabel();
    void updateItemID();
    void updateItemIDInputLabel();
    void updateTargetCount();
    void updateTargetID();
    void updateTargetIDInputLabel();

    CCTextInputNode* m_itemIDInput;
    CCTextInputNode* m_targetIDInput;
    CCTextInputNode* m_targetCountInput;
    int m_itemID;
    int m_targetID;
    int m_targetCount;
    bool m_activateGroup;
    int m_mode;
    CCMenuItemToggler* m_equalsToggler;
    CCMenuItemToggler* m_largerToggler;
    CCMenuItemToggler* m_smallerToggler;
}

[[link(android)]]
class SetupInteractObjectPopup : SetupTriggerPopup {
    // virtual ~SetupInteractObjectPopup();

    static SetupInteractObjectPopup* create(EffectGameObject* object, cocos2d::CCArray* objects);

    virtual void onClose(cocos2d::CCObject* sender) = win 0x424140, m1 0x465908, imac 0x50e6d0;
    virtual void onPlusButton(cocos2d::CCObject* sender) = win 0x423ff0, m1 0x4657e4, imac 0x50e5a0;
    virtual void valueDidChange(int tag, float value) = win 0x424110, m1 0x465874, imac 0x50e640;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x423730, m1 0x464f3c;
    void updateItems() = win 0x424090, imac 0x50e520, m1 0x465770;
}

[[link(android)]]
class SetupItemCompareTriggerPopup : SetupTriggerPopup {
    // virtual ~SetupItemCompareTriggerPopup();

    static SetupItemCompareTriggerPopup* create(ItemTriggerGameObject* object, cocos2d::CCArray* objects);

    virtual void valueDidChange(int tag, float value) = win 0x46f1e0, imac 0x582710, m1 0x4cea34;
    virtual void onCustomToggleTriggerValue(cocos2d::CCObject* sender) = win 0x46e6d0, imac 0x5825b0, m1 0x4ce8dc;

    bool init(ItemTriggerGameObject* object, cocos2d::CCArray* objects) = win 0x46d030;
    void onOpButton(cocos2d::CCObject* sender) = win 0x46e300, imac 0x581940, m1 0x4cdb80;
    void updateFormulaLabel() = win 0x46e8d0, imac 0x581c60, m1 0x4cdec4;
    void updateOpButton(CCMenuItemSpriteExtra* button, int key, int objectID) = win 0x46e3e0, imac 0x581a00, m1 0x4cdc3c;

    cocos2d::CCLabelBMFont* m_formulaLabel;
}

[[link(android)]]
class SetupItemEditTriggerPopup : SetupTriggerPopup {
    // virtual ~SetupItemEditTriggerPopup();

    static SetupItemEditTriggerPopup* create(ItemTriggerGameObject* object, cocos2d::CCArray* objects);

    virtual void valueDidChange(int tag, float value) = win 0x46cee0, imac 0x5802e0, m1 0x4cc8e4;
    virtual void onCustomToggleTriggerValue(cocos2d::CCObject* sender) = win 0x46cc40, imac 0x580100, m1 0x4cc704;

    bool init(ItemTriggerGameObject* object, cocos2d::CCArray* objects) = win 0x46a7f0, imac 0x2b21b0;
    void onOpButton(cocos2d::CCObject* sender) = win 0x46b9e0, m1 0x4cb404;
    void updateFormulaLabel() = win 0x46c0b0, imac 0x57f1f0, m1 0x4cb6d0;
    void updateOpButton(CCMenuItemSpriteExtra* button, int key, int objectID) = win 0x46be50, imac 0x57eff0, m1 0x4cb4c4;

    cocos2d::CCLabelBMFont* m_formulaLabel;
}

[[link(android)]]
class SetupKeyframeAnimPopup : SetupTriggerPopup {
    // virtual ~SetupKeyframeAnimPopup();

    static SetupKeyframeAnimPopup* create(EffectGameObject* object, cocos2d::CCArray* objects);

    bool init(EffectGameObject* object, cocos2d::CCArray* objects);
}

[[link(android)]]
class SetupKeyframePopup : SetupTriggerPopup {
    // virtual ~SetupKeyframePopup();

    static SetupKeyframePopup* create(KeyframeGameObject* object, cocos2d::CCArray* objects, LevelEditorLayer* layer) = win 0x424eb0, imac 0x1ff6e0;

    virtual void onClose(cocos2d::CCObject* sender) = win 0x426b90, m1 0x1ae790, imac 0x201980;
    virtual void onCustomButton(cocos2d::CCObject* sender) = win 0x4263a0, imac 0x2015b0, m1 0x1ae3b0;
    virtual void valueDidChange(int tag, float value) = win 0x4262c0, m1 0x1ae0c8, imac 0x201300;
    virtual void onCustomToggleTriggerValue(cocos2d::CCObject* sender) = win 0x4262e0, imac 0x201520, m1 0x1ae30c;

    bool init(KeyframeGameObject* object, cocos2d::CCArray* objects, LevelEditorLayer* layer) = win 0x424ff0;
    void onTimeMode(cocos2d::CCObject* sender) = win 0x426aa0, imac 0x201170, m1 0x1adf34;
    void refreshPreviewArt() = win 0x426800, m1 0x1ae0e8;
    void updateTimeModeButtons() = win 0x426b00, imac 0x201270, m1 0x1ae03c;

    cocos2d::CCArray* m_timeModeToggles;
    LevelEditorLayer* m_editorLayer;
    bool m_groupIDChanged;
}

[[link(android)]]
class SetupMGTrigger : SetupTriggerPopup {
    // virtual ~SetupMGTrigger();

    static SetupMGTrigger* create(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x426df0;

    virtual void determineStartValues() = win 0x427ee0, m1 0x461220, imac 0x509810;
    virtual void onClose(cocos2d::CCObject* sender) = win 0x4285d0, m1 0x461998, imac 0x50a0e0;
    virtual void textChanged(CCTextInputNode* node) = win 0x428240, m1 0x461798, imac 0x509e80;
    virtual void valuePopupClosed(ConfigureValuePopup* popup, float value) = win 0x416750, m1 0x4614b4, imac 0x509b40;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x426f10;
    void onEasing(cocos2d::CCObject* sender) = win 0x416b10;
    void onEasingRate(cocos2d::CCObject* sender);
    int posFromSliderValue(float value) = win inline, ios inline {
        return (int)((value - .5f) * 200.f) * 3.f;
    }
    void sliderChanged(cocos2d::CCObject* sender) = win 0x271b30;
    float sliderValueFromPos(int pos) = win inline, imac 0x5095a0, m1 0x460fac, ios inline {
        return std::clamp((int)((float)pos / 3.f) / 200.f + .5f, 0.f, 1.f);
    }
    void sliderYChanged(cocos2d::CCObject* sender) = m1 0x460f54;
    void toggleEasingRateVisibility();
    void updateDuration();
    void updateDurLabel(bool decimals);
    void updateEasingLabel();
    void updateEasingRateLabel();
    void updateMoveCommandEasing() = win inline {
        if (m_gameObject) m_gameObject->m_easingType = m_mgEasingType;
        else {
            for (int i = 0; i < m_gameObjects->count(); i++) {
                static_cast<EffectGameObject*>(m_gameObjects->objectAtIndex(i))->m_easingType = m_mgEasingType;
            }
        }
    }
    void updateMoveCommandEasingRate() = win inline {
        if (m_gameObject) m_gameObject->m_easingRate = m_mgEasingRate;
        else {
            for (int i = 0; i < m_gameObjects->count(); i++) {
                static_cast<EffectGameObject*>(m_gameObjects->objectAtIndex(i))->m_easingRate = m_mgEasingRate;
            }
        }
    }
    void updateMoveCommandPosY();
    void updateValueYLabel();

    CCTextInputNode* m_moveTimeInput;
    Slider* m_moveTimeSlider;
    float m_moveTime;
    cocos2d::CCLabelBMFont* m_mgEasingLabel;
    EasingType m_mgEasingType;
    float m_mgEasingRate;
    CCMenuItemSpriteExtra* m_mgEasingRateButton;
    cocos2d::CCLabelBMFont* m_mgEasingRateLabel;
    CCTextInputNode* m_offsetYInput;
    Slider* m_offsetYSlider;
    int m_offsetY;
}

[[link(android)]]
class SetupMoveCommandPopup : SetupTriggerPopup {
    // virtual ~SetupMoveCommandPopup();

    static SetupMoveCommandPopup* create(EffectGameObject* object, cocos2d::CCArray* objects);

    virtual void updateInputValue(int tag, float& value) = win 0x281c60, m1 0x52eca0, imac 0x608700;
    virtual void updateInputNode(int tag, float value) = win 0x281c30, m1 0x52ec78, imac 0x6086d0;
    virtual void valueDidChange(int tag, float value) = win 0x281c90, m1 0x52ecd0, imac 0x608730;
    virtual float triggerValueFromSliderValue(int tag, float value) = win 0x281b70, m1 0x52ebc4, imac 0x6085f0;
    virtual float triggerSliderValueFromValue(int tag, float value) = win 0x281bc0, m1 0x52ec08, imac 0x608640;
    virtual void onCustomToggleTriggerValue(cocos2d::CCObject* sender) = win 0x282300, imac 0x608940, m1 0x52ee98;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x2807a0;
    void updateControlVisibility() = win 0x282140, imac 0x608440;

    bool m_smallStep;
}

[[link(android)]]
class SetupObjectControlPopup : SetupTriggerPopup {
    // virtual ~SetupObjectControlPopup();

    static SetupObjectControlPopup* create(ObjectControlGameObject* object, cocos2d::CCArray* objects);

    bool init(ObjectControlGameObject* object, cocos2d::CCArray* objects) = win 0x472bd0, imac 0x5865c0, m1 0x4d1f9c;
}

[[link(android)]]
class SetupObjectOptions2Popup : SetupTriggerPopup {
    // virtual ~SetupObjectOptions2Popup();
    SetupObjectOptions2Popup() {}

    static SetupObjectOptions2Popup* create(GameObject* object, cocos2d::CCArray* objects) = win inline {
        auto ret = new SetupObjectOptions2Popup();
        if (ret->init(object, objects)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void onPlusButton(cocos2d::CCObject* sender) = win 0x400c50, m1 0x2a93e0, imac 0x31b2d0;

    bool init(GameObject* object, cocos2d::CCArray* objects) = win 0x400750, imac 0x501100;
}

[[link(android)]]
class SetupObjectOptionsPopup : FLAlertLayer, TextInputDelegate {
    SetupObjectOptionsPopup() {
        m_gameObject = nullptr;
        m_gameObjects = nullptr;
        m_iceBlock = false;
        m_dontFade = false;
        m_dontEnter = false;
        m_noEffects = false;
        m_noParticle = false;
        m_noTouch = false;
        m_passable = false;
        m_hide = false;
        m_nonStickX = false;
        m_nonStickY = false;
        m_extraSticky = false;
        m_dontBoostY = false;
        m_scaleStick = false;
        m_highDetail = false;
        m_groupParent = false;
        m_areaParent = false;
        m_gripSlope = false;
        m_noGlow = false;
        m_reverse = false;
        m_extendedCollision = false;
        m_unk2a6 = false;
        m_groupIDLayer = nullptr;
        m_effectObject = false;
        m_singlePlayerTouch = false;
    }
    ~SetupObjectOptionsPopup() = win inline {
        CC_SAFE_RELEASE(m_gameObject);
        CC_SAFE_RELEASE(m_gameObjects);
    }

    static SetupObjectOptionsPopup* create(GameObject* object, cocos2d::CCArray* objects, SetGroupIDLayer* layer) = win inline, imac 0x316bf0, m1 0x2a5878 {
        auto ret = new SetupObjectOptionsPopup();
        if (ret->init(object, objects, layer)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyBackClicked() = win 0x257110, m1 0x2a8e48, imac 0x31ac40;
    virtual void show() = win 0x8bb10, m1 0x2a8e6c, imac 0x31ac80;
    virtual void determineStartValues() = win 0x3ff5a0, imac 0x31a830, m1 0x2a8b98;
    virtual void onClose(cocos2d::CCObject* sender) = win 0x84690, imac 0x31ace0, m1 0x2a8eb8;

    bool init(GameObject* object, cocos2d::CCArray* objects, SetGroupIDLayer* layer) = win 0x3fdbc0;
    void onAlwaysHide(cocos2d::CCObject* sender);
    void onApplyScaleStick(cocos2d::CCObject* sender) = m1 0x9bac4;
    void onCenterEffect(cocos2d::CCObject* sender);
    void onDisableGlow(cocos2d::CCObject* sender);
    void onDisableObject(cocos2d::CCObject* sender) = win 0x3ffb00, imac 0x319ef0, m1 0x2a8330;
    void onDontBoost(cocos2d::CCObject* sender);
    void onDontBoostX(cocos2d::CCObject* sender);
    void onDontEnter(cocos2d::CCObject* sender);
    void onDontFade(cocos2d::CCObject* sender);
    void onExtendedCollision(cocos2d::CCObject* sender) = win 0x400400;
    void onExtraSticky(cocos2d::CCObject* sender);
    void onGripSlope(cocos2d::CCObject* sender);
    void onHideEffects(cocos2d::CCObject* sender);
    void onHighDetail(cocos2d::CCObject* sender);
    void onIceBlock(cocos2d::CCObject* sender) = m1 0x548520;
    void onNoAudioScale(cocos2d::CCObject* sender);
    void onNonStickX(cocos2d::CCObject* sender);
    void onNonStickY(cocos2d::CCObject* sender);
    void onNoParticle(cocos2d::CCObject* sender);
    void onPassable(cocos2d::CCObject* sender);
    void onReverse(cocos2d::CCObject* sender) = win 0x400530, imac 0x31a790;
    void onSinglePlayerTouch(cocos2d::CCObject* sender);
    void onToggleAreaParent(cocos2d::CCObject* sender);
    void onToggleGroupParent(cocos2d::CCObject* sender) = m1 0x22ace8;

    GameObject* m_gameObject;
    cocos2d::CCArray* m_gameObjects;
    bool m_iceBlock;
    bool m_dontFade;
    bool m_dontEnter;
    bool m_noEffects;
    bool m_noParticle;
    bool m_noTouch;
    bool m_passable;
    bool m_hide;
    bool m_nonStickX;
    bool m_nonStickY;
    bool m_extraSticky;
    bool m_dontBoostY;
    bool m_dontBoostX;
    bool m_noAudioScale;
    bool m_scaleStick;
    bool m_highDetail;
    bool m_groupParent;
    bool m_areaParent;
    bool m_gripSlope;
    bool m_noGlow;
    bool m_reverse;
    bool m_extendedCollision;
    bool m_unk2a6;
    SetGroupIDLayer* m_groupIDLayer;
    bool m_effectObject;
    bool m_singlePlayerTouch;
    bool m_centerEffect;
}

[[link(android)]]
class SetupObjectTogglePopup : SetupTriggerPopup {
    // virtual ~SetupObjectTogglePopup();

    static SetupObjectTogglePopup* create(EffectGameObject* object, cocos2d::CCArray* objects, bool platformer) = win 0x429580;

    virtual void onClose(cocos2d::CCObject* sender) = win 0x424140, imac 0x376380, m1 0x2ffa04;
    virtual void valueDidChange(int tag, float value) = win 0x429ff0, imac 0x376300, m1 0x2ff98c;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects, bool platformer) = win 0x4296a0;
}

[[link(android)]]
class SetupOpacityPopup : SetupTriggerPopup {
    // virtual ~SetupOpacityPopup();

    static SetupOpacityPopup* create(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x42a140;

    virtual void determineStartValues() = win 0x42b070, m1 0x4bd0c, imac 0x58260;
    virtual void onClose(cocos2d::CCObject* sender) = win 0x409d90, m1 0x4c1dc, imac 0x58860;
    virtual void textInputClosed(CCTextInputNode* node) = win 0x8b870, m1 0x4bfc0, imac 0x585c0;
    virtual void textChanged(CCTextInputNode* node) = win 0x42b460, m1 0x4bfdc, imac 0x58600;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x42a270;
    void onTargetIDArrow(cocos2d::CCObject* sender) = win 0x42b200;
    void sliderChanged(cocos2d::CCObject* sender) = m1 0x4b97c;
    void updateDuration() = m1 0x4bf54;
    void updateDurLabel(bool decimals);
    void updateOpacity() = win inline, m1 0x4bee8 {
        if (m_gameObject) m_gameObject->m_opacity = m_opacity;
        else {
            for (int i = 0; i < m_gameObjects->count(); i++) {
                static_cast<EffectGameObject*>(m_gameObjects->objectAtIndex(i))->m_opacity = m_opacity;
            }
        }
    }
    void updateOpacityLabel();
    void updateTargetID() = m1 0x4be64;
    void updateTextInputLabel();

    CCTextInputNode* m_groupIDInput;
    CCTextInputNode* m_fadeTimeInput;
    cocos2d::CCLabelBMFont* m_opacityLabel;
    Slider* m_fadeTimeSlider;
    Slider* m_opacitySlider;
    float m_opacity;
    float m_fadeTime;
    int m_groupID;
}

[[link(android)]]
class SetupOptionsTriggerPopup : SetupTriggerPopup {
    // virtual ~SetupOptionsTriggerPopup();
    SetupOptionsTriggerPopup() = m1 0x45f798 {
        m_togglePage = 0;
    }

    static SetupOptionsTriggerPopup* create(GameOptionsTrigger* object, cocos2d::CCArray* objects) = win inline, m1 0x510f74 {
        auto ret = new SetupOptionsTriggerPopup();
        if (ret->init(object, objects)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void onCustomToggleTriggerValue(cocos2d::CCObject* sender) = win 0x4365d0, imac 0x5e7330, m1 0x511a00;

    void addOption(int property, gd::string label) = win 0x436370;
    bool init(GameOptionsTrigger* object, cocos2d::CCArray* objects) = win 0x435b70, m1 0x511008;

    cocos2d::CCPoint m_togglePosition;
    int m_togglePage;
}

[[link(android)]]
class SetupPersistentItemTriggerPopup : SetupTriggerPopup {
    // virtual ~SetupPersistentItemTriggerPopup();

    static SetupPersistentItemTriggerPopup* create(ItemTriggerGameObject* object, cocos2d::CCArray* objects);

    bool init(ItemTriggerGameObject* object, cocos2d::CCArray* objects) = win 0x46f6a0;
}

[[link(android)]]
class SetupPickupTriggerPopup : SetupTriggerPopup {
    // virtual ~SetupPickupTriggerPopup();

    static SetupPickupTriggerPopup* create(EffectGameObject* object, cocos2d::CCArray* objects);

    virtual void onPlusButton(cocos2d::CCObject* sender) = win 0x436ed0, m1 0x4cb54, imac 0x59380;
    virtual void onCustomToggleTriggerValue(cocos2d::CCObject* sender) = win 0x436ff0, imac 0x59430, m1 0x4cbf0;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x4367b0, imac 0x9abe0;
    void updateState() = win 0x436f80, imac 0x59310, m1 0x4caf4, ios inline {
        auto pickupTriggerMode = this->getValue(88);
        this->toggleGroup(1, pickupTriggerMode == 0.0f);
        this->toggleGroup(2, pickupTriggerMode != 0.0f);
    }
}

[[link(android)]]
class SetupPlatformerEndPopup : SetupTriggerPopup {
    // virtual ~SetupPlatformerEndPopup();

    static SetupPlatformerEndPopup* create(EndTriggerGameObject* object, cocos2d::CCArray* objects);

    bool init(EndTriggerGameObject* object, cocos2d::CCArray* objects) = win 0x41d810, m1 0x269370;
}

[[link(android)]]
class SetupPlayerControlPopup : SetupTriggerPopup {
    // virtual ~SetupPlayerControlPopup();

    static SetupPlayerControlPopup* create(PlayerControlGameObject* object, cocos2d::CCArray* objects);

    bool init(PlayerControlGameObject* object, cocos2d::CCArray* objects) = win 0x467a30;
}

[[link(android)]]
class SetupPortalPopup : FLAlertLayer, TextInputDelegate {
    // virtual ~SetupPortalPopup();

    static SetupPortalPopup* create(EffectGameObject* object, cocos2d::CCArray* objects) = imac 0x56f0e0, m1 0x4bd158;

    virtual void keyBackClicked() = m1 0x4be280, imac 0x570420;

    void determineStartValues();
    bool init(EffectGameObject* object, cocos2d::CCArray* objects);
    void onClose(cocos2d::CCObject* sender);
    void onEditCameraSettings(cocos2d::CCObject* sender);
    void onUnboundMode(cocos2d::CCObject* sender);
    void sliderChanged(cocos2d::CCObject* sender);
    void updateCameraEasing() = m1 0x4be198;
    void updateCameraEasingLabel();
    void updateCameraPadding() = m1 0x4be210;
    void updateCameraPaddingLabel() = m1 0x4be0ac;
    void updateItemVisibility() = m1 0x4be0fc;

    EffectGameObject* m_gameObject;
    cocos2d::CCArray* m_gameObjects;
    cocos2d::CCArray* m_freeModeObjects;
    cocos2d::CCArray* m_cameraSettingsObjects;
    Slider* m_cameraEasingSlider;
    cocos2d::CCLabelBMFont* m_cameraEasingLabel;
    int m_cameraEasing;
    Slider* m_cameraPaddingSlider;
    cocos2d::CCLabelBMFont* m_cameraPaddingLabel;
    float m_cameraPadding;
    bool m_freeMode;
    bool m_cameraSettingsEnabled;
    bool m_disableDelegate;
}

[[link(android)]]
class SetupPulsePopup : SetupTriggerPopup, cocos2d::extension::ColorPickerDelegate, GJSpecialColorSelectDelegate {
    // virtual ~SetupPulsePopup();

    static SetupPulsePopup* create(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x4371b0, imac 0x3a9b90, m1 0x32dafc;

    virtual void show() = win 0x43bf00, m1 0x332e98, imac 0x3afab0;
    virtual void determineStartValues() = win 0x43ae50, m1 0x331e28, imac 0x3ae6b0;
    virtual void onClose(cocos2d::CCObject* sender) = win 0x43bc10, imac 0x3af310, m1 0x332848;
    virtual void textChanged(CCTextInputNode* node) = win 0x43c0b0, m1 0x332ef4, imac 0x3afb30;
    virtual void colorValueChanged(cocos2d::ccColor3B color) = win 0x43bdf0, m1 0x3329bc, imac 0x3af4f0;
    virtual void textInputOpened(CCTextInputNode* node) = win inline, imac 0x3afb10, m1 0x332eec {}
    virtual void colorSelectClosed(GJSpecialColorSelect* select, int id) = win 0x43b680, m1 0x3322dc, imac 0x3aec60;

    cocos2d::ccColor3B getColorValue() = win inline, imac 0x3af090, m1 0x33267c, ios inline {
        return m_colorPicker->getColorValue();
    }
    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x437390;
    void onCopy(cocos2d::CCObject* sender) = win 0x90e40, m1 0x331748;
    void onExclusive(cocos2d::CCObject* sender);
    void onGroupMainOnly(cocos2d::CCObject* sender) = win 0x43b370;
    void onGroupSecondaryOnly(cocos2d::CCObject* sender) = win 0x43b460;
    void onHSVLegacyMode(cocos2d::CCObject* sender);
    void onPaste(cocos2d::CCObject* sender) = win 0x90ec0, m1 0x33177c;
    void onSelectPulseMode(cocos2d::CCObject* sender) = win 0x43aa00, imac 0x3ad9e0, m1 0x3312ac;
    void onSelectSpecialColor(cocos2d::CCObject* sender) = m1 0x3318b0;
    void onSelectSpecialTargetID(cocos2d::CCObject* sender) = m1 0x331260;
    void onSelectTargetMode(cocos2d::CCObject* sender) = win 0x43ac30, imac 0x3ad630, m1 0x330f48;
    void onUpdateCopyColor(cocos2d::CCObject* sender) = win 0x43c040, imac 0x3ae030, m1 0x331800;
    void onUpdateCustomColor(cocos2d::CCObject* sender) = win 0x43bfb0, imac 0x3ad8b0, m1 0x33118c;
    void selectColor(cocos2d::ccColor3B color) = win inline, imac 0x3ae000, m1 0x3317c8, ios inline {
        m_colorPicker->setColorValue(color);
    }
    void sliderChanged(cocos2d::CCObject* sender) = win 0x43b820, m1 0x330954;
    void updateColorLabels();
    void updateColorValue() = win inline {
        if (m_colorInitializing) return;
        if (m_gameObject) {
            m_gameObject->m_triggerTargetColor = m_currentColor;
        }
        else if (m_gameObjects) {
            for (int i = 0; i < m_gameObjects->count(); i++) {
                static_cast<EffectGameObject*>(m_gameObjects->objectAtIndex(i))->m_triggerTargetColor = m_currentColor;
            }
        }
    }
    void updateCopyColor() = m1 0x332608;
    void updateCopyColorTextInputLabel();
    void updateFadeInLabel(bool decimals);
    void updateFadeInTime() = m1 0x332690;
    void updateFadeOutLabel(bool decimals);
    void updateFadeOutTime() = m1 0x332768;
    void updateGroupMainOnly() = m1 0x332270;
    void updateGroupSecondaryOnly() = m1 0x332204;
    void updateHoldLabel(bool decimals);
    void updateHoldTime() = m1 0x3326fc;
    void updateHSVValue() = win inline, imac 0x3af260, m1 0x3327d4 {
        if (m_gameObject) {
            m_gameObject->m_hsvValue = m_hsv;
        }
        else if (m_gameObjects) {
            for (int i = 0; i < m_gameObjects->count(); i++) {
                static_cast<EffectGameObject*>(m_gameObjects->objectAtIndex(i))->m_hsvValue = m_hsv;
            }
        }
    }
    void updatePulseMode() = win inline, m1 0x331ce0 {
        if (m_gameObject) {
            m_gameObject->m_pulseMode = m_pulseMode;
        }
        else if (m_gameObjects) {
            for (int i = 0; i < m_gameObjects->count(); i++) {
                static_cast<EffectGameObject*>(m_gameObjects->objectAtIndex(i))->m_pulseMode = m_pulseMode;
            }
        }
    }
    void updatePulseTargetType() = win inline, m1 0x331dbc {
        if (m_gameObject) {
            m_gameObject->m_pulseTargetType = m_pulseTargetType;
        }
        else if (m_gameObjects) {
            for (int i = 0; i < m_gameObjects->count(); i++) {
                static_cast<EffectGameObject*>(m_gameObjects->objectAtIndex(i))->m_pulseTargetType = m_pulseTargetType;
            }
        }
    }
    void updateTargetID() = win 0x43ca30, imac 0x3ae5b0, m1 0x331d4c;
    void updateTextInputLabel() = win 0x43cb80, m1 0x3318fc;

    cocos2d::extension::CCControlColourPicker* m_colorPicker;
    bool m_unk3c0;
    cocos2d::CCArray* m_colorObjects;
    cocos2d::CCArray* m_hsvObjects;
    Slider* m_fadeInSlider;
    Slider* m_holdSlider;
    Slider* m_fadeOutSlider;
    CCMenuItemSpriteExtra* m_channelButton;
    CCMenuItemSpriteExtra* m_groupButton;
    cocos2d::CCLabelBMFont* m_idLabel;
    cocos2d::ccColor3B m_originalColor;
    cocos2d::CCSprite* m_currentColorSprite;
    cocos2d::CCSprite* m_originalColorSprite;
    cocos2d::ccColor3B m_currentColor;
    CCMenuItemSpriteExtra* m_colorButton;
    CCMenuItemSpriteExtra* m_hsvButton;
    ConfigureHSVWidget* m_hsvWidget;
    CCMenuItemSpriteExtra* m_specialColorButton;
    CCTextInputNode* m_fadeInInput;
    CCTextInputNode* m_holdInput;
    CCTextInputNode* m_fadeOutInput;
    CCTextInputNode* m_idInput;
    CCTextInputNode* m_colorIDInput;
    CCMenuItemToggler* m_mainOnlyToggler;
    CCMenuItemToggler* m_secondaryOnlyToggler;
    CCMenuItemToggler* m_staticHSVToggler;
    cocos2d::CCLabelBMFont* m_mainOnlyLabel;
    cocos2d::CCLabelBMFont* m_secondaryOnlyLabel;
    cocos2d::CCLabelBMFont* m_staticHSVLabel;
    bool m_groupMainOnly;
    bool m_groupSecondaryOnly;
    bool m_staticHSV;
    int m_targetGroupID;
    int m_copyColorID;
    bool m_colorInitializing;
    float m_fadeInTime;
    float m_holdTime;
    float m_fadeOutTime;
    int m_pulseMode;
    int m_pulseTargetType;
    bool m_modesInitializing;
    bool m_pulseExclusive;
    cocos2d::ccHSVValue m_hsv;
    CCTextInputNode* m_rInput;
    CCTextInputNode* m_gInput;
    CCTextInputNode* m_bInput;
    CCTextInputNode* m_hexInput;
}

[[link(android)]]
class SetupRandAdvTriggerPopup : SetupTriggerPopup {
    // virtual ~SetupRandAdvTriggerPopup();

    static SetupRandAdvTriggerPopup* create(RandTriggerGameObject* object, cocos2d::CCArray* objects);

    virtual void onClose(cocos2d::CCObject* sender) = win 0x43da70, m1 0x3154b8, imac 0x38ec80;
    virtual void textChanged(CCTextInputNode* node) = win inline, imac 0x38ec60, m1 0x3154b0 {}

    void addChance(int id, int chance) = win inline, imac 0x38ecf0, m1 0x315524 {
        m_performedAction = true;
        if (m_gameObject) {
            this->addChanceToObject(static_cast<RandTriggerGameObject*>(m_gameObject), id, chance);
        }
        else if (m_gameObjects) {
            for (int i = 0; i < m_gameObjects->count(); i++) {
                this->addChanceToObject(static_cast<RandTriggerGameObject*>(m_gameObjects->objectAtIndex(i)), id, chance);
            }
        }
        this->updateGroupIDButtons();
    }
    void addChanceToObject(RandTriggerGameObject* object, int id, int chance) = win inline {
        for (auto& object : object->m_chanceObjects) {
            if (object.m_groupID == id) {
                object.m_chance += chance;
                return;
            }
        }
        object->m_chanceObjects.emplace_back(id, chance);
    }
    void callRemoveFromGroup(float dt) = win 0x43e4b0, m1 0x3159c0;
    bool init(RandTriggerGameObject* object, cocos2d::CCArray* objects) = win 0x43cff0;
    void onAddChance(cocos2d::CCObject* sender) = win 0x43e6f0, imac 0x38e180, m1 0x314b44;
    void onRemoveFromGroup(cocos2d::CCObject* sender);
    void removeGroupID(int id) = win inline, m1 0x315710 {
        m_performedAction = true;
        if (m_gameObject) {
            this->removeGroupIDFromObject(static_cast<RandTriggerGameObject*>(m_gameObject), id);
        }
        else if (m_gameObjects) {
            for (int i = 0; i < m_gameObjects->count(); i++) {
                this->removeGroupIDFromObject(static_cast<RandTriggerGameObject*>(m_gameObjects->objectAtIndex(i)), id);
            }
        }
        this->updateGroupIDButtons();
    }
    void removeGroupIDFromObject(RandTriggerGameObject* object, int id) = win inline, m1 0x17a814 {
        for (int i = 0; i < object->m_chanceObjects.size(); i++) {
            if (object->m_chanceObjects[i].m_groupID == id) {
                object->m_chanceObjects.erase(object->m_chanceObjects.begin() + i);
                return;
            }
        }
    }
    void updateGroupIDButtons() = win 0x43db30;

    bool m_performedAction;
    cocos2d::CCArray* m_groupButtons;
    CCTextInputNode* m_groupIDInput;
    CCTextInputNode* m_chanceInput;
    int m_groupToRemove;
    bool m_removingGroup;
}

[[link(android)]]
class SetupRandTriggerPopup : SetupTriggerPopup {
    // virtual ~SetupRandTriggerPopup();

    static SetupRandTriggerPopup* create(EffectGameObject* object, cocos2d::CCArray* objects);

    virtual void determineStartValues() = win 0x440540, m1 0x510990, imac 0x5e60c0;
    virtual void onClose(cocos2d::CCObject* sender) = win 0x441020, m1 0x510e8c, imac 0x5e66a0;
    virtual void textChanged(CCTextInputNode* node) = win 0x440840, m1 0x510c18, imac 0x5e63b0;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects);
    void onTargetID2Arrow(cocos2d::CCObject* sender) = win 0x4407f0, m1 0x5103bc;
    void onTargetIDArrow(cocos2d::CCObject* sender) = win 0x4407a0, m1 0x510314;
    void sliderChanged(cocos2d::CCObject* sender) = m1 0x510794;
    void updateChance() = m1 0x510aa0;
    void updateChanceLabel(bool decimals);
    void updateTargetID() = m1 0x510b10;
    void updateTargetID2();
    void updateTextInputLabel();
    void updateTextInputLabel2();

    CCTextInputNode* m_chanceInput;
    Slider* m_chanceSlider;
    float m_chancePercent;
    CCTextInputNode* m_groupID1Input;
    CCTextInputNode* m_groupID2Input;
    int m_groupID1;
    int m_groupID2;
}

[[link(android)]]
class SetupResetTriggerPopup : SetupTriggerPopup {
    // virtual ~SetupResetTriggerPopup();

    static SetupResetTriggerPopup* create(EffectGameObject* object, cocos2d::CCArray* objects);

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x46a3e0, imac 0x57d7c0, m1 0x4c9ff8;
}

[[link(android)]]
class SetupReverbPopup : SetupTriggerPopup {
    // virtual ~SetupReverbPopup();
    SetupReverbPopup() {}

    static SetupReverbPopup* create(SFXTriggerGameObject* object, cocos2d::CCArray* objects) = win inline {
        auto ret = new SetupReverbPopup();
        if (ret->init(object, objects)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void onClose(cocos2d::CCObject* sender) = win 0x446d40, m1 0x418ce8, imac 0x4b7fc0;

    bool init(SFXTriggerGameObject* object, cocos2d::CCArray* objects) = win 0x4464b0, m1 0x418590;
    void onPlay(cocos2d::CCObject* sender) = win 0x446a70, m1 0x418c98;
    void onReverb(cocos2d::CCObject* sender) = win 0x446b60, imac 0x35ab70, m1 0x418b48;
    void updateReverbLabel() = win 0x446bf0, imac 0x4b7eb0, m1 0x418bc4;

    cocos2d::CCLabelBMFont* m_reverbLabel;
}

[[link(android)]]
class SetupRotateCommandPopup : SetupTriggerPopup {
    // virtual ~SetupRotateCommandPopup();

    static SetupRotateCommandPopup* create(EffectGameObject* object, cocos2d::CCArray* objects);

    virtual void updateInputNode(int tag, float value) = win 0x2a8dc0, m1 0x5d68, imac 0x67a0;
    virtual void valueDidChange(int tag, float value) = win 0x2a8dd0, imac 0x67b0, m1 0x5d6c;
    virtual float triggerValueFromSliderValue(int tag, float value) = win 0x2a8d80, m1 0x5d40, imac 0x6750;
    virtual float triggerSliderValueFromValue(int tag, float value) = win 0x2a8db0, m1 0x5d64, imac 0x6790;
    virtual void onCustomToggleTriggerValue(cocos2d::CCObject* sender) = win 0xc3e50, imac 0x6af0, m1 0x5ffc;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x2a7bf0;
    void onInfiniteDuration(cocos2d::CCObject* sender) = win 0x2a9130, imac 0x6650;
    void updateControlVisibility() = win 0x2a9050, imac 0x6670, m1 0x52ea18;
}

[[link(android)]]
class SetupRotateGameplayPopup : SetupTriggerPopup {
    // virtual ~SetupRotateGameplayPopup();
    SetupRotateGameplayPopup() {}

    static SetupRotateGameplayPopup* create(RotateGameplayGameObject* object, cocos2d::CCArray* objects) = win inline {
        auto ret = new SetupRotateGameplayPopup();
        if (ret->init(object, objects)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void onPlusButton(cocos2d::CCObject* sender) = win 0x441bb0, m1 0x69fcc4, imac 0x797ea0;
    virtual void valueDidChange(int tag, float value) = win 0x441c60, m1 0x69fd60, imac 0x797f50;

    bool init(RotateGameplayGameObject* object, cocos2d::CCArray* objects) = win 0x4411e0;
}

[[link(android)]]
class SetupRotatePopup : SetupTriggerPopup {
    // virtual ~SetupRotatePopup();

    static SetupRotatePopup* create(EnhancedGameObject* object, cocos2d::CCArray* objects);

    virtual void onClose(cocos2d::CCObject* sender) = win 0x442c70, m1 0x4e58b0, imac 0x59cc00;
    virtual void onCustomToggleTriggerValue(cocos2d::CCObject* sender) = win 0x442d10, imac 0x59cc80, m1 0x4e592c;

    bool init(EnhancedGameObject* object, cocos2d::CCArray* objects) = win 0x442710, m1 0x4d17b0;
}

[[link(android)]]
class SetupSequenceTriggerPopup : SetupTriggerPopup {
    // virtual ~SetupSequenceTriggerPopup();

    static SetupSequenceTriggerPopup* create(SequenceTriggerGameObject* object) = win 0x442fa0, imac 0x4dd0e0, m1 0x43974c;

    virtual void onCustomToggleTriggerValue(cocos2d::CCObject* sender) = win 0x4442e0, imac 0x4de6c0, m1 0x43aaf4;

    bool init(SequenceTriggerGameObject* object) = win 0x4430d0;
    void onAddChance(cocos2d::CCObject* sender) = win 0x444930, imac 0x4de1e0, m1 0x43a5e8;
    void onChangeOrder(cocos2d::CCObject* sender) = win 0x444a70, imac 0x4de2d0, m1 0x43a704;
    void onDeleteSelected(cocos2d::CCObject* sender) = win 0x444b50, imac 0x4de280, m1 0x43a6b8;
    void onSelect(cocos2d::CCObject* sender) = win 0x4448b0, imac 0x4de7c0, m1 0x43abd4;
    void updateGroupIDButtons() = win 0x4443d0, imac 0x4de370, m1 0x43a7b8;

    CCMenuItemSpriteExtra* m_selectedButton;
    bool m_unk3b0;
    bool m_unk3b1;
    cocos2d::CCArray* m_groupButtons;
    int m_unk3c0;
    bool m_unk3c4;
}

[[link(android)]]
class SetupSFXEditPopup : SetupAudioTriggerPopup {
    // virtual ~SetupSFXEditPopup();

    static SetupSFXEditPopup* create(SFXTriggerGameObject* object, cocos2d::CCArray* objects, bool songTrigger) = win 0x4490a0, imac 0x4ba760, m1 0x41ace8;

    bool init(SFXTriggerGameObject* object, cocos2d::CCArray* objects, bool songTrigger) = win 0x4491c0;
}

[[link(android)]]
class SetupSFXPopup : SetupAudioTriggerPopup, CustomSFXDelegate, SFXBrowserDelegate {
    // virtual ~SetupSFXPopup();

    static SetupSFXPopup* create(SFXTriggerGameObject* object, cocos2d::CCArray* objects) = win 0x446db0, m1 0x418fac;

    virtual void pageChanged() = win 0x448160, imac 0x4b9c90, m1 0x41a430;
    virtual void onClose(cocos2d::CCObject* sender) = win 0x4481d0, m1 0x41a488, imac 0x4b9cf0;
    virtual void onPlusButton(cocos2d::CCObject* sender) = win 0x448a90, m1 0x41a8d8, imac 0x4ba1b0;
    virtual void valueDidChange(int tag, float value) = win 0x448980, imac 0x4ba090, m1 0x41a7b4;
    virtual void sfxObjectSelected(SFXInfoObject* object) = win inline, imac 0x4b9fb0, m1 0x41a700 {}
    virtual int getActiveSFXID() = win 0x4488c0, imac 0x4b9fd0, m1 0x41a708;
    virtual bool overridePlaySFX(SFXInfoObject* object) = win 0x4488d0, m1 0x41a718, imac 0x4b9ff0;
    virtual void sfxBrowserClosed(SFXBrowser* browser) = win 0x449080, imac 0x4ba320, m1 0x41aa30;

    void createSFXWidget() = win 0x448590, imac 0x4b99e0, m1 0x41a1a4;
    bool init(SFXTriggerGameObject* object, cocos2d::CCArray* objects) = win 0x446f00;
    void onBrowseSFX(cocos2d::CCObject* sender) = win 0x448ea0, imac 0x4b9980, m1 0x41a158;
    void updateLength() = win 0x448510, imac 0x4b9f60, m1 0x41a6ac;

    int m_sfxID;
    CustomSFXWidget* m_sfxWidget;
    int m_sfxLength;
}

[[link(android)]]
class SetupShaderEffectPopup : SetupTriggerPopup {
    SetupShaderEffectPopup() {
        m_zLayerSprites = nullptr;
        m_zLayerMin = 0;
        m_zLayerMax = 0;
        m_changeMin = false;
        m_objectID = 0;
    }
    ~SetupShaderEffectPopup() = win inline {
        CC_SAFE_RELEASE(m_zLayerSprites);
    }

    static SetupShaderEffectPopup* create(EffectGameObject* object, cocos2d::CCArray* objects, int id) = win inline, m1 0x261b84 {
        auto ret = new SetupShaderEffectPopup();
        if (ret->init(object, objects, id)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void toggleGroup(int group, bool visible) = win 0x454680, m1 0x26b8f0, imac 0x2d04e0;
    virtual void onClose(cocos2d::CCObject* sender) = win 0x28f0b0, m1 0x26b930, imac 0x2d0520;
    virtual void updateDefaultTriggerValues() = win 0x44a240, m1 0x26afd0, imac 0x2cfc70;
    virtual void valueDidChange(int tag, float value) = win 0x454250, imac 0x2d01b0, m1 0x26b5c0;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects, int id) = win 0x449f50;
    void onResetColors(cocos2d::CCObject* sender) = win 0x453bb0, imac 0x2d0130, m1 0x26b54c;
    void onZLayer(cocos2d::CCObject* sender) = win 0x44ad30, imac 0x2cfee0, m1 0x26b310;
    void setupBulge() = win 0x450e30;
    void setupChromatic() = win 0x44da60, m1 0x26420c;
    void setupChromaticGlitch() = win 0x44dfe0, m1 0x266484;
    void setupColorChange() = win 0x4534e0;
    void setupGlitch() = win 0x44d3e0;
    void setupGrayscale() = win 0x4522f0, imac 0x30b360;
    void setupHueShift() = win 0x453190;
    void setupInvertColor() = win 0x452b20, m1 0x2678ec;
    void setupLensCircle() = win 0x44ef30;
    void setupMotionBlur() = win 0x4502c0;
    void setupPinch() = win 0x451700;
    void setupPixelate() = win 0x44e890;
    void setupRadialBlur() = win 0x44f880, imac 0x2cb5e0, m1 0x42fddc;
    void setupSepia() = win 0x4527f0, m1 0x26998c;
    void setupShaderTrigger() = win 0x44a330, m1 0x26a78c;
    void setupShockLine() = win 0x44c1e0;
    void setupShockWave() = win 0x44aed0;
    void setupSplitScreen() = win 0x453d70, m1 0x35d890;
    void updateZLayerButtons() = win 0x44ae20, m1 0x26b494;
    gd::string zLayerToString(int zLayer) = win 0x44aa50, m1 0x26b170;

    cocos2d::CCArray* m_zLayerSprites;
    int m_zLayerMin;
    int m_zLayerMax;
    bool m_changeMin;
    int m_objectID;
}

[[link(android)]]
class SetupShakePopup : SetupTriggerPopup {
    // virtual ~SetupShakePopup();

    static SetupShakePopup* create(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x454880;

    virtual void determineStartValues() = win 0x455700, m1 0x584214, imac 0x664b60;
    virtual void onClose(cocos2d::CCObject* sender) = win 0x456150, m1 0x584854, imac 0x6652d0;
    virtual void textChanged(CCTextInputNode* node) = win 0x455d90, m1 0x584548, imac 0x664f40;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects);
    void sliderChanged(cocos2d::CCObject* sender) = m1 0x583c10;
    void updateDuration();
    void updateDurLabel(bool decimals);
    void updateInterval();
    void updateIntervalLabel(bool decimals);
    void updateShake();
    void updateShakeLabel(bool decimals);

    CCTextInputNode* m_durationInput;
    Slider* m_durationSlider;
    float m_duration;
    CCTextInputNode* m_strengthInput;
    Slider* m_strengthSlider;
    float m_strength;
    CCTextInputNode* m_intervalInput;
    Slider* m_intervalSlider;
    float m_interval;
}

[[link(android)]]
class SetupSmartBlockLayer : FLAlertLayer, TextInputDelegate, SelectArtDelegate {
    // virtual ~SetupSmartBlockLayer();

    static SetupSmartBlockLayer* create(SmartGameObject* object, cocos2d::CCArray* objects) = win 0x456560, imac 0x4e5670, m1 0x44051c;

    virtual void keyBackClicked() = win 0x458700, m1 0x441bf8, imac 0x4e7070;
    virtual void show() = win 0x8bb10, m1 0x441b94, imac 0x4e6fe0;
    virtual void selectArtClosed(SelectArtLayer* layer) = win 0x4586c0, imac 0x4e7040, m1 0x441be0;

    void determineStartValues() = win inline, m1 0x441270 {
        if (auto smartTemplate = GameLevelManager::sharedState()->m_smartTemplate) {
            m_allowRotation = smartTemplate->m_allowRotation;
            m_allowFlipX = smartTemplate->m_allowFlipX;
            m_allowFlipY = smartTemplate->m_allowFlipY;
            m_ignoreCorners = smartTemplate->m_ignoreCorners;
        }
        auto gameManager = GameManager::sharedState();
        m_useNearby = gameManager->getGameVariable("0131");
        m_dontDelete = gameManager->getGameVariable("0132");
        if (m_gameObject) {
            m_referenceOnly = m_gameObject->m_referenceOnly;
        }
        else {
            m_referenceOnly = true;
            for (int i = 0; i < m_gameObjects->count(); i++) {
                auto obj = static_cast<SmartGameObject*>(m_gameObjects->objectAtIndex(i));
                if (!obj->m_referenceOnly) m_referenceOnly = false;
            }
        }
    }
    bool init(SmartGameObject* object, cocos2d::CCArray* objects) = win 0x4566a0;
    void onAllowFlipping(cocos2d::CCObject* sender) = win 0x457780, imac 0x4e6ea0, m1 0x441a64;
    void onAllowRotation(cocos2d::CCObject* sender) = m1 0x441a28;
    void onClose(cocos2d::CCObject* sender) = win 0x458060, m1 0x441334;
    void onCreate(cocos2d::CCObject* sender) = win 0x458120, m1 0x4413d4;
    void onCreateAll(cocos2d::CCObject* sender) = win 0x457db0, m1 0x44177c;
    void onCreateTemplate(cocos2d::CCObject* sender) = win 0x458550, m1 0x4414c0;
    void onDontDelete(cocos2d::CCObject* sender) = m1 0x441b5c;
    void onIgnoreCorners(cocos2d::CCObject* sender) = m1 0x441ae8;
    void onNearbyReference(cocos2d::CCObject* sender) = m1 0x441b24;
    void onPasteTemplate(cocos2d::CCObject* sender) = win 0x4579b0, m1 0x4415a4;
    void onReferenceOnly(cocos2d::CCObject* sender);
    void onSelectPremade(cocos2d::CCObject* sender) = win 0x458650, imac 0x4e68c0, m1 0x441538;
    void onSelectTemplate(cocos2d::CCObject* sender) = win 0x4586d0, imac 0x4e6910, m1 0x441580;

    bool m_referenceOnly;
    bool m_allowRotation;
    bool m_allowFlipX;
    bool m_allowFlipY;
    bool m_useNearby;
    bool m_dontDelete;
    bool m_ignoreCorners;
    int m_specialTemplate;
    SmartGameObject* m_gameObject;
    cocos2d::CCArray* m_gameObjects;
}

[[link(android)]]
class SetupSmartTemplateLayer : FLAlertLayer, TextInputDelegate, FLAlertLayerProtocol {
    // virtual ~SetupSmartTemplateLayer();

    static SetupSmartTemplateLayer* create(GJSmartTemplate* smartTemplate) = win 0x458710, m1 0x441e70;

    virtual void keyBackClicked() = win 0x459970, imac 0x4e8500, m1 0x442eec;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x4593d0, m1 0x442b90, imac 0x4e8200;
    virtual void textInputOpened(CCTextInputNode* node) = win 0x459710, imac 0x4e8420, m1 0x442de0;
    virtual void textInputClosed(CCTextInputNode* node) = win 0x4594b0, imac 0x4e82e0, m1 0x442c74;
    virtual void textChanged(CCTextInputNode* node) = win 0xc3e50, imac 0x4e84e0, m1 0x442ecc;

    bool init(GJSmartTemplate* smartTemplate) = win 0x458820;
    void onBack(cocos2d::CCObject* sender) = win 0x459870, imac 0x4e7e90, m1 0x442860;
    void onClick(cocos2d::CCObject* sender) = win 0x459210, imac 0x4e7ec0, m1 0x442888;
    void onClose(cocos2d::CCObject* sender) = win 0x4598a0, imac 0x4e8130, m1 0x442ac0;

    GJSmartTemplate* m_smartTemplate;
    CCTextInputNode* m_nameInput;
    cocos2d::CCNode* m_unk298;
}

[[link(android)]]
class SetupSongTriggerPopup : SetupAudioTriggerPopup, MusicDownloadDelegate, SongPlaybackDelegate {
    // virtual ~SetupSongTriggerPopup();

    static SetupSongTriggerPopup* create(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x45c4a0, m1 0x26da44;

    virtual void pageChanged() = win 0x45d940, imac 0x2d3dd0, m1 0x26eb8c;
    virtual void onClose(cocos2d::CCObject* sender) = win 0x45d9c0, m1 0x26ec20, imac 0x2d3e60;
    virtual void valueDidChange(int tag, float value) = win 0x45d7f0, imac 0x2d3cd0, m1 0x26ea8c;
    virtual void onPlayback(SongInfoObject* object) = win 0x45d2c0, imac 0x2d3a90, m1 0x26e878;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x45c5e0, imac 0x1720;
    void onResetSongTime(cocos2d::CCObject* sender) = win inline, imac 0x2d3cb0, m1 0x26ea80, ios inline {
        this->updateValue(408, 0.f);
    }
    void onSavePlaybackPos(cocos2d::CCObject* sender) = win 0x45d660, m1 0x26e624;
    void updateApplyPrepare(bool hideAll) = win inline, imac 0x2d3a50, m1 0x26e834 {
        if (hideAll) this->hideAll();
        else this->goToPage(0, false);
        this->toggleGroup(2, true);
    }
    void updateLength() = win 0x45d230, imac 0x2d3810, m1 0xb2f98;
    void updateSongTimeSlider() = win inline, imac 0x2d3960, m1 0x26e758 {
        if (m_selectNode->m_selectedSongID <= 0) return;
        auto engine = FMODAudioEngine::sharedEngine();
        engine->loadMusic(MusicDownloadManager::sharedState()->pathForSong(m_selectNode->m_selectedSongID));
        auto musicLength = engine->getMusicLengthMS(0);
        if (musicLength != 0) {
            this->setMaxSliderValue(musicLength, 408);
            this->setMaxSliderValue(musicLength, 410);
            this->updateSlider(408);
            this->updateSlider(410);
        }
    }

    SongSelectNode* m_selectNode;
}

[[link(android)]]
class SetupSpawnParticlePopup : SetupTriggerPopup {
    // virtual ~SetupSpawnParticlePopup();

    static SetupSpawnParticlePopup* create(EffectGameObject* object, cocos2d::CCArray* objects);

    bool init(EffectGameObject* object, cocos2d::CCArray* objects);
}

[[link(android)]]
class SetupSpawnPopup : SetupTriggerPopup {
    // virtual ~SetupSpawnPopup();

    static SetupSpawnPopup* create(EffectGameObject* object, cocos2d::CCArray* objects);

    virtual void onClose(cocos2d::CCObject* sender) = win 0x424140, m1 0x230d38, imac 0x2907f0;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x45dd50;
    void onAddRemap(cocos2d::CCObject* sender);
    void onDeleteRemap(cocos2d::CCObject* sender) = win 0x45ec80, imac 0x28fce0;
    void onSelectRemap(cocos2d::CCObject* sender) = win 0x45f6e0, imac 0x2906f0;
    void queueUpdateButtons() = win 0x45f7b0;
    void updateRemapButtons(float dt) = win 0x45eec0;

    bool m_isBusy;
    cocos2d::CCArray* m_remapButtons;
    gd::vector<int> m_remapGroups;
    int m_remapOriginalID;
    int m_remapNewID;
}

[[link(android)]]
class SetupStaticCameraPopup : SetupTriggerPopup {
    // virtual ~SetupStaticCameraPopup();

    static SetupStaticCameraPopup* create(CameraTriggerGameObject* object, cocos2d::CCArray* objects);

    virtual void valueDidChange(int tag, float value) = win 0x460330, m1 0x321074, imac 0x39ba50;
    virtual void onCustomToggleTriggerValue(cocos2d::CCObject* sender) = win 0x4424b0, m1 0x3210fc, imac 0x39bae0;

    bool init(CameraTriggerGameObject* object, cocos2d::CCArray* objects) = win 0x45f930;
    void updateState() = win 0x460350, imac 0x39b9d0, m1 0x321000;
}

[[link(android)]]
class SetupStopTriggerPopup : SetupTriggerPopup {
    // virtual ~SetupStopTriggerPopup();

    static SetupStopTriggerPopup* create(EffectGameObject* object, cocos2d::CCArray* objects);

    virtual void onClose(cocos2d::CCObject* sender) = win 0x472a20, imac 0x586300, m1 0x4d1d8c;
    virtual void onCustomToggleTriggerValue(cocos2d::CCObject* sender) = win 0x472970, imac 0x586290, m1 0x4d1d14;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x472290;
}

[[link(android)]]
class SetupTeleportPopup : SetupTriggerPopup {
    // virtual ~SetupTeleportPopup();

    static SetupTeleportPopup* create(TeleportPortalObject* object, cocos2d::CCArray* objects, int id, bool platformer) = win 0x4604c0, imac 0x358640, m1 0x2e4164;

    virtual void determineStartValues() = win 0x28f0a0, m1 0x2e5618, imac 0x359e70;
    virtual void updateDefaultTriggerValues() = win 0x461760, m1 0x2e561c, imac 0x359e80;
    virtual void valueDidChange(int tag, float value) = win 0x461790, m1 0x2e5728, imac 0x359f80;

    bool init(TeleportPortalObject* object, cocos2d::CCArray* objects, int id, bool platformer) = win 0x460600;
    void onTeleportGravity(cocos2d::CCObject* sender) = win 0x461890, imac 0x359d50, m1 0x2e5500;
    void updateTeleportGravityState(int state) = win 0x461920;

    cocos2d::CCArray* m_teleportGravityToggles;
}

[[link(android)]]
class SetupTimerControlTriggerPopup : SetupTriggerPopup {
    // virtual ~SetupTimerControlTriggerPopup();

    static SetupTimerControlTriggerPopup* create(TimerTriggerGameObject* object, cocos2d::CCArray* objects);

    virtual void onCustomToggleTriggerValue(cocos2d::CCObject* sender) = win 0x462e80, imac 0x3a1f20, m1 0x326bc0;

    bool init(TimerTriggerGameObject* object, cocos2d::CCArray* objects) = win 0x462aa0, imac 0x31ada0;
}

[[link(android)]]
class SetupTimerEventTriggerPopup : SetupTriggerPopup {
    // virtual ~SetupTimerEventTriggerPopup();

    static SetupTimerEventTriggerPopup* create(TimerTriggerGameObject* object, cocos2d::CCArray* objects);

    bool init(TimerTriggerGameObject* object, cocos2d::CCArray* objects) = win 0x462440;
}

[[link(android)]]
class SetupTimerTriggerPopup : SetupTriggerPopup {
    // virtual ~SetupTimerTriggerPopup();

    static SetupTimerTriggerPopup* create(TimerTriggerGameObject* object, cocos2d::CCArray* objects);

    bool init(TimerTriggerGameObject* object, cocos2d::CCArray* objects) = win 0x461ac0;
}

[[link(android)]]
class SetupTimeWarpPopup : SetupTriggerPopup {
    // virtual ~SetupTimeWarpPopup();

    static SetupTimeWarpPopup* create(EffectGameObject* object, cocos2d::CCArray* objects);

    virtual void determineStartValues() = win 0x463560, m1 0x45ab38, imac 0x502d90;
    virtual void onClose(cocos2d::CCObject* sender) = win 0x28f0b0, m1 0x45ac88, imac 0x502f20;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x4630f0, m1 0x45a5f0;
    void sliderChanged(cocos2d::CCObject* sender) = win 0x463670, m1 0x2f4a10;
    void updateTimeWarp() = win inline, m1 0x45ac1c {
        if (m_gameObject) m_gameObject->m_timeWarpTimeMod = m_timeWarpMod;
        else if (m_gameObjects) {
            for (int i = 0; i < m_gameObjects->count(); i++) {
                static_cast<EffectGameObject*>(m_gameObjects->objectAtIndex(i))->m_timeWarpTimeMod = m_timeWarpMod;
            }
        }
    }
    void updateTimeWarpLabel() = m1 0x45aae8;

    cocos2d::CCLabelBMFont* m_timeWarpLabel;
    Slider* m_timeWarpSlider;
    float m_timeWarpMod;
}

[[link(android)]]
class SetupTouchTogglePopup : SetupTriggerPopup {
    // virtual ~SetupTouchTogglePopup();

    static SetupTouchTogglePopup* create(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x463880;

    virtual void determineStartValues() = win 0x4645f0, m1 0x2567c0, imac 0x2b92b0;
    virtual void onClose(cocos2d::CCObject* sender) = win 0x464b20, m1 0x256a7c, imac 0x2b95f0;
    virtual void textChanged(CCTextInputNode* node) = win 0x464a00, m1 0x256988, imac 0x2b94d0;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x4639c0;
    void onControlMode(cocos2d::CCObject* sender) = win 0x464940, imac 0x2b91e0, m1 0x256714;
    void onDualTouchMode(cocos2d::CCObject* sender);
    void onHoldMode(cocos2d::CCObject* sender);
    void onTargetIDArrow(cocos2d::CCObject* sender);
    void onTouchMode(cocos2d::CCObject* sender) = win 0x464870, imac 0x2b9080, m1 0x2565e4;
    void updateTargetID();
    void updateTextInputLabel();

    CCTextInputNode* m_groupIDInput;
    int m_groupID;
    bool m_holdMode;
    int m_toggleMode;
    int m_playerMode;
    CCMenuItemToggler* m_toggleOnToggler;
    CCMenuItemToggler* m_toggleOffToggler;
    bool m_dualMode;
    CCMenuItemToggler* m_p1OnlyToggler;
    CCMenuItemToggler* m_p2OnlyToggler;
}

[[link(android)]]
class SetupTransformPopup : SetupTriggerPopup {
    // virtual ~SetupTransformPopup();

    static SetupTransformPopup* create(TransformTriggerGameObject* object, cocos2d::CCArray* objects);

    bool init(TransformTriggerGameObject* object, cocos2d::CCArray* objects) = win 0x464cd0;
}

[[link(android)]]
class SetupTriggerPopup : FLAlertLayer, TextInputDelegate, ConfigureValuePopupDelegate, SliderDelegate {
    SetupTriggerPopup() {
        m_gameObject = nullptr;
        m_gameObjects = nullptr;
        m_touchTriggered = false;
        m_spawnTriggered = false;
        m_touchToggle = nullptr;
        m_spawnToggle = nullptr;
        m_multiTriggerContainer = nullptr;
        m_multiTriggered = false;
        m_width = 0.f;
        m_height = 0.f;
        m_disableTextDelegate = false;
        m_valueToggles = nullptr;
        m_inputNodes = nullptr;
        m_valueControls = nullptr;
        m_customValueToggles = nullptr;
        m_disableButtons = nullptr;
        m_easingLabel = nullptr;
        m_easingRateLabel = nullptr;
        m_easingRateButton = nullptr;
        m_easingType = EasingType::None;
        m_easingRate = 0.f;
        m_inputLabels = nullptr;
        m_triggerValues = nullptr;
        m_minSliderValues = nullptr;
        m_maxSliderValues = nullptr;
        m_disableSliderDelegate = false;
        m_effectObjects = false;
        m_pageContainers = nullptr;
        m_page = 0;
        m_easingControlScale = 1.f;
        m_groupContainers = nullptr;
        m_customEasingTags = nullptr;
        m_customEasingLabels = nullptr;
        m_customEasingButtons = nullptr;
        m_customEasingScales = nullptr;
        m_disabledEasingButtons = nullptr;
        m_prevButton = nullptr;
        m_nextButton = nullptr;
        m_hideAll = false;
    }
    ~SetupTriggerPopup() = win 0x473710, m1 0x1de174;

    static SetupTriggerPopup* create(float width, float height) = win inline, imac 0x234da0, m1 0x1de760, ios inline {
        return SetupTriggerPopup::create(nullptr, nullptr, width, height, 1);
    }
    static SetupTriggerPopup* create(EffectGameObject* trigger, cocos2d::CCArray* triggers, float width, float height, int background) = win inline, imac 0x234810, m1 0x1de31c, ios inline {
        auto ret = new SetupTriggerPopup();
        if (ret->init(trigger, triggers, width, height, background)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x47dbf0, m1 0x1e7494, imac 0x23fa90;
    virtual void keyBackClicked() = win 0x2f6c60, imac 0x238df0, m1 0x1e12e4;
    virtual void show() = win 0x8bb10, m1 0x1e1160, imac 0x238c30;
    virtual void pageChanged() {}
    virtual void toggleGroup(int group, bool visible) = win 0x474340, imac 0x235580, m1 0x1deef0;
    virtual void determineStartValues() = win 0x475090, imac 0x236770, m1 0x1dff40;
    virtual void onClose(cocos2d::CCObject* sender) = win 0x4756d0, m1 0x1e11ac, imac 0x238c90;
    virtual void textInputClosed(CCTextInputNode* node) = win 0x8b870, imac 0x236af0, m1 0x1e0240;
    virtual void textChanged(CCTextInputNode* node) = win 0x475510, imac 0x236b30, m1 0x1e025c;
    virtual void textInputShouldOffset(CCTextInputNode* node, float yOffset) = win 0x7b620, m1 0x1e1308, imac 0x238e30;
    virtual void textInputReturn(CCTextInputNode* node) = win 0x7b680, m1 0x1e13d8, imac 0x238ef0;
    virtual void updateInputValue(int tag, float& value) {}
    virtual void sliderBegan(Slider* slider) = win 0x475810, m1 0x1e1490, imac 0x238fa0;
    virtual void sliderEnded(Slider* slider) = win 0x4758e0, m1 0x1e1560, imac 0x239080;
    virtual void onPlusButton(cocos2d::CCObject* sender) {}
    virtual void onCustomButton(cocos2d::CCObject* sender) {}
    virtual void updateDefaultTriggerValues() = win 0x4774c0, imac 0x23b5d0, m1 0x1e3a8c;
    virtual void updateInputNode(int tag, float value) = win 0x4779b0, imac 0x23d8d0, m1 0x1e5130;
    virtual void updateToggleItem(int value, bool toggled) = win 0x477d50, m1 0x1e536c, imac 0x23dac0;
    virtual void valueDidChange(int tag, float value) {}
    virtual float getValue(int tag) = win 0x477dc0, imac 0x23db80, m1 0x1e5424;
    virtual float triggerValueFromSliderValue(int tag, float value) = win 0x47bdb0, m1 0x1e57d0, imac 0x23df10;
    virtual float triggerSliderValueFromValue(int tag, float value) = win 0x47be40, m1 0x1e585c, imac 0x23df90;
    virtual void onCustomToggleTriggerValue(cocos2d::CCObject* sender) {}
    virtual void valuePopupClosed(ConfigureValuePopup* popup, float value) = win 0x47cd60, imac 0x23eba0, m1 0x1e649c;

    void addCloseButton(gd::string text) = win 0x4745c0, imac 0x235a80, m1 0x1df390;
    void addHelpButton(gd::string title, gd::string desc, float scale) = win 0x4746d0, imac 0x235b00, m1 0x1df410;
    void addInfoLabel(gd::string text, float scale, cocos2d::CCPoint position, int page, int group) = win 0x476ec0, imac 0x23adf0, m1 0x2bd4c;
    void addObjectsToGroup(cocos2d::CCArray* objects, int group) = win inline, m1 0x1df1e4 {
        this->getGroupContainer(group)->addObjectsFromArray(objects);
    }
    void addObjectsToPage(cocos2d::CCArray* objects, int page) = win inline, m1 0x1df090 {
        this->getPageContainer(page)->addObjectsFromArray(objects);
    }
    void addObjectToGroup(cocos2d::CCObject* object, int group) = win inline {
        this->getGroupContainer(group)->addObject(object);
    }
    void addObjectToPage(cocos2d::CCObject* object, int page) = win 0x474430;
    void addTitle(gd::string title) = win 0x4744c0, imac 0x2359b0, m1 0x1df2c8;
    void closeInputNodes() = win inline, ios inline {
        cocos2d::CCDictElement* element;
        cocos2d::CCDictElement* temp;
        HASH_ITER(hh, m_inputNodes->m_pElements, element, temp) {
            auto inputNode = static_cast<CCTextInputNode*>(element->getObject());
            inputNode->m_delegate = nullptr;
            inputNode->onClickTrackNode(false);
        }
    }
    void createCustomButton(int tag, gd::string text, gd::string frame, cocos2d::CCPoint position, float buttonScale, float labelScale, bool vertical, int page, int group) = win 0x477140, imac 0x441c40, m1 0x1e35b8;
    void createCustomEasingControls(gd::string text, cocos2d::CCPoint position, float scale, int typeProperty, int rateProperty, int page, int group) = win 0x47ce20, imac 0x23eda0, m1 0x1e6690;
    cocos2d::CCArray* createCustomToggleValueControl(int property, bool toggled, bool notClickable, gd::string text, cocos2d::CCPoint position, bool vertical, int page, int group) = win 0x476c40, imac 0x23ab10, m1 0x1e2fc4;
    void createEasingControls(cocos2d::CCPoint position, float scale, int page, int group) = win 0x47bef0, imac 0x23e040, m1 0x1e590c;
    void createMultiTriggerItems(cocos2d::CCPoint touchPos, cocos2d::CCPoint spawnPos, cocos2d::CCPoint multiPos) = win 0x474d80;
    void createMultiTriggerItemsCorner() = win 0x474a70, m1 0x1dfaf0;
    void createMultiTriggerItemsDefault() = win 0x474960, m1 0x1df6f0;
    void createMultiTriggerItemsDefaultHorizontal() = win 0x474c70, m1 0x1dfc90;
    void createMultiTriggerItemsDefaultVertical() = win 0x474b70, m1 0x1dfbc0;
    void createPageButtons(float offset, int arrow) = win 0x473cb0;
    CCMenuItemSpriteExtra* createPlusButton(int tag, cocos2d::CCPoint position, float scale, gd::string frame, int page, int group) = win 0x476fa0, imac 0x23af40, m1 0x1e33fc;
    CCMenuItemToggler* createToggleButton(gd::string text, cocos2d::SEL_MenuHandler selector, bool toggled, cocos2d::CCPoint position) = win 0x474830, imac 0x235ca0, m1 0x1df5bc;
    cocos2d::CCArray* createToggleValueControl(int property, gd::string label, cocos2d::CCPoint position, bool vertical, int page, int group, float scale) = win 0x476930, imac 0x23a740, m1 0x1e2bd0;
    cocos2d::CCArray* createToggleValueControlAdvanced(int property, gd::string label, cocos2d::CCPoint position, bool vertical, int page, int group, float buttonScale, float labelScale, float labelWidth, cocos2d::CCPoint offset) = win inline, imac 0x23a870 {
        auto pageContainer = this->getPageContainer(page);
        auto groupContainer = this->getGroupContainer(group);
        auto nodes = cocos2d::CCArray::create();
        auto toggle = GameToolbox::createToggleButton(
            label, menu_selector(SetupTriggerPopup::onToggleTriggerValue), false, m_buttonMenu, position,
            this, m_mainLayer, buttonScale, labelScale, labelWidth, offset, "bigFont.fnt", vertical, 0, nodes
        );
        toggle->setTag(property);
        toggle->m_notClickable = true;
        m_valueToggles->setObject(toggle, property);
        pageContainer->addObjectsFromArray(nodes);
        if (group > 0) groupContainer->addObjectsFromArray(nodes);
        return nodes;
    }
    void createValueControl(int property, gd::string label, cocos2d::CCPoint position, float scale, float sliderMin, float sliderMax) = win 0x475b70, imac 0x239580, m1 0x1e1a40;
    cocos2d::CCArray* createValueControlAdvanced(int property, gd::string label, cocos2d::CCPoint position, float scale, bool noSlider, InputValueType valueType, int length, bool arrows, float sliderMin, float sliderMax, int page, int group, GJInputStyle inputStyle, int decimalPlaces, bool allowDisable) = win 0x475c60;
    void createValueControlWArrows(int property, gd::string label, cocos2d::CCPoint position, float scale) = win inline, imac 0x23a2b0, m1 0x1e26e0, ios inline {
        this->createValueControlAdvanced(property, label, position, scale, true, InputValueType::Int, 6, true, 0.f, 0.f, 0, 0, GJInputStyle::GoldLabel, 2, false);
    }
    cocos2d::CCArray* getGroupContainer(int group) = win 0x4742d0, m1 0x1dee8c;
    float getMaxSliderValue(int property) = win inline, m1 0x1e57a0, ios inline {
        if (auto value = static_cast<cocos2d::CCFloat*>(m_maxSliderValues->objectForKey(property))) {
            return value->getValue();
        }
        return 1.f;
    }
    float getMinSliderValue(int property) = win inline, m1 0x1e5770, ios inline {
        if (auto value = static_cast<cocos2d::CCFloat*>(m_minSliderValues->objectForKey(property))) {
            return value->getValue();
        }
        return 0.f;
    }
    cocos2d::CCArray* getObjects() = win inline, imac 0x236730, m1 0x1dfef4 {
        if (m_gameObject) {
            auto arr = cocos2d::CCArray::create();
            arr->addObject(m_gameObject);
            return arr;
        }
        return m_gameObjects;
    }
    cocos2d::CCArray* getPageContainer(int page) = win 0x473fd0, m1 0x1ded0c;
    float getTriggerValue(int property, GameObject* object) = win 0x47a240, imac 0x23b9e0, m1 0x1e3e10;
    float getTruncatedValue(float value, int decimals) = win 0x4778a0, imac 0x236cf0, ios inline {
        if (decimals < 1) return value;
        auto exponent = decimals > 1 ? powf(10.f, decimals) : 10.f;
        return roundf(value * exponent) / exponent;
    }
    float getTruncatedValueByTag(int tag, float value) = win inline, imac 0x239260, m1 0x1e1714 {
        if (auto inputNode = static_cast<CCTextInputNode*>(m_inputNodes->objectForKey(tag))) {
            return this->getTruncatedValue(value, inputNode->m_decimalPlaces);
        }
        return value;
    }
    void goToPage(int page, bool hideAll) = win 0x474040, imac 0x235190, m1 0x1deb5c;
    void hideAll() = win inline, imac 0x2353d0, m1 0x1ded70 {
        this->goToPage(0, true);
    }
    bool init(EffectGameObject* trigger, cocos2d::CCArray* triggers, float width, float height, int background) = win 0x473930;
    void onCustomEaseArrow(int property, bool up) = win 0x47d700, imac 0x23f9f0, m1 0x1e73f0;
    void onCustomEaseArrowDown(cocos2d::CCObject* sender) = win 0x47d6d0, imac 0x23f730, m1 0x1e70c0;
    void onCustomEaseArrowUp(cocos2d::CCObject* sender) = win 0x47d6a0, imac 0x23f690, m1 0x1e700c;
    void onCustomEaseRate(cocos2d::CCObject* sender) = imac 0x23f5a0, m1 0x1e6ecc;
    void onDisableValue(cocos2d::CCObject* sender) = win 0x476820, imac 0x23a4a0, m1 0x1e28d4;
    void onEase(cocos2d::CCObject* sender) = win 0x47cc10, imac 0x23e880, m1 0x1e6144;
    void onEaseRate(cocos2d::CCObject* sender);
    void onMultiTrigger(cocos2d::CCObject* sender);
    void onPage(cocos2d::CCObject* sender) = win 0x473f60;
    void onSpawnedByTrigger(cocos2d::CCObject* sender) = win 0x475300, imac 0x2365d0, m1 0x1dfdbc;
    void onToggleTriggerValue(cocos2d::CCObject* sender) = win 0x477810;
    void onTouchTriggered(cocos2d::CCObject* sender) = win 0x475210, imac 0x236580;
    void postSetup() = win inline, imac 0x23b5b0, m1 0x1e3a60 {
        this->updateDefaultTriggerValues();
        m_disableTextDelegate = false;
    }
    void preSetup() = win inline, imac 0x23b590, m1 0x1e3a4c {
        m_disableTextDelegate = true;
        this->determineStartValues();
    }
    void refreshGroupVisibility() = win inline, m1 0x1ded7c {
        for (int i = 0; i < m_groupContainers->count(); i++) {
            auto groupContainer = static_cast<cocos2d::CCArray*>(m_groupContainers->objectAtIndex(i));
            auto tag = groupContainer->getTag();
            for (int j = 0; j < groupContainer->count(); j++) {
                auto node = static_cast<cocos2d::CCNode*>(groupContainer->objectAtIndex(j));
                if (node->isVisible() && tag == 0) node->setVisible(false);
            }
        }
    }
    void removeObjectFromGroup(cocos2d::CCObject* object, int group) = win inline, m1 0x1df254, ios inline {
        this->getGroupContainer(group)->removeObject(object);
    }
    void removeObjectFromPage(cocos2d::CCObject* object, int page) = win inline, m1 0x1df100 {
        this->getPageContainer(page)->removeObject(object);
    }
    void resetDisabledValues() = win inline {
        cocos2d::CCDictElement* element;
        cocos2d::CCDictElement* temp;
        HASH_ITER(hh, m_inputNodes->m_pElements, element, temp) {
            auto property = element->getObject()->getTag();
            if (this->getValue(property) == -909190.f) this->updateValue(property, 0.f);
        }
    }
    void setMaxSliderValue(float value, int property) = win inline, m1 0x1e2854 {
        m_maxSliderValues->setObject(cocos2d::CCFloat::create(value), property);
    }
    void setMinSliderValue(float value, int property) = win inline, m1 0x1e27d4, ios inline {
        m_minSliderValues->setObject(cocos2d::CCFloat::create(value), property);
    }
    bool shouldLimitValue(int property) = win inline, imac 0x23dc90, m1 0x1e5530, ios inline {
        return m_shouldLimitValues[property];
    }
    void toggleBG(bool visible) = win inline, imac 0x234dc0, m1 0x1de770 {
        if (auto background = m_mainLayer->getChildByTag(1)) background->setVisible(visible);
    }
    void toggleCustomEaseRateVisibility(int property, int tag) = win 0x47da80, imac 0x23f8d0, m1 0x1e72b4;
    void toggleDisableButtons(bool visible) = win 0x476850, m1 0x2614d8;
    void toggleEaseRateVisibility() = m1 0x1e63fc;
    void toggleLimitValue(int property, bool limit) = win inline, imac 0x23ddf0, m1 0x1e56ac {
        m_shouldLimitValues[property] = limit;
    }
    void togglePageArrows(bool visible) = win inline, imac 0x235120 {
        if (m_prevButton) {
            m_prevButton->setVisible(visible);
            m_prevButton->setEnabled(visible);
            m_nextButton->setVisible(visible);
            m_nextButton->setEnabled(visible);
        }
    }
    void triggerArrowChanged(int property, bool isRight) = win 0x475ad0, imac 0x239380, m1 0x1e1820;
    void triggerArrowLeft(cocos2d::CCObject* sender) = win 0x475a70, m1 0x1e1788;
    void triggerArrowRight(cocos2d::CCObject* sender) = win 0x475aa0, m1 0x1e18b4;
    void triggerSliderChanged(cocos2d::CCObject* sender) = win 0x4759b0, imac 0x239160, m1 0x1e1630;
    void updateCustomEaseLabel(int property, int easingType) = win 0x47d7a0, imac 0x23f7d0, m1 0x1e7174;
    void updateCustomEaseRateLabel(int property, float easingRate) = win 0x47d970, imac 0x23ec50, m1 0x1e6560;
    void updateCustomToggleTrigger(int tag, bool toggled) = win inline, imac 0x23ad60, m1 0x1e3218 {
        if (auto toggle = static_cast<CCMenuItemToggler*>(m_customValueToggles->objectForKey(tag))) {
            toggle->toggle(toggled);
        }
    }
    void updateEaseLabel() = m1 0x1e61b0;
    void updateEaseRateLabel();
    void updateEditorLabel() = m1 0x1e0038;
    void updateInputNodeLabel(int property, gd::string text) = win 0x47bd30;
    void updateLabel(int property, gd::string text) = win inline, imac 0x23ada0, m1 0x1e3254, ios inline {
        if (auto label = static_cast<cocos2d::CCLabelBMFont*>(m_inputLabels->objectForKey(property))) {
            label->setString(text.c_str());
        }
    }
    void updateMultiTriggerBtn() = win 0x4753f0, m1 0x1dfe7c;
    void updateSlider(int property) = win 0x477ce0, imac 0x23da60, m1 0x1e52fc;
    void updateSlider(int property, float value) = win inline, imac 0x238bd0, m1 0x1e111c {
        if (auto slider = static_cast<Slider*>(m_valueControls->objectForKey(property))) slider->setValue(value);
    }
    void updateSpawnedByTrigger() = win 0x475350, m1 0x1e00b0;
    void updateTouchTriggered() = win 0x475260, m1 0x1e0178;
    void updateValue(int property, float value) = win 0x47bca0, imac 0x23a510, m1 0x1e295c;
    void updateValueControls(int property, float value) = win 0x477910, m1 0x1e194c;
    void valueChanged(int property, float value) = win 0x45eb40, m1 0x1e0454;

    EffectGameObject* m_gameObject;
    cocos2d::CCArray* m_gameObjects;
    bool m_touchTriggered;
    bool m_spawnTriggered;
    CCMenuItemToggler* m_touchToggle;
    CCMenuItemToggler* m_spawnToggle;
    cocos2d::CCArray* m_multiTriggerContainer;
    bool m_multiTriggered;
    float m_width;
    float m_height;
    bool m_disableTextDelegate;
    cocos2d::CCDictionary* m_valueToggles;
    cocos2d::CCDictionary* m_inputNodes;
    cocos2d::CCDictionary* m_valueControls;
    cocos2d::CCDictionary* m_customValueToggles;
    cocos2d::CCDictionary* m_disableButtons;
    cocos2d::CCLabelBMFont* m_easingLabel;
    cocos2d::CCLabelBMFont* m_easingRateLabel;
    CCMenuItemSpriteExtra* m_easingRateButton;
    EasingType m_easingType;
    float m_easingRate;
    cocos2d::CCDictionary* m_inputLabels;
    cocos2d::CCDictionary* m_triggerValues;
    cocos2d::CCDictionary* m_minSliderValues;
    cocos2d::CCDictionary* m_maxSliderValues;
    gd::map<int, bool> m_shouldLimitValues;
    bool m_disableSliderDelegate;
    bool m_effectObjects;
    cocos2d::CCArray* m_pageContainers;
    int m_page;
    float m_easingControlScale;
    cocos2d::CCArray* m_groupContainers;
    cocos2d::CCDictionary* m_customEasingTags;
    cocos2d::CCDictionary* m_customEasingLabels;
    cocos2d::CCDictionary* m_customEasingButtons;
    cocos2d::CCDictionary* m_customEasingScales;
    cocos2d::CCDictionary* m_disabledEasingButtons;
    CCMenuItemSpriteExtra* m_prevButton;
    CCMenuItemSpriteExtra* m_nextButton;
    bool m_hideAll;
}

[[link(android)]]
class SetupZoomTriggerPopup : SetupTriggerPopup {
    // virtual ~SetupZoomTriggerPopup();

    static SetupZoomTriggerPopup* create(EffectGameObject* object, cocos2d::CCArray* objects);

    virtual void determineStartValues() = win 0x28f0a0, m1 0x2aeed4, imac 0x3212a0;
    virtual void onClose(cocos2d::CCObject* sender) = win 0x28f0b0, m1 0x2aeed8, imac 0x3212b0;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects);
}

[[link(android)]]
class SFXBrowser : FLAlertLayer, MusicDownloadDelegate, TableViewCellDelegate, SetTextPopupDelegate, SelectSFXSortDelegate {
    SFXBrowser() {
        m_searchResult = nullptr;
        m_sfxObjects = nullptr;
        m_listLayer = nullptr;
        m_nameLabel = nullptr;
        m_pathLabel = nullptr;
        m_infoLabel = nullptr;
        m_pageLabel = nullptr;
        m_searchLabel = nullptr;
        m_prevButton = nullptr;
        m_refreshButton = nullptr;
        m_clearSearchButton = nullptr;
        m_circleSprite = nullptr;
        m_libraryVersion = 0;
        m_cellAmount = 0;
        m_gettingURL = false;
        m_selectedCell = false;
        m_snapToSelected = false;
        m_compactMode = false;
        m_sortType = AudioSortType::NameAscending;
        m_delegate = nullptr;
        m_autoUpdating = false;
    }
    ~SFXBrowser() = win inline, m1 0x3af8c8 {
        MusicDownloadManager::sharedState()->removeMusicDownloadDelegate(this);
        CC_SAFE_RELEASE(m_sfxObjects);
        CC_SAFE_RELEASE(m_searchResult);
    }

    static SFXBrowser* create(int id) = win inline, imac 0x43df30, m1 0x3af9a4 {
        auto ret = new SFXBrowser();
        if (ret->init(id)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void registerWithTouchDispatcher() = win 0x42660, m1 0x3b2038, imac 0x440930;
    virtual void keyBackClicked() = win 0x480960, m1 0x3b1f88, imac 0x440890;
    virtual void musicActionFinished(GJMusicAction action) = win 0x47f4d0, m1 0x3b16e4, imac 0x43fef0 {}
    virtual void musicActionFailed(GJMusicAction action) = win 0x47f570, m1 0x3b17ac, imac 0x43fff0;
    virtual void sortSelectClosed(SelectSFXSortLayer* layer) = win 0x480090, m1 0x3b1b1c, imac 0x4403c0;
    virtual void setTextPopupClosed(SetTextPopup* popup, gd::string text) = win 0x480370, imac 0x440620, m1 0x3b1d4c;
    virtual bool cellPerformedAction(TableViewCell* cell, int listType, CellAction action, cocos2d::CCNode* parent) = win 0x480410, imac 0x4406e0, m1 0x3b1df8;
    virtual int getSelectedCellIdx() = win 0x480510, imac 0x440850, m1 0x3b1f68;
    virtual bool shouldSnapToSelected() = win 0x480520, imac 0x440870, m1 0x3b1f78;

    bool init(int id) = win 0x47e320;
    void onClearSearch(cocos2d::CCObject* sender) = imac 0x43f3e0;
    void onClose(cocos2d::CCObject* sender) = imac 0x43efb0, m1 0x3b089c;
    void onCredits(cocos2d::CCObject* sender) = m1 0x3b0b60;
    void onExitFolder(cocos2d::CCObject* sender) = win 0x4807d0, imac 0x43f000, m1 0x3b08f4;
    void onPage(cocos2d::CCObject* sender) = win 0x480530, imac 0x43f0c0, m1 0x3b099c;
    void onSearch(cocos2d::CCObject* sender) = win 0x480200, imac 0x43f330, m1 0x3b0c2c;
    void onSorting(cocos2d::CCObject* sender) = win 0x47ff50;
    void onToggleCompactMode(cocos2d::CCObject* sender) = win 0x4800f0;
    void onUpdateLibrary(cocos2d::CCObject* sender) = m1 0x3b0a60;
    void setupList(SFXSearchResult* result) = win 0x47f6b0, imac 0x43f5e0, m1 0x3b0ec0;
    void setupSFXBrowser();
    void trySetupSFXBrowser();
    void updatePageLabel() = win 0x480600, m1 0x3b18bc;

    SFXSearchResult* m_searchResult;
    cocos2d::CCArray* m_sfxObjects;
    GJCommentListLayer* m_listLayer;
    cocos2d::CCLabelBMFont* m_nameLabel;
    cocos2d::CCLabelBMFont* m_pathLabel;
    cocos2d::CCLabelBMFont* m_infoLabel;
    cocos2d::CCLabelBMFont* m_pageLabel;
    cocos2d::CCLabelBMFont* m_searchLabel;
    CCMenuItemSpriteExtra* m_prevButton;
    CCMenuItemSpriteExtra* m_nextButton;
    CCMenuItemSpriteExtra* m_backButton;
    CCMenuItemSpriteExtra* m_refreshButton;
    CCMenuItemSpriteExtra* m_clearSearchButton;
    LoadingCircleSprite* m_circleSprite;
    int m_sfxID;
    int m_libraryVersion;
    int m_cellAmount;
    bool m_gettingURL;
    bool m_selectedCell;
    bool m_snapToSelected;
    bool m_compactMode;
    AudioSortType m_sortType;
    SFXBrowserDelegate* m_delegate;
    bool m_autoUpdating;
}

[[link(android)]]
class SFXBrowserDelegate {
    virtual void sfxBrowserClosed(SFXBrowser* browser) {}
}

[[link(android)]]
class SFXFolderObject : SFXInfoObject {
    SFXFolderObject() {
        m_sfxObjects = nullptr;
    }
    ~SFXFolderObject() = win inline, m1 0x4e21fc {
        CC_SAFE_RELEASE(m_sfxObjects);
    }

    static SFXFolderObject* create(int id, gd::string name, int folderID) = win inline, imac 0x595fc0, m1 0x4dffa0 {
        auto ret = new SFXFolderObject();
        if (ret->init(id, name, folderID)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init(int id, gd::string name, int folderID) = win inline, imac 0x5989f0, m1 0x4e233c {
        if (!SFXInfoObject::init(id, name, folderID, 0, 0)) return false;
        m_sfxObjects = cocos2d::CCArray::create();
        m_sfxObjects->retain();
        return true;
    }

    cocos2d::CCArray* m_sfxObjects;
}

[[link(android)]]
class SFXInfoObject : cocos2d::CCObject {
    // virtual ~SFXInfoObject();
    SFXInfoObject() {
        m_sfxID = 0;
        m_folderID = 0;
        m_size = 0;
        m_duration = 0;
        m_folder = false;
        m_unk049 = false;
    }

    static SFXInfoObject* create(int id, gd::string name, int folderID, int size, int duration) = win inline, imac 0x595ec0, m1 0x4dfe94 {
        auto ret = new SFXInfoObject();
        if (ret->init(id, name, folderID, size, duration)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    gd::string getLowerCaseName() = win inline, imac 0x598820 {
        gd::string name = m_name;
        for (int i = 0; i < name.size(); i++) {
            name[i] = tolower(name[i]);
        }
        return name;
    }
    bool init(int id, gd::string name, int folderID, int size, int duration) = win inline, imac 0x5987d0, m1 0x4e20ec, ios inline {
        m_sfxID = id;
        m_name = name;
        m_folderID = folderID;
        m_size = size;
        m_duration = duration;
        m_folder = false;
        return true;
    }

    int m_sfxID;
    int m_folderID;
    int m_size;
    int m_duration;
    bool m_folder;
    bool m_unk049;
    gd::string m_name;
}

[[link(android)]]
class SFXSearchResult : MusicSearchResult {
    // virtual ~SFXSearchResult();

    static SFXSearchResult* create(int folderID) = win 0x3479f0, imac 0x59a1c0, m1 0x4e3730;

    virtual void updateObjects(AudioSortType type) = win 0x347a70, imac 0x59a2e0, m1 0x4e3830;

    SFXFolderObject* getActiveFolder() = win inline, imac 0x59a2d0, m1 0x4e3828 {
        return m_folderObject;
    }
    int getSelectedPage(int id, int count) = win 0x347fd0, m1 0x4e40c8;
    bool init(int folderID) = win inline, imac 0x59a250, m1 0x4e37b4, ios inline {
        if (!MusicSearchResult::init(GJSongType::Music)) return false;
        m_folderID = folderID;
        m_audioType = 1;
        return true;
    }
    void setActiveFolder(SFXFolderObject* folder) = win inline, imac 0x59a270 {
        if (folder != m_folderObject) {
            CC_SAFE_RELEASE(m_folderObject);
            CC_SAFE_RETAIN(folder);
            m_folderObject = folder;
        }
        else if (!folder) {
            CC_SAFE_RELEASE_NULL(m_folderObject);
        }
    }

    int m_folderID;
    SFXFolderObject* m_folderObject;
}

[[link(android)]]
class SFXTriggerGameObject : EffectGameObject {
    // virtual ~SFXTriggerGameObject();
    SFXTriggerGameObject() = win 0x495fa0 {
        m_soundID = 0;
        m_pitch = 0.f;
        m_speed = 0;
        m_pitchIndex = 0;
        m_fadeIn = 0;
        m_end = 0;
        m_fadeOut = 0;
        m_reverb = false;
        m_fastFourierTransform = false;
        m_loop = false;
        m_stopLoop = false;
        m_dontReset = false;
        m_unique = false;
        m_override = false;
        m_sfxUniqueID = 0;
        m_minDistNear = 0;
        m_minDistMedium = 0;
        m_minDistFar = 0;
        m_proximityMode = 0;
        m_cameraDistance = false;
        m_preload = false;
        m_ignoreVolumeTest = false;
        m_minInterval = 0.f;
        m_sfxGroup = 0;
        m_stop = false;
        m_changeSpeed = false;
        m_changeVolume = false;
        m_groupID = 0;
        m_unk788 = 0;
        m_reverbPreset = FMODReverbPreset::Generic;
        m_reverbEnabled = false;
        m_soundDuration = 0.f;
        m_applyDisabled = false;
        m_speedVariance = 0;
        m_pitchVariance = 0;
        m_volumeVariance = 0.f;
        m_pitchSteps = false;
        m_volume = 1.f;
        m_start = 0;
        m_volumeNear = 1.f;
        m_volumeMedium = .5f;
        m_volumeFar = 0.f;
    }

    static SFXTriggerGameObject* create(char const* frame) = win inline, m1 0x180320 {
        auto ret = new SFXTriggerGameObject();
        if (ret->init(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4b77b0, m1 0x184a74, imac 0x1cf610;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x4b6250, m1 0x1804e8, imac 0x1c9960;

    int getSFXRefID() = win inline, imac 0x1c9940, m1 0x1804c8 {
        return m_sfxUniqueID > 0 ? m_sfxUniqueID : m_uniqueID;
    }
    int getUniqueSFXID() = win inline {
        return m_unique ? this->getSFXRefID() : 0;
    }
    bool init(char const* frame) = win inline, ios inline {
        return EffectGameObject::init(frame);
    }

    gd::string m_soundPath;
    // property 392
    int m_soundID;
    float m_pitch;
    // property 404
    int m_speed;
    // property 405
    int m_pitchIndex;
    // property 406
    float m_volume;
    // property 408
    int m_start;
    // property 409
    int m_fadeIn;
    // property 410
    int m_end;
    // property 411
    int m_fadeOut;
    // property 407
    bool m_reverb;
    // property 412
    bool m_fastFourierTransform;
    // property 413
    bool m_loop;
    // property 414
    bool m_stopLoop;
    // property 595
    bool m_dontReset;
    // property 415
    bool m_unique;
    // property 420
    bool m_override;
    // property 416
    int m_sfxUniqueID;
    // property 421
    float m_volumeNear;
    // property 422
    float m_volumeMedium;
    // property 423
    float m_volumeFar;
    // property 424
    int m_minDistNear;
    // property 425
    int m_minDistMedium;
    // property 426
    int m_minDistFar;
    // property 458
    int m_proximityMode;
    // property 428
    bool m_cameraDistance;
    // property 433
    bool m_preload;
    // property 489
    bool m_ignoreVolumeTest;
    // property 434
    float m_minInterval;
    // property 455
    int m_sfxGroup;
    // property 417
    bool m_stop;
    // property 418
    bool m_changeSpeed;
    // property 419
    bool m_changeVolume;
    // property 457
    int m_groupID;
    int m_unk788;
    // property 502
    FMODReverbPreset m_reverbPreset;
    // property 503
    bool m_reverbEnabled;
    // property 490
    float m_soundDuration;
    bool m_applyDisabled;
    // property 596
    int m_speedVariance;
    // property 597
    int m_pitchVariance;
    // property 598
    float m_volumeVariance;
    // property 599
    bool m_pitchSteps;
}

[[link(android)]]
class ShaderGameObject : EffectGameObject {
    // virtual ~ShaderGameObject();
    ShaderGameObject() {
        m_speed = 1.f;
        m_strength = 1.f;
        m_outer = 1.f;
        m_timeOff = 0.f;
        m_waveWidth = 1.f;
        m_targetX = 1.f;
        m_targetY = 1.f;
        m_fadeIn = 1.f;
        m_fadeOut = 1.f;
        m_screenOffsetX = 0.f;
        m_screenOffsetY = 0.f;
        m_invert = false;
        m_inner = 0.f;
        m_maxSize = 0.f;
        m_flip = false;
        m_rotate = false;
        m_dual = false;
        m_useX = false;
        m_useY = false;
        m_snapGrid = false;
        m_hardEdges = false;
        m_disableAll = false;
        m_zLayerMin = 0;
        m_zLayerMax = 0;
        m_animate = false;
        m_relative = false;
        m_editorDisabled = false;
    }

    static ShaderGameObject* create(char const* frame) = win inline, imac 0x19cda0, m1 0x15c0f8 {
        auto ret = new ShaderGameObject();
        if (ret->init(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void customSetup() = win 0x4997d0, m1 0x15c250, imac 0x19cf00;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x49aa50, m1 0x15fd60, imac 0x1a1e30;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x499830, m1 0x15c2a8, imac 0x19cf70;

    bool init(char const* frame) = win inline, m1 0x15c208, ios inline {
        return EffectGameObject::init(frame);
    }

    // property 175
    float m_speed;
    // property 176
    float m_strength;
    // property 191
    float m_outer;
    // property 177
    float m_timeOff;
    // property 179
    float m_waveWidth;
    // property 180
    float m_targetX;
    // property 189
    float m_targetY;
    // property 181
    float m_fadeIn;
    // property 182
    float m_fadeOut;
    // property 290
    float m_screenOffsetX;
    // property 291
    float m_screenOffsetY;
    // property 184
    bool m_invert;
    // property 183
    float m_inner;
    // property 512
    float m_maxSize;
    // property 185
    bool m_flip;
    // property 186
    bool m_rotate;
    // property 187
    bool m_dual;
    // property 188
    bool m_useX;
    // property 190
    bool m_useY;
    // property 194
    bool m_snapGrid;
    // property 515
    bool m_hardEdges;
    // property 192
    bool m_disableAll;
    // property 196
    int m_zLayerMin;
    // property 197
    int m_zLayerMax;
    // property 513
    bool m_animate;
    // property 514
    bool m_relative;
    // property 531
    bool m_editorDisabled;
}

[[link(android), depends(GJShaderState)]]
class ShaderLayer : cocos2d::CCLayer {
    ShaderLayer() {
        m_timesyncShaderActions = false;
        m_shader = nullptr;
        m_renderTexture = nullptr;
        m_sprite = nullptr;
        m_antiAlias = false;
        m_configuredAntiAlias = false;
        m_gameLayer = nullptr;
        m_savedCameraRotation = 0.f;
        m_shockWaveTimeMult = 1.f;
        m_scaleFactor = 1.f;
    }
    ~ShaderLayer() = win inline, m1 0x34b1e0 {
        CC_SAFE_RELEASE(m_renderTexture);
    }

    static ShaderLayer* create() = win inline, imac 0x3ca180, m1 0x34b334 {
        auto ret = new ShaderLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x481920, m1 0x34b3b4, imac 0x3ca1e0;
    virtual void update(float dt) = win 0x4826d0, imac 0x3cba50, m1 0x34cb88;
    virtual void visit() = win 0x4886f0, m1 0x351b24, imac 0x3d1740;

    cocos2d::CCPoint objectPosToShaderPos(cocos2d::CCPoint position) = win 0x482a00, imac 0x3cbe30, m1 0x34cf00;
    void performCalculations() = win 0x487d40;
    void preBulgeShader() = win inline, imac 0x3d0770, m1 0x350d50 {
        if (m_state.m_bulgeValue <= 0.f) {
            if (this->getActionByTag(21)) {
                m_state.m_usesShaders = true;
            }
            m_sprite->getShaderProgram()->setUniformLocationWith1f(m_bulgeValueUniform, 0.f);
        }
    }
    void preChromaticGlitchShader() = win 0x4859b0;
    void preChromaticShader() = win inline, imac 0x3cefb0, m1 0x34f7fc {
        if (m_state.m_chromaticTargetX != 0.f || m_state.m_chromaticTargetY != 0.f || this->getActionByTag(1) || this->getActionByTag(2)) {
            m_state.m_usesShaders = true;
        }
        auto scale = m_state.m_chromaticRelative && m_gameLayer ? abs(m_gameLayer->m_objectLayer->getScale()) : 1.f;
        auto shaderProgram = m_sprite->getShaderProgram();
        shaderProgram->setUniformLocationWith1f(m_chromaticXOffUniform, (m_scaleFactor / 1.2018504f) * m_state.m_chromaticTargetX * m_state.m_textureScaleX * scale);
        shaderProgram->setUniformLocationWith1f(m_chromaticYOffUniform, (m_scaleFactor / 1.2018504f) * m_state.m_chromaticTargetY * m_state.m_textureScaleY * scale);
    }
    void preColorChangeShader() = win inline, imac 0x3d0f30, m1 0x351498 {
        auto shaderProgram = m_sprite->getShaderProgram();
        if (m_state.m_colorChangeCR != 1.f || m_state.m_colorChangeCG != 1.f || m_state.m_colorChangeCB != 1.f ||
            m_state.m_colorChangeBR != 0.f || m_state.m_colorChangeBG != 0.f || m_state.m_colorChangeBB != 0.f) {
            m_state.m_usesShaders = true;
            shaderProgram->setUniformLocationWith3f(m_colorChangeCUniform, std::max(m_state.m_colorChangeCR, .001f), m_state.m_colorChangeCG, m_state.m_colorChangeCB);
            shaderProgram->setUniformLocationWith3f(m_colorChangeBUniform, m_state.m_colorChangeBR, m_state.m_colorChangeBG, m_state.m_colorChangeBB);
        }
        else {
            shaderProgram->setUniformLocationWith3f(m_colorChangeCUniform, 0.f, 0.f, 0.f);
            if (this->getActionByTag(42) || this->getActionByTag(43) || this->getActionByTag(44) || this->getActionByTag(39) || this->getActionByTag(40) || this->getActionByTag(41)) {
                m_state.m_usesShaders = true;
            }
        }
    }
    void preCommonShader() = win inline, imac 0x3cbc60, m1 0x34cd94 {
        auto shaderProgram = m_sprite->getShaderProgram();
        shaderProgram->setUniformLocationWith3f(m_blurRefColorUniform, m_state.m_blurRefColor.r / 255.f, m_state.m_blurRefColor.g / 255.f, m_state.m_blurRefColor.b / 255.f);
        shaderProgram->setUniformLocationWith1f(m_blurUseRefUniform, m_state.m_minBlendingLayer > 1);
        shaderProgram->setUniformLocationWith1f(m_blurIntensityUniform, m_state.m_blurIntensity + 1.f);
        shaderProgram->setUniformLocationWith2f(m_textureScaleUniform, m_state.m_textureScaleX, m_state.m_textureScaleY);
        shaderProgram->setUniformLocationWith2f(m_textureScaleInvUniform, 1.f / m_state.m_textureScaleX, 1.f / m_state.m_textureScaleY);
        shaderProgram->setUniformLocationWith1f(m_blurOnlyEmptyUniform, m_state.m_minBlendingLayer > 1 && m_state.m_blurOnlyEmpty);
        shaderProgram->setUniformLocationWith1f(m_screenAspectINVUniform, m_screenSize.height / m_screenSize.width);
        shaderProgram->setUniformLocationWith1f(m_shaderPositionUniform, m_screenSize.width / m_screenSize.height);
    }
    void preGlitchShader() = win 0x485240;
    void preGrayscaleShader() = win inline, imac 0x3d0a30, m1 0x35100c {
        if (m_state.m_grayscaleValue > 0.f || this->getActionByTag(32)) {
            m_state.m_usesShaders = true;
        }
        auto shaderProgram = m_sprite->getShaderProgram();
        shaderProgram->setUniformLocationWith1f(m_grayscaleValueUniform, m_state.m_grayscaleValue);
        if (m_state.m_grayscaleValue > 0.f) {
            shaderProgram->setUniformLocationWith1f(m_grayscaleUseLumUniform, m_state.m_grayscaleUseLum);
            shaderProgram->setUniformLocationWith3f(m_grayscaleTintUniform, m_state.m_grayscaleTint.r / 255.f, m_state.m_grayscaleTint.g / 255.f, m_state.m_grayscaleTint.b / 255.f);
        }
    }
    void preHueShiftShader() = win inline, imac 0x3d0d80, m1 0x3512ec {
        if (m_state.m_hueShiftDegrees != 0.f || this->getActionByTag(38)) {
            m_state.m_usesShaders = true;
        }
        auto radians = m_state.m_hueShiftDegrees * (M_PI / 180.f);
        auto shaderProgram = m_sprite->getShaderProgram();
        shaderProgram->setUniformLocationWith1f(m_hueShiftCosAUniform, cosf(radians));
        shaderProgram->setUniformLocationWith1f(m_hueShiftSinAUniform, sinf(radians));
    }
    void preInvertColorShader() = win inline, imac 0x3d0c90, m1 0x351220 {
        if (m_state.m_invertColorEditRGB > 0.f || this->getActionByTag(34)) {
            m_state.m_usesShaders = true;
        }
        auto shaderProgram = m_sprite->getShaderProgram();
        auto edit = m_state.m_invertColorEditRGB;
        auto r = edit * m_state.m_invertColorR;
        auto g = edit * m_state.m_invertColorG;
        auto b = edit * m_state.m_invertColorB;
        if (m_state.m_invertColorClampRGB) {
            r = std::min(r, 1.f);
            g = std::min(g, 1.f);
            b = std::min(b, 1.f);
        }
        shaderProgram->setUniformLocationWith4f(m_invertColorValueUniform, r, g, b, edit);
    }
    void preLensCircleShader() = win 0x4864f0, imac 0x3cfda0;
    void preMotionBlurShader() = win 0x4869c0, imac 0x3d0320, m1 0x3509b0;
    cocos2d::CCPoint prepareTargetContainer() = win 0x485ee0, imac 0x3cf920, m1 0x35003c;
    void prePinchShader() = win inline {
        if (m_state.m_pinchTargetX != 0.0 || m_state.m_pinchTargetY != 0.0 || this->getActionByTag(25) || this->getActionByTag(26)) {
            m_state.m_usesShaders = true;
        }
    }
    void prePixelateShader() = win 0x485d30, imac 0x3cf6c0, m1 0x34fe58;
    void preRadialBlurShader() = win inline, imac 0x3d0070, m1 0x35046c {
        if (m_state.m_radialBlurSize != 0.f || this->getActionByTag(16)) {
            m_state.m_usesShaders = true;
        }
        auto shaderProgram = m_sprite->getShaderProgram();
        shaderProgram->setUniformLocationWith1f(m_radialBlurValueUniform, m_state.m_radialBlurSize / 45.f);
        if (m_state.m_radialBlurSize != 0.f) {
            shaderProgram->setUniformLocationWith1f(m_blurFadeUniform, std::clamp(m_state.m_radialBlurFade * .2f, .0f, .2f));
        }
    }
    void preSepiaShader() = win inline, imac 0x3d0b50, m1 0x3510f8 {
        if (m_state.m_sepiaValue > 0.f || this->getActionByTag(33)) {
            m_state.m_usesShaders = true;
        }
        m_sprite->getShaderProgram()->setUniformLocationWith1f(m_sepiaValueUniform, m_state.m_sepiaValue);
    }
    void preShockLineShader() = win 0x484d30, imac 0x3ce4f0, m1 0x34ef1c;
    void preShockWaveShader() = win 0x4841e0, imac 0x3cde40, m1 0x34e9c8;
    void preSplitScreenShader() = win 0x487a20, imac 0x3d1140, m1 0x351628;
    bool resetAllShaders() = win 0x489260, m1 0x351e7c;
    void resetTargetContainer() = win inline {
        if (m_gameLayer) {
            auto parent = m_state.m_minBlendingLayer < 2 ? m_gameLayer->m_objectParent : m_gameLayer->m_inShaderParent;
            parent->setPosition(m_savedCameraPosition);
            parent->setScale(1.f);
            parent->setRotation(m_savedCameraRotation);
            this->setRotation(0.f);
        }
    }
    void setupBulgeShader() = win inline {
        auto program = m_sprite->getShaderProgram()->getProgram();
        m_bulgeValueUniform = glGetUniformLocation(program, "_bulgeValue");
        m_bulgeValue2Uniform = glGetUniformLocation(program, "_bulgeValue2");
        m_bulgeOriginUniform = glGetUniformLocation(program, "_bulgeOrigin");
        m_bulgeRadiusUniform = glGetUniformLocation(program, "_bulgeRadius");
    }
    void setupChromaticGlitchUniforms() = win inline {
        auto program = m_sprite->getShaderProgram()->getProgram();
        m_cGRGBOffsetUniform = glGetUniformLocation(program, "_cGRGBOffset");
        m_cGYOffsetUniform = glGetUniformLocation(program, "_cGYOffset");
        m_cGTimeUniform = glGetUniformLocation(program, "_cGTime");
        m_cGStrengthUniform = glGetUniformLocation(program, "_cGStrength");
        m_cGHeightUniform = glGetUniformLocation(program, "_cGHeight");
        m_cGLineThickUniform = glGetUniformLocation(program, "_cGLineThick");
        m_cGLineStrengthUniform = glGetUniformLocation(program, "_cGLineStrength");
    }
    void setupChromaticUniforms() = win inline {
        auto program = m_sprite->getShaderProgram()->getProgram();
        m_chromaticXOffUniform = glGetUniformLocation(program, "_chromaticXOff");
        m_chromaticYOffUniform = glGetUniformLocation(program, "_chromaticYOff");
    }
    void setupColorChangeShader() = win inline {
        auto program = m_sprite->getShaderProgram()->getProgram();
        m_colorChangeCUniform = glGetUniformLocation(program, "_colorChangeC");
        m_colorChangeBUniform = glGetUniformLocation(program, "_colorChangeB");
    }
    void setupCommonUniforms();
    void setupGlitchUniforms() = win inline, m1 0x34c2b0 {
        auto program = m_sprite->getShaderProgram()->getProgram();
        m_glitchBotUniform = glGetUniformLocation(program, "_glitchBot");
        m_glitchTopUniform = glGetUniformLocation(program, "_glitchTop");
        m_glitchXOffsetUniform = glGetUniformLocation(program, "_glitchXOffset");
        m_glitchColOffsetUniform = glGetUniformLocation(program, "_glitchColOffset");
        m_glitchRndUniform = glGetUniformLocation(program, "_glitchRnd");
    }
    void setupGrayscaleShader() = win inline, m1 0x34c834 {
        auto program = m_sprite->getShaderProgram()->getProgram();
        m_grayscaleValueUniform = glGetUniformLocation(program, "_grayscaleValue");
        m_grayscaleTintUniform = glGetUniformLocation(program, "_grayscaleTint");
        m_grayscaleUseLumUniform = glGetUniformLocation(program, "_grayscaleUseLum");
    }
    void setupHueShiftShader() = win inline, m1 0x34c93c {
        auto program = m_sprite->getShaderProgram()->getProgram();
        m_hueShiftCosAUniform = glGetUniformLocation(program, "_hueShiftCosA");
        m_hueShiftSinAUniform = glGetUniformLocation(program, "_hueShiftSinA");
    }
    void setupInvertColorShader() = win inline, m1 0x34c8fc, ios inline {
        m_invertColorValueUniform = glGetUniformLocation(m_sprite->getShaderProgram()->getProgram(), "_invertColorValue");
    }
    void setupLensCircleShader() = win inline, m1 0x34c4fc {
        auto program = m_sprite->getShaderProgram()->getProgram();
        m_lensCircleOriginUniform = glGetUniformLocation(program, "_lensCircleOrigin");
        m_lensCircleStartUniform = glGetUniformLocation(program, "_lensCircleStart");
        m_lensCircleEndUniform = glGetUniformLocation(program, "_lensCircleEnd");
        m_lensCircleStrengthUniform = glGetUniformLocation(program, "_lensCircleStrength");
        m_lensCircleTintUniform = glGetUniformLocation(program, "_lensCircleTint");
        m_lensCircleAdditiveUniform = glGetUniformLocation(program, "_lensCircleAdditive");
    }
    void setupMotionBlurShader() = win inline, m1 0x34c7ac {
        auto program = m_sprite->getShaderProgram()->getProgram();
        m_motionBlurValueUniform = glGetUniformLocation(program, "_motionBlurValue");
        m_motionBlurMultUniform = glGetUniformLocation(program, "_motionBlurMult");
        m_motionBlurDualUniform = glGetUniformLocation(program, "_motionBlurDual");
    }
    void setupPinchShader() = win inline {
        auto program = m_sprite->getShaderProgram()->getProgram();
        m_pinchValueUniform = glGetUniformLocation(program, "_pinchValue");
        m_pinchCenterPosUniform = glGetUniformLocation(program, "_pinchCenterPos");
        m_pinchCalcUniform = glGetUniformLocation(program, "_pinchCalc1");
        m_pinchRadiusUniform = glGetUniformLocation(program, "_pinchRadius");
    }
    void setupRadialBlurShader() = win inline {
        auto program = m_sprite->getShaderProgram()->getProgram();
        m_radialBlurCenterUniform = glGetUniformLocation(program, "_radialBlurCenter");
        m_radialBlurValueUniform = glGetUniformLocation(program, "_radialBlurValue");
    }
    void setupSepiaShader() = win inline, m1 0x34c8bc, ios inline {
        m_sepiaValueUniform = glGetUniformLocation(m_sprite->getShaderProgram()->getProgram(), "_sepiaValue");
    }
    void setupShader(bool reset) = win 0x481a30, imac 0x3ca2a0, m1 0x34b474;
    void setupShockLineUniforms();
    void setupShockWaveUniforms();
    void setupSplitScreenShader();
    void toggleAntiAlias(bool antiAlias) = win 0x482660;
    void triggerBulge(float fadeTime, float bulge, float screenOffsetX, float screenOffsetY, float radius, int targetID, int easingType, float easingRate, bool relative) = win 0x486cd0, imac 0x3d06a0, m1 0x350c84;
    void triggerChromaticGlitch(bool enable, float duration, float speed, float strength, float rgbOffset, float lineThickness, float lineStrength, float segmentHeight, int easingType, float easingRate, bool relative, bool relativePos) = win 0x485690, m1 0x34f908;
    void triggerChromaticX(float fadeTime, float targetX, int easingType, float easingRate, bool relative) = win inline, imac 0x3cef50, m1 0x34f784 {
        this->tweenValueAuto(targetX, 1, fadeTime, easingType, easingRate);
        m_state.m_chromaticRelative = relative;
    }
    void triggerChromaticY(float fadeTime, float targetY, int easingType, float easingRate, bool relative) = win inline, imac 0x3cef80, m1 0x34f7c0 {
        this->tweenValueAuto(targetY, 2, fadeTime, easingType, easingRate);
        m_state.m_chromaticRelative = relative;
    }
    void triggerColorChange(float fadeTime, float cr, float cg, float cb, float br, float bg, float bb, int easingType, float easingRate) = win 0x4875a0, imac 0x3d0e40, m1 0x35139c;
    void triggerGlitch(float fadeTime, float strength, float speed, float sliceHeight, float maxSliceXOff, float maxColXOff, float maxColYOff, bool relative) = win inline, imac 0x3ce960, m1 0x34f298 {
        this->tweenValueAuto(strength, 49, fadeTime, 0, 0.f);
        m_state.m_glitchSpeed = speed;
        m_state.m_glitchSliceHeight = sliceHeight;
        m_state.m_glitchMaxSliceXOff = maxSliceXOff;
        m_state.m_glitchMaxColXOff = maxColXOff;
        m_state.m_glitchMaxColYOff = maxColYOff;
        m_state.m_glitchRelative = relative;
    }
    void triggerGrayscale(float fadeTime, float target, bool useLuminance, int tintChannel, int easingType, float easingRate) = win inline, imac 0x3d0a00, m1 0x350fe8 {
        if (tintChannel > -1) m_state.m_grayscaleTintChannel = tintChannel;
        m_state.m_grayscaleUseLum = useLuminance;
        this->tweenValueAuto(target, 32, fadeTime, easingType, easingRate);
    }
    void triggerHueShift(float fadeTime, float degrees, int easingType, float easingRate) = win inline, imac 0x3d0d60, m1 0x3512d4 {
        this->tweenValueAuto(degrees, 38, fadeTime, easingType, easingRate);
    }
    void triggerInvertColor(float fadeTime, float target, float r, float g, float b, bool editRGB, bool tweenRGB, bool clampRGB, int easingType, float easingRate) = win 0x487320, imac 0x3d0bb0, m1 0x351150;
    void triggerLensCircle(float fadeTime, float size, float fade, float strength, int targetID, int tintChannel, float screenOffsetX, float screenOffsetY, int easingType, float easingRate, bool relative) = win 0x486250, imac 0x3cfc90, m1 0x35035c;
    void triggerMotionBlurX(float fadeTime, float targetX, float intensity, float fade, int targetID, float followEase, bool dualDir, int refChannel, int easingType, float easingRate, bool relative, bool emptyOnly) = win inline, m1 0x350808 {
        m_state.m_blurRefChannel = refChannel;
        this->tweenValueAuto(fade, 48, fadeTime, 0, 0.f);
        this->tweenValueAuto(intensity, 47, fadeTime, 0, 0.f);
        this->tweenValueAuto(targetX, 19, fadeTime, easingType, easingRate);
        m_state.m_blurOnlyEmpty = emptyOnly;
        m_state.m_motionBlurFollowEaseX = followEase;
        m_state.m_motionBlurTargetIDX = targetID;
        m_state.m_motionBlurDual = dualDir;
        m_state.m_motionBlurRelative = relative;
    }
    void triggerMotionBlurY(float fadeTime, float targetY, float intensity, float fade, int targetID, float followEase, bool dualDir, int refChannel, int easingType, float easingRate, bool relative, bool emptyOnly) = win inline, m1 0x3508dc {
        m_state.m_blurRefChannel = refChannel;
        this->tweenValueAuto(fade, 48, fadeTime, 0, 0.f);
        this->tweenValueAuto(intensity, 47, fadeTime, 0, 0.f);
        this->tweenValueAuto(targetY, 20, fadeTime, easingType, easingRate);
        m_state.m_blurOnlyEmpty = emptyOnly;
        m_state.m_motionBlurFollowEaseY = followEase;
        m_state.m_motionBlurTargetIDY = targetID;
        m_state.m_motionBlurDual = dualDir;
        m_state.m_motionBlurRelative = relative;
    }
    void triggerPinchX(float fadeTime, float targetX, float screenOffsetX, float radius, float modifier, bool target, int targetID, int easingType, float easingRate, bool relative) = win 0x486ee0, imac 0x3d07e0, m1 0x350dc0;
    void triggerPinchY(float fadeTime, float targetY, float screenOffsetY, float radius, float modifier, bool target, int targetID, int easingType, float easingRate, bool relative) = win 0x487100, imac 0x3d08c0, m1 0x350ea0;
    void triggerPixelateX(float fadeTime, float targetX, bool snapGrid, bool hardEdges, int easingType, float easingRate, bool relative) = win inline, imac 0x3cf5e0, m1 0x34fd80 {
        m_state.m_pixelateSnapGrid = snapGrid;
        if (m_state.m_pixelateTargetX < 1.f) m_state.m_pixelateTargetX = 1.f;
        this->tweenValueAuto(targetX, 9, fadeTime, easingType, easingRate);
        m_state.m_pixelateRelative = relative;
        m_state.m_pixelateHardEdges = hardEdges;
    }
    void triggerPixelateY(float fadeTime, float targetY, bool snapGrid, bool hardEdges, int easingType, float easingRate, bool relative) = win inline, imac 0x3cf650, m1 0x34fdec {
        m_state.m_pixelateSnapGrid = snapGrid;
        if (m_state.m_pixelateTargetY < 1.f) m_state.m_pixelateTargetY = 1.f;
        this->tweenValueAuto(targetY, 10, fadeTime, easingType, easingRate);
        m_state.m_pixelateRelative = relative;
        m_state.m_pixelateHardEdges = hardEdges;
    }
    void triggerRadialBlur(float fadeTime, float size, float intensity, float fade, int refChannel, float screenOffsetX, float screenOffsetY, bool target, int targetID, int easingType, float easingRate, bool emptyOnly) = win 0x486720, imac 0x3cff70, m1 0x3505fc;
    void triggerSepia(float fadeTime, float target, int easingType, float easingRate) = win inline, imac 0x3d0b30, m1 0x3510e0 {
        this->tweenValueAuto(target, 33, fadeTime, easingType, easingRate);
    }
    void triggerShockLine(float speed, float thickness, bool rotate, bool flip, bool dual, bool invert, float strength, float waveWidth, float fadeIn, float fadeOut, float timeOffset, float screenOffset, int targetID, bool target, bool follow, bool relative, float maxSize, bool animate, float fadeTime, int easingType, float easingRate) = win 0x484680, imac 0x3ce290, m1 0x34ed2c;
    void triggerShockWave(float speed, float thickness, float strength, float waveWidth, float fadeIn, float fadeOut, float timeOffset, bool invert, float inner, float screenOffsetX, float screenOffsetY, int targetID, bool target, bool follow, bool relative, float outer, float maxSize, bool animate, float fadeTime, int easingType, float easingRate) = win 0x483a20, imac 0x3cd4d0, m1 0x34e084;
    void triggerSplitScreenCols(float fadeTime, float targetX, int easingType, float easingRate) = win inline, imac 0x3d1120, m1 0x351610 {
        this->tweenValueAuto(targetX, 46, fadeTime, easingType, easingRate);
    }
    void triggerSplitScreenRows(float fadeTime, float targetY, int easingType, float easingRate) = win inline, imac 0x3d1100, m1 0x3515f8 {
        this->tweenValueAuto(targetY, 45, fadeTime, easingType, easingRate);
    }
    void tweenValue(float fromValue, float toValue, int action, float duration, int easingType, float easingRate) = win 0x4890d0, imac 0x3d19e0, ios inline {
        m_state.tweenValue(fromValue, toValue, action, duration, easingType, easingRate);
    }
    void tweenValueAuto(float value, int action, float duration, int easingType, float easingRate) = win 0x4889d0, m1 0x34e2b8;
    void updateEffectOffsets(cocos2d::CCPoint center) = win 0x482bc0;
    void updateMotionBlurSpeedX(float x, float dt) = win inline, m1 0x350c1c {
        auto divisor = m_state.m_motionBlurFollowEaseX;
        if (divisor > 1.f) {
            if (dt > 0.f) divisor /= dt;
            m_state.m_motionBlurSpeedX += (x - m_state.m_motionBlurSpeedX) / divisor;
        }
        else m_state.m_motionBlurSpeedX = x;
    }
    void updateMotionBlurSpeedY(float y, float dt) = win inline, m1 0x350c50 {
        auto divisor = m_state.m_motionBlurFollowEaseY;
        if (divisor > 1.f) {
            if (dt > 0.f) divisor /= dt;
            m_state.m_motionBlurSpeedY += (y - m_state.m_motionBlurSpeedY) / divisor;
        }
        else m_state.m_motionBlurSpeedY = y;
    }
    void updateShockLineCenter(cocos2d::CCPoint center) = win inline {
        if (m_state.m_shockLineCenterDirty) {
            if (!m_state.m_shockLineCenterMoving) m_state.m_shockLineCenterDirty = false;
            m_state.m_shockLineCenter = center;
        }
    }
    void updateShockWaveCenter(cocos2d::CCPoint center) = win inline {
        if (m_state.m_shockWaveCenterDirty) {
            if (!m_state.m_shockWaveCenterMoving) m_state.m_shockWaveCenterDirty = false;
            m_state.m_shockWaveCenter = center;
        }
    }
    bool updateZLayer(int minLayer, int maxLayer, bool noParticles) = win 0x4891e0, m1 0x34bca4;

    GJShaderState m_state;
    bool m_timesyncShaderActions;
    cocos2d::CCGLProgram* m_shader;
    cocos2d::CCRenderTexture* m_renderTexture;
    cocos2d::CCSprite* m_sprite;
    bool m_antiAlias;
    bool m_configuredAntiAlias;
    void* m_unk3d4;
    GJBaseGameLayer* m_gameLayer;
    cocos2d::CCPoint m_savedCameraPosition;
    float m_savedCameraRotation;
    float m_shockWaveTimeMult;
    float m_scaleFactor;
    float m_aspectRatio;
    cocos2d::CCSize m_screenSize;
    cocos2d::CCSize m_textureContentSize;
    cocos2d::CCSize m_targetTextureSize;
    // how much bigger is the texture compared to visibleSize
    cocos2d::CCSize m_targetTextureSizeExtra;
    int m_textureScaleUniform;
    int m_textureScaleInvUniform;
    int m_screenAspectUniform;
    int m_screenAspectINVUniform;
    int m_shaderPositionUniform;
    int m_blurRefColorUniform;
    int m_blurUseRefUniform;
    int m_blurIntensityUniform;
    int m_blurOnlyEmptyUniform;
    int m_shockWaveTimeUniform;
    int m_shockWaveTime1Uniform;
    int m_shockWaveTime2Uniform;
    int m_shockWaveTime3Uniform;
    int m_shockWaveTime4Uniform;
    int m_shockWaveStrengthUniform;
    int m_shockWaveWavesUniform;
    int m_shockWaveCenterUniform;
    int m_shockWaveInvertUniform;
    int m_shockWaveMinSizeUniform;
    int m_shockWaveMaxSizeUniform;
    int m_shockWaveMaxDistValUniform;
    float m_shockWaveTime1;
    float m_shockWaveTime2;
    float m_shockWaveTime3;
    float m_shockWaveTime4;
    float m_shockWaveMaxDistVal;
    float m_shockWaveMinSize;
    float m_shockWaveMaxSize;
    bool m_shockWaveUnk46c;
    int m_shockLineTimeUniform;
    int m_shockLineTime1Uniform;
    int m_shockLineTime2Uniform;
    int m_shockLineTime3Uniform;
    int m_shockLineTime4Uniform;
    int m_shockLineAxisUniform;
    int m_shockLineDirectionUniform;
    int m_shockLineDualUniform;
    int m_shockLineWavesUniform;
    int m_shockLineStrengthUniform;
    int m_shockLineCenterUniform;
    int m_shockLineMaxDistValUniform;
    float m_shockLineTime1;
    float m_shockLineTime2;
    float m_shockLineTime3;
    float m_shockLineTime4;
    float m_shockLineMaxDistVal;
    int m_unk4b4;
    int m_unk4b8;
    int m_unk4bc;
    int m_glitchBotUniform;
    int m_glitchTopUniform;
    int m_glitchXOffsetUniform;
    int m_glitchColOffsetUniform;
    int m_glitchRndUniform;
    int m_chromaticXOffUniform;
    int m_chromaticYOffUniform;
    int m_cGRGBOffsetUniform;
    int m_cGYOffsetUniform;
    int m_cGTimeUniform;
    int m_cGStrengthUniform;
    int m_cGHeightUniform;
    int m_cGLineThickUniform;
    int m_cGLineStrengthUniform;
    int m_lensCircleOriginUniform;
    int m_lensCircleStartUniform;
    int m_lensCircleEndUniform;
    int m_lensCircleStrengthUniform;
    int m_lensCircleTintUniform;
    int m_lensCircleAdditiveUniform;
    int m_radialBlurCenterUniform;
    int m_radialBlurValueUniform;
    int m_blurFadeUniform;
    int m_motionBlurValueUniform;
    int m_motionBlurMultUniform;
    int m_motionBlurDualUniform;
    int m_bulgeValueUniform;
    int m_bulgeValue2Uniform;
    int m_bulgeOriginUniform;
    int m_bulgeRadiusUniform;
    int m_pinchValueUniform;
    int m_pinchCenterPosUniform;
    int m_pinchCalcUniform;
    int m_pinchRadiusUniform;
    int m_grayscaleValueUniform;
    int m_grayscaleTintUniform;
    int m_grayscaleUseLumUniform;
    int m_sepiaValueUniform;
    int m_invertColorValueUniform;
    int m_hueShiftCosAUniform;
    int m_hueShiftSinAUniform;
    int m_colorChangeCUniform;
    int m_colorChangeBUniform;
    int m_rowmodUniform;
    int m_colmodUniform;
    int m_rowmodCalcUniform;
    int m_colmodCalcUniform;
    int m_splitXStartUniform;
    int m_splitXRangeUniform;
    int m_splitXRangeMultUniform;
    int m_splitYStartUniform;
    int m_splitYRangeUniform;
    int m_splitYRangeMultUniform;
}

[[link(android)]]
class ShardsPage : FLAlertLayer {
    ShardsPage() {
        m_pages = nullptr;
        m_prevButton = nullptr;
        m_nextButton = nullptr;
        m_tierSprite = nullptr;
        m_page = -1;
    }
    ~ShardsPage() = win inline {
        CC_SAFE_RELEASE(m_pages);
    }

    static ShardsPage* create() = win inline, m1 0x4248f8 {
        auto ret = new ShardsPage();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x489790, m1 0x4249f8, imac 0x4c55d0;
    virtual void registerWithTouchDispatcher() = win 0x42660, m1 0x4266e4, imac 0x4c74c0;
    virtual void keyBackClicked() = win 0x846c0, m1 0x426668, imac 0x4c7450;
    virtual void show() = win 0x86810, m1 0x4264dc, imac 0x4c72c0;

    void FLAlert_Clicked(FLAlertLayer* alert, bool btn2) = win inline, ios inline {}
    void goToPage(int page) = win inline, m1 0x426390 {
        if (page < 4 && page != m_page) {
            m_page = page;
            for (int i = 0; i < m_pages->count(); i++) {
                auto arr = static_cast<cocos2d::CCArray*>(m_pages->objectForKey(i));
                for (auto obj : geode::cocos::CCArrayExt<cocos2d::CCObject*, false>(arr)) {
                    static_cast<cocos2d::CCNode*>(obj)->setVisible(i == page);
                }
            }
            m_prevButton->setVisible(m_page > 0);
            m_nextButton->setVisible(m_page < 3);
            m_tierSprite->setDisplayFrame(cocos2d::CCSpriteFrameCache::sharedSpriteFrameCache()->spriteFrameByName(page > 1 ? "tier2Icon_001.png" : "tier1Icon_001.png"));
        }
    }
    void onClose(cocos2d::CCObject* sender) = win 0x84690, imac 0x4c70e0, m1 0x4262dc;
    void onIconInfo(cocos2d::CCObject* sender) = win 0x48c780, imac 0x4c7110, m1 0x426318;
    void onSwitchPage(cocos2d::CCObject* sender) = m1 0x426350;

    cocos2d::CCDictionary* m_pages;
    CCMenuItemSpriteExtra* m_prevButton;
    CCMenuItemSpriteExtra* m_nextButton;
    cocos2d::CCSprite* m_tierSprite;
    int m_page;
}

[[link(android)]]
class ShareCommentDelegate {
    virtual void shareCommentClosed(gd::string text, ShareCommentLayer* layer) {}
}

[[link(android)]]
class ShareCommentLayer : FLAlertLayer, TextInputDelegate, UploadActionDelegate, UploadPopupDelegate {
    // virtual ~ShareCommentLayer();

    static ShareCommentLayer* create(gd::string title, int charLimit, CommentType type, int ID, gd::string desc) = win 0x48caa0, imac 0x5df240, m1 0x4a7468;

    virtual void registerWithTouchDispatcher() = win 0x42660, m1 0x50ba38, imac 0x5e0dd0;
    virtual void keyBackClicked() = win 0x48e2e0, imac 0x5e0d20, m1 0x50b990;
    virtual void textInputOpened(CCTextInputNode* node) = win inline, imac 0x5e0f80, m1 0x50bbec {}
    virtual void textInputClosed(CCTextInputNode* node) = win 0x48e330, imac 0x5e0e10, m1 0x50ba70;
    virtual void textChanged(CCTextInputNode* node) = win 0x48e470, imac 0x5e0fa0, m1 0x50bbf4;
    virtual void uploadActionFinished(int id, int response) = win 0x48e6c0, m1 0x50be70, imac 0x5e1200;
    virtual void uploadActionFailed(int id, int response) = win 0x48e750, m1 0x50bfa8, imac 0x5e1300;
    virtual void onClosePopup(UploadActionPopup* popup) = win 0x48e800, m1 0x50c108, imac 0x5e1420;

    bool init(gd::string title, int charLimit, CommentType type, int ID, gd::string desc) = win 0x48ccb0;
    void onClear(cocos2d::CCObject* sender) = win 0x2c3790, m1 0x50b4bc;
    void onClose(cocos2d::CCObject* sender) = win 0x48e2a0, imac 0x5e08d0, m1 0x50b574;
    void onPercent(cocos2d::CCObject* sender) = win 0x48de00, imac 0x5e06a0, m1 0x50b320;
    void onShare(cocos2d::CCObject* sender) = win 0x48df00, m1 0x50b5c8;
    void updateCharCountLabel() = win inline, imac 0x5e10f0 {
        if (m_charLimit * .9f <= m_descText.size()) {
            m_charCountLabel->setColor({ 255, 0, 0 });
            m_charCountLabel->setOpacity(255);
        } else if (m_charLimit * .7f <= m_descText.size()) {
            m_charCountLabel->setColor({ 0, 0, 0 });
            m_charCountLabel->setOpacity(255);
        } else {
            m_charCountLabel->setColor({ 0, 0, 0 });
            m_charCountLabel->setOpacity(125);
        }
        m_charCountLabel->setString(cocos2d::CCString::createWithFormat("%i", m_charLimit - m_descText.size())->getCString());
    }
    void updateDescText(gd::string desc) = win 0x48e590, imac 0x5e0cf0, m1 0x50b968, ios inline {
        m_descText = desc;
        this->updateCharCountLabel();
    }
    void updatePercentLabel() = win 0x48de20;

    int m_charLimit;
    int m_itemID;
    CommentType m_commentType;
    CCTextInputNode* m_commentInput;
    gd::string m_descText;
    gd::string m_placeholderText;
    cocos2d::CCLabelBMFont* m_charCountLabel;
    cocos2d::CCLabelBMFont* m_percentLabel;
    UploadActionPopup* m_uploadPopup;
    bool m_uploadSuccess;
    bool m_percentEnabled;
    int m_percent;
    ShareCommentDelegate* m_delegate;
}

[[link(android)]]
class ShareLevelLayer : FLAlertLayer {
    ShareLevelLayer() {
        m_level = nullptr;
        m_starsRequested = 0;
        m_starButtons = nullptr;
    }
    ~ShareLevelLayer() = win inline {
        CC_SAFE_RELEASE(m_level);
        CC_SAFE_RELEASE(m_starButtons);
    }

    static ShareLevelLayer* create(GJGameLevel* level) = win inline, imac 0x27fbd0 {
        auto ret = new ShareLevelLayer();
        if (ret->init(level)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyBackClicked() = win 0x846c0, m1 0x223324, imac 0x281460;

    CCMenuItemSpriteExtra* getStarsButton(int btnID, cocos2d::SEL_MenuHandler selector, cocos2d::CCMenu* menu, float scale) = win inline, m1 0x222ed8 {
        auto btnSpr = ButtonSprite::create(cocos2d::CCString::createWithFormat("%i", btnID)->getCString(), 20, 0, .5f, true, "bigFont.fnt", "GJ_button_01.png", 30.f);
        auto btn = CCMenuItemSpriteExtra::create(btnSpr, this, selector);
        btn->setScale(scale);
        btn->m_baseScale = scale;
        if (menu) menu->addChild(btn);
        return btn;
    }
    bool init(GJGameLevel* level) = win 0x48eb50, imac 0x53f4e0;
    void onClose(cocos2d::CCObject* sender) = win 0x84690, imac 0x280d80, m1 0x222c64;
    void onSettings(cocos2d::CCObject* sender) = m1 0x222e98;
    void onShare(cocos2d::CCObject* sender) = win 0x48ff00;
    void selectRating(cocos2d::CCObject* sender) = win 0x48fc20, m1 0x222fa0;
    void setupStars() = win 0x48f810;

    GJGameLevel* m_level;
    int m_starsRequested;
    cocos2d::CCArray* m_starButtons;
    cocos2d::CCSprite* m_difficultySprite;
}

[[link(android)]]
class ShareLevelSettingsLayer : FLAlertLayer, NumberInputDelegate {
    // virtual ~ShareLevelSettingsLayer();
    ShareLevelSettingsLayer() {}

    static ShareLevelSettingsLayer* create(GJGameLevel* level) = win inline, m1 0x22311c {
        auto ret = new ShareLevelSettingsLayer();
        if (ret->init(level)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyBackClicked() = win 0x491b30, m1 0x224b84, imac 0x282f00;

    bool init(GJGameLevel* level) = win 0x490d70, imac 0xa0010;
    void onClose(cocos2d::CCObject* sender) = win 0x491ab0;
    void onUnlisted(cocos2d::CCObject* sender) = win 0x491790, imac 0x282c30, m1 0x2248f8;
    void onUnlistedFriendsOnly(cocos2d::CCObject* sender) = imac 0x282e20, m1 0x224ab4;
    void updateSettingsState();

    cocos2d::CCLabelBMFont* m_passwordLabel;
    GJGameLevel* m_level;
    CCMenuItemToggler* m_friendsOnlyToggler;
    cocos2d::CCLabelBMFont* m_friendsOnlyLabel;
}

[[link(android)]]
class ShareListLayer : FLAlertLayer {
    ShareListLayer() {
        m_list = nullptr;
        m_friendsOnlyToggler = nullptr;
        m_friendsOnlyLabel = nullptr;
    }
    ~ShareListLayer() = win inline {
        CC_SAFE_RELEASE(m_list);
    }

    static ShareListLayer* create(GJLevelList* list) = win inline, m1 0x2eb330 {
        auto ret = new ShareListLayer();
        if (ret->init(list)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyBackClicked() = win 0x846c0, m1 0x2edfb0, imac 0x363050;

    bool init(GJLevelList* list) = win 0x3098a0;
    void onClose(cocos2d::CCObject* sender) = win 0x84690, imac 0x362b70, m1 0x2edae0;
    void onInfo(cocos2d::CCObject* sender) = win 0x30aa40, imac 0x362ca0, m1 0x2edc34;
    void onShare(cocos2d::CCObject* sender) = win 0x30ad00, m1 0x2edb1c;
    void onUnlisted(cocos2d::CCObject* sender) = win 0x30abb0, imac 0x362d50, m1 0x2edcf0;
    void updateUnlistedF();

    GJLevelList* m_list;
    CCMenuItemToggler* m_friendsOnlyToggler;
    cocos2d::CCLabelBMFont* m_friendsOnlyLabel;
}

[[link(android)]]
class SimpleObject : cocos2d::CCObject {
    // virtual ~SimpleObject();
    SimpleObject() {}

    static SimpleObject* create() = win inline, m1 0x2733c4, ios inline {
        auto ret = new SimpleObject();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init() = win inline, imac 0x2d8db0, m1 0x27341c, ios inline {
        return true;
    }

    cocos2d::ccColor3B m_color;
}

[[link(android)]]
class SimplePlayer : cocos2d::CCSprite {
    SimplePlayer() {
        m_firstLayer = nullptr;
        m_secondLayer = nullptr;
        m_birdDome = nullptr;
        m_outlineSprite = nullptr;
        m_detailSprite = nullptr;
        m_robotSprite = nullptr;
        m_spiderSprite = nullptr;
        m_unknown = 0;
        m_hasGlowOutline = false;
        m_iconRequestID = 0;
        m_hasCustomGlowColor = false;
        m_iconLoaded = false;
    }
    ~SimplePlayer() = win 0x278ff0;

    static SimplePlayer* create(int id) = win 0x2791b0, m1 0x2f48f0;

    virtual void setOpacity(unsigned char opacity) = win 0x27a600, imac 0x370840, m1 0x2fa4fc;
    virtual void setColor(cocos2d::ccColor3B const& color) = win 0x279a10, m1 0x2fa138, imac 0x370480;

    void asyncLoadIcon(int id, IconType type) = m1 0x2f9f0c;
    void createRobotSprite(int frame) = win inline {
        if (m_robotSprite) return;
        auto robotSprite = GJRobotSprite::create(frame);
        m_robotSprite = robotSprite;
        addChild(robotSprite);
        m_robotSprite->setVisible(false);
    }
    void createSpiderSprite(int frame) = win 0x279980;
    void disableCustomGlowColor() = win inline, imac 0x36e980, m1 0x2f8824 {
        m_hasCustomGlowColor = false;
    }
    void disableGlowOutline() {
        disableCustomGlowColor();
        m_hasGlowOutline = false;
        updateColors();
    }
    void enableCustomGlowColor(cocos2d::ccColor3B const& color) = win inline, imac 0x36e950, m1 0x2f8804 {
        m_hasCustomGlowColor = true;
        m_glowColor = color;
    }
    void hideAll() = win inline, imac 0x370380, m1 0x2fa024, ios inline {
        m_firstLayer->setVisible(false);
        m_secondLayer->setVisible(false);
        if (m_birdDome) m_birdDome->setVisible(false);
        if (m_outlineSprite) m_outlineSprite->setVisible(false);
        if (m_detailSprite) m_detailSprite->setVisible(false);
        if (m_robotSprite) m_robotSprite->setVisible(false);
        if (m_spiderSprite) m_spiderSprite->setVisible(false);
    }
    void hideSecondary() = win inline, imac 0x370560, m1 0x2fa224 {
        m_secondLayer->setVisible(false);
        m_birdDome->setVisible(false);
        m_detailSprite->setVisible(false);
        m_outlineSprite->setVisible(false);
        if (m_robotSprite) {
            m_robotSprite->hideSecondary();
            m_robotSprite->hideGlow();
        }
        if (m_spiderSprite) {
            m_spiderSprite->hideSecondary();
            m_spiderSprite->hideGlow();
        }
    }
    void iconFinishedLoading(int id, IconType type) = m1 0x2fa0e8;
    bool init(int id) = win 0x2792a0, m1 0x2f991c;
    void setColors(cocos2d::ccColor3B const& color1, cocos2d::ccColor3B const& color2) = win inline, imac 0x36e910, m1 0x2f87bc, ios inline {
        m_firstLayer->setColor(color1);
        m_secondLayer->setColor(color2);
        updateColors();
    }
    void setFrames(char const* firstFrame, char const* secondFrame, char const* ufoFrame, char const* glowFrame, char const* extraFrame) = win 0x27a3d0, imac 0x370610, m1 0x2fa2d8;
    void setGlowOutline(cocos2d::ccColor3B color) {
        enableCustomGlowColor(color);
        m_hasGlowOutline = true;
        updateColors();
    }
    void setSecondColor(cocos2d::ccColor3B const& color) = win inline {
        m_secondLayer->setColor(color);
        updateColors();
    }
    void updateColors() = win 0x279ae0, imac 0x36e3d0;
    void updatePlayerFrame(int id, IconType type) = win 0x279ea0, imac 0x36aab0, m1 0x2f4bbc;

    cocos2d::CCSprite* m_firstLayer;
    cocos2d::CCSprite* m_secondLayer;
    cocos2d::CCSprite* m_birdDome;
    cocos2d::CCSprite* m_outlineSprite;
    cocos2d::CCSprite* m_detailSprite;
    GJRobotSprite* m_robotSprite;
    GJSpiderSprite* m_spiderSprite;
    int m_unknown;
    bool m_hasGlowOutline;
    int m_iconRequestID;
    bool m_hasCustomGlowColor;
    cocos2d::ccColor3B m_glowColor;
    bool m_iconLoaded;
}

[[link(android)]]
class SlideInLayer : cocos2d::CCLayerColor {
    // virtual ~SlideInLayer();

    static SlideInLayer* create() = m1 0x22eac4;

    virtual bool init() = imac 0x28e160, m1 0x22ebb8;
    virtual void draw() = m1 0x22f280, imac 0x28e880;
    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = m1 0x22f2bc, imac 0x28e8b0;
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = m1 0x22f2dc, imac 0x28e910;
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = m1 0x22f2cc, imac 0x28e8d0;
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = m1 0x22f2d4, imac 0x28e8f0;
    virtual void registerWithTouchDispatcher() = m1 0x22ef9c, imac 0x28e580;
    virtual void keyBackClicked() = imac 0x28e5c0, m1 0x22efd4;
    virtual void customSetup() = m1 0x22ef38, imac 0x28e500;
    virtual void enterLayer() = m1 0x22ef64, imac 0x28e550;
    virtual void exitLayer(cocos2d::CCObject* sender) = imac 0x28e600, m1 0x22eff8;
    virtual void showLayer(bool instant) = m1 0x22f05c, imac 0x28e650;
    virtual void hideLayer(bool instant) = m1 0x22f14c, imac 0x28e740;
    virtual void layerVisible() = m1 0x22f21c, imac 0x28e820;
    virtual void layerHidden() = m1 0x22f22c, imac 0x28e840;
    virtual void enterAnimFinished() = m1 0x22f218, imac 0x28e810;
    virtual void disableUI() = m1 0x22ef3c, imac 0x28e510;
    virtual void enableUI() = m1 0x22ef50, imac 0x28e530;

    cocos2d::CCLayer* m_mainLayer;
    cocos2d::CCMenu* m_buttonMenu;
    cocos2d::CCSprite* m_exitSprite;
    CCMenuItemSpriteExtra* m_exitButton;
    cocos2d::CCPoint m_endPosition;
    cocos2d::CCPoint m_startPosition;
    void* m_delegate;
    bool m_closeOnHide;
}

[[link(android), depends(SliderTouchLogic)]]
class Slider : cocos2d::CCLayer {
    // virtual ~Slider();

    static Slider* create(cocos2d::CCNode* target, cocos2d::SEL_MenuHandler handler) = win inline, imac 0x304030, m1 0x294b18 {
        return Slider::create(target, handler, 1.f);
    }
    static Slider* create(cocos2d::CCNode* target, cocos2d::SEL_MenuHandler handler, float scale) = win inline, imac 0x304150, m1 0x294c1c {
        return Slider::create(target, handler, "sliderBar.png", "slidergroove.png", "sliderthumb.png", "sliderthumbsel.png", scale);
    }
    static Slider* create(cocos2d::CCNode* target, cocos2d::SEL_MenuHandler handler, char const* bar, char const* groove, char const* thumb, char const* thumbSel, float scale) = win 0x71770, imac 0x304270, m1 0x294d30;

    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x71d60, imac 0x3049b0, m1 0x2953c4;
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x71da0, imac 0x304a30, m1 0x295404;
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x71d80, imac 0x3049f0, m1 0x2953e4;

    void disableSlider() = win inline {
        if (!m_enabled) return;
        m_enabled = false;
        m_touchLogic->setTouchEnabled(false);
        m_sliderBar->setColor({ 150, 150, 150 });
        m_groove->setColor({ 150, 150, 150 });
        if (auto normalImage = static_cast<cocos2d::CCSprite*>(m_touchLogic->m_thumb->getNormalImage())) {
            normalImage->setColor({ 150, 150, 150 });
        }
    }
    void disableTouch() = win inline, imac 0x304870, m1 0x2952f0 {
        m_touchLogic->setTouchEnabled(false);
    }
    void enableSlider() = win inline {
        if (m_enabled) return;
        m_enabled = true;
        m_touchLogic->setTouchEnabled(true);
        m_sliderBar->setColor({ 255, 255, 255 });
        m_groove->setColor({ 255, 255, 255 });
        if (auto normalImage = static_cast<cocos2d::CCSprite*>(m_touchLogic->m_thumb->getNormalImage())) {
            normalImage->setColor({ 255, 255, 255 });
        }
    }
    bool getLiveDragging() = win inline, imac 0x304970, m1 0x2953ac {
        return m_touchLogic->m_activateThumb;
    }
    SliderThumb* getThumb() = win inline, imac 0x304890, m1 0x295304 {
        return m_touchLogic->m_thumb;
    }
    float getValue() = win inline, imac 0x3048b0, m1 0x295310 {
        return this->getThumb()->getValue();
    }
    void hideGroove(bool visibility) = win inline, imac 0x304c80 {
        m_groove->setVisible(!visibility);
    }
    bool init(cocos2d::CCNode* target, cocos2d::SEL_MenuHandler handler, char const* bar, char const* groove, char const* thumb, char const* thumbSel, float scale) = win 0x718a0;
    void setBarVisibility(bool visibility) = win inline, imac 0x304950, m1 0x29539c {
        m_sliderBar->setVisible(visibility);
    }
    void setLiveDragging(bool activateThumb) = win inline, imac 0x304990, m1 0x2953b8, ios inline {
        m_touchLogic->m_activateThumb = activateThumb;
    }
    void setMaxOffset(float offset) = win 0x71e60, imac 0x304b80, m1 0x295524;
    void setRotated(bool rotated) = win 0x71dc0, imac 0x304a70, m1 0x295424;
    void setValue(float val) = win 0x71c50, imac 0x3046d0, m1 0x295160;
    void sliderBegan() = win inline, imac 0x303b70, m1 0x2946e4, ios inline {
        if (m_delegate) m_delegate->sliderBegan(this);
    }
    void sliderEnded() = win inline, imac 0x303c90, m1 0x2947f0, ios inline {
        if (m_delegate) m_delegate->sliderEnded(this);
    }
    void updateBar() = win 0x71ce0, imac 0x303ee0, m1 0x2949fc;

    SliderTouchLogic* m_touchLogic;
    cocos2d::CCSprite* m_sliderBar;
    cocos2d::CCSprite* m_groove;
    float m_width;
    float m_height;
    SliderDelegate* m_delegate;
    bool m_enabled;
}

[[link(android)]]
class SliderDelegate {
    virtual void sliderBegan(Slider* slider) {}
    virtual void sliderEnded(Slider* slider) {}
}

[[link(android)]]
class SliderThumb : cocos2d::CCMenuItemImage {
    // virtual ~SliderThumb();
    SliderThumb() {
        m_length = 0.f;
        m_vertical = false;
    }

    static SliderThumb* create(cocos2d::CCNode* target, cocos2d::SEL_MenuHandler selector, char const* normalFrame, char const* selectedFrame) = win inline, imac 0x303180, m1 0x293d6c {
        auto ret = new SliderThumb();
        if (ret->init(target, selector, normalFrame, selectedFrame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    float getValue() = win 0x71300, imac 0x303380, m1 0x293f5c;
    bool init(cocos2d::CCNode* target, cocos2d::SEL_MenuHandler selector, char const* normalFrame, char const* selectedFrame) = win inline, imac 0x303270, m1 0x293e64, ios inline {
        m_length = 200.f;
        return cocos2d::CCMenuItemImage::initWithNormalImage(normalFrame, selectedFrame, nullptr, target, selector);
    }
    void setMaxOffset(float offset) = win inline, imac 0x303550 {
        float value = getValue();
        m_length = offset;
        this->setPosition({0, 0});
        setValue(value);
    }
    void setRotated(bool rotated) = win inline, imac 0x3032b0, m1 0x293e90 {
        float value = getValue();
        m_vertical = rotated;
        this->setPosition({0, 0});
        setValue(value);
    }
    void setValue(float value) = win 0x71390, m1 0x293fe0, imac 0x303410;

    float m_length;
    bool m_vertical;
}

[[link(android), depends(SliderThumb)]]
class SliderTouchLogic : cocos2d::CCMenu {
    // virtual ~SliderTouchLogic();
    SliderTouchLogic() {}

    static SliderTouchLogic* create(cocos2d::CCNode* target, cocos2d::SEL_MenuHandler selector, char const* thumb, char const* thumbSel, float scale) = win inline, imac 0x303620, m1 0x2941bc {
        auto ret = new SliderTouchLogic();
        if (ret->init(target, selector, thumb, thumbSel, scale)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x71500, m1 0x294644, imac 0x303ad0;
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x715f0, imac 0x303d00, m1 0x294858;
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x715b0, m1 0x2947a8, imac 0x303c40;
    virtual void registerWithTouchDispatcher() = win 0x71720, m1 0x294ae0, imac 0x303ff0;

    bool init(cocos2d::CCNode* target, cocos2d::SEL_MenuHandler selector, char const* thumb, char const* thumbSel, float scale) = win inline {
        if (!cocos2d::CCMenu::init()) return false;
        m_rotated = false;
        m_length = scale * 200.f;
        this->setPosition({ 0.f, 0.f });
        m_thumb = SliderThumb::create(target, selector, thumb, thumbSel);
        this->addChild(m_thumb);
        m_thumb->setScale(scale);
        m_activateThumb = false;
        return true;
    }
    void setMaxOffset(float offset) = win inline, imac 0x3038f0, m1 0x294484, ios inline {
        float newOffset = m_thumb->getScale() * offset;
        m_length = newOffset;
        m_thumb->setMaxOffset(newOffset);
    }
    void setRotated(bool rotated) = win inline, imac 0x3039f0, m1 0x294570, ios inline {
        m_rotated = rotated;
        m_thumb->setRotated(rotated);
    }

    float m_unknownUnused;
    float m_length;
    SliderThumb* m_thumb;
    Slider* m_slider;
    bool m_activateThumb;
    cocos2d::CCPoint m_position;
    bool m_rotated;
}

[[link(android)]]
class SmartGameObject : GameObject {
    // virtual ~SmartGameObject();
    SmartGameObject() {
        m_referenceOnly = false;
    }

    static SmartGameObject* create(char const* frame) = win inline, imac 0x1b07c0, m1 0x16af2c {
        auto ret = new SmartGameObject();
        if (ret->init(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x49f740, m1 0x16b750, imac 0x1b10e0;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x49f5d0, m1 0x16b260, imac 0x1b0b10;

    bool init(char const* frame) = win inline {
        if (!GameObject::init(frame)) return false;
        m_baseFrame = frame;
        m_classType = GameObjectClassType::Smart;
        m_bUnkBool2 = false;
        return true;
    }
    void updateSmartFrame() = win 0x49f3e0, imac 0x1b08e0;

    // property 157
    bool m_referenceOnly;
    gd::string m_baseFrame;
    gd::string m_smartFrame;
}

[[link(android)]]
class SmartTemplateCell : TableViewCell {
    // virtual ~SmartTemplateCell();
    SmartTemplateCell(char const* identifier, float width, float height) = win inline, m1 0x1fdee0, ios inline : TableViewCell(identifier, width, height) {
        this->init();
    }

    virtual bool init() = win 0x3c850, imac 0x258ab0, m1 0x1fdf24;
    virtual void draw() = win 0xade40, m1 0x1fdfe0, imac 0x258b80;

    void loadFromObject(GJSmartTemplate* smartTemplate) = win 0xbe600, imac 0x1807e0, m1 0x1f3bc4;
    void onClick(cocos2d::CCObject* sender) = win 0xbeae0, imac 0x258ad0, m1 0x1fdf30;
    void updateBGColor(int index) = m1 0x1f3ed8;

    GJSmartTemplate* m_smartTemplate;
}

[[link(android)]]
class SongCell : TableViewCell {
    // virtual ~SongCell();
    SongCell(char const* identifier, float width, float height) = win inline, m1 0x1f9b84, ios inline : TableViewCell(identifier, width, height) {
        this->init();
    }

    virtual bool init() = win 0x3c850, imac 0x2537a0, m1 0x1f9bc8;
    virtual void draw() = win 0xade40, m1 0x1f9bf8, imac 0x2537e0;

    void loadFromObject(SongObject* object) = win 0xb4130, imac 0x246970, m1 0x1ed840;
    void onClick(cocos2d::CCObject* sender) = win 0xb4540, imac 0x2537c0, m1 0x1f9bd4;
    void updateBGColor(int index) = win inline, imac 0x246d50, m1 0x1edc84 {
        m_backgroundLayer->setColor(index % 2 == 0 ? cocos2d::ccColor3B { 161, 88, 44 } : cocos2d::ccColor3B { 194, 114, 62 });
        m_backgroundLayer->setOpacity(255);
    }

    SongObject* m_songObject;
}

[[link(android)]]
class SongInfoLayer : FLAlertLayer {
    // virtual ~SongInfoLayer();

    static SongInfoLayer* create(int artistID) = win 0x492090, imac 0x5ff980, m1 0x527a90;
    static SongInfoLayer* create(gd::string songName, gd::string artistName, gd::string songURL, gd::string newgroundsURL, gd::string youtubeURL, gd::string facebookURL, int songID, gd::string songTags, int nongType) = win 0x4922a0, imac 0xf6610, m1 0x527f44;

    virtual void keyBackClicked() = win 0x846c0, m1 0x529950, imac 0x601a20;

    bool init(gd::string songName, gd::string artistName, gd::string songURL, gd::string newgroundsURL, gd::string youtubeURL, gd::string facebookURL, int songID, gd::string songTags, int nongType);
    void onBPM(cocos2d::CCObject* sender) = m1 0x52941c;
    void onClose(cocos2d::CCObject* sender) = win 0x84690, m1 0x5293e0;
    void onDownload(cocos2d::CCObject* sender) = m1 0x529454;
    void onFB(cocos2d::CCObject* sender) = m1 0x529538;
    void onMenuMusic(cocos2d::CCObject* sender) = m1 0x529584;
    void onNG(cocos2d::CCObject* sender) = m1 0x5294a0;
    void onPracticeMusic(cocos2d::CCObject* sender) = m1 0x52962c;
    void onYT(cocos2d::CCObject* sender) = m1 0x5294ec;
    void showCustomMusicUnlockInfo() = win 0x4938e0, imac 0x601810, m1 0x5296b8;

    gd::string m_downloadLink;
    gd::string m_newgroundsLink;
    gd::string m_youtubeLink;
    gd::string m_facebookLink;
    int m_songID;
    int m_musicCustomizerMessageIndex;
}

[[link(android)]]
class SongInfoObject : cocos2d::CCNode {
    // virtual ~SongInfoObject();

    static SongInfoObject* create(cocos2d::CCDictionary* dict) = imac 0x50db80;
    static SongInfoObject* create(int songID);
    static SongInfoObject* create(int songID, gd::string songName, gd::string artistName, int artistID, float filesize, gd::string youtubeVideo, gd::string youtubeChannel, gd::string url, int nongType, gd::string extraArtistIDs, bool isNew, int libraryOrder, int priority) = win 0x345b90;
    static SongInfoObject* createWithCoder(DS_Dictionary* dict);

    virtual void encodeWithCoder(DS_Dictionary* dict) = win 0x3462e0, m1 0x4e13f8, imac 0x5977c0;
    virtual bool canEncode() = win inline, imac 0x5979c0, m1 0x4e1598 { return true; }

    void addTags(gd::string tags) = win 0x3469a0;
    bool containsTag(int tag) = win inline, m1 0x4de64c, ios inline {
        return m_tags.find(tag) != m_tags.end();
    }
    gd::string getArtistNames(int unused) = imac 0x5979d0, m1 0x4e15a0;
    gd::string getTagsString(bool shortTags) = win 0x346b90, imac 0x598300, m1 0x4e1c84;
    bool init(int songID, gd::string songName, gd::string artistName, int artistID, float filesize, gd::string youtubeVideo, gd::string youtubeChannel, gd::string url, int nongType, gd::string extraArtistIDs, bool isNew, int libraryOrder, int priority) = imac 0x596b00, m1 0x1c3bc8;
    void updateArtists(gd::string artists) = win inline, imac 0x596d70 {
        m_extraArtists = artists;
        m_artistIDs.clear();
        if (m_extraArtists.empty()) return;
        std::vector<std::string> splitArtists;
        auto start = 0;
        auto index = artists.find_first_of(".");
        auto size = artists.size();
        while (index != std::string::npos) {
            auto str = artists.substr(start, index - start);
            if (!str.empty() || start != size) {
                splitArtists.push_back(str);
            }
            start = index + 1;
            index = artists.find_first_of(".", start);
        }
        for (auto& artistID : splitArtists) {
            m_artistIDs.insert(atoi(artistID.c_str()));
        }
    }

    int m_songID;
    gd::string m_songName;
    gd::string m_artistName;
    gd::string m_unkString;
    gd::string m_youtubeVideo;
    gd::string m_youtubeChannel;
    gd::string m_songUrl;
    int m_artistID;
    float m_fileSize;
    int m_nongType;
    gd::string m_extraArtists;
    bool m_isUnknownSong; //isUnloaded
    bool m_autoDownload; //isVerified
    bool m_isBlocked;
    int m_priority;
    int m_unkInt;
    int m_BPM;
    bool m_isNew;
    int m_libraryOrder;
    int m_songOrder;
    gd::string m_extraArtistNames;
    gd::unordered_set<int> m_artistIDs;
    gd::set<int> m_tags;
    gd::string m_longTagsString;
    gd::string m_shortTagsString;
}

[[link(android)]]
class SongObject : cocos2d::CCObject {
    // virtual ~SongObject();
    SongObject() {
        m_audioID = 0;
    }

    static SongObject* create(int audioID) = win inline, m1 0x1f9ad0 {
        auto ret = new SongObject();
        if(ret->init(audioID)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init(int audioID) = win inline, imac 0x253690, m1 0x1f9b3c, ios inline {
        m_audioID = audioID;
        return true;
    }

    int m_audioID;
}

[[link(android)]]
class SongOptionsLayer : FLAlertLayer {
    // virtual ~SongOptionsLayer();
    SongOptionsLayer() {
        m_delegate = nullptr;
    }

    static SongOptionsLayer* create(CustomSongDelegate* delegate) = win inline, m1 0x1c0e80 {
        auto ret = new SongOptionsLayer();
        if (ret->init(delegate)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyBackClicked() = win 0xc5660, imac 0x217120, m1 0x1c2604;

    bool init(CustomSongDelegate* delegate) = win 0xc45c0;
    void onClose(cocos2d::CCObject* sender) = win 0xc54f0, imac 0x216db0, m1 0x1c225c;
    void onFadeIn(cocos2d::CCObject* sender) = imac 0x216cf0, m1 0x1c2178;
    void onFadeOut(cocos2d::CCObject* sender) = imac 0x216d30, m1 0x1c21c4;
    void onInfo(cocos2d::CCObject* sender) = win 0xc5390, imac 0x216eb0, m1 0x1c236c;
    void onPlayback(cocos2d::CCObject* sender) = win 0xc50d0, m1 0x1c244c;
    void onSongPersistent(cocos2d::CCObject* sender) = imac 0x216d70, m1 0x1c2210;
    void updatePlaybackBtn() = win inline, imac 0x2170b0, m1 0x1c2598 {
        auto playbackSprite = static_cast<cocos2d::CCSprite*>(m_playbackButton->getNormalImage());
        if (FMODAudioEngine::sharedEngine()->isMusicPlaying(0)) {
            playbackSprite->setDisplayFrame(cocos2d::CCSpriteFrameCache::sharedSpriteFrameCache()->spriteFrameByName("GJ_stopMusicBtn_001.png"));
        } else {
            playbackSprite->setDisplayFrame(cocos2d::CCSpriteFrameCache::sharedSpriteFrameCache()->spriteFrameByName("GJ_playMusicBtn_001.png"));
        }
    }

    CustomSongDelegate* m_delegate;
    CCTextInputNode* m_offsetInput;
    CCMenuItemSpriteExtra* m_playbackButton;
}

[[link(android)]]
class SongPlaybackDelegate {
    virtual void onPlayback(SongInfoObject* object) {}
}

[[link(android)]]
class SongSelectNode : cocos2d::CCNode, FLAlertLayerProtocol, CustomSongLayerDelegate, CustomSongDelegate {
    // virtual ~SongSelectNode();

    static SongSelectNode* create(int id, bool customSong, LevelSettingsObject* settings, SongSelectType selectType, cocos2d::CCPoint position, cocos2d::CCNode* parent, cocos2d::CCMenu* menu, bool noLabel) = win 0xc6cc0, imac 0x218650, m1 0x1c3ab8;

    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0xc7d20, m1 0x1c488c, imac 0x219480;
    virtual void customSongLayerClosed() = win 0xc7db0, imac 0x219560, m1 0x1c4974;
    virtual void songIDChanged(int id) = win 0xc7de0, imac 0x2195c0, m1 0x1c49dc;
    virtual int getActiveSongID() = win 0xc7df0, imac 0x2195f0, m1 0x1c49fc;
    virtual gd::string getSongFileName() = win 0xc7e00, m1 0x1c4a0c, imac 0x219610;
    virtual LevelSettingsObject* getLevelSettings() = win 0xc7ec0, m1 0x1c4b48, imac 0x219760;

    void audioNext(cocos2d::CCObject* sender) = win 0xc77f0, imac 0x2190c0, m1 0x1c4530;
    void audioPrevious(cocos2d::CCObject* sender) = win 0xc7830, imac 0x219080, m1 0x1c44fc;
    bool init(int id, bool customSong, LevelSettingsObject* settings, SongSelectType selectType, cocos2d::CCPoint position, cocos2d::CCNode* parent, cocos2d::CCMenu* menu, bool noLabel) = win 0xc6df0;
    void onOpenCustomSong(cocos2d::CCObject* sender) = m1 0x1c459c;
    void onSongMode(cocos2d::CCObject* sender) = imac 0x219100, m1 0x1c4568;
    void onSongMode(int songMode) = win 0xc7890, imac 0x2191d0, m1 0x1c4618;
    void selectSong(int id) = win inline, imac 0x2191a0, m1 0x1c45f8, ios inline {
        auto songID = id;
        if (songID > 21) songID = 21;
        m_songChanged = true;
        if (songID < 0) songID = 0;
        m_selectedSongID = songID;
        this->updateAudioLabel();
    }
    void showCustomSongSelect() = win 0xc7bc0, imac 0x219440, m1 0x1c4858, ios inline {
        auto layer = CustomSongLayer::create(this);
        layer->m_delegate = this;
        layer->show();
    }
    void updateAudioLabel() = win 0xc7700, imac 0x218f90, m1 0x1c43e4;
    void updateWidgetVisibility() = win 0xc7ab0;

    int m_selectedSongID;
    bool m_isCustomSong;
    bool m_songChanged;
    cocos2d::CCLabelBMFont* m_audioLabel;
    cocos2d::CCArray* m_selectSongObjects;
    cocos2d::CCArray* m_normalSongObjects;
    cocos2d::CCArray* m_changeSongObjects;
    CCMenuItemSpriteExtra* m_normalButton;
    CCMenuItemSpriteExtra* m_customButton;
    CCMenuItemSpriteExtra* m_selectButton;
    CCMenuItemSpriteExtra* m_changeButton;
    CustomSongWidget* m_songWidget;
    LevelSettingsObject* m_settingsObject;
}

[[link(android)]]
class SongsLayer : GJDropDownLayer {
    // virtual ~SongsLayer();

    static SongsLayer* create();

    virtual void customSetup() = win 0x4943c0, m1 0x468218, imac 0x511710;
}

[[link(android)]]
class SongTriggerGameObject : SFXTriggerGameObject {
    // virtual ~SongTriggerGameObject();
    SongTriggerGameObject() {
        m_unk7a9 = false;
        m_prep = false;
        m_loadPrep = false;
        m_songChannel = 0;
    }

    static SongTriggerGameObject* create(char const* frame) = win inline, m1 0x185728 {
        auto ret = new SongTriggerGameObject();
        if (ret->init(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4b83e0, m1 0x185ff8, imac 0x1d0f40;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x4b8180, m1 0x1858a8, imac 0x1d0610;

    bool init(char const* frame) = win inline, ios inline {
        return SFXTriggerGameObject::init(frame);
    }

    bool m_unk7a9;
    // property 399
    bool m_prep;
    // property 400
    bool m_loadPrep;
    // property 432
    int m_songChannel;
}

[[link(android)]]
class SpawnParticleGameObject : EffectGameObject {
    // virtual ~SpawnParticleGameObject();
    SpawnParticleGameObject() {
        m_matchRotation = false;
        m_rotation = 0.f;
        m_rotationVariance = 0.f;
        m_scale = 1.f;
        m_scaleVariance = 0.f;
    }

    static SpawnParticleGameObject* create() = win inline, m1 0x19e710 {
        auto ret = new SpawnParticleGameObject();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x4c31c0, m1 0x19e7e4, imac 0x1ef8a0;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4c3890, m1 0x19fd44, imac 0x1f13e0;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x4c3230, m1 0x19e834, imac 0x1ef8f0;

    // property 547, property 548
    cocos2d::CCPoint m_offset;
    // property 549, property 550
    cocos2d::CCPoint m_offsetVariance;
    // property 551
    bool m_matchRotation;
    // property 552
    float m_rotation;
    // property 553
    float m_rotationVariance;
    // property 554
    float m_scale;
    // property 555
    float m_scaleVariance;
}

[[link(android)]]
class SpawnTriggerAction {
    SpawnTriggerAction() {}
    SpawnTriggerAction(GameObject* object, float delay, gd::vector<int> const& remapKeys, int uniqueID, int controlID) {
        m_finished = false;
        m_disabled = false;
        m_duration = delay;
        m_deltaTime = 0.0;
        m_targetGroupID = 0;
        m_triggerUniqueID = uniqueID;
        m_controlID = controlID;
        m_spawnOrdered = false;
        m_gameObject = object;
        m_remapKeys = remapKeys;
    }
    SpawnTriggerAction(int targetID, float delay, bool spawnOrdered, gd::vector<int> const& remapKeys, int uniqueID, int controlID) {
        m_finished = false;
        m_disabled = false;
        m_duration = delay;
        m_deltaTime = 0.0;
        m_targetGroupID = targetID;
        m_triggerUniqueID = uniqueID;
        m_controlID = controlID;
        m_spawnOrdered = spawnOrdered;
        m_gameObject = nullptr;
        m_remapKeys = remapKeys;
    }

    bool isFinished() = win inline, imac 0x2d9050, m1 0x27367c, ios inline {
        return m_finished;
    }
    void step(float dt) = win inline, ios inline {
        if (m_finished || m_disabled) return;
        m_deltaTime += dt;
        m_finished = m_deltaTime >= m_duration;
    }

    bool m_finished;
    bool m_disabled;
    double m_duration;
    double m_deltaTime;
    int m_targetGroupID;
    int m_triggerUniqueID;
    int m_controlID;
    bool m_spawnOrdered;
    GameObject* m_gameObject;
    gd::vector<int> m_remapKeys;
}

[[link(android), depends(ChanceObject)]]
class SpawnTriggerGameObject : EffectGameObject {
    // virtual ~SpawnTriggerGameObject();
    SpawnTriggerGameObject() {
        m_remapKey = 0;
        m_currentDelay = 0.0;
        m_spawnDelay = 0.f;
        m_delayRange = 0.f;
        m_resetRemap = false;
    }

    static SpawnTriggerGameObject* create() = win inline, imac 0x1d2900, m1 0x1876f0 {
        auto ret = new SpawnTriggerGameObject();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x4b8d10, m1 0x1877d4, imac 0x1d29e0;
    virtual void triggerObject(GJBaseGameLayer* layer, int uniqueID, gd::vector<int> const* remapKeys) = win 0x4b8e80, imac 0x1d2cd0, m1 0x1879c0;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4b91f0, m1 0x187f8c, imac 0x1d3210;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x4b9530, m1 0x188310, imac 0x1d3640;

    void addRemap(int oldID, int newID) = win inline, imac 0x1d2e10 {
        for (auto& obj : m_remapObjects) {
            if (obj.m_groupID == oldID && obj.m_chance == newID) return;
        }
        m_remapObjects.emplace_back(oldID, newID);
    }
    void changeRemap(int oldID, int newID, bool reverse) = win 0x4b8fa0, imac 0x1d3020, m1 0x187cd4;
    void removeRemap(int oldID, int newID) = win inline {
        for (int i = 0; i < m_remapObjects.size(); i++) {
            auto& obj = m_remapObjects[i];
            if (obj.m_groupID == oldID && obj.m_chance == newID) {
                m_remapObjects.erase(m_remapObjects.begin() + i);
                return;
            }
        }
    }
    void updateRemapKeys(gd::vector<int> const& remapKeys) = win 0x4b8d80;

    // property 442
    gd::vector<ChanceObject> m_remapObjects;
    int m_remapKey;
    gd::vector<int> m_remapKeys;
    double m_currentDelay;
    // property 63
    float m_spawnDelay;
    // property 556
    float m_delayRange;
    // property 581
    bool m_resetRemap;
}

[[link(android)]]
class SpecialAnimGameObject : EnhancedGameObject {
    // virtual ~SpecialAnimGameObject();
    SpecialAnimGameObject() {
        m_skipMainColorUpdate = false;
        m_skipSecondaryColorUpdate = false;
    }

    static SpecialAnimGameObject* create(char const* frame) = win inline, imac 0x1b3590, m1 0x16d8cc {
        auto ret = new SpecialAnimGameObject();
        if (ret->init(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void resetObject() = win 0x4a16f0, m1 0x16da10, imac 0x1b3710;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4a1700, m1 0x16da1c, imac 0x1b3730;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x4a1770, m1 0x16da7c, imac 0x1b3790;
    virtual void updateMainColor(cocos2d::ccColor3B const& color) = win 0x4a16b0, m1 0x16d9f0, imac 0x1b36d0;
    virtual void updateSecondaryColor(cocos2d::ccColor3B const& color) = win 0x4a16d0, m1 0x16da00, imac 0x1b36f0;
    virtual void updateSyncedAnimation(float totalTime, int frameIndex) = win 0x1a9980, imac 0x25d370, m1 0x2016a0;

    bool init(char const* frame) = win inline, m1 0x16d9c8, ios inline {
        if (!EnhancedGameObject::init(frame)) return false;
        m_bUnkBool2 = false;
        return true;
    }

    bool m_skipMainColorUpdate;
    bool m_skipSecondaryColorUpdate;
}

[[link(android)]]
class SpriteAnimationManager : cocos2d::CCNode {
    SpriteAnimationManager() {
        m_sprite = nullptr;
        m_priorityDict = nullptr;
        m_typeDict = nullptr;
        m_soundDict = nullptr;
        m_frameDict = nullptr;
    }
    ~SpriteAnimationManager() = win inline, m1 0x636970 {
        CC_SAFE_RELEASE(m_frameDict);
        CC_SAFE_RELEASE(m_priorityDict);
        CC_SAFE_RELEASE(m_typeDict);
        CC_SAFE_RELEASE(m_soundDict);
        CC_SAFE_RELEASE(m_animateDict);
    }

    static void createAnimations(gd::string definition) = win 0x72ff0, m1 0x6339ec;
    static SpriteAnimationManager* createWithOwner(CCAnimatedSprite* sprite, gd::string definition) = win inline, imac 0x720a00, m1 0x6336d8 {
        auto ret = new SpriteAnimationManager();
        if (ret->initWithOwner(sprite, definition)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    void animationFinished() = win 0x74640, m1 0x63536c;
    void callAnimationFinished() = win 0x74690, imac 0x723c10, m1 0x636488;
    void doCleanup() = win inline, m1 0x636948 {
        m_frameDict->removeAllObjects();
        this->release();
    }
    void executeAnimation(gd::string animation) = win 0x73f80, imac 0x723510, m1 0x635df8;
    void finishAnimation(gd::string animation) = win inline, imac 0x723d20, m1 0x63659c, ios inline {
        if (m_queuedAnimation == animation) m_queuedAnimation = "not_used";
        if (m_currentAnimation == animation) this->runQueuedAnimation();
    }
    spriteMode getAnimType(gd::string animation) = win inline, m1 0x6361a8 {
        return (spriteMode)m_typeDict->valueForKey(animation)->intValue();
    }
    int getPrio(gd::string animation) = win 0x74770, m1 0x635c18;
    bool initWithOwner(CCAnimatedSprite* sprite, gd::string definition) = win 0x723b0, imac 0x720b00, m1 0x6337c0;
    void loadAnimations(gd::string definition) = win 0x72620, imac 0x3a9e60, m1 0x2a64f4;
    void offsetCurrentAnimation(float dt) = win inline, imac 0x723e70, m1 0x16c5d0 {
        if (auto action = static_cast<cocos2d::CCActionInterval*>(m_sprite->m_sprite->getActionByTag(1))) {
            if (action->getM_bFirstTick()) action->step(0.f);
            action->step(dt);
        }
    }
    void overridePrio() = win 0x74470, m1 0x6361c0;
    void playSound(gd::string sound) = win inline, imac 0x44670, m1 0x6358a8, ios inline {}
    void playSoundForAnimation(gd::string animation) = win inline, imac 0x722d30, m1 0x6356cc {
        if (auto sound = static_cast<cocos2d::CCString*>(m_soundDict->objectForKey(animation))) {
            auto delay = static_cast<cocos2d::CCString*>(m_soundDict->objectForKey(cocos2d::CCString::createWithFormat("%s%s", animation.c_str(), "delay")->getCString()))->floatValue();
            if (delay == 0.f) this->playSound(sound->getCString());
        }
    }
    void queueAnimation(gd::string animation) = win 0x74560, m1 0x635c40;
    void resetAnimState() = win inline, imac 0x723ed0, ios inline {
        m_queuedAnimation = "not_used";
        m_nextAnimation = "not_used";
    }
    void runAnimation(gd::string animation) = win 0x73e20, imac 0x722f30, m1 0x6358ac;
    void runQueuedAnimation() = win inline, imac 0x7239f0, m1 0x636270, ios inline {
        if (m_queuedAnimation != "not_used") {
            this->executeAnimation(m_queuedAnimation);
            m_queuedAnimation = "not_used";
        }
    }
    void stopAnimations() = win inline, m1 0x6363b8 {
        this->overridePrio();
        if (m_sprite->m_paSprite) m_sprite->m_paSprite->stopAllActions();
        if (m_sprite->m_fbfSprite) m_sprite->m_fbfSprite->stopAllActions();
    }
    void storeAnimation(cocos2d::CCAnimate* action, cocos2d::CCAnimate* frames, gd::string name, int priority, spriteMode type, cocos2d::CCSpriteFrame* first) = win 0x73bb0, m1 0x6353d0;
    void storeSoundForAnimation(cocos2d::CCString* sound, gd::string animation, float delay) = win inline, imac 0x722920, m1 0x63530c {
        m_soundDict->setObject(sound, animation);
        m_soundDict->setObject(cocos2d::CCString::createWithFormat("%f", delay), animation);
    }
    void switchToFirstFrameOfAnimation(gd::string animation) = win inline, m1 0x636758, ios inline {
        if (m_frameDict->objectForKey(animation)->getObjType() == (cocos2d::CCObjectType)0) {
            m_sprite->switchToMode(this->getAnimType(animation));
            auto frame = static_cast<cocos2d::CCSpriteFrame*>(m_frameDict->objectForKey(cocos2d::CCString::createWithFormat("%s_first", animation.c_str())->getCString()));
            auto type = (int)frame->getObjType();
            if (type == 1 || type == 2) m_sprite->m_sprite->setDisplayFrame(frame);
        }
    }
    void updateAnimationSpeed(float speed) = win inline, m1 0x635688 {
        cocos2d::CCDictElement* element;
        cocos2d::CCDictElement* temp;
        if (m_animateDict) HASH_ITER(hh, m_animateDict->m_pElements, element, temp) {
            if (element->getObject()->getObjType() == (cocos2d::CCObjectType)0) {
                static_cast<cocos2d::CCAnimate*>(element->getObject())->setSpeedMod(speed);
            }
        }
    }

    CCAnimatedSprite* m_sprite;
    cocos2d::CCDictionary* m_priorityDict;
    cocos2d::CCDictionary* m_typeDict;
    cocos2d::CCDictionary* m_soundDict;
    gd::string m_queuedAnimation;
    float m_speed;
    cocos2d::CCDictionary* m_animateDict;
    cocos2d::CCDictionary* m_frameDict;
    gd::string m_currentAnimation;
    gd::string m_nextAnimation;
}

[[link(android)]]
class SpriteDescription : cocos2d::CCObject {
    SpriteDescription() {
        m_rotation = 0;
        m_zValue = 0;
        m_tag = 0;
        m_usesCustomTag = false;
        m_texture = nullptr;
    }
    ~SpriteDescription() = win inline, m1 0x4baf5c {
        CC_SAFE_RELEASE(m_texture);
    }

    static SpriteDescription* createDescription(DS_Dictionary* dict) = win inline, m1 0x4ba6dc {
        auto ret = new SpriteDescription();
        if (ret->initDescription(dict)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static SpriteDescription* createDescription(cocos2d::CCDictionary* dict) = win inline, m1 0x4b9f88 {
        auto ret = new SpriteDescription();
        if (ret->initDescription(dict)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool initDescription(DS_Dictionary* dict) = win 0x41d80, imac 0x56c600, m1 0x4ba8b0;
    bool initDescription(cocos2d::CCDictionary* dict) = win inline, imac 0x56c880, m1 0x4bab5c {
        m_position = cocos2d::CCPointFromString(dict->valueForKey("position")->getCString());
        m_scale = cocos2d::CCPointFromString(dict->valueForKey("scale")->getCString());
        m_flipped = cocos2d::CCPointFromString(dict->valueForKey("flipped")->getCString());
        m_rotation = dict->valueForKey("rotation")->floatValue();
        m_zValue = dict->valueForKey("zValue")->intValue();
        m_tag = dict->valueForKey("tag")->intValue();
        m_usesCustomTag = dict->valueForKey("usesCustomTag")->boolValue();
        if (m_usesCustomTag) {
            auto frameName = dict->valueForKey("texture")->getCString();
            m_texture = cocos2d::CCSpriteFrameCache::sharedSpriteFrameCache()->spriteFrameByName(frameName);
            m_texture->retain();
            m_texture->setFrameName(frameName);
        }
        return true;
    }

    cocos2d::CCPoint m_position;
    cocos2d::CCPoint m_scale;
    cocos2d::CCPoint m_flipped;
    float m_rotation;
    int m_zValue;
    int m_tag;
    bool m_usesCustomTag;
    cocos2d::CCSpriteFrame* m_texture;
}

[[link(android)]]
class SpritePartDelegate {
    virtual void displayFrameChanged(cocos2d::CCObject* sprite, gd::string frameName) {}
}

[[link(android)]]
class StarInfoPopup : FLAlertLayer {
    // virtual ~StarInfoPopup();

    static StarInfoPopup* create(int autos, int easies, int normals, int hards, int harders, int insanes, int dailies, int gauntlets, int maps, bool platformer) = win 0x3c7d00, imac 0x7c1840, m1 0x6c6dc0;
    static StarInfoPopup* createFromString(gd::string str) = m1 0x6c3980;
    static StarInfoPopup* createFromStringMoons(gd::string str) = m1 0x6c3be0;

    virtual void keyBackClicked() = win 0x846c0, m1 0x6c78bc, imac 0x7c22e0;

    bool init(int autos, int easies, int normals, int hards, int harders, int insanes, int dailies, int gauntlets, int maps, bool platformer) = win 0x3c7e40;
    void onClose(cocos2d::CCObject* sender) = win 0x84690, imac 0x7c22b0, m1 0x6c7880;
}

[[link(android)]]
class StartPosObject : EffectGameObject {
    StartPosObject() {
        m_startSettings = nullptr;
    }
    ~StartPosObject() = win inline, m1 0x175d90 {
        CC_SAFE_RELEASE(m_startSettings);
    }

    static StartPosObject* create() = win inline, m1 0x175e78 {
        auto ret = new StartPosObject();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x4b1c30, m1 0x175f84, imac 0x1bd4f0;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4b1d90, m1 0x1760c8, imac 0x1bd640;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x4b1da0, m1 0x1760cc, imac 0x1bd650;

    void loadSettingsFromString(gd::string objectString) = win 0x4b1cf0, m1 0x176068;
    void setSettings(LevelSettingsObject* settings) = win inline, m1 0x176020 {
        if (settings == m_startSettings) return;
        CC_SAFE_RETAIN(settings);
        CC_SAFE_RELEASE(m_startSettings);
        m_startSettings = settings;
    }

    LevelSettingsObject* m_startSettings;
}

[[link(android)]]
class StatsCell : TableViewCell {
    // virtual ~StatsCell();
    StatsCell(char const* identifier, float width, float height) = win inline, m1 0x1f8de8, ios inline : TableViewCell(identifier, width, height) {
        this->init();
    }

    virtual bool init() = win inline, imac 0x252a80, m1 0x1f8e28 { return true; }
    virtual void draw() = win 0xade40, m1 0x1f9a24, imac 0x253550;

    const char* getTitleFromKey(char const* key) = win 0xb3030, imac 0x252a90, m1 0x1f8e30;
    void loadFromObject(StatsObject* object) = win 0xb2dd0, imac 0x246670, m1 0x1ed4d0;
    void updateBGColor(int index) = win inline, imac 0x246920, m1 0x1ed7d4 {
        m_backgroundLayer->setColor(index % 2 == 0 ? cocos2d::ccColor3B { 161, 88, 44 } : cocos2d::ccColor3B { 194, 114, 62 });
    }
}

[[link(android)]]
class StatsLayer : GJDropDownLayer {
    // virtual ~StatsLayer();
    StatsLayer() {}

    static StatsLayer* create() = win inline {
        auto ret = new StatsLayer();
        if(ret->init("Stats", 220.f, false)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void customSetup() = win 0x4c78e0, m1 0x8c514, imac 0x9b810;
}

[[link(android)]]
class StatsObject : cocos2d::CCObject {
    // virtual ~StatsObject();

    static StatsObject* create(char const* key, int value) = win 0xb2c70, m1 0x1f8c70;

    bool init(char const* key, int value) = win inline, m1 0x1f8cf8 {
        m_key = cocos2d::CCString::create(key)->getCString();
        m_value = value;
        return true;
    }

    const char* m_key;
    int m_value;
}

[[link(android)]]
class SupportLayer : GJDropDownLayer, FLAlertLayerProtocol, UploadActionDelegate, UploadPopupDelegate {
    SupportLayer() {
        m_uploadPopup = nullptr;
    }
    ~SupportLayer() = win inline, m1 0x31db4c {
        auto glm = GameLevelManager::sharedState();
        if (glm->m_uploadActionDelegate == this) glm->m_uploadActionDelegate = nullptr;
    }

    static SupportLayer* create() = win inline, m1 0x31d9f4 {
        auto ret = new SupportLayer();
        if (ret->init("Support", 220.f, false)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void customSetup() = win 0x4c81f0, imac 0x3984d0, m1 0x31de90;
    virtual void uploadActionFinished(int id, int response) = win 0x4c9790, m1 0x31fc34, imac 0x39a360;
    virtual void uploadActionFailed(int id, int response) = win 0x4c9960, imac 0x39a550, m1 0x31fe30;
    virtual void onClosePopup(UploadActionPopup* popup) = win 0x4c9750, m1 0x31fbe4, imac 0x39a310;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x4ca5e0, imac 0x39a870, m1 0x32017c;

    CCMenuItemToggler* createToggleButton(gd::string text, cocos2d::SEL_MenuHandler selector, bool toggled, cocos2d::CCMenu* menu, cocos2d::CCPoint position, cocos2d::CCArray* nodes) = win 0x4c8db0, m1 0x31f698;
    void exitLayer() = win inline, m1 0x31fbdc, ios inline {
        GJDropDownLayer::exitLayer(nullptr);
    }
    void onCocos2d(cocos2d::CCObject* sender) = m1 0x31fbb8;
    void onEmail(cocos2d::CCObject* sender) = win 0x4c9c80, m1 0x31f024;
    void onGetReward(cocos2d::CCObject* sender) = win 0x4c9600, m1 0x31fadc;
    void onLinks(cocos2d::CCObject* sender) = imac 0x2ccb30, m1 0x31e788;
    void onLowDetail(cocos2d::CCObject* sender) = win 0x4c99f0, m1 0x31f930;
    void onPrivacy(cocos2d::CCObject* sender) = m1 0x31f0f4;
    void onRequestAccess(cocos2d::CCObject* sender) = win 0x4c9510, m1 0x31fa30;
    void onRobTop(cocos2d::CCObject* sender) = m1 0x31fb94;
    void onSFX(cocos2d::CCObject* sender) = imac 0x3998c0, m1 0x31f13c;
    void onTOS(cocos2d::CCObject* sender) = m1 0x31f118;
    void sendSupportMail() = win inline, m1 0x31ff58 {
        PlatformToolbox::sendMail("Geometry Dash Support", cocos2d::CCString::createWithFormat(
            "\n\nGame: %s"
            "\n\nUserID: %s"
            "\n\nAccount: %s"
            "\n\nPlatform: %i"
            "\n\nVersion: %i - %i",
            "Geometry Dash",
            GameManager::sharedState()->m_playerUDID.c_str(),
            GJAccountManager::sharedState()->m_username.c_str(),
            (int)AppDelegate::get()->m_ios,
            22,
            45
        )->getCString(), "support@robtopgames.com");
    }

    UploadActionPopup* m_uploadPopup;
}

[[link(android), depends(CCIndexPath)]]
class TableView : CCScrollLayerExt, CCScrollLayerExtDelegate {
    TableView(cocos2d::CCRect rect) = win inline, m1 0x544e08 : CCScrollLayerExt(rect) {
        m_tableDelegate = nullptr;
        m_dataSource = nullptr;
        m_cellDelegate = nullptr;
        m_unused2 = false;
        this->setTouchEnabled(true);
        this->setMouseEnabled(true);
        m_vScrollbarVisible = false;
        m_hScrollbarVisible = false;
        m_disableHorizontal = false;
        m_unused3 = nullptr;
        m_delegate = this;
        m_touchOutOfBoundary = false;
        m_cellRemovedArray = cocos2d::CCArray::create();
        m_cellRemovedArray->retain();
        m_cellArray = cocos2d::CCArray::create();
        m_cellArray->retain();
        m_indexPathArray = cocos2d::CCArray::create();
        m_indexPathArray->retain();
        m_touchLastY = 0.f;
        m_cancellingTouches = false;
        m_idk2 = false;
    }
    ~TableView() = win inline, m1 0x544f30 {
        CCNode::removeAllChildrenWithCleanup(true);
        m_cellRemovedArray->removeAllObjects();
        CC_SAFE_DELETE(m_cellRemovedArray);
        m_cellArray->removeAllObjects();
        CC_SAFE_DELETE(m_cellArray);
        m_indexPathArray->removeAllObjects();
        CC_SAFE_DELETE(m_indexPathArray);
    }

    static TableView* create(TableViewDelegate* tvd, TableViewDataSource* tvds, TableViewCellDelegate* tvcd, cocos2d::CCRect rect) = win inline, imac 0x6211c0 {
        auto ret = new TableView(rect);
        ret->m_tableDelegate = tvd;
        ret->m_dataSource = tvds;
        ret->m_cellDelegate = tvcd;
        ret->setPosition({ 0.f, 0.f });
        ret->autorelease();
        return ret;
    }

    virtual void onEnter() = win 0x52e40, m1 0x545f54, imac 0x622550;
    virtual void onExit() = win 0x75290, m1 0x545f58, imac 0x622560;
    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x752a0, m1 0x5460d4, imac 0x622700;
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x75530, m1 0x546b28, imac 0x623230;
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x75450, m1 0x5468ec, imac 0x623000;
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x754b0, m1 0x546a60, imac 0x623180;
    virtual void registerWithTouchDispatcher() = win 0x3e610, m1 0x545f5c, imac 0x622570;
    virtual void scrollWheel(float y, float x) = win 0x75ae0, imac 0x623320, m1 0x546c18;
    virtual void scrllViewWillBeginDecelerating(CCScrollLayerExt* layer) = win inline, imac 0x623f20, m1 0x547774 {}
    virtual void scrollViewDidEndDecelerating(CCScrollLayerExt* layer) = win inline, m1 0x54777c, imac 0x623f40 {}
    virtual void scrollViewTouchMoving(CCScrollLayerExt* layer) = win inline, m1 0x547784, imac 0x623f60 {}
    virtual void scrollViewDidEndMoving(CCScrollLayerExt* layer) = win inline, m1 0x54778c, imac 0x623f80 {}

    void cancelAndStoleTouch(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline, m1 0x545ff8 {
        auto touches = new cocos2d::CCSet();
        touches->addObject(touch);
        touches->autorelease();
        m_cancellingTouches = true;
        cocos2d::CCDirector::sharedDirector()->getTouchDispatcher()->touchesCancelled(touches, event);
        m_cancellingTouches = false;
        this->claimTouch(touch);
    }
    TableViewCell* cellForRowAtIndexPath(CCIndexPath& path) = win inline, m1 0x545964, ios inline {
        for (int i = 0; i < m_cellArray->count(); i++) {
            auto cell = static_cast<TableViewCell*>(m_cellArray->objectAtIndex(i));
            if (cell->m_indexPath.m_row == path.m_row && cell->m_indexPath.m_section == path.m_section) {
                return cell;
            }
        }
        return nullptr;
    }
    TableViewCell* cellForTouch(cocos2d::CCTouch* touch) = win inline, imac 0x621a90, m1 0x545550 {
        auto location = cocos2d::CCDirector::sharedDirector()->convertToGL(touch->getLocationInView());
        if (!m_cellArray || m_cellArray->count() == 0) return nullptr;
        for (int i = 0; i < m_cellArray->count(); i++) {
            auto cell = static_cast<TableViewCell*>(m_cellArray->objectAtIndex(i));
            auto cellBox = cocos2d::CCRect {
                cell->getPosition().x - cell->getAnchorPoint().x * cell->getContentSize().width,
                cell->getPosition().y - cell->getAnchorPoint().y * cell->getContentSize().height,
                cell->getContentSize().width,
                cell->getContentSize().height
            };
            cellBox.origin.x = 0.f;
            cellBox.origin.y = 0.f;
            if (cellBox.containsPoint(location)) return cell;
        }
        return nullptr;
    }
    int checkBoundaryOfCell(TableViewCell* cell) = win 0x75bc0, imac 0x623360, m1 0x546c3c;
    int checkBoundaryOfCell(cocos2d::CCPoint& position, float height) = win 0x75ce0, imac 0x6234a0, m1 0x546d74;
    void checkBoundaryOfContent(float dt) = win 0x75de0, m1 0x546178;
    void checkFirstCell(TableViewCell* cell) = win 0x763a0, imac 0x623b70, m1 0x5473f0;
    void checkLastCell(TableViewCell* cell) = win 0x76650, imac 0x6235c0, m1 0x546e84;
    void claimTouch(cocos2d::CCTouch* touch) = win inline {
        auto handler = static_cast<cocos2d::CCTargetedTouchHandler*>(cocos2d::CCDirector::sharedDirector()->getTouchDispatcher()->findHandler(this));
        if (!handler->getClaimedTouches()->containsObject(touch)) {
            handler->getClaimedTouches()->addObject(touch);
        }
    }
    void deleteTableViewCell(TableViewCell* cell) = win 0x74aa0, imac 0x621c70, m1 0x5456f8;
    bool dequeueReusableCellWithIdentifier(char const* identifier) = win inline, imac 0x621f00, m1 0x54595c {
        return false;
    }
    void initTableViewCells() = imac 0x621750, m1 0x545220;
    bool isDuplicateIndexPath(CCIndexPath& path) = win 0x74a00, imac 0x621620, m1 0x5450c8;
    bool isDuplicateInVisibleCellArray(CCIndexPath* path) = win 0x74970, imac 0x621590, m1 0x545028;
    void reloadData() = win 0x74d50, imac 0x621fa0, m1 0x5459fc;
    bool removeIndexPathFromPathAddedArray(CCIndexPath& path) = win inline, imac 0x6216b0, m1 0x54516c {
        if (!m_indexPathArray || m_indexPathArray->count() == 0) return false;
        for (int i = 0; i < m_indexPathArray->count(); i++) {
            auto indexPath = static_cast<CCIndexPath*>(m_indexPathArray->objectAtIndex(i));
            if (indexPath->m_row == path.m_row && indexPath->m_section == path.m_section) {
                m_indexPathArray->removeObject(indexPath);
                return true;
            }
        }
        return false;
    }
    void scrollToIndexPath(CCIndexPath& path) = win inline, imac 0x621f90, m1 0x5459f8, ios inline {}
    void touchFinish(cocos2d::CCTouch* touch) = win 0x757f0, imac 0x623050, m1 0x546940;

    bool m_touchOutOfBoundary; //isScheduled
    cocos2d::CCTouch* m_touchStart; //beginTouch
    cocos2d::CCPoint m_touchStartPosition2; //beginLocation
    cocos2d::CCPoint m_lastCellPos;
    cocos2d::CCPoint m_touchPosition2; //checkLocation
    TableViewCell* m_touchedCell; //touchCell
    bool m_touchMoved;
    bool m_isTouch;
    cocos2d::CCArray* m_cellArray; //cellVisibleArray
    cocos2d::CCArray* m_cellRemovedArray;
    cocos2d::CCArray* m_indexPathArray;
    TableViewDelegate* m_tableDelegate;
    TableViewDataSource* m_dataSource;
    TableViewCellDelegate* m_cellDelegate;
    bool m_unused2;
    void* m_unused3;
    int m_unused4;
    float m_touchLastY;
    bool m_cancellingTouches;
    bool m_idk2;
}

[[link(android), depends(CCIndexPath)]]
class TableViewCell : cocos2d::CCLayer {
    TableViewCell(char const* identifier, float width, float height) = win 0x76b20, imac 0x626870, m1 0x549e04;
    ~TableViewCell() = win 0x76d80, m1 0x549ff4, imac 0x626ad0;

    void updateVisibility() = win inline, imac 0x7bc560, m1 0x123f6c {
        if (!m_tableView) return;
        auto height = this->getContentSize().height;
        auto tableHeight = m_tableView->getContentSize().height;
        auto y = this->getPosition().y + this->getParent()->getPosition().y;
        this->setVisible(tableHeight >= y && y >= -height);
    }

    void* m_unknown;
    TableView* m_tableView;
    CCIndexPath m_indexPath;
    void* m_unknown2;
    gd::string m_cellIdentifier;
    float m_width;
    float m_height;
    cocos2d::CCLayerColor* m_backgroundLayer;
    cocos2d::CCLayer* m_mainLayer;
    BoomListType m_listType;
}

[[link(android)]]
class TableViewCellDelegate {
    virtual bool cellPerformedAction(TableViewCell* cell, int listType, CellAction action, cocos2d::CCNode* parent) { return false; }
    virtual int getSelectedCellIdx() { return 0; }
    virtual bool shouldSnapToSelected() { return true; }
    virtual int getCellDelegateType() { return 0; }
}

[[link(android)]]
class TableViewDataSource {
    virtual int numberOfRowsInSection(unsigned int section, TableView* tableView) { return 0; }
    virtual unsigned int numberOfSectionsInTableView(TableView* tableView) { return 0; }
    virtual void TableViewCommitCellEditingStyleForRowAtIndexPath(TableView* tableView, TableViewCellEditingStyle style, CCIndexPath& indexPath) {}
    virtual TableViewCell* cellForRowAtIndexPath(CCIndexPath& indexPath, TableView* tableView) { return nullptr; }
}

[[link(android)]]
class TableViewDelegate {
    virtual void willTweenToIndexPath(CCIndexPath& indexPath, TableViewCell* cell, TableView* tableView) {}
    virtual void didEndTweenToIndexPath(CCIndexPath& indexPath, TableView* tableView) {}
    virtual void TableViewWillDisplayCellForRowAtIndexPath(CCIndexPath& indexPath, TableViewCell* cell, TableView* tableView) {}
    virtual void TableViewDidDisplayCellForRowAtIndexPath(CCIndexPath& indexPath, TableViewCell* cell, TableView* tableView) {}
    virtual void TableViewWillReloadCellForRowAtIndexPath(CCIndexPath& indexPath, TableViewCell* cell, TableView* tableView) {}
    virtual float cellHeightForRowAtIndexPath(CCIndexPath& indexPath, TableView* tableView) { return 0; }
    virtual void didSelectRowAtIndexPath(CCIndexPath& indexPath, TableView* tableView) {}
}

[[link(android)]]
class TeleportPortalObject : RingObject {
    // virtual ~TeleportPortalObject();
    TeleportPortalObject() {
        m_orangePortal = nullptr;
        m_isYellowPortal = false;
        m_teleportYOffset = 0.f;
        m_teleportEase = false;
        m_staticForceEnabled = false;
        m_staticForce = 0.f;
        m_redirectForceEnabled = false;
        m_redirectForceMod = 1.f;
        m_redirectForceMin = 0.f;
        m_redirectForceMax = 0.f;
        m_saveOffset = false;
        m_ignoreX = false;
        m_ignoreY = false;
        m_gravityMode = 0;
        m_staticForceAdditive = false;
        m_instantCamera = false;
        m_snapGround = false;
        m_redirectDash = false;
    }

    static TeleportPortalObject* create(char const* frame, bool trigger) = win 0x4b1e50, imac 0x1bd710, m1 0x1761b0;

    virtual void setPosition(cocos2d::CCPoint const& position) = win 0x4b2030, imac 0x1bdab0, m1 0x176510;
    virtual void setRotation(float rotation) = win 0x4b21b0, m1 0x1765bc, imac 0x1bdb60;
    virtual void setStartPos(cocos2d::CCPoint position) = win 0x4b1f70, m1 0x176374, imac 0x1bd910;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4b2ce0, m1 0x17844c, imac 0x1c0310;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x4b23a0, m1 0x176720, imac 0x1bdcb0;
    virtual int addToGroup(int id) = win 0x4b2260, m1 0x17663c, imac 0x1bdbf0;
    virtual void removeFromGroup(int id) = win 0x4b2310, m1 0x1766b8, imac 0x1bdc50;
    virtual void setRotation2(float rotation) = win 0x3a34f0, m1 0x176630, imac 0x1bdbc0;
    virtual void addToGroup2(int id) = win 0x4b2240, m1 0x176634, imac 0x1bdbd0;
    virtual void removeFromGroup2(int id) = win 0x4b2250, m1 0x176638, imac 0x1bdbe0;

    float getTeleportXOff(cocos2d::CCNode* parent) = win 0x4b20d0, imac 0x1bd9e0, m1 0x17643c;
    bool init(char const* frame, bool trigger) = win inline, m1 0x1762e4, ios inline {
        if (!EffectGameObject::init(frame)) return false;
        if (!trigger) m_isTouchTriggered = true;
        return true;
    }
    void setPositionOverride(cocos2d::CCPoint position) = win inline, m1 0x176370, ios inline {
        return GameObject::setPosition(position);
    }
    void setStartPosOverride(cocos2d::CCPoint position) = win inline, m1 0x176338, ios inline {
        return GameObject::setStartPos(position);
    }

    TeleportPortalObject* m_orangePortal;
    bool m_isYellowPortal;
    float m_teleportYOffset;
    // property 55
    bool m_teleportEase;
    // property 345
    bool m_staticForceEnabled;
    // property 346
    float m_staticForce;
    // property 347
    bool m_redirectForceEnabled;
    // property 350
    float m_redirectForceMod;
    // property 348
    float m_redirectForceMin;
    // property 349
    float m_redirectForceMax;
    // property 351
    bool m_saveOffset;
    // property 352
    bool m_ignoreX;
    // property 353
    bool m_ignoreY;
    // property 354
    int m_gravityMode;
    // property 443
    bool m_staticForceAdditive;
    // property 464
    bool m_instantCamera;
    // property 510
    bool m_snapGround;
    // property 591
    bool m_redirectDash;
    cocos2d::CCPoint m_teleportPosition;
}

[[link(android)]]
class TextAlertPopup : cocos2d::CCNode {
    // virtual ~TextAlertPopup();

    static TextAlertPopup* create(gd::string text, float delay, float scale, int opacity, gd::string font) = win 0x29d960, imac 0x2af2a0, m1 0x24d498;

    bool init(gd::string text, float delay, float scale, int opacity, gd::string font) = win 0x29da90;
    void setAlertPosition(cocos2d::CCPoint windowOffset, cocos2d::CCPoint pointOffset) = win inline {
        if (!m_label) return;

        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        this->setPosition({
            windowOffset.x * winSize.width + m_width / 2 + pointOffset.x,
            windowOffset.y * winSize.height + m_height / 2 + pointOffset.y
        });
    }
    void setLabelColor(cocos2d::ccColor3B color) = win inline, imac 0x2af720, m1 0x24d930 {
        if (m_label) m_label->setColor(color);
    }

    float m_width;
    float m_height;
    cocos2d::CCLabelBMFont* m_label;
}

[[link(android)]]
class TextArea : cocos2d::CCSprite {
    // virtual ~TextArea();
    // TextArea();

    static TextArea* create(gd::string str, char const* font, float scale, float width, cocos2d::CCPoint anchor, float lineHeight, bool disableColor) = win 0x76ea0, imac 0x321500, m1 0x2af104;

    virtual void update(float dt) = win 0x77700, m1 0x2afd54, imac 0x3221c0;
    virtual void draw() = win inline, m1 0x2afd50, imac 0x3221b0 {}
    virtual void setOpacity(unsigned char opacity) = win 0x77610, m1 0x2afbac, imac 0x322010;

    void colorAllCharactersTo(cocos2d::ccColor3B color) = win 0x77650, imac 0x322080, m1 0x2afc18;
    void colorAllLabels(cocos2d::ccColor3B color) = win inline, imac 0x322130, m1 0x2afcdc {
        auto lines = m_label->m_lines;
        for (int i = 0; i < lines->count(); i++) {
            static_cast<cocos2d::CCLabelBMFont*>(lines->objectAtIndex(i))->setColor(color);
        }
    }
    float fadeIn(float duration, bool unused) = win inline, m1 0x2af8dc, ios inline {
        this->stopAllActions();
        this->stopAllCharacterActions();
        this->setOpacity(0);
        this->runAction(cocos2d::CCSequence::create(
            cocos2d::CCFadeIn::create(duration),
            cocos2d::CCDelayTime::create(duration),
            cocos2d::CCCallFunc::create(this, callfunc_selector(TextArea::finishFade)),
            nullptr
        ));
        return duration;
    }
    float fadeInCharacters(float duration, float charDuration, bool fadeOut, TextFadeInStyle style) = win 0x778e0, m1 0x2afe94;
    void fadeOut(float duration) = win inline, m1 0x2afaac, ios inline {
        this->stopAllActions();
        this->stopAllCharacterActions();
        this->runAction(cocos2d::CCActionTween::create(duration, "opacity", this->getOpacity(), 0.f));
    }
    void fadeOutAndRemove() = win inline, imac 0x321eb0, m1 0x2afa3c, ios inline {
        this->fadeOut(.3f);
        this->runAction(cocos2d::CCSequence::create(
            cocos2d::CCDelayTime::create(.3f),
            cocos2d::CCCallFunc::create(this, callfunc_selector(cocos2d::CCNode::removeMeAndCleanup)),
            nullptr
        ));
    }
    void finishFade() = win 0x775f0, imac 0x321e80, m1 0x2afa18;
    void hideAll() = win inline, m1 0x2af670, ios inline {
        this->stopAllCharacterActions();
        this->setOpacity(0);
    }
    bool init(gd::string str, char const* font, float scale, float width, cocos2d::CCPoint anchor, float lineHeight, bool disableColor) = win inline, imac 0x3216b0, m1 0x2af2b4 {
        if (!cocos2d::CCSprite::init()) return false;
        m_width = width;
        m_anchorPoint = anchor;
        m_fontFile = font;
        m_scale = scale;
        m_height = lineHeight;
        m_disableColor = disableColor;
        this->setString(str);
        return true;
    }
    void setIgnoreColorCode(bool ignore) = win inline, m1 0x2af65c, ios inline {
        m_disableColor = ignore;
        if (m_label) m_label->m_disableColor = ignore;
    }
    void setString(gd::string text) = win 0x770e0, m1 0x2af3ac, imac 0x3217b0;
    void showAll() = win inline, m1 0x2af800 {
        this->stopAllCharacterActions();
        this->setOpacity(255);
        m_allShown = true;
    }
    void stopAllCharacterActions() = win 0x77530, imac 0x321bb0, m1 0x2af740;

    bool m_disableColor;
    MultilineBitmapFont* m_label;
    float m_width;
    float m_unknown;
    gd::string m_fontFile;
    float m_height;
    bool m_unkBool;
    cocos2d::CCPoint m_anchorPoint;
    bool m_allShown;
    float m_scale;
    int m_rectHeight;
    int m_rectWidth;
    float m_maxWidth;
    cocos2d::CCPoint m_unkPoint;
    TextAreaDelegate* m_delegate;
    cocos2d::CCDictionary* m_shakeCharacters;
    float m_shakeElapsed;
}

[[link(android)]]
class TextAreaDelegate {
    virtual void fadeInTextFinished(TextArea* textArea) {}
}

[[link(android)]]
class TextGameObject : GameObject {
    // virtual ~TextGameObject();
    TextGameObject() {
        m_kerning = 0;
    }

    static TextGameObject* create(cocos2d::CCTexture2D* texture) = win 0x1a74f0, imac 0x5a1850, m1 0x4e5e44;

    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x1a7980, imac 0x5d14b0, m1 0x4fdc98;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x1a7b40, imac 0x5d15e0, m1 0x4fde04;
    virtual void updateTextKerning(int kerning) = win 0x1a75d0, imac 0x5d1230, m1 0x4fd9ec;
    virtual int getTextKerning() = win 0x18b690, imac 0x5d1fd0, m1 0x4fe5ec;

    bool init(cocos2d::CCTexture2D* texture) = win inline, ios inline {
        return GameObject::initWithTexture(texture);
    }
    void updateTextObject(gd::string text, bool defaultFont) = win 0x1a75e0, imac 0x5d1240, m1 0x4fd9f4;

    // property 31
    gd::string m_text;
    // property 488
    int m_kerning;
}

[[link(android)]]
class TextInputDelegate {
    virtual void textChanged(CCTextInputNode* node) {}
    virtual void textInputOpened(CCTextInputNode* node) {}
    virtual void textInputClosed(CCTextInputNode* node) {}
    virtual void textInputShouldOffset(CCTextInputNode* node, float yOffset) {}
    virtual void textInputReturn(CCTextInputNode* node) {}
    virtual bool allowTextInput(CCTextInputNode* node) { return true; }
    virtual void enterPressed(CCTextInputNode* node) {}
}

[[link(android)]]
class TextStyleSection : cocos2d::CCObject {
    // virtual ~TextStyleSection();

    static TextStyleSection* create(int start, int end, TextStyleType type) = win 0x6d860, imac 0x488d70, m1 0x3ee6e0;
    static TextStyleSection* createColoredSection(cocos2d::ccColor3B color, int start, int end) = win inline, m1 0x3ee3a4, ios inline {
        auto ret = TextStyleSection::create(start, end, TextStyleType::Colored);
        ret->m_color = color;
        return ret;
    }
    static TextStyleSection* createDelaySection(int start, float delay) = win inline, imac 0x488b70, m1 0x3ee534, ios inline {
        auto ret = TextStyleSection::create(start, -1, TextStyleType::Delayed);
        ret->m_delay = delay;
        return ret;
    }
    static TextStyleSection* createInstantSection(int start, int end, float duration) = win inline, imac 0x488a60, m1 0x3ee428, ios inline {
        auto ret = TextStyleSection::create(start, end, TextStyleType::Instant);
        ret->m_instantTime = duration;
        return ret;
    }
    static TextStyleSection* createShakeSection(int start, int end, int intensity, int perSecond) = win inline, imac 0x488ae0, m1 0x3ee4ac, ios inline {
        auto ret = TextStyleSection::create(start, end, TextStyleType::Shake);
        ret->m_shakeIntensity = intensity;
        ret->m_shakesPerSecond = perSecond;
        return ret;
    }

    bool init(int start, int end, TextStyleType type) = win inline, imac 0x488de0, m1 0x3ee754, ios inline {
        m_styleType = type;
        m_startIndex = start;
        m_endIndex = end;
        return true;
    }

    TextStyleType m_styleType;
    int m_startIndex;
    int m_endIndex;
    cocos2d::ccColor3B m_color;
    float m_instantTime;
    float m_delay;
    int m_shakeIntensity;
    int m_shakesPerSecond;
}

[[link(android)]]
class TimerTriggerAction {
    TimerTriggerAction() {}
    TimerTriggerAction(int targetID, float targetTime, bool multiActivate, int itemID, gd::vector<int> const& remapKeys, int uniqueID, int controlID) {
        m_disabled = false;
        m_time = 0.f;
        m_targetTime = targetTime;
        m_targetGroupID = targetID;
        m_triggerUniqueID = uniqueID;
        m_controlID = controlID;
        m_itemID = itemID;
        m_multiActivate = multiActivate;
        m_remapKeys = remapKeys;
    }

    bool m_disabled;
    float m_time;
    float m_targetTime;
    int m_targetGroupID;
    int m_triggerUniqueID;
    int m_controlID;
    int m_itemID;
    bool m_multiActivate;
    gd::vector<int> m_remapKeys;
}

[[link(android)]]
class TimerTriggerGameObject : EffectGameObject {
    // virtual ~TimerTriggerGameObject();
    TimerTriggerGameObject() {
        m_startTime = 0.0;
        m_targetTime = 0.0;
        m_stopTimeEnabled = false;
        m_dontOverride = false;
        m_ignoreTimeWarp = false;
        m_timeMod = 1.f;
        m_startPaused = false;
        m_multiActivate = false;
        m_controlType = 0;
    }

    static TimerTriggerGameObject* create(char const* frame) = win inline, m1 0x194114 {
        auto ret = new TimerTriggerGameObject();
        if (ret->init(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void triggerObject(GJBaseGameLayer* layer, int uniqueID, gd::vector<int> const* remapKeys) = win 0x4bee70, m1 0x19423c, imac 0x1e2a30;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4bf650, m1 0x195a7c, imac 0x1e4950;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x4bef80, m1 0x194334, imac 0x1e2b30;

    bool init(char const* frame) = win inline, m1 0x1941f4, ios inline {
        return EffectGameObject::init(frame);
    }

    // property 467
    double m_startTime;
    // property 473
    double m_targetTime;
    // property 474
    bool m_stopTimeEnabled;
    // property 468
    bool m_dontOverride;
    // property 469
    bool m_ignoreTimeWarp;
    // property 470
    float m_timeMod;
    // property 471
    bool m_startPaused;
    // property 475
    bool m_multiActivate;
    // property 472
    int m_controlType;
}

[[link(android)]]
class ToggleTriggerAction {
    ToggleTriggerAction() {}
    ToggleTriggerAction(int targetID, bool activateGroup, gd::vector<int> const& remapKeys, int uniqueID, int controlID) {
        m_disabled = false;
        m_targetGroupID = targetID;
        m_activateGroup = activateGroup;
        m_triggerUniqueID = uniqueID;
        m_controlID = controlID;
        m_remapKeys = remapKeys;
    }

    bool m_disabled;
    int m_targetGroupID;
    bool m_activateGroup;
    int m_triggerUniqueID;
    int m_controlID;
    gd::vector<int> m_remapKeys;
}

[[link(android)]]
class TopArtistsLayer : FLAlertLayer, OnlineListDelegate {
    TopArtistsLayer() {
        m_topArtists = nullptr;
        m_listLayer = nullptr;
        m_loadingCircle = nullptr;
        m_page = 0;
    }
    ~TopArtistsLayer() = win inline, m1 0x29f18c {
        auto glm = GameLevelManager::sharedState();
        if (glm->m_onlineListDelegate == this) glm->m_onlineListDelegate = nullptr;
    }

    static TopArtistsLayer* create() = win inline, m1 0x29f488 {
        auto ret = new TopArtistsLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x4ca8a0, m1 0x29f590, imac 0x310310;
    virtual void registerWithTouchDispatcher() = win 0x42660, m1 0x29feb8, imac 0x310cb0;
    virtual void keyBackClicked() = win 0x846c0, m1 0x29fe3c, imac 0x310c40;
    virtual void show() = win 0x86810, m1 0x2a0a24, imac 0x3117f0;
    virtual void loadListFinished(cocos2d::CCArray* objects, char const* key) = win 0x4cb040, imac 0x310d00, m1 0x29fef8;
    virtual void loadListFailed(char const* key) = win 0x4cb0a0, imac 0x310dc0, m1 0x29ffbc;
    virtual void setupPageInfo(gd::string info, char const* key) = win 0x4cb200, imac 0x310e00, m1 0x29ffe4;

    bool isCorrect(char const* key) = win inline, imac 0x310cf0, m1 0x29fef0, ios inline {
        return true;
    }
    void loadPage(int page) = win 0x4cb3e0, imac 0x311400, m1 0x2a0658;
    void onClose(cocos2d::CCObject* sender) = win 0x84690, m1 0x29fcbc;
    void onNextPage(cocos2d::CCObject* sender) = win 0x4cb850, m1 0x29fd04;
    void onPrevPage(cocos2d::CCObject* sender) = win 0x4cb860, m1 0x29fcf8;
    void setupLeaderboard(cocos2d::CCArray* artists) = win 0x4cb0b0, m1 0x29fd10;
    void updateLevelsLabel() = win inline, m1 0x2a05d0 {
        auto end = m_pageEndIdx + m_pageStartIdx;
        auto count = m_itemCount;
        if (end > count) end = count;
        m_pageInfoLabel->setString(cocos2d::CCString::createWithFormat("%i to %i of %i", m_pageStartIdx + 1, end, count)->getCString());
        m_pageInfoLabel->limitLabelWidth(100.f, .5f, .0f);
    }

    cocos2d::CCArray* m_topArtists;
    GJCommentListLayer* m_listLayer;
    LoadingCircle* m_loadingCircle;
    CCMenuItemSpriteExtra* m_nextButton;
    CCMenuItemSpriteExtra* m_prevButton;
    void* m_unkPtr;
    cocos2d::CCLabelBMFont* m_pageInfoLabel;
    int m_itemCount;
    int m_pageStartIdx;
    int m_pageEndIdx;
    int m_unkSize4;
    int m_page;
}

[[link(android)]]
class TOSPopup : FLAlertLayer {
    // virtual ~TOSPopup();
    TOSPopup() {}

    static TOSPopup* create() = win inline, m1 0x24da5c {
        auto ret = new TOSPopup();
        if(ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x29ddf0, m1 0x24db4c, imac 0x2afa00;
    virtual void keyBackClicked() = win inline, m1 0x24e198, imac 0x2b0080 {}

    void onClose(cocos2d::CCObject* sender) = m1 0x24e0fc;
    void onPrivacy(cocos2d::CCObject* sender) = m1 0x24e174;
    void onTOS(cocos2d::CCObject* sender) = m1 0x24e150;
}

[[link(android)]]
class TouchToggleAction {
    TouchToggleAction() {}
    TouchToggleAction(int targetID, bool holdMode, TouchTriggerType touchType, TouchTriggerControl touchControl, bool dualMode, gd::vector<int> const& remapKeys, int uniqueID, int controlID) {
        m_disabled = false;
        m_targetGroupID = targetID;
        m_holdMode = holdMode;
        m_touchTriggerType = touchType;
        m_touchTriggerControl = touchControl;
        m_triggerUniqueID = uniqueID;
        m_controlID = controlID;
        m_dualMode = dualMode;
        m_remapKeys = remapKeys;
    }

    bool m_disabled;
    int m_targetGroupID;
    bool m_holdMode;
    TouchTriggerType m_touchTriggerType;
    TouchTriggerControl m_touchTriggerControl;
    int m_triggerUniqueID;
    int m_controlID;
    bool m_dualMode;
    gd::vector<int> m_remapKeys;
}

[[link(android)]]
class TransformTriggerGameObject : EffectGameObject {
    // virtual ~TransformTriggerGameObject();
    TransformTriggerGameObject() {
        m_objectScaleX = 1.f;
        m_objectScaleY = 1.f;
        m_property450 = 0.f;
        m_property451 = 0.f;
        m_onlyMove = false;
        m_divideX = false;
        m_divideY = false;
        m_relativeRotation = false;
        m_relativeScale = false;
    }

    static TransformTriggerGameObject* create(char const* frame) = win inline, m1 0x18cc18 {
        auto ret = new TransformTriggerGameObject();
        if (ret->init(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void triggerObject(GJBaseGameLayer* layer, int uniqueID, gd::vector<int> const* remapKeys) = win 0x4bbe10, m1 0x18cd38, imac 0x1d9200;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4bbe30, imac 0x1d9230, m1 0x18cd58;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x4bc130, m1 0x18d020, imac 0x1d9610;

    bool init(char const* frame) = win inline, ios inline {
        return EffectGameObject::init(frame);
    }

    // property 150
    float m_objectScaleX;
    // property 151
    float m_objectScaleY;
    // property 450
    float m_property450;
    // property 451
    float m_property451;
    // property 133
    bool m_onlyMove;
    // property 153
    bool m_divideX;
    // property 154
    bool m_divideY;
    // property 452
    bool m_relativeRotation;
    // property 577
    bool m_relativeScale;
}

[[link(android)]]
class TriggerControlGameObject : EffectGameObject {
    // virtual ~TriggerControlGameObject();
    TriggerControlGameObject() {
        m_customTriggerValue = GJActionCommand::Stop;
    }

    static TriggerControlGameObject* create(char const* frame) = win inline {
        auto ret = new TriggerControlGameObject();
        if (ret->init(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void triggerObject(GJBaseGameLayer* layer, int uniqueID, gd::vector<int> const* remapKeys) = win 0x4c2fb0, m1 0x19e6ec, imac 0x1ef7a0;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4c2ec0, m1 0x19e494, imac 0x1ef550;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x4c2c60, m1 0x19dd08, imac 0x1eec20;

    bool init(char const* frame) = win inline, imac 0x1eebc0, m1 0x19dcac {
        m_triggerControlFrame = frame;
        return EffectGameObject::init(frame);
    }
    void updateTriggerControlFrame() = win 0x4c2fe0, imac 0x1ef640, m1 0x19e584;

    gd::string m_triggerControlFrame;
    // property 580 (The type of a stop trigger for example)
    GJActionCommand m_customTriggerValue;
}

[[link(android)]]
class TriggerEffectDelegate {
    virtual void toggleGroupTriggered(int group, bool activate, gd::vector<int> const& remapKeys, int triggerID, int controlID) {}
    virtual void spawnGroup(int group, bool ordered, double delay, gd::vector<int> const& remapKeys, int triggerID, int controlID) {}
    virtual void spawnObject(GameObject* object, double delay, gd::vector<int> const& remapKeys) {}
}

[[link(android)]]
class TutorialLayer : FLAlertLayer {
    // virtual ~TutorialLayer();

    static TutorialLayer* create() = win 0x4cb920, m1 0x43878c;

    virtual bool init() = win 0x4cba30, m1 0x438890, imac 0x4dc140;
    virtual void keyBackClicked() = win 0x4cc650, m1 0x439324, imac 0x4dcb70;

    void loadPage(int page) = win 0x4cbfa0, imac 0x4dc6c0, m1 0x438e60;
    void onClose(cocos2d::CCObject* sender) = win 0x4cc5d0;
    void onNext(cocos2d::CCObject* sender) = win 0x4cbf80;
    void removeTutorialTexture() = win inline {
        if (m_page == 0) return;
        cocos2d::CCTextureCache::sharedTextureCache()->removeTextureForKey(cocos2d::CCString::createWithFormat("tutorial_%02d", m_page)->getCString());
    }

    cocos2d::CCLayer* m_tutorialLayer;
    int m_page;
    CCMenuItemSpriteExtra* m_nextButton;
    CCMenuItemSpriteExtra* m_exitButton;
}

[[link(android)]]
class TutorialPopup : FLAlertLayer {
    // virtual ~TutorialPopup();

    static TutorialPopup* create(gd::string frame) = m1 0x4ffd20;

    virtual void keyBackClicked() = m1 0x500108, imac 0x5d4040;
    virtual void show() = m1 0x5001e4, imac 0x5d4110;

    void animateMenu() = imac 0x5d4160, m1 0x500240;
    void closeTutorial(cocos2d::CCObject* sender);
    bool init(gd::string frame);
    void registerForCallback(cocos2d::SEL_MenuHandler selector, cocos2d::CCNode* target) = imac 0x5d41d0, m1 0x5002b0;

    gd::string m_currentSprite;
    bool m_callbackRegistered;
    cocos2d::SEL_MenuHandler m_callbackSelector;
    cocos2d::CCNode* m_targetNode;
    CCMenuItemSpriteExtra* m_closeButton;
}

[[link(android)]]
class UIButtonConfig {
    void reset() = win 0x17aa30 {
        m_width = 280;
        m_height = 120;
        m_deadzone = 0.f;
        m_scale = 1.f;
        m_opacity = 255;
        m_radius = 10.f;
        m_modeB = false;
        m_position.x = 95.f;
        m_position.y = 36.f;
        m_oneButton = false;
        m_player2 = false;
        m_snap = false;
        m_split = false;
    }
    void resetOneBtn() = win 0x17aaa0 {
        this->reset();
        m_width = 200;
        m_height = 200;
        m_position.x = 95.f;
        m_position.y = 196.f;
        m_oneButton = true;
    }

    int m_width;
    int m_height;
    float m_deadzone;
    float m_scale;
    int m_opacity;
    float m_radius;
    bool m_modeB;
    bool m_snap;
    cocos2d::CCPoint m_position;
    bool m_oneButton;
    bool m_player2;
    bool m_split;
}

[[link(android)]]
class UILayer : cocos2d::CCLayerColor {
    UILayer() {
        m_pUnknown1 = nullptr;
        m_checkpointMenu = nullptr;
        m_pauseBtn = nullptr;
        m_bUnknown2 = false;
        m_bUnknown3 = false;
        m_p1Jumping = false;
        m_p2Jumping = false;
        m_checkpointBtnDown = false;
        m_p1TouchId = -1;
        m_p2TouchId = -1;
        m_clkTimer = 0.f;
        m_inPlatformer = false;
        m_gameLayer = nullptr;
        m_initialized = false;
        m_uiNodes = nullptr;
        m_dualMode = false;
        m_dpadType = false;
        m_editorMode = false;
        m_controllerButtons = nullptr;
    }
    ~UILayer() = win inline {
        CC_SAFE_RELEASE(m_uiNodes);
        CC_SAFE_RELEASE(m_controllerButtons);
    }

    static UILayer* create(GJBaseGameLayer* layer) = win inline, imac 0x4c7560 {
        auto ret = new UILayer();
        if (ret->init(layer)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static UILayer* get() {
        if (auto gjbgl = GJBaseGameLayer::get()) return gjbgl->m_uiLayer;
        return nullptr;
    }

    virtual void draw() = win inline, m1 0x4282d8, imac 0x4c9400 {}
    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x4cde50, m1 0x428378, imac 0x4c9470;
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x4ce040, m1 0x4285fc, imac 0x4c9670;
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x4ce060, m1 0x428750, imac 0x4c9780;
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x71260, m1 0x42909c, imac 0x4ca060;
    virtual void registerWithTouchDispatcher() = win 0x9b7f0, m1 0x4290b8, imac 0x4ca0a0;
    virtual void keyBackClicked() = win 0x4cdad0, m1 0x427ec0, imac 0x4c8fc0;
    virtual void keyDown(cocos2d::enumKeyCodes key, double timestamp) = win 0x4cda90, m1 0x427e80, imac 0x4c8f20;
    virtual void keyUp(cocos2d::enumKeyCodes key, double timestamp) = win 0x4cdab0, m1 0x427ea0, imac 0x4c8f70;

    void disableMenu() = win inline, imac 0x4c88f0, m1 0x4279ec {
        m_pauseBtn->setEnabled(false);
    }
    void doPause() = win inline, imac 0x4c9080, m1 0x427f80 {
        m_p1TouchId = -1;
        m_p2TouchId = -1;
        this->resetUINodeState();
        if (auto playLayer = GameManager::sharedState()->m_playLayer) {
            playLayer->pauseGame(false);
            playLayer->m_gameState.m_pauseCounter++;
        }
    }
    void editorPlaytest(bool visible) = win inline, imac 0x4c8910, m1 0x427a00 {
        this->resetAllButtons();
        this->toggleMenuVisibility(visible);
        this->setVisible(visible);
        cocos2d::CCEGLView::sharedOpenGLView()->toggleGameplayActive(false);
    }
    void enableEditorMode() = win inline, imac 0x4c87b0, m1 0x4278b0 {
        m_editorMode = true;
        m_pauseBtn->setVisible(false);
        this->disableMenu();
        this->editorPlaytest(false);
    }
    void enableMenu() = win inline, imac 0x4c9190, m1 0x428088 {
        m_pauseBtn->setEnabled(true);
    }
    void handleKeypress(cocos2d::enumKeyCodes key, bool down, double timestamp) = win 0x4cd4c0;
    bool init(GJBaseGameLayer* layer) = win 0x4cc790, m1 0x426884, imac 0x4c76a0;
    bool isJumpButtonPressed(bool player1) = win inline, imac 0x4c9440 {
        return player1 ? (m_p2TouchId != -1 || m_p1Jumping) : (m_p1TouchId != -1 || m_p2Jumping);
    }
    void onCheck(cocos2d::CCObject* sender) = m1 0x4270a8;
    void onDeleteCheck(cocos2d::CCObject* sender) = m1 0x4270e4;
    void onPause(cocos2d::CCObject* sender) = win 0x4cdb90, m1 0x42705c;
    bool processUINodesTouch(GJUITouchEvent event, cocos2d::CCTouch* touch) = m1 0x428498;
    bool processUINodeTouch(GJUITouchEvent event, int touchID, cocos2d::CCPoint position, GJUINode* node) = win 0x4ce210;
    void refreshDpad() = win inline, imac 0x4c82b0, m1 0x427410 {}
    void resetAllButtons() = win inline {
        m_p1Jumping = false;
        m_p2Jumping = false;
        m_checkpointBtnDown = false;
        m_p1TouchId = -1;
        m_p2TouchId = -1;
        this->resetUINodeState();
    }
    void resetUINodeState() = win 0x4cd350;
    void toggleCheckpointsMenu(bool visible) = win 0x4cdb10, m1 0x427114;
    void toggleMenuVisibility(bool visible) = win inline, m1 0x142320 {
        this->resetUINodeState();
        if (GameManager::sharedState()->getGameVariable("0024")) {
            static_cast<cocos2d::CCNodeRGBA*>(m_pauseBtn->getNormalImage())->setOpacity(visible ? 75 : 0);
            this->updateUINodeVisibility(visible && m_inPlatformer);
        }
    }
    void togglePlatformerMode(bool platformer) = win inline, imac 0x4c8160, m1 0x4272d4 {
        m_inPlatformer = platformer;
        this->refreshDpad();
        this->updateUINodeVisibility(platformer);
    }
    void updateCheckState() = win 0x4cd0b0, m1 0x427158;
    void updateDualMode(bool dual) = win inline {
        if (m_dualMode == dual) return;
        m_dualMode = dual;
        this->togglePlatformerMode(m_inPlatformer);
    }
    void updateUINodeVisibility(bool visible) = win 0x4cd460, m1 0x42768c;

    // This member is here because rob managed to inhert CCKeyboardDelegate twice
    // in this class, which ended up breaking addresser when trying to hook it.
    // so instead, we removed the second CCKeyboardDelegate from the base class list
    // and put this member here to take the place of its vtable
    void* m_stupidDelegate;
    void* m_pUnknown1;
    cocos2d::CCMenu* m_checkpointMenu;
    CCMenuItemSpriteExtra* m_pauseBtn;
    bool m_bUnknown2;
    bool m_bUnknown3;
    bool m_p1Jumping;
    bool m_p2Jumping;
    bool m_checkpointBtnDown;
    int m_p1TouchId;
    int m_p2TouchId;
    float m_clkTimer;
    bool m_inPlatformer;
    GJBaseGameLayer* m_gameLayer;
    bool m_initialized;
    cocos2d::CCArray* m_uiNodes;
    bool m_dualMode;
    bool m_dpadType;
    bool m_editorMode;
    cocos2d::CCArray* m_controllerButtons;
}

[[link(android)]]
class UIObjectSettingsPopup : SetupTriggerPopup {
    // virtual ~UIObjectSettingsPopup();

    static UIObjectSettingsPopup* create(UISettingsGameObject* object, cocos2d::CCArray* objects);

    virtual void onCustomToggleTriggerValue(cocos2d::CCObject* sender) = win 0x46a160, m1 0x4c9d98, imac 0x57d4c0;

    bool init(UISettingsGameObject* object, cocos2d::CCArray* objects) = win 0x469620, imac 0x52d0;
}

[[link(android)]]
class UIOptionsLayer : SetupTriggerPopup {
    // virtual ~UIOptionsLayer();

    static UIOptionsLayer* create(bool dual) = win 0x2a0b00, imac 0x2b1790, m1 0x24f92c;

    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x2a3b60, m1 0x252314, imac 0x2b4940;
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x2a3cb0, m1 0x2524d8, imac 0x2b4a80;
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x2a3de0, imac 0x2b4b90, m1 0x2526c4;
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x71260, m1 0x2527fc, imac 0x2b4cd0;
    virtual void registerWithTouchDispatcher() = win 0x9b7f0, m1 0x252818, imac 0x2b4d10;
    virtual void onClose(cocos2d::CCObject* sender) = win 0x2a2c40, m1 0x251d40, imac 0x2b41f0;
    virtual void valueDidChange(int tag, float value) = win 0x2a3040, imac 0x2b4380, m1 0x251e90;
    virtual float getValue(int tag) = win 0x2a37c0, imac 0x2b46a0, m1 0x2520f0;

    GJUINode* getNode(int type) = win inline, ios inline {
        switch (type) {
            case 0: return m_uiNode1;
            case 1: return m_uiNode2;
            case 2: return m_uiNode3;
            case 3: return m_uiNode4;
            default: return nullptr;
        }
    }
    bool init(bool dual) = win 0x2a0c40, imac 0x4d9f20, m1 0x250150;
    void onReset(cocos2d::CCObject* sender) = win 0x2a2f30, m1 0x2519c8;
    void onSaveLoad(cocos2d::CCObject* sender) = win 0x2a2b10, imac 0x2b3e70, m1 0x251a38;
    void toggleUIGroup(int group) = win 0x2a2950, imac 0x2b3e90, m1 0x251a54;

    bool m_dual;
    GJUINode* m_uiNode1;
    GJUINode* m_uiNode2;
    GJUINode* m_uiNode3;
    GJUINode* m_uiNode4;
    cocos2d::CCLabelBMFont* m_nameLabel;
    int m_activeUIGroup;
}

[[link(android)]]
class UIPOptionsLayer : SetupTriggerPopup {
    // virtual ~UIPOptionsLayer();
    UIPOptionsLayer() = m1 0x255534 {
        m_touchID = -1;
        m_practiceNode = nullptr;
    }

    static UIPOptionsLayer* create() = win inline, m1 0x24fab0 {
        auto ret = new UIPOptionsLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x2a5690, m1 0x2546fc, imac 0x2b6c80;
    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x2a6000, m1 0x254df0, imac 0x2b73d0;
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x2a6110, imac 0x2b74f0, m1 0x254f0c;
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x2a61c0, imac 0x2b7660, m1 0x255068;
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x71260, m1 0x2550a0, imac 0x2b76a0;
    virtual void registerWithTouchDispatcher() = win 0x9b7f0, m1 0x2550bc, imac 0x2b76e0;
    virtual void onClose(cocos2d::CCObject* sender) = win 0x2a5ca0, imac 0x2b71f0, m1 0x254c38;
    virtual void valueDidChange(int tag, float value) = win 0x2a5ea0, imac 0x2b7270, m1 0x254ca8;
    virtual float getValue(int tag) = win 0x2a5fa0, imac 0x2b7340, m1 0x254d5c;

    cocos2d::CCRect getTouchRect() = win inline, imac 0x2b7360, m1 0x254d80 {
        return { m_practiceNode->getPosition() - cocos2d::CCPoint { 70.0f, 25.0f }, { 140.0f, 50.0f } };
    }
    void onReset(cocos2d::CCObject* sender) = win 0x2a5d80, m1 0x254b90;

    int m_touchID;
    cocos2d::CCNode* m_practiceNode;
    cocos2d::CCPoint m_touchPosition;
    cocos2d::CCPoint m_touchDelta;
}

[[link(android)]]
class UISaveLoadLayer : SetupTriggerPopup {
    // virtual ~UISaveLoadLayer();
    UISaveLoadLayer() {
        m_optionsLayer = nullptr;
    }

    static UISaveLoadLayer* create(UIOptionsLayer* layer) = win inline, imac 0x2b3fc0, m1 0x251bc4 {
        auto ret = new UISaveLoadLayer();
        if (ret->init(layer)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init(UIOptionsLayer* layer) = win 0x2a3e60, imac 0x2b4d50, m1 0x252850;
    void onLoad(cocos2d::CCObject* sender);
    void onSave(cocos2d::CCObject* sender);

    UIOptionsLayer* m_optionsLayer;
}

[[link(android)]]
class UISettingsGameObject : EffectGameObject {
    // virtual ~UISettingsGameObject();
    UISettingsGameObject() {
        m_xRef = 0;
        m_yRef = 0;
        m_xRelative = false;
        m_yRelative = false;
    }

    static UISettingsGameObject* create() = win inline, m1 0x18f708 {
        auto ret = new UISettingsGameObject();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x4bcf00, m1 0x18f7d4, imac 0x1dc850;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4bd320, imac 0x1dd7f0, m1 0x190458;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x4bcf70, m1 0x18f824, imac 0x1dc8a0;

    // property 385
    int m_xRef;
    // property 386
    int m_yRef;
    // property 387
    bool m_xRelative;
    // property 388
    bool m_yRelative;
}

[[link(android), depends(GJTransformState)]]
class UndoObject : cocos2d::CCObject {
    UndoObject() {
        m_objectCopy = nullptr;
        m_command = (UndoCommand)0;
        m_objects = nullptr;
        m_redo = false;
        m_undoTransform = false;
    }
    ~UndoObject() = win inline, m1 0xdf688 {
        CC_SAFE_RELEASE(m_objectCopy);
        CC_SAFE_RELEASE(m_objects);
    }

    static UndoObject* create(GameObject* object, UndoCommand command) = win inline {
        auto ret = new UndoObject();
        if (ret->init(object, command)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static UndoObject* createWithArray(cocos2d::CCArray* array, UndoCommand command) = win inline {
        auto ret = new UndoObject();
        if (ret->init(array, command)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static UndoObject* createWithTransformObjects(cocos2d::CCArray* objects, UndoCommand command) = win inline {
        auto ret = new UndoObject();
        if (ret->initWithTransformObjects(objects, command)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init(GameObject* object, UndoCommand command) = win inline, imac 0x1005e0, m1 0xdf764, ios inline {
        if (object) {
            m_objectCopy = GameObjectCopy::create(object);
            m_objectCopy->retain();
        }
        m_command = command;
        return true;
    }
    bool init(cocos2d::CCArray* array, UndoCommand command) = win inline, imac 0x100780, m1 0xdf8fc {
        if (array) {
            m_objects = cocos2d::CCArray::create();
            m_objects->addObjectsFromArray(array);
            m_objects->retain();
        }
        m_command = command;
        return true;
    }
    bool initWithTransformObjects(cocos2d::CCArray* objects, UndoCommand command) = win inline, m1 0xdf878 {
        m_objects = cocos2d::CCArray::create();
        for (int i = 0; i < objects->count(); i++) {
            m_objects->addObject(GameObjectCopy::create(static_cast<GameObject*>(objects->objectAtIndex(i))));
        }
        m_objects->retain();
        m_command = command;
        return true;
    }
    void setObjects(cocos2d::CCArray* objects) = win inline, m1 0xc8bd4 {
        if (m_objects != objects) {
            CC_SAFE_RETAIN(objects);
            CC_SAFE_RELEASE(m_objects);
            m_objects = objects;
        }
    }

    GameObjectCopy* m_objectCopy;
    UndoCommand m_command;
    cocos2d::CCArray* m_objects;
    bool m_redo;
    bool m_undoTransform;
    GJTransformState m_transformState;
}

[[link(android)]]
class UpdateAccountSettingsPopup : FLAlertLayer, GJAccountSettingsDelegate {
    UpdateAccountSettingsPopup() {
        m_updateSuccess = false;
        m_textArea = nullptr;
        m_loadingCircle = nullptr;
        m_closeButton = nullptr;
    }
    ~UpdateAccountSettingsPopup() = win inline, m1 0x241c00 {
        auto gjam = GJAccountManager::sharedState();
        if (gjam->m_accountSettingsDelegate == this) gjam->m_accountSettingsDelegate = nullptr;
    }

    static UpdateAccountSettingsPopup* create(GJAccountSettingsLayer* settingsLayer, int messageStatus, int friendStatus, int commentStatus, gd::string youtubeURL, gd::string twitterURL, gd::string twitchURL, gd::string instagramURL, gd::string tiktokURL, gd::string discordUsername, gd::string customString) = win 0x2943d0 {
        auto ret = new UpdateAccountSettingsPopup();
        if (ret->init(settingsLayer, messageStatus, friendStatus, commentStatus, youtubeURL, twitterURL, twitchURL, instagramURL, tiktokURL, discordUsername, customString)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyBackClicked() = win 0x294fd0, m1 0x2428c4, imac 0x2a3990;
    virtual void updateSettingsFinished() = win 0x294d90, imac 0x2a3780, m1 0x2426c0;
    virtual void updateSettingsFailed() = win 0x294e90, imac 0x2a38a0, m1 0x2427d8;

    bool init(GJAccountSettingsLayer* settingsLayer, int messageStatus, int friendStatus, int commentStatus, gd::string youtubeURL, gd::string twitterURL, gd::string twitchURL, gd::string instagramURL, gd::string tiktokURL, gd::string discordUsername, gd::string customString) = win 0x2946c0;
    void onClose(cocos2d::CCObject* sender);

    bool m_updateSuccess;
    GJAccountSettingsLayer* m_settingsLayer;
    TextArea* m_textArea;
    LoadingCircle* m_loadingCircle;
    CCMenuItemSpriteExtra* m_closeButton;
}

[[link(android)]]
class UploadActionDelegate {
    virtual void uploadActionFinished(int id, int response) {}
    virtual void uploadActionFailed(int id, int response) {}
}

[[link(android)]]
class UploadActionPopup : FLAlertLayer {
    // virtual ~UploadActionPopup();

    static UploadActionPopup* create(UploadPopupDelegate* delegate, gd::string str) = win 0x294fe0, imac 0x2a3b50, m1 0x242a38;

    virtual void keyBackClicked() = win 0x2957e0, imac 0x2a4480, m1 0x24330c;

    void closePopup() = win inline, imac 0x2a4450, m1 0x2432d0 {
        this->setKeypadEnabled(false);
        this->removeFromParentAndCleanup(true);
    }
    bool init(UploadPopupDelegate* delegate, gd::string str) = win 0x295120, imac 0x5ee340;
    void onClose(cocos2d::CCObject* sender) = win 0x295790, imac 0x2a4140, m1 0x242fcc;
    void showFailMessage(gd::string message) = win 0x295690, m1 0x243188;
    void showSuccessMessage(gd::string message) = win 0x295580, m1 0x24302c;

    UploadPopupDelegate* m_delegate;
    TextArea* m_textArea;
    LoadingCircle* m_loadingCircle;
    CCMenuItemSpriteExtra* m_closeButton;
    bool m_succeeded;
}

[[link(android)]]
class UploadListPopup : FLAlertLayer, ListUploadDelegate {
    UploadListPopup() {
        m_levelList = nullptr;
        m_textArea = nullptr;
        m_loadingCircle = nullptr;
        m_backButton = nullptr;
    }
    ~UploadListPopup() = win inline, m1 0x2ee02c {
        CC_SAFE_RELEASE(m_levelList);
        auto glm = GameLevelManager::sharedState();
        if (glm->m_listUploadDelegate == this) glm->m_listUploadDelegate = nullptr;
    }

    static UploadListPopup* create(GJLevelList* list) = win inline {
        auto ret = new UploadListPopup();
        if (ret->init(list)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyBackClicked() = win inline, imac 0x363eb0, m1 0x2eeccc {}
    virtual void show() = win 0x30b9f0, m1 0x2eec6c, imac 0x363e40;
    virtual void listUploadFinished(GJLevelList* list) = win 0x30b490, m1 0x2ee770, imac 0x363940;
    virtual void listUploadFailed(GJLevelList* list, int response) = win 0x30b660, imac 0x363b60, m1 0x2ee974;

    bool init(GJLevelList* list) = win 0x30af50;
    void onBack(cocos2d::CCObject* sender) = win 0x30ba50;
    void onClose(cocos2d::CCObject* sender) = win 0x84690, imac 0x363df0, m1 0x2eec28;
    void onReturnToList(cocos2d::CCObject* sender) = win 0x30b9a0, m1 0x2ee920;

    GJLevelList* m_levelList;
    TextArea* m_textArea;
    LoadingCircle* m_loadingCircle;
    CCMenuItemSpriteExtra* m_backButton;
}

[[link(android)]]
class UploadMessageDelegate {
    virtual void uploadMessageFinished(int accountID) {}
    virtual void uploadMessageFailed(int accountID) {}
}

[[link(android)]]
class UploadPopup : FLAlertLayer, LevelUploadDelegate {
    UploadPopup() {
        m_level = nullptr;
        m_textArea = nullptr;
        m_loadingCircle = nullptr;
        m_backButton = nullptr;
    }
    ~UploadPopup() = win inline, m1 0x2233a0 {
        CC_SAFE_RELEASE(m_level);
        auto glm = GameLevelManager::sharedState();
        if (glm->m_levelUploadDelegate == this) glm->m_levelUploadDelegate = nullptr;
    }

    static UploadPopup* create(GJGameLevel* level) = win inline {
        auto ret = new UploadPopup();
        if (ret->init(level)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyBackClicked() = win inline, m1 0x223e38, imac 0x282090 {}
    virtual void show() = win 0x30b9f0, m1 0x223dd8, imac 0x282020;
    virtual void levelUploadFinished(GJGameLevel* level) = win 0x490880, m1 0x2239a8, imac 0x281bc0;
    virtual void levelUploadFailed(GJGameLevel* level) = win 0x490a50, m1 0x223be0, imac 0x281e10;

    bool init(GJGameLevel* level) = win 0x4902b0;
    void onBack(cocos2d::CCObject* sender) = win 0x490d20;
    void onClose(cocos2d::CCObject* sender) = win 0x84690, imac 0x281fd0, m1 0x223d94;
    void onReturnToLevel(cocos2d::CCObject* sender) = win 0x490c30, m1 0x223b58;

    GJGameLevel* m_level;
    TextArea* m_textArea;
    LoadingCircle* m_loadingCircle;
    CCMenuItemSpriteExtra* m_backButton;
}

[[link(android)]]
class UploadPopupDelegate {
    virtual void onClosePopup(UploadActionPopup* popup) {}
}

[[link(android)]]
class URLCell : TableViewCell {
    // virtual ~URLCell();
    URLCell(char const* identifier, float width, float height) = win inline, ios inline : TableViewCell(identifier, width, height) {
        this->init();
    }

    virtual bool init() = win 0x3c850, m1 0x1fe54c, imac 0x2592c0;
    virtual void draw() = win 0xade40, m1 0x1fe5b4, imac 0x259330;

    void loadFromObject(CCURLObject* object) = win 0xc0270, imac 0x247160, m1 0x1ee0d0;
    void onURL(cocos2d::CCObject* sender) = win 0xc04a0;
    void updateBGColor(int index) = win inline {
        m_backgroundLayer->setColor(index % 2 == 0 ? cocos2d::ccColor3B { 161, 88, 44 } : cocos2d::ccColor3B { 194, 114, 62 });
        m_backgroundLayer->setOpacity(255);
    }

    CCURLObject* m_urlObject;
}

[[link(android)]]
class URLViewLayer : GJDropDownLayer {
    // virtual ~URLViewLayer();

    static URLViewLayer* create(gd::string title, cocos2d::CCArray* objects) = win 0x2a48d0, imac 0x2b5bc0, m1 0x2535d0;

    bool init(gd::string title, cocos2d::CCArray* objects) = win inline {
        if (!GJDropDownLayer::init(title.c_str())) return false;
        if (objects) {
            m_urlObjects = objects;
            objects->retain();
        }
        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        auto listView = CustomListView::create(m_urlObjects, nullptr, 220.f, 356.f, 0, BoomListType::URL, 0.f);
        listView->setTag(9);
        m_listLayer->addChild(listView, 6);
        return true;
    }

    cocos2d::CCArray* m_urlObjects;
}

[[link(android)]]
class UserInfoDelegate {
    virtual void getUserInfoFinished(GJUserScore* score) {}
    virtual void getUserInfoFailed(int id) {}
    virtual void userInfoChanged(GJUserScore* score) {}
}

[[link(android)]]
class UserListDelegate {
    virtual void getUserListFinished(cocos2d::CCArray* scores, UserListType type) {}
    virtual void getUserListFailed(UserListType type, GJErrorCode errorType) {}
    virtual void userListChanged(cocos2d::CCArray* scores, UserListType type) {}
    virtual void forceReloadList(UserListType type) {}
}

[[link(android)]]
class VideoOptionsLayer : FLAlertLayer {
    // virtual ~VideoOptionsLayer();

    static VideoOptionsLayer* create() = win 0x376770, imac 0x79adc0, m1 0x6a27b0;

    virtual bool init() = win 0x376890, m1 0x6a6148, imac 0x79ea40;
    virtual void keyBackClicked() = win 0x378700, m1 0x6a7ae0, imac 0x7a0590;

    CCMenuItemToggler* createToggleButton(gd::string label, cocos2d::SEL_MenuHandler selector, bool toggled, cocos2d::CCMenu* menu, cocos2d::CCPoint position, float scale, float width, bool center, cocos2d::CCArray* nodes) = win 0x378710, imac 0x79f970, m1 0x6a6f84;
    void onAdvanced(cocos2d::CCObject* sender) = win 0x377bd0, imac 0x7a0130, m1 0x6a76cc;
    void onApply(cocos2d::CCObject* sender) = win 0x3781c0, imac 0x79fd90, m1 0x6a7360;
    void onBorderless(cocos2d::CCObject* sender) = win 0x377d20, m1 0x6a71f0;
    void onBorderlessFix(cocos2d::CCObject* sender) = imac 0x79fbe0, m1 0x6a7200;
    void onClose(cocos2d::CCObject* sender) = m1 0x6a7308;
    void onFullscreen(cocos2d::CCObject* sender) = win 0x377d00, m1 0x6a71e0;
    void onInfo(cocos2d::CCObject* sender) = win inline, imac 0x7a04d0, m1 0x6a79fc, ios inline {
        FLAlertLayer::create(
            nullptr,
            "Video Options",
            "No info yet",
            "OK",
            nullptr,
            360.f
        )->show();
    }
    void onResolutionNext(cocos2d::CCObject* sender) = m1 0x6a721c;
    void onResolutionPrev(cocos2d::CCObject* sender) = m1 0x6a7210;
    void onTextureQualityNext(cocos2d::CCObject* sender) = imac 0x79fcb0;
    void onTextureQualityPrev(cocos2d::CCObject* sender) = imac 0x79fc30;
    void reloadMenu() = win inline, m1 0x6a7ab0, ios inline {
        cocos2d::CCDirector::sharedDirector()->replaceScene(MenuLayer::scene(true));
    }
    void toggleResolution() = win 0x377f60, imac 0x7a02b0;
    void updateResolution(int resolution) = win 0x377e50, m1 0x6a760c;
    void updateTextureQuality(int quality) = win 0x377d80, imac 0x79fff0, m1 0x6a75a0;

    CCMenuItemSpriteExtra* m_prevResolutionBtn;
    CCMenuItemSpriteExtra* m_nextResolutionBtn;
    cocos2d::CCLabelBMFont* m_windowedResolutionLabel;
    cocos2d::CCLabelBMFont* m_selectedResolutionLabel;
    cocos2d::CCLabelBMFont* m_qualityLabel;
    int m_textureQuality;
    cocos2d::CCArray* m_availableResolutions;
    CCMenuItemToggler* m_borderlessToggle;
    cocos2d::CCLabelBMFont* m_borderlessLabel;
    CCMenuItemToggler* m_fixToggle;
    cocos2d::CCLabelBMFont* m_fixLabel;
    bool m_fullscreen;
    bool m_borderless;
    bool m_fix;
    int m_currentResolution;
}

[[link(android)]]
class WorldLevelPage : FLAlertLayer {
    // virtual ~WorldLevelPage();

    static WorldLevelPage* create(GJGameLevel* level, GJWorldNode* node) = imac 0x3c4650, m1 0x345e58;

    virtual void keyBackClicked() = m1 0x347d24, imac 0x3c66d0;
    virtual void show() = m1 0x347bd8, imac 0x3c6590;

    bool init(GJGameLevel* level, GJWorldNode* node);
    void onClose(cocos2d::CCObject* sender) = imac 0x3c6260, m1 0x3478d8;
    void onInfo(cocos2d::CCObject* sender) = m1 0x347950;
    void onPlay(cocos2d::CCObject* sender);
    void onSong(cocos2d::CCObject* sender) = imac 0x3c62b0;

    GJWorldNode* m_worldNode;
    GJGameLevel* m_level;
}

[[link(android)]]
class WorldSelectLayer : cocos2d::CCLayer, BoomScrollLayerDelegate {
    // virtual ~WorldSelectLayer();

    static WorldSelectLayer* create(int page) = m1 0x3430b4;
    static cocos2d::CCScene* scene(int page) = m1 0x342fd0;

    virtual void onExit() = m1 0x344e84, imac 0x3c35d0;
    virtual void keyBackClicked() = m1 0x344db4, imac 0x3c3500;
    virtual void scrollLayerWillScrollToPage(BoomScrollLayer* layer, int page) = m1 0x344c6c, imac 0x3c3410;
    virtual void scrollLayerScrolledToPage(BoomScrollLayer* layer, int page) = m1 0x344b24, imac 0x3c3320;
    virtual void scrollLayerMoved(cocos2d::CCPoint position) = imac 0x3c3620, m1 0x344ed8;

    void animateInActiveIsland() = imac 0x3c2690, m1 0x343e78;
    cocos2d::ccColor3B colorForPage(int page) = imac 0x3c38d0, m1 0x34516c;
    cocos2d::ccColor3B getColorValue(int page1, int page2, float progress) = imac 0x3c37c0, m1 0x345078;
    void goToPage(int page, bool instant) = m1 0x343f3c;
    bool init(int page);
    void onBack(cocos2d::CCObject* sender);
    void onFreeLevels(cocos2d::CCObject* sender) = m1 0x344ac0;
    void onGarage(cocos2d::CCObject* sender);
    void onNext(cocos2d::CCObject* sender) = imac 0x3c2170;
    void onPrev(cocos2d::CCObject* sender) = imac 0x3c2140;
    void setupWorlds() = m1 0x4bf740;
    void showCompleteDialog() = imac 0x3c2820, m1 0x344020;
    void tryShowAd() = m1 0x3449c8;
    void unblockButtons() = imac 0x3c3190, m1 0x3449b0;
    void updateArrows() = m1 0x343dd4;

    cocos2d::CCSprite* m_background;
    BoomScrollLayer* m_scrollLayer;
    CCMenuItemSpriteExtra* m_arrowLeft;
    CCMenuItemSpriteExtra* m_arrowRight;
    bool m_cleanupSprites;
    bool m_enteringLevel;
    GJWorldNode* m_worldNode;
    bool m_buttonsLocked;
}
