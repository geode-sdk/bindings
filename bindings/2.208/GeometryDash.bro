#import win <random>
#import win <sys/timeb.h>
#import <Geode/utils/cocos.hpp>

[[link(android)]]
class AccountHelpLayer : GJDropDownLayer, GJAccountDelegate, FLAlertLayerProtocol {
    AccountHelpLayer() {
        m_unk290 = false;
    }
    ~AccountHelpLayer() = win inline {
        auto gjam = GJAccountManager::sharedState();
        if (gjam->m_accountDelegate == this) gjam->m_accountDelegate = nullptr;
    }

    static AccountHelpLayer* create() = win inline {
        auto ret = new AccountHelpLayer();
        if (ret->init("Account Help")) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void customSetup() = win 0x7f630;
    virtual void layerHidden() = win 0x80390;
    virtual void accountStatusChanged() = win 0x7fd30;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x80010;

    void doUnlink() = win inline, ios inline {
        GJAccountManager::sharedState()->unlinkFromAccount();
        this->exitLayer();
    }
    void exitLayer() = win inline, ios inline {
        GJDropDownLayer::exitLayer(nullptr);
    }
    void onAccountManagement(cocos2d::CCObject* sender);
    void onReLogin(cocos2d::CCObject* sender) = win 0x7fa40;
    void onUnlink(cocos2d::CCObject* sender) = win 0x7fb90;
    void updatePage() = win 0x7fd40;
    void verifyUnlink() = win inline {
        auto alert = FLAlertLayer::create(
            this,
            "Warning",
            "This will <cr>delete</c> ALL <cl>save data</c>.\nDo you want to continue?\n<cy>(You cannot undo this action)</c>",
            "Cancel",
            "DELETE",
            300.f,
            false,
            0.f,
            1.f
        );
        alert->setTag(4);
        alert->m_button2->updateBGImage("GJ_button_06.png");
        alert->show();
    }

    cocos2d::CCLabelBMFont* m_loginStatusLabel;
    TextArea* m_textArea;
    CCMenuItemSpriteExtra* m_refreshLoginButton;
    CCMenuItemSpriteExtra* m_unlinkAccountButton;
    bool m_unk290;
}

[[link(android)]]
class AccountLayer : GJDropDownLayer, GJAccountDelegate, GJAccountBackupDelegate, GJAccountSyncDelegate, FLAlertLayerProtocol {
    // virtual ~AccountLayer();
    // AccountLayer();

    static AccountLayer* create() = win 0x7d5d0;

    virtual void customSetup() = win 0x7d730;
    virtual void layerHidden() = win 0x7f4c0;
    virtual void backupAccountFinished() = win 0x7eba0;
    virtual void backupAccountFailed(BackupAccountError errorType, int response) = win 0x7ed50;
    virtual void syncAccountFinished() = win 0x7f060;
    virtual void syncAccountFailed(BackupAccountError errorType, int response) = win 0x7f220;
    virtual void accountStatusChanged() = win 0x7e7c0;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x7f3b0;

    void createToggleButton(gd::string text, cocos2d::SEL_MenuHandler selector, bool toggled, cocos2d::CCMenu* menu, cocos2d::CCPoint position) = win inline, ios inline {
        auto onSprite = cocos2d::CCSprite::createWithSpriteFrameName("GJ_checkOn_001.png");
        auto offSprite = cocos2d::CCSprite::createWithSpriteFrameName("GJ_checkOff_001.png");
        onSprite->setScale(.8f);
        offSprite->setScale(.8f);
        auto toggler = CCMenuItemToggler::create(offSprite, onSprite, this, selector);
        toggler->toggle(toggled);
        menu->addChild(toggler);
        toggler->setPosition(menu->convertToNodeSpace(position));
        toggler->setSizeMult(1.5f);
        auto label = cocos2d::CCLabelBMFont::create(text.c_str(), "bigFont.fnt");
        m_mainLayer->addChild(label);
        label->setAnchorPoint({ .0f, .5f });
        label->setPosition(position + cocos2d::CCPoint { onSprite->getContentSize().width * .5f + 6.4f, 0.f });
        auto width = label->getContentSize().width;
        if (width > 120.f) label->setScale(120.f / width);
        label->setScale(std::min(label->getScale(), .35f));
    }
    void doBackup() = win inline {
        this->updatePage(false);
        if (!GJAccountManager::sharedState()->getAccountBackupURL()) this->backupAccountFailed(BackupAccountError::GenericError, 0);
        else this->showLoadingUI();
    }
    void doSync() = win inline {
        this->updatePage(false);
        if (!GJAccountManager::sharedState()->getAccountSyncURL()) this->syncAccountFailed(BackupAccountError::GenericError, 0);
        else this->showLoadingUI();
    }
    void exitLayer() = win inline, ios inline {
        GJDropDownLayer::exitLayer(nullptr);
    }
    void hideLoadingUI() = win inline, ios inline {
        this->toggleUI(true);
        m_loadingCircle->setVisible(false);
    }
    void onBackup(cocos2d::CCObject* sender);
    void onHelp(cocos2d::CCObject* sender);
    void onLogin(cocos2d::CCObject* sender);
    void onMore(cocos2d::CCObject* sender);
    void onRegister(cocos2d::CCObject* sender) = win 0x7dec0;
    void onSync(cocos2d::CCObject* sender);
    void showLoadingUI() = win inline, ios inline {
        this->toggleUI(false);
        m_loadingCircle->setVisible(true);
    }
    void toggleUI(bool enable) = win inline, ios inline {
        m_buttonMenu->setEnabled(enable);
        this->setKeypadEnabled(enable);
    }
    void updatePage(bool changed) = win 0x7e7d0;

    cocos2d::CCLabelBMFont* m_linkedAccountTitle;
    TextArea* m_textArea;
    CCMenuItemSpriteExtra* m_loginButton;
    CCMenuItemSpriteExtra* m_registerButton;
    CCMenuItemSpriteExtra* m_backupButton;
    CCMenuItemSpriteExtra* m_syncButton;
    CCMenuItemSpriteExtra* m_helpButton;
    CCMenuItemSpriteExtra* m_moreButton;
    LoadingCircle* m_loadingCircle;
    int m_accountHelpRelated;
    bool m_isLoggedIn;
}

[[link(android)]]
class AccountLoginLayer : FLAlertLayer, TextInputDelegate, GJAccountLoginDelegate, FLAlertLayerProtocol {
    // virtual ~AccountLoginLayer();

    static AccountLoginLayer* create(gd::string username) = win 0x7b790;

    virtual void registerWithTouchDispatcher() = win 0x42660;
    virtual void keyBackClicked() = win 0x7d010;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x7cbc0;
    virtual void textInputOpened(CCTextInputNode* node) = win inline {}
    virtual void textInputClosed(CCTextInputNode* node) = win 0x7d0e0;
    virtual void textChanged(CCTextInputNode* node) = win inline {}
    virtual void loginAccountFinished(int accountID, int userID) = win 0x7c7b0;
    virtual void loginAccountFailed(AccountError errorType) = win 0x7ca00;

    cocos2d::extension::CCScale9Sprite* createTextBackground(cocos2d::CCPoint position, char const* text, cocos2d::CCSize size) = win 0x7c520;
    CCTextInputNode* createTextInput(cocos2d::CCPoint position, cocos2d::CCSize size, char const* text, int tag) = win 0x7c6c0;
    cocos2d::CCLabelBMFont* createTextLabel(cocos2d::CCPoint position, char const* text, cocos2d::CCSize size) = win 0x7c5e0;
    void disableNodes() = win inline, ios inline {
        m_usernameInput->onClickTrackNode(false);
        m_passwordInput->onClickTrackNode(false);
    }
    void hideLoadingUI() = win inline, ios inline {
        this->toggleUI(true);
        m_loadingCircle->setVisible(false);
    }
    bool init(gd::string username) = win 0x7b930;
    void onClose(cocos2d::CCObject* sender) = win 0x7cfc0;
    void onForgotPassword(cocos2d::CCObject* sender);
    void onForgotUser(cocos2d::CCObject* sender);
    void onSubmit(cocos2d::CCObject* sender) = win 0x7cc30;
    void resetLabel(int tag) = win 0x7cb40;
    void resetLabels() = win inline {
        this->resetLabel(1);
        this->resetLabel(2);
    }
    void showLoadingUI() = win inline {
        this->disableNodes();
        this->toggleUI(false);
        m_loadingCircle->setVisible(true);
    }
    void toggleUI(bool enable) = win 0x7d070;
    void updateLabel(AccountError type) = win 0x7ca40;

    CCTextInputNode* m_usernameInput;
    CCTextInputNode* m_passwordInput;
    cocos2d::CCLabelBMFont* m_usernameLabel;
    cocos2d::CCLabelBMFont* m_passwordLabel;
    LoadingCircle* m_loadingCircle;
    gd::string m_username;
    gd::string m_password;
}

[[link(android)]]
class AccountRegisterLayer : FLAlertLayer, TextInputDelegate, GJAccountRegisterDelegate, FLAlertLayerProtocol {
    AccountRegisterLayer() {
        m_usernameField = nullptr;
        m_passwordField = nullptr;
        m_confirmPasswordField = nullptr;
        m_emailField = nullptr;
        m_usernameLabel = nullptr;
        m_passwordLabel = nullptr;
        m_confirmPasswordLabel = nullptr;
        m_emailLabel = nullptr;
        m_loadingCircle = nullptr;
        m_lockInput = false;
    }
    ~AccountRegisterLayer() = win inline {
        auto gjam = GJAccountManager::sharedState();
        if (gjam->m_accountRegisterDelegate == this) gjam->m_accountRegisterDelegate = nullptr;
        CC_SAFE_RELEASE(m_loadingCircle);
    }

    static AccountRegisterLayer* create() = win inline {
        auto ret = new AccountRegisterLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x78ac0;
    virtual void registerWithTouchDispatcher() = win 0x42660;
    virtual void keyBackClicked() = win 0x7ac50;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x7a260;
    virtual void textInputOpened(CCTextInputNode* node) = win inline {}
    virtual void textInputClosed(CCTextInputNode* node) = win 0x7adb0;
    virtual void textChanged(CCTextInputNode* node) = win inline {}
    virtual void textInputShouldOffset(CCTextInputNode* node, float yOffset) = win 0x7b620;
    virtual void textInputReturn(CCTextInputNode* node) = win 0x7b680;
    virtual bool allowTextInput(CCTextInputNode* node) = win 0x7b6d0;
    virtual void registerAccountFinished() = win 0x79cf0;
    virtual void registerAccountFailed(AccountError errorType) = win 0x79f10;

    cocos2d::extension::CCScale9Sprite* createTextBackground(cocos2d::CCPoint position, cocos2d::CCSize size) = win 0x799f0;
    CCTextInputNode* createTextInput(cocos2d::CCPoint position, cocos2d::CCSize size, gd::string text, int tag) = win 0x79bc0;
    cocos2d::CCLabelBMFont* createTextLabel(cocos2d::CCPoint position, gd::string text, cocos2d::CCSize size) = win 0x79ab0;
    void disableNodes() = win 0x7ac90;
    void hideLoadingUI() = win inline, ios inline {
        this->toggleUI(true);
        m_loadingCircle->setVisible(false);
    }
    void onClose(cocos2d::CCObject* sender) = win 0x7ac20;
    void onSubmit(cocos2d::CCObject* sender) = win 0x7a2b0;
    void resetLabel(int tag) = win 0x7a150;
    void resetLabels() = win inline {
        this->resetLabel(1);
        this->resetLabel(2);
        this->resetLabel(3);
        this->resetLabel(4);
        this->resetLabel(5);
    }
    void showLoadingUI() = win inline {
        this->disableNodes();
        this->toggleUI(false);
        m_loadingCircle->setVisible(true);
    }
    void toggleUI(bool enable) = win 0x7ad00;
    void updateLabel(AccountError type) = win 0x79f50;
    bool validEmail(gd::string email) = win 0x7b6e0, ios inline {
        if (!email.c_str()) return false;
        auto first = email[0];
        if (first < 'A' || (first > 'Z' && first < 'a') || first > 'z') return false;
        auto len = strlen(email.c_str());
        auto atPos = -1;
        auto dotPos = -1;
        for (int i = 0; i < len; i++) {
            if (email[i] == '@') atPos = i;
            else if (email[i] == '.') dotPos = i;
        }
        return atPos != -1 && dotPos != -1 && atPos <= dotPos && dotPos < len - 1;
    }
    bool validPassword(gd::string password) = win inline, ios inline {
        return password.size() > 5;
    }
    bool validUser(gd::string username) = win inline, ios inline {
        return username.size() > 2;
    }

    CCTextInputNode* m_usernameField;
    CCTextInputNode* m_passwordField;
    CCTextInputNode* m_confirmPasswordField;
    CCTextInputNode* m_emailField;
    CCTextInputNode* m_verifyEmailField;
    cocos2d::CCLabelBMFont* m_usernameLabel;
    cocos2d::CCLabelBMFont* m_passwordLabel;
    cocos2d::CCLabelBMFont* m_confirmPasswordLabel;
    cocos2d::CCLabelBMFont* m_emailLabel;
    cocos2d::CCLabelBMFont* m_verifyEmailLabel;
    LoadingCircle* m_loadingCircle;
    bool m_lockInput;
}

[[link(android)]]
class AchievementBar : cocos2d::CCNodeRGBA {
    // virtual ~AchievementBar();
    AchievementBar() {
        m_layerColor = nullptr;
        m_unkUnused = 0;
        m_nextScene = nullptr;
    }

    static AchievementBar* create(char const* title, char const* desc, char const* icon, bool quest) = win inline {
        auto ret = new AchievementBar();
        if (ret->init(title, desc, icon, quest)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void setOpacity(unsigned char opacity) = win 0x81f10;

    bool init(char const* title, char const* desc, char const* icon, bool quest) = win 0x806e0;
    void show() = win 0x81c90;

    cocos2d::CCLayerColor* m_layerColor;
    int m_unkUnused;
    cocos2d::CCScene* m_nextScene;
    cocos2d::extension::CCScale9Sprite* m_bg;
    cocos2d::extension::CCScale9Sprite* m_bg2;
    cocos2d::CCSprite* m_achievementGlowSprite;
    cocos2d::CCSprite* m_achievementSprite;
    cocos2d::CCLabelBMFont* m_titleLabel;
    TextArea* m_achievementDescription;
}

[[link(android)]]
class AchievementCell : TableViewCell {
    // virtual ~AchievementCell();
    AchievementCell(char const* identifier, float width, float height) = win inline, ios inline : TableViewCell(identifier, width, height) {
        this->init();
    }

    virtual bool init() = win inline { return true; }
    virtual void draw() = win 0xade40;

    void loadFromDict(cocos2d::CCDictionary* dict) = win 0xac880;
    void updateBGColor(int index) = win inline {
        m_backgroundLayer->setColor(index % 2 == 0 ? cocos2d::ccColor3B { 161, 88, 44 } : cocos2d::ccColor3B { 194, 114, 62 });
    }
}

[[link(android)]]
class AchievementManager : cocos2d::CCNode {
    // virtual ~AchievementManager();

    static AchievementManager* sharedState() = win 0x7da0;

    virtual bool init() = win 0x7e60;

    gd::string achievementForUnlock(int id, UnlockType type) = win 0x3a1c0;
    void addAchievement(gd::string identifier, gd::string title, gd::string achievedDescription, gd::string unachievedDescription, gd::string icon, int limits) = win 0x7ef0;
    void addManualAchievements() = win 0x8410;
    bool areAchievementsEarned(cocos2d::CCArray* achievements) = win inline, ios inline {
        for (int i = 0; i < achievements->count(); i++) {
            if (!this->isAchievementEarned(static_cast<cocos2d::CCString*>(achievements->objectAtIndex(i))->getCString())) {
                return false;
            }
        }
        return true;
    }
    void checkAchFromUnlock(char const* id) = win inline, ios inline {}
    void dataLoaded(DS_Dictionary* dict) = win inline {
        auto reportedAchievements = dict->getDictForKey("reportedAchievements", false);
        if (m_reportedAchievements) {
            GameToolbox::mergeDictsSaveLargestInt(m_reportedAchievements, reportedAchievements);
        }
        else if (reportedAchievements) {
            CC_SAFE_RETAIN(reportedAchievements);
            CC_SAFE_RELEASE(m_reportedAchievements);
            m_reportedAchievements = reportedAchievements;
        }
    }
    void encodeDataTo(DS_Dictionary* dict) = win inline {
        dict->setDictForKey("reportedAchievements", m_reportedAchievements);
    }
    void firstSetup() = win inline {
        auto reportedAchievements = cocos2d::CCDictionary::create();
        if (m_reportedAchievements != reportedAchievements) {
            CC_SAFE_RETAIN(reportedAchievements);
            CC_SAFE_RELEASE(m_reportedAchievements);
            m_reportedAchievements = reportedAchievements;
        }
    }
    cocos2d::CCDictionary* getAchievementRewardDict();
    cocos2d::CCDictionary* getAchievementsWithID(char const* id) = win 0x39d70;
    cocos2d::CCArray* getAllAchievements() = win inline {
        return m_allAchievements;
    }
    cocos2d::CCArray* getAllAchievementsSorted(bool available) = win 0x39b50;
    bool isAchievementAvailable(gd::string id) = win inline, ios inline {
        if (auto achievements = getAchievementsWithID(id.c_str())) {
            return achievements->objectForKey("un") == nullptr;
        }
        return false;
    }
    bool isAchievementEarned(char const* ach) = win 0x39a70;
    int limitForAchievement(gd::string id) = win inline {
        if (auto achievements = getAchievementsWithID(id.c_str())) {
            if (auto limits = static_cast<cocos2d::CCString*>(achievements->objectForKey("limits"))) return limits->intValue();
        }
        return 0;
    }
    void notifyAchievement(char const* title, char const* description, char const* icon) = win inline {
        if (!m_dontNotify) AchievementNotifier::sharedState()->notifyAchievement(title, description, icon, true);
    }
    void notifyAchievementWithID(char const* id) = win 0x3a470;
    int percentageForCount(int count, int total) = win inline, ios inline {
        return std::min<int>(100, ((float)count / (float)total) * 100.f);
    }
    int percentForAchievement(char const* id) = win 0x39a90;
    void reportAchievementWithID(char const* id, int percent, bool dontNotify);
    void reportPlatformAchievementWithID(char const* id, int percent);
    void resetAchievement(char const* id) = win inline {
        m_reportedAchievements->removeObjectForKey(id);
    }
    void resetAchievements() = win inline, ios inline {
        m_reportedAchievements->removeAllObjects();
    }
    void setup() = win inline, ios inline {}
    void storeAchievementUnlocks() = win 0x39e20;

    cocos2d::CCArray* m_allAchievements;
    cocos2d::CCDictionary* m_platformAchievements;
    cocos2d::CCDictionary* m_achievementUnlocks;
    void* m_unkPtrUnused;
    cocos2d::CCDictionary* m_reportedAchievements;
    bool m_dontNotify;
    cocos2d::CCArray* m_allAchievementsSorted;
    int m_order;
    cocos2d::CCDictionary* m_unAchieved;
}

[[link(android)]]
class AchievementNotifier : cocos2d::CCNode {
    // virtual ~AchievementNotifier();

    static AchievementNotifier* sharedState() = win 0x3ab20;

    virtual bool init() = win 0x3abd0;

    void achievementDisplayFinished() = win 0x3ae40;
    void notifyAchievement(char const* title, char const* desc, char const* icon, bool quest) = win 0x3ac00;
    void showNextAchievement() = win 0x3ace0;
    void willSwitchToScene(cocos2d::CCScene* scene) = win inline {
        this->m_nextScene = scene;

        if (this->m_activeAchievementBar && this->m_activeAchievementBar->getParent() != this->m_nextScene)
        {
            this->m_activeAchievementBar->retain();
            this->m_activeAchievementBar->removeFromParentAndCleanup(false);
            this->m_nextScene->addChild(this->m_activeAchievementBar, 105);
            this->m_activeAchievementBar->release();
            this->m_activeAchievementBar->resumeSchedulerAndActions();
        }
    }

    cocos2d::CCScene* m_nextScene;
    cocos2d::CCArray* m_achievementBarArray;
    AchievementBar* m_activeAchievementBar;
}

[[link(android)]]
class AchievementsLayer : GJDropDownLayer {
    // virtual ~AchievementsLayer();
    AchievementsLayer() {
        m_currentPage = 0;
        m_nextPageButton = nullptr;
        m_prevPageButton = nullptr;
        m_pageLabel = nullptr;
    }

    static AchievementsLayer* create() = win inline {
        auto ret = new AchievementsLayer();
        if (ret->init("Achievements")) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyDown(cocos2d::enumKeyCodes key) = win 0x822d0;
    virtual void customSetup() = win 0x82020;

    void loadPage(int page) = win 0x82370;
    void onNextPage(cocos2d::CCObject* sender) = win 0x82550;
    void onPrevPage(cocos2d::CCObject* sender) = win 0x82560;
    void setupLevelBrowser(cocos2d::CCArray* arr) = win inline {
        m_listLayer->removeChildByTag(9, true);
        auto* listView = CustomListView::create(arr, BoomListType::Default, 220.f, 356.f);
        listView->setTag(9);
        m_listLayer->addChild(listView, 6);
    }
    void setupPageInfo(int itemCount, int pageStartIdx, int pageEndIdx) = win inline {
        m_prevPageButton->setVisible(pageStartIdx != 0);
        auto nextIndex = pageStartIdx + pageEndIdx;
        m_nextPageButton->setVisible(itemCount > nextIndex);
        nextIndex = std::min(nextIndex, itemCount);
        m_pageLabel->setString(cocos2d::CCString::createWithFormat("%i to %i of %i", pageStartIdx + 1, nextIndex, itemCount)->getCString());
    }

    int m_currentPage;
    CCMenuItemSpriteExtra* m_nextPageButton;
    CCMenuItemSpriteExtra* m_prevPageButton;
    cocos2d::CCLabelBMFont* m_pageLabel;
    cocos2d::CCPoint m_unkPoint;
}

[[link(android)]]
class AdToolbox {
    static void cacheInterstitial();
    static void cacheRewardedVideo();
    static void disableBanner();
    static void enableBanner();
    static void enableBannerNoRefresh();
    static bool hasCachedInterstitial();
    static bool hasCachedRewardedVideo();
    static bool isShowingAd();
    static void queueRefreshBanner();
    static void setupAds() = win inline {}
    static void showDebug();
    static void showInterstitial();
    static void showRewardedVideo();
}

[[link(android)]]
class AdvancedFollowEditObject : AdvancedFollowTriggerObject {
    // virtual ~AdvancedFollowEditObject();
    AdvancedFollowEditObject() {
        m_modX = 1.f;
        m_modXVariance = 0.f;
        m_modY = 1.f;
        m_modYVariance = 0.f;
        m_redirectDirection = false;
    }

    static AdvancedFollowEditObject* create(char const* frame) = win inline {
        auto ret = new AdvancedFollowEditObject();
        if (ret->init(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x49e7e0;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x49e3f0;

    bool init(char const* frame) = win inline, ios inline {
        return AdvancedFollowTriggerObject::init(frame);
    }

    // property 566
    float m_modX;
    // property 567
    float m_modXVariance;
    // property 568
    float m_modY;
    // property 569
    float m_modYVariance;
    // property 570
    bool m_redirectDirection;
}

[[link(android)]]
class AdvancedFollowTriggerObject : EffectGameObject {
    // virtual ~AdvancedFollowTriggerObject();
    AdvancedFollowTriggerObject() = win 0x495880 {
        m_delay = 0.f;
        m_delayVariance = 0.f;
        m_startSpeed = 0.f;
        m_startSpeedVariance = 0.f;
        m_startSpeedReference = 0;
        m_startDirection = 0.f;
        m_startDirectionVariance = 0.f;
        m_startDirectionReference = 0;
        m_maxSpeed = 0.f;
        m_maxSpeedVariance = 0.f;
        m_xOnly = false;
        m_yOnly = false;
        m_maxRange = 0.f;
        m_maxRangeVariance = 0.f;
        m_property310 = 0.f;
        m_property311 = 0.f;
        m_acceleration = 0.f;
        m_accelerationVariance = 0.f;
        m_property312 = 0.f;
        m_property313 = 0.f;
        m_property314 = 0.f;
        m_property315 = 0.f;
        m_steerForce = 0.f;
        m_steerForceVariance = 0.f;
        m_steerForceLowEnabled = false;
        m_steerForceLow = 0.f;
        m_steerForceLowVariance = 0.f;
        m_steerForceHighEnabled = false;
        m_steerForceHigh = 0.f;
        m_steerFroceHighVariance = 0.f;
        m_speedRangeLow = 0.f;
        m_speedRangeLowVariance = 0.f;
        m_speedRangeHigh = 0.f;
        m_speedRangeHighVariance = 0.f;
        m_breakForce = 0.f;
        m_breakForceVariance = 0.f;
        m_breakAngle = 0.f;
        m_breakAngleVariance = 0.f;
        m_breakSteerForce = 0.f;
        m_breakSteerForceVariance = 0.f;
        m_breakSteerSpeedLimit = 0.f;
        m_breakSteerSpeedLimitVariance = 0.f;
        m_targetDirection = false;
        m_ignoreDisabled = false;
        m_rotateDirection = false;
        m_rotationOffset = 0.f;
        m_nearAcceleration = 0.f;
        m_nearAccelerationVariance = 0.f;
        m_nearDistance = 0.f;
        m_nearDistanceVariance = 0.f;
        m_nearFriction = 0.f;
        m_nearFrictionVariance = 0.f;
        m_friction = 0.f;
        m_frictionVariance = 0.f;
        m_easing = 0.f;
        m_easingVariance = 0.f;
        m_rotateEasing = 0.f;
        m_rotateDeadZ = 0.f;
        m_priority = 0;
        m_unk7fc = 0;
        m_maxRangeReference = 0;
        m_followMode = 0;
        m_exclusive = false;
        m_startMode = 0;
    }

    static AdvancedFollowTriggerObject* create(char const* frame) = win inline {
        auto ret = new AdvancedFollowTriggerObject();
        if (ret->init(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x49d4c0;
    virtual gd::string getSaveString(GJBaseGameLayer* layer);

    int getAdvancedFollowID() = win inline {
        if (m_targetPlayer1) return -1;
        if (m_targetPlayer2) return -2;
        if (m_followCPP) return -3;
        else return m_centerGroupID;
    }
    bool init(char const* frame) = win inline, ios inline {
        return EffectGameObject::init(frame);
    }

    // property 292
    float m_delay;
    // property 293
    float m_delayVariance;
    // property 300
    float m_startSpeed;
    // property 301
    float m_startSpeedVariance;
    // property 560
    int m_startSpeedReference;
    // property 563
    float m_startDirection;
    // property 564
    float m_startDirectionVariance;
    // property 565
    int m_startDirectionReference;
    // property 298
    float m_maxSpeed;
    // property 299
    float m_maxSpeedVariance;
    // property 306
    bool m_xOnly;
    // property 307
    bool m_yOnly;
    // property 308
    float m_maxRange;
    // property 309
    float m_maxRangeVariance;
    // property 310
    float m_property310;
    // property 311
    float m_property311;
    // property 334
    float m_acceleration;
    // property 335
    float m_accelerationVariance;
    // property 312
    float m_property312;
    // property 313
    float m_property313;
    // property 314
    float m_property314;
    // property 315
    float m_property315;
    // property 316
    float m_steerForce;
    // property 317
    float m_steerForceVariance;
    // property 337
    bool m_steerForceLowEnabled;
    // property 318
    float m_steerForceLow;
    // property 319
    float m_steerForceLowVariance;
    // property 338
    bool m_steerForceHighEnabled;
    // property 320
    float m_steerForceHigh;
    // property 321
    float m_steerFroceHighVariance;
    // property 322
    float m_speedRangeLow;
    // property 323
    float m_speedRangeLowVariance;
    // property 324
    float m_speedRangeHigh;
    // property 325
    float m_speedRangeHighVariance;
    // property 326
    float m_breakForce;
    // property 327
    float m_breakForceVariance;
    // property 328
    float m_breakAngle;
    // property 329
    float m_breakAngleVariance;
    // property 330
    float m_breakSteerForce;
    // property 331
    float m_breakSteerForceVariance;
    // property 332
    float m_breakSteerSpeedLimit;
    // property 333
    float m_breakSteerSpeedLimitVariance;
    // property 305
    bool m_targetDirection;
    // property 336
    bool m_ignoreDisabled;
    // property 339
    bool m_rotateDirection;
    // property 340
    float m_rotationOffset;
    // property 357
    float m_nearAcceleration;
    // property 358
    float m_nearAccelerationVariance;
    // property 359
    float m_nearDistance;
    // property 360
    float m_nearDistanceVariance;
    // property 561
    float m_nearFriction;
    // property 562
    float m_nearFrictionVariance;
    // property 558
    float m_friction;
    // property 559
    float m_frictionVariance;
    // property 361
    float m_easing;
    // property 362
    float m_easingVariance;
    // property 363
    float m_rotateEasing;
    // property 364
    float m_rotateDeadZ;
    // property 365
    int m_priority;
    int m_unk7fc;
    // property 366
    int m_maxRangeReference;
    // property 367
    int m_followMode;
    // property 571
    bool m_exclusive;
    // property 572
    int m_startMode;
}

[[link(android)]]
class AdvFollowSetup {
    // ~AdvFollowSetup();

    gd::unordered_set<int> m_centerIDs;
    gd::unordered_set<int> m_groupIDs;
    gd::unordered_set<int> m_controlIDs;
    int m_delay;
}

[[link(android)]]
class AnimatedGameObject : EnhancedGameObject, AnimatedSpriteDelegate, SpritePartDelegate {
    AnimatedGameObject() {
        m_animatedSprite = nullptr;
        m_childSprite = nullptr;
        m_eyeSpritePart = nullptr;
        m_finishedAnimating = false;
        m_playingAnimation = false;
        m_notGrounded = false;
        m_animationID = 0;
    }
    ~AnimatedGameObject() = win inline {
        CC_SAFE_RELEASE(m_eyeSpritePart);
    }

    static gd::string animationForID(int type, int id) = win 0x4a5010;
    static AnimatedGameObject* create(int id) = win inline {
        auto ret = new AnimatedGameObject();
        if (ret->init(id)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static float getTweenTime(int type, int id) = win inline, ios inline { return .05f; }

    virtual void setOpacity(unsigned char opacity);
    virtual void setChildColor(cocos2d::ccColor3B const& color);
    virtual void resetObject() = win 0x4a4fc0;
    virtual void activateObject() = win 0x4a37a0;
    virtual void deactivateObject(bool deactivate) = win 0x4a3870;
    virtual void setObjectColor(cocos2d::ccColor3B const& color) = win 0x4a3a20;
    virtual void animationFinished(char const* key) = win 0x4a3a60;
    virtual void displayFrameChanged(cocos2d::CCObject* sprite, gd::string frameName) = win 0x4a4d40;

    bool init(int id) = win 0x4a26d0;
    void playAnimation(int type) = win 0x4a4e90;
    void setupAnimatedSize(int id) = win inline {
        auto width = 10.f;
        auto height = 10.f;
        switch (id) {
            case 918:
                m_hasContentSize = true;
                m_objectRadius = 24.f;
                m_lastSize.width = 80.f;
                m_lastSize.height = 80.f;
                width = 48.f;
                height = 48.f;
                break;
            case 919:
                width = 25.f;
                height = 6.f;
                break;
            case 1327:
                m_hasContentSize = true;
                m_lastSize.width = 35.f;
                m_lastSize.height = 30.f;
                width = 8.f;
                height = 8.f;
                break;
            case 1328:
                m_hasContentSize = true;
                m_lastSize.width = 35.f;
                m_lastSize.height = 40.f;
                width = 8.f;
                height = 15.f;
                break;
            case 1584:
                m_hasContentSize = true;
                m_lastSize.width = 60.f;
                m_lastSize.height = 80.f;
                width = 8.f;
                height = 8.f;
                break;
            case 2012:
                m_hasContentSize = true;
                m_objectRadius = 15.f;
                m_lastSize.width = 45.f;
                m_lastSize.height = 45.f;
                width = 8.f;
                height = 8.f;
                break;
        }
        m_width = width * m_scaleX;
        m_height = height * m_scaleY;
        this->setContentSize({ width, height });
    }
    void setupChildSprites() = win 0x4a2c60;
    void updateChildSpriteColor(cocos2d::ccColor3B color) = win inline {
        if (!m_childSprite) return;
        auto spriteChildren = m_childSprite->getChildren();
        for (int i = 0; i < spriteChildren->count(); i++) {
            static_cast<cocos2d::CCSprite*>(spriteChildren->objectAtIndex(i))->setColor(color);
        }
    }
    void updateObjectAnimation() = win 0x4a3530;

    CCAnimatedSprite* m_animatedSprite;
    cocos2d::CCSprite* m_childSprite;
    CCSpritePart* m_eyeSpritePart;
    bool m_finishedAnimating;
    bool m_playingAnimation;
    gd::string m_currentAnimation;
    bool m_notGrounded;
    int m_animationID;
}

[[link(android)]]
class AnimatedShopKeeper : CCAnimatedSprite {
    // virtual ~AnimatedShopKeeper();
    AnimatedShopKeeper() {
        m_type = ShopType::Normal;
        m_idleInt1 = 0;
        m_idleInt2 = 0;
        m_looking = false;
        m_reacting = false;
        m_reactCount = 0;
        m_gruntIndex = 0;
    }

    static AnimatedShopKeeper* create(ShopType type) = win inline {
        auto ret = new AnimatedShopKeeper();
        if (ret->init(type)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void animationFinished(char const* key) = win 0x2afd60;

    bool init(ShopType type) = win inline {
        m_type = type;
        auto shopkeeper = "GJShopKeeper";
        switch (type) {
            case ShopType::Secret: shopkeeper = "GJShopKeeper2"; break;
            case ShopType::Community: shopkeeper = "GJShopKeeper3"; break;
            case ShopType::Mechanic: shopkeeper = "GJShopKeeper4"; break;
            case ShopType::Diamond: shopkeeper = "GJShopKeeper5"; break;
            default: shopkeeper = "GJShopKeeper"; break;
        }
        if (!CCAnimatedSprite::initWithType(shopkeeper, nullptr, false)) return false;
        m_idleInt2 = (rand() / 32767.f) * 5.f + 10.f;
        m_idleInt1 = (rand() / 32767.f) * 2.f + 1.f;
        m_animationManager->stopAnimations();
        return true;
    }
    void playReactAnimation() = win 0x2afa40;
    void startAnimating() = win 0x2afcd0;

    ShopType m_type;
    int m_idleInt1;
    int m_idleInt2;
    bool m_looking;
    bool m_reacting;
    int m_reactCount;
    int m_gruntIndex;
}

[[link(android)]]
class AnimatedSpriteDelegate {
    virtual void animationFinished(char const* key) {}
}

[[link(android)]]
class AppDelegate : cocos2d::CCApplication, cocos2d::CCSceneDelegate {
    // virtual ~AppDelegate() = ios 0x1b7c90;

    static AppDelegate* get() = win inline {
        return static_cast<AppDelegate*>(cocos2d::CCApplication::sharedApplication());
    }

    virtual bool applicationDidFinishLaunching() = win 0x82a60;
    virtual void applicationDidEnterBackground() = win 0x82e10;
    virtual void applicationWillEnterForeground() = win 0x82e90;
    virtual void applicationWillBecomeActive();
    virtual void applicationWillResignActive();
    virtual void trySaveGame(bool force) = win 0x83520,, ios 0x1234567, imac 0x1234567, m1 0x1234567;
    virtual void willSwitchToScene(cocos2d::CCScene* scene) = win 0x1234567, ios 0x1234567, imac 0x1234567, m1 0x1234567;

    float bgScale() = win inline {
        return cocos2d::CCDirector::sharedDirector()->getScreenScaleFactorMax();
    }
    void checkSound() = win inline {
        if (this->musicTest()) FMODAudioEngine::sharedEngine()->pauseAllMusic(true);
    }
    void hideLoadingCircle() = win inline {}
    void loadingIsFinished() = win inline {
        m_loadingFinished = true;
        PlatformToolbox::reportLoadingFinished();
    }
    bool musicTest() = win 0x833e0;
    void pauseGame() = win 0x83060;
    void pauseSound() = win 0x83140;
    void platformShutdown() = ios inline {}
    void resumeSound() = win 0x832e0;
    void setIdleTimerDisabled(bool disabled) = win inline, ios inline {}
    void setupGLView() = win 0x825f0;
    void showLoadingCircle(bool unk1, bool unk2, bool unk3) = win inline {}

    bool m_glViewSetup;
    bool m_gamePaused;
    cocos2d::CCScene* m_runningScene;
    bool m_loadingFinished;
    bool m_unk0e9;
    bool m_ios;
    bool m_unk0eb;
    bool m_unk0ec;
    bool m_unk0ed;
    float m_saveTime;
}

[[link(android)]]
class ArtistCell : TableViewCell {
    // virtual ~ArtistCell();
    ArtistCell(char const* identifier, float width, float height) = win inline, ios inline : TableViewCell(identifier, width, height) {
        this->init();
    }

    virtual bool init();
    virtual void draw() = win 0xade40;

    void loadFromObject(SongInfoObject* object) = win 0xb5630;
    void onNewgrounds(cocos2d::CCObject* sender) = win 0xb5960;
    void onYouTube(cocos2d::CCObject* sender) = win 0xb5a00;
    void updateBGColor(int index) = win inline {
        m_backgroundLayer->setColor(index % 2 == 0 ? cocos2d::ccColor3B { 161, 88, 44 } : cocos2d::ccColor3B { 194, 114, 62 });
        m_backgroundLayer->setOpacity(255);
    }

    SongInfoObject* m_songInfo;
}

[[link(android)]]
class ArtTriggerGameObject : EffectGameObject {
    // virtual ~ArtTriggerGameObject();
    ArtTriggerGameObject() {
        m_artIndex = 0;
    }

    static ArtTriggerGameObject* create(char const* frame) = win inline {
        auto ret = new ArtTriggerGameObject();
        if (ret->init(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void triggerObject(GJBaseGameLayer* layer, int uniqueID, gd::vector<int> const* remapKeys) = win 0x4c2080;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists);
    virtual gd::string getSaveString(GJBaseGameLayer* layer);

    bool init(char const* frame) = win inline, ios inline {
        return EffectGameObject::init(frame);
    }

    // property 533
    int m_artIndex;
}

[[link(android)]]
class AudioAssetsBrowser : FLAlertLayer, TableViewCellDelegate, MusicDownloadDelegate {
    AudioAssetsBrowser() {
        m_songInfoObjects = nullptr;
        m_songList = nullptr;
        m_pageIndicatorLabel = nullptr;
        m_loadingCircle = nullptr;
    }
    ~AudioAssetsBrowser() = win inline {
        MusicDownloadManager::sharedState()->removeMusicDownloadDelegate(this);
        CC_SAFE_RELEASE(m_songInfoObjects);
    }

    static AudioAssetsBrowser* create(gd::vector<int>& songIds, gd::vector<int>& sfxIds) = win inline {
        auto ret = new AudioAssetsBrowser();
        if (ret->init(songIds, sfxIds)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void registerWithTouchDispatcher() = win 0x42660;
    virtual void keyBackClicked() = win 0x846c0;
    virtual void musicActionFinished(GJMusicAction action);
    virtual void musicActionFailed(GJMusicAction action) = win 0x83dc0;
    virtual bool cellPerformedAction(TableViewCell* cell, int listType, CellAction action, cocos2d::CCNode* parent) = win inline { return false; }
    virtual int getSelectedCellIdx() = win inline { return 0; }
    virtual int getCellDelegateType() = win inline { return 1; }

    bool init(gd::vector<int>& songIds, gd::vector<int>& sfxIds) = win 0x837d0;
    void onClose(cocos2d::CCObject* sender) = win 0x84690;
    void onInfo(cocos2d::CCObject* sender) = win 0x83fe0;
    void onPage(cocos2d::CCObject* sender) = win inline, ios inline {}
    void setupList() = win 0x83e00;
    void trySetupAudioBrowser() = win inline {
        auto mdm = MusicDownloadManager::sharedState();
        if (mdm->m_sfxObjects) {
            if (mdm->m_customContentURL.empty()) mdm->getCustomContentURL();
            this->setupList();
        }
        else {
            if (mdm->m_customContentURL.empty()) mdm->getCustomContentURL();
            else mdm->downloadSFXLibrary();
        }
    }
    void updatePageLabel() = win inline, ios inline {}

    cocos2d::CCArray* m_songInfoObjects;
    GJCommentListLayer* m_songList;
    cocos2d::CCLabelBMFont* m_pageIndicatorLabel;
    gd::vector<int> m_songsIds;
    gd::vector<int> m_sfxIds;
    LoadingCircleSprite* m_loadingCircle;
}

[[link(android)]]
class AudioEffectsLayer : cocos2d::CCLayerColor {
    AudioEffectsLayer() {
        m_batchNode = nullptr;
        m_unk1bc = nullptr;
        m_unk1c0 = nullptr;
        m_timeElapsed = 0;
        m_audioPulseMod = 0;
        m_goingDown = false;
        m_audioScale = 0;
        m_unk1d4 = false;
    }
    ~AudioEffectsLayer() = win inline {
        CC_SAFE_RELEASE(m_unk1bc);
        CC_SAFE_RELEASE(m_unk1c0);
    }

    static AudioEffectsLayer* create(gd::string audioString) = win inline {
        auto ret = new AudioEffectsLayer();
        if (ret->init(audioString)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void draw() = win inline {}
    virtual void updateTweenAction(float value, char const* key) = win 0x85020;

    void audioStep(float dt) = win 0x84df0;
    cocos2d::CCSprite* getBGSquare();
    void goingDown() = win 0x85190;
    bool init(gd::string audioString) = win 0x84c00;
    void resetAudioVars() = win 0x84d90;
    void triggerEffect(float pulse) = win inline {
        float scale;
        if (pulse == 1.f) scale = .8f;
        else if (pulse == .9f) scale = .6f;
        else if (pulse == .8f) scale = .4f;
        else scale = pulse * .2f;
        auto pulseMod = std::min(scale + m_audioScale, 1.1f);
        if (!m_goingDown && m_audioPulseMod > pulseMod) return;
        m_audioPulseMod = pulseMod;
        m_goingDown = false;
        this->stopActionByTag(0);
        auto action = cocos2d::CCSequence::create(
            cocos2d::CCActionTween::create(.05f, "audioScale", m_audioScale, pulseMod),
            cocos2d::CCCallFunc::create(this, callfunc_selector(AudioEffectsLayer::goingDown)),
            cocos2d::CCActionTween::create(.2f, "audioScale", pulseMod, .1f),
            nullptr
        );
        action->setTag(0);
        this->runAction(action);
    }

    cocos2d::CCSpriteBatchNode* m_batchNode;
    cocos2d::CCArray* m_unk1bc;
    cocos2d::CCArray* m_unk1c0;
    float m_timeElapsed;
    float m_audioPulseMod;
    bool m_goingDown;
    float m_audioScale;
    bool m_unk1d4;
}

[[link(android)]]
class AudioLineGuideGameObject : EffectGameObject {
    // virtual ~AudioLineGuideGameObject();
    AudioLineGuideGameObject() {
        m_beatsPerMinute = 100;
        m_beatsPerBar = 1;
        m_speed = Speed::Normal;
        m_disabled = false;
    }

    static AudioLineGuideGameObject* create() = win inline {
        auto ret = new AudioLineGuideGameObject();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init();
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4c14a0;
    virtual gd::string getSaveString(GJBaseGameLayer* layer);

    // property 498
    int m_beatsPerMinute;
    // property 501
    int m_beatsPerBar;
    // property 499
    Speed m_speed;
    // property 500
    bool m_disabled;
}

[[link(android)]]
class BitmapFontCache : cocos2d::CCObject {
    BitmapFontCache() {
        m_cache = nullptr;
    }
    ~BitmapFontCache() = win inline {
        CC_SAFE_RELEASE(m_cache);
    }

    static void purgeSharedFontCache() = win inline {
        auto** instancePtr = reinterpret_cast<BitmapFontCache**>(geode::base::get() + 0x6a4e08);
        if (*instancePtr) {
            (*instancePtr)->release();
            *instancePtr = nullptr;
        }
    }
    static BitmapFontCache* sharedFontCache() = win inline {
        auto** instancePtr = reinterpret_cast<BitmapFontCache**>(geode::base::get() + 0x6a4e08);
        if (!*instancePtr) {
            *instancePtr = new BitmapFontCache();
            (*instancePtr)->init();
        }
        return *instancePtr;
    }

    FontObject* fontWithConfigFile(char const* font, float scale) = win 0x3b3e0;
    bool init() = win inline, ios inline {
        m_cache = cocos2d::CCDictionary::create();
        m_cache->retain();
        return true;
    }

    cocos2d::CCDictionary* m_cache;
}

[[link(android)]]
class BonusDropdown : cocos2d::CCNode {
    // virtual ~BonusDropdown();

    static BonusDropdown* create(gd::string text, int price);

    bool init(gd::string text, int price);
    void show();

    cocos2d::CCLayerColor* m_layerColor;
    float m_yPosition;
    cocos2d::CCScene* m_scene;
}

[[link(android)]]
class BoomListLayer : cocos2d::CCLayerColor {
    // virtual ~BoomListLayer();

    static BoomListLayer* create(BoomListView* listView, char const* title);

    bool init(BoomListView* listView, char const* title);
}

[[link(android)]]
class BoomListView : cocos2d::CCLayer, TableViewDelegate, TableViewDataSource {
    BoomListView() {
        m_tableView = nullptr;
        m_entries = nullptr;
        m_type = BoomListType::Default;
        m_height = 0.f;
        m_width = 0.f;
        m_itemSeparation = 0.f;
        m_currentPage = 0;
        m_locked = false;
    }
    ~BoomListView() = win 0x3bfa0;

    static BoomListView* create(cocos2d::CCArray* entries, TableViewCellDelegate* delegate, float height, float width, int page, BoomListType type, float y) = win inline, ios inline {
        auto ret = new BoomListView();
        if (ret->init(entries, delegate, height, width, page, type, y)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void draw() = win inline {}
    virtual void setupList(float yOffset) = win 0x3c3b0;
    virtual void TableViewWillDisplayCellForRowAtIndexPath(CCIndexPath& indexPath, TableViewCell* cell, TableView* tableView) = win inline {}
    virtual float cellHeightForRowAtIndexPath(CCIndexPath& indexPath, TableView* tableView) = win 0x3c440;
    virtual void didSelectRowAtIndexPath(CCIndexPath& indexPath, TableView* tableView) = win inline {}
    virtual int numberOfRowsInSection(unsigned int section, TableView* tableView) = win 0x3c450;
    virtual unsigned int numberOfSectionsInTableView(TableView* tableView) = win inline { return 1; }
    virtual TableViewCell* cellForRowAtIndexPath(CCIndexPath& indexPath, TableView* tableView) = win 0x3c470;
    virtual void TableViewCommitCellEditingStyleForRowAtIndexPath(TableView* tableView, TableViewCellEditingStyle style, CCIndexPath& indexPath) = win inline {}
    virtual void TableViewWillReloadCellForRowAtIndexPath(CCIndexPath& indexPath, TableViewCell* cell, TableView* tableView) = win inline {}
    virtual TableViewCell* getListCell(char const* identifier) = win 0x3c500;
    virtual void loadCell(TableViewCell* cell, int index) = win 0x3c670;

    void addObjectToList(cocos2d::CCNode* node) = win inline, ios inline {
        if (m_entries) m_entries->addObject(node);
    }
    bool init(cocos2d::CCArray* entries, BoomListType type, float width, float height) {
        return this->init(entries, nullptr, height, width, 0, type, 0.0f);
    }
    bool init(cocos2d::CCArray* entries, TableViewCellDelegate* delegate, float height, float width, int page, BoomListType type, float y) = win 0x3c040;
    void lockList(bool locked) = win inline {
        m_locked = locked;
        this->setTouchEnabled(!locked);
        this->setMouseEnabled(!locked);
        this->setKeyboardEnabled(!locked);
    }

    TableView* m_tableView;
    cocos2d::CCArray* m_entries;
    BoomListType m_type;
    float m_height;
    float m_width;
    float m_itemSeparation;
    int m_currentPage;
    bool m_locked;
}

[[link(android)]]
class BoomScrollLayer : cocos2d::CCLayer {
    BoomScrollLayer() {
        m_dots = nullptr;
        m_slowPage = 0;
        m_touchX = 0.f;
        m_touchQuotient = 0.f;
        m_looped = false;
        m_dynamicDelegate = nullptr;
        m_dynamicObjects = nullptr;
        m_dynamic = false;
        m_touchType = 0;
        m_ignoreTouchCancel = false;
        m_touch = nullptr;
        m_pages = nullptr;
        m_touchTime = 0.0;
        m_extendedLayer = nullptr;
        m_unkFloat1 = 0.f;
        m_maxSpeed = 0.f;
        m_minSpeed = 0.f;
        m_unkFloat2 = 0.f;
        m_delegate = nullptr;
        m_pageMoving = false;
        m_pagesInvisible = false;
        m_minimumTouchLengthToSlide = 0.f;
        m_minimumTouchLengthToChangePage = 0.f;
        m_width = 0.f;
        m_cancelAndStealTouch = false;
        m_dotsVisible = false;
        m_page = 0;
        m_pageOffset = 0.f;
        m_unkPtr = nullptr;
        m_doVisit = false;
    }
    ~BoomScrollLayer() = win inline {
        CC_SAFE_RELEASE(m_dynamicObjects);
        CC_SAFE_RELEASE(m_pages);
        CC_SAFE_RELEASE(m_dots);
    }

    static BoomScrollLayer* create(cocos2d::CCArray* pages, int offset, bool looped) = win inline {
        return BoomScrollLayer::create(pages, offset, looped, nullptr, nullptr);
    }
    static BoomScrollLayer* create(cocos2d::CCArray* pages, int offset, bool looped, cocos2d::CCArray* dynamicObjects, DynamicScrollDelegate* delegate) = win 0x3d0c0;

    virtual void visit() = win 0x3dc40;
    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event);
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x3e840;
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x3eb80;
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x3e6a0;
    virtual void registerWithTouchDispatcher() = win 0x3e610;

    void addPage(cocos2d::CCLayer* page) = win inline, ios inline {
        this->addPage(page, m_pages->count());
    }
    void addPage(cocos2d::CCLayer* page, int index) = win inline, ios inline {
        index = std::clamp<int>(index, 0, m_pages->count());
        m_pages->insertObject(page, index);
        this->updatePages();
        this->moveToPage(m_page);
    }
    void cancelAndStoleTouch(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline {
        auto touches = new cocos2d::CCSet();
        touches->addObject(touch);
        touches->autorelease();
        m_ignoreTouchCancel = true;
        cocos2d::CCDirector::sharedDirector()->getTouchDispatcher()->touchesCancelled(touches, event);
        m_ignoreTouchCancel = false;
        this->claimTouch(touch);
    }
    void claimTouch(cocos2d::CCTouch* touch) = win inline {
        auto handler = static_cast<cocos2d::CCTargetedTouchHandler*>(cocos2d::CCDirector::sharedDirector()->getTouchDispatcher()->findHandler(this));
        if (!handler->getClaimedTouches()->containsObject(touch)) {
            handler->getClaimedTouches()->addObject(touch);
        }
    }
    cocos2d::CCLayer* getPage(int page) = win inline {
        if (m_dynamic) {
            auto pages = m_pages->count();
            if (page > 0) page = page % pages;
            else {
                while (page < 0) page += pages;
            }
        }
        return static_cast<cocos2d::CCLayer*>(m_pages->objectAtIndex(page));
    }
    int getRelativePageForNum(int page) = win inline {
        auto pages = this->getTotalPages();
        if (page > 0) return page % pages;
        while (page < 0) page += pages;
        return page;
    }
    cocos2d::CCPoint getRelativePosForPage(int page) = win inline, ios inline {
        return { this->getContentSize().width - m_pageOffset * page, 0.f };
    }
    int getTotalPages() = win inline {
        return m_dynamic ? m_dynamicObjects->count() : m_pages->count();
    }
    bool init(cocos2d::CCArray* pages, int offset, bool looped, cocos2d::CCArray* dynamicObjects, DynamicScrollDelegate* delegate) = win 0x3d2a0;
    void instantMoveToPage(int page) = win 0x3de30;
    void moveToPage(int page) = win 0x3df10;
    void moveToPageEnded() = win 0x3dca0;
    int pageNumberForPosition(cocos2d::CCPoint position) = win 0x3dd30;
    cocos2d::CCPoint positionForPageWithNumber(int page) = win inline, ios inline {
        return { this->getContentSize().width + m_pageOffset * page, 0.f };
    }
    void quickUpdate() = win inline {
        if (m_pageMoving) {
            m_pageMoving = false;
            m_extendedLayer->stopActionByTag(2);
            m_extendedLayer->setPosition(m_position);
            this->moveToPageEnded();
        }
    }
    void removePage(cocos2d::CCLayer* page) = win inline, ios inline {
        m_pages->removeObject(page);
        this->removeChild(page, true);
        m_slowPage = m_page;
        m_page = std::min<int>(m_page, m_pages->count() - 1);
        this->moveToPage(m_page);
    }
    void removePageWithNumber(int page) = win inline, ios inline {
        if (page > -1 && page < m_pages->count()) {
            this->removePage(static_cast<cocos2d::CCLayer*>(m_pages->objectAtIndex(page)));
        }
    }
    void repositionPagesLooped() = win 0x3e0d0;
    void selectPage(int page) = win inline {
        if (page > -1 && page < this->getTotalPages()) {
            m_extendedLayer->setPosition(this->positionForPageWithNumber(page));
            m_slowPage = m_page;
            m_page = page;
        }
    }
    void setDotScale(float scale) = win inline {
        for (int i = 0; i < m_dots->count(); i++) {
            static_cast<cocos2d::CCSprite*>(m_dots->objectAtIndex(i))->setScale(scale);
        }
    }
    void setPagesIndicatorPosition(cocos2d::CCPoint pos) = win inline {
        m_dotPosition = pos;
        this->updateDots(0.f);
    }
    void setupDynamicScrolling(cocos2d::CCArray* dynamicObjects, DynamicScrollDelegate* delegate) = win 0x3d610;
    void togglePageIndicators(bool visible) = win 0x3dbd0;
    void updateDots(float dt) = win 0x3d9d0;
    void updatePages() = win 0x3d8b0;

    cocos2d::CCArray* m_dots;
    int m_slowPage;
    float m_touchX;
    float m_touchQuotient;
    bool m_looped;
    DynamicScrollDelegate* m_dynamicDelegate;
    cocos2d::CCArray* m_dynamicObjects;
    bool m_dynamic;
    int m_touchType;
    bool m_ignoreTouchCancel;
    cocos2d::CCTouch* m_touch;
    cocos2d::CCArray* m_pages;
    double m_touchTime;
    cocos2d::CCPoint m_position;
    ExtendedLayer* m_extendedLayer;
    cocos2d::CCRect m_rect;
    // these 4 floats are likely wrong, they're min, touchSpeedFast, touchSpeedMid in 2.0 but it only has 3 of them
    float m_unkFloat1;
    float m_maxSpeed;
    float m_minSpeed;
    float m_unkFloat2;
    BoomScrollLayerDelegate* m_delegate;
    bool m_pageMoving;
    bool m_pagesInvisible;
    float m_minimumTouchLengthToSlide;
    float m_minimumTouchLengthToChangePage;
    float m_width; //marginOffset in Rob terms
    bool m_cancelAndStealTouch;
    bool m_dotsVisible;
    cocos2d::CCPoint m_dotPosition;
    cocos2d::ccColor4B m_selectedPageColor;
    cocos2d::ccColor4B m_normalPageColor;
    int m_page;
    float m_pageOffset;
    void* m_unkPtr;
    bool m_doVisit;
    cocos2d::CCRect m_clippingRect;
}

[[link(android)]]
class BoomScrollLayerDelegate {
    virtual void scrollLayerScrollingStarted(BoomScrollLayer* layer) {}
    virtual void scrollLayerScrolledToPage(BoomScrollLayer* layer, int page) {}
    virtual void scrollLayerMoved(cocos2d::CCPoint position) {}
    virtual void scrollLayerWillScrollToPage(BoomScrollLayer* layer, int page) {}
}

[[link(android)]]
class BrowseSmartKeyLayer : BrowseSmartTemplateLayer {
    // virtual ~BrowseSmartKeyLayer();
    BrowseSmartKeyLayer() {
        m_templatePage = 0;
    }

    static BrowseSmartKeyLayer* create(GJSmartTemplate* smartTemplate, gd::string prefabKey) = win inline {
        auto ret = new BrowseSmartKeyLayer();
        if (ret->init(smartTemplate, prefabKey)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void onBack(cocos2d::CCObject* sender) = win 0x45c1e0;

    void addChanceToSelected(int chance, bool zero) = win inline {
        auto blocks = this->getAllSelectedBlocks();
        for (int i = 0; i < blocks->count(); i++) {
            if (auto prefab = m_template->getPrefabWithID(m_prefabKey, blocks->objectAtIndex(i)->getTag())) {
                if (zero) prefab->m_prefabChance = 0;
                else prefab->m_prefabChance += chance;
            }
        }
        this->updateChanceValues();
    }
    void createTemplateObjects() = win inline {
        auto blocks = this->getAllSelectedBlocks();
        if (blocks->count() == 0) return;
        for (int i = 0; i < blocks->count(); i++) {
            this->createPrefab(m_prefabKey, blocks->objectAtIndex(i)->getTag());
        }
        this->addChild(TextAlertPopup::create("Added to editor", .5f, .6f, 150, ""), 100);
    }
    void deletedSelectedItems() = win inline {
        for (int i = 0; i < m_pages->count(); i++) {
            auto page = static_cast<cocos2d::CCArray*>(m_pages->objectAtIndex(i));
            for (int j = 0; j < page->count();) {
                auto button = static_cast<CCMenuItemSpriteExtra*>(page->objectAtIndex(j));
                auto block = static_cast<GJSmartBlockPreview*>(button->getNormalImage());
                if (block->m_selected) {
                    m_template->removePrefab(m_prefabKey, block->getTag());
                    page->removeObjectAtIndex(j);
                }
                else j++;
            }
        }
        this->updateChanceValues();
    }
    cocos2d::CCArray* getAllSelectedBlocks() = win 0x45bf00;
    bool init(GJSmartTemplate* smartTemplate, gd::string prefabKey) = win 0x45b100;
    void onButton(cocos2d::CCObject* sender) = win 0x45bae0;
    void onPrefabObject(cocos2d::CCObject* sender) = win 0x45c100;
    void updateChanceValues() = win 0x45bfd0;

    gd::string m_prefabKey;
    int m_templatePage;
}

[[link(android), depends(SmartPrefabResult)]]
class BrowseSmartTemplateLayer : FLAlertLayer {
    BrowseSmartTemplateLayer() {
        m_template = nullptr;
        m_pages = nullptr;
        m_page = 0;
        m_nextPageBtn = nullptr;
        m_prevPageBtn = nullptr;
        m_dotsArray = nullptr;
    }
    ~BrowseSmartTemplateLayer() = win 0x4599b0;

    static BrowseSmartTemplateLayer* create(GJSmartTemplate* smartTemplate, SmartBrowseFilter browseFilter) = win inline {
        auto ret = new BrowseSmartTemplateLayer();
        if (ret->init(smartTemplate, browseFilter)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyBackClicked();
    virtual void onBack(cocos2d::CCObject* sender) = win 0x45b090;

    void addObjectToPage(cocos2d::CCObject* object, int page) = win 0x45a4e0;
    void addPrefabMenuItem(SmartPrefabResult result, int index) = win 0x45a0e0;
    void baseSetup() = win 0x45a570;
    void createDots() = win inline {
        auto batchNode = cocos2d::CCSpriteBatchNode::create("smallDot.png");
        m_mainLayer->addChild(batchNode, 5);
        m_dotsArray = cocos2d::CCArray::create();
        m_dotsArray->retain();
        for (int i = 0; i < m_pages->count(); i++) {
            auto dot = cocos2d::CCSprite::create("smallDot.png");
            dot->setScale(.8f);
            batchNode->addChild(dot);
            m_dotsArray->addObject(dot);
        }
    }
    void createPrefab(gd::string key, int id) = win 0x45ac90;
    void goToPage(int page) = win 0x45ab20;
    bool init(GJSmartTemplate* smartTemplate, SmartBrowseFilter browseFilter) = win 0x459a70;
    void onClick(cocos2d::CCObject* sender) = win 0x45b020;
    void onClose(cocos2d::CCObject* sender) = win inline {
        cocos2d::CCDirector::sharedDirector()->getTouchDispatcher()->unregisterForcePrio(this);
        this->setKeypadEnabled(false);
        this->removeFromParentAndCleanup(true);
    }
    void onTemplateObject(cocos2d::CCObject* sender) = win 0x45ad60;
    void updateDots() = win inline {
        if (!m_dotsArray) this->createDots();
        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        auto count = m_pages->count();
        for (int i = 0; i < count; i++) {
            if (i < m_dotsArray->count()) {
                auto dot = static_cast<cocos2d::CCSprite*>(m_dotsArray->objectAtIndex(i));
                dot->setPosition(winSize * .5f + cocos2d::CCPoint { (i - (count - 1) * .5f) * 16.f, -125.f });
                dot->setColor(i == m_page ? cocos2d::ccColor3B { 255, 255, 255 } : cocos2d::ccColor3B { 125, 125, 125 });
            }
        }
    }

    GJSmartTemplate* m_template;
    cocos2d::CCArray* m_pages;
    int m_page;
    cocos2d::CCNode* m_nextPageBtn;
    cocos2d::CCNode* m_prevPageBtn;
    cocos2d::CCArray* m_dotsArray;
}

[[link(android)]]
class ButtonPage : cocos2d::CCLayer {
    // virtual ~ButtonPage();
    ButtonPage() {}

    static ButtonPage* create(cocos2d::CCArray* objects, cocos2d::CCPoint position, int rows, float spacing) = win inline {
        auto ret = new ButtonPage();
        if (ret->init(objects, position, rows, spacing)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init(cocos2d::CCArray* objects, cocos2d::CCPoint position, int rows, float spacing) = win inline {
        if (!cocos2d::CCLayer::init()) return false;

        auto menu = cocos2d::CCMenu::create();
        this->addChild(menu);

        auto x = position.x;
        auto y = position.y;
        for (int i = 0; i < objects->count(); i++) {
            auto row = rows != 0 ? (int)(i / rows) : 0;
            auto node = static_cast<cocos2d::CCNode*>(objects->objectAtIndex(i));
            menu->addChild(node);
            node->setPosition(menu->convertToNodeSpace({
                (i % rows) + (spacing + 4.f) * (spacing * .5f + x - rows * spacing * .5f - (rows - 1) * 2.f),
                (y - spacing * .5f) - row * (spacing + 4.f)
            }));
        }

        return true;
    }
}

[[link(android)]]
class ButtonSprite : cocos2d::CCSprite {
    // virtual ~ButtonSprite();
    ButtonSprite() = win 0x3edb0 {
        m_mode = 0;
        m_width = 0.f;
        m_minWidth = 0.f;
        m_scale = 0.f;
        m_height = 0.f;
        m_absolute = false;
        m_label = nullptr;
        m_subSprite = nullptr;
        m_subBGSprite = nullptr;
        m_BGSprite = nullptr;
    }

    static ButtonSprite* create(char const* caption) {
        return ButtonSprite::create(caption, 0, false, "goldFont.fnt", "GJ_button_01.png", .0f, 1.f);
    }
    static ButtonSprite* create(cocos2d::CCSprite* topSprite) {
        return ButtonSprite::create(topSprite, 0, 0, .0f, 1.f, false, "GJ_button_01.png", false);
    }
    static ButtonSprite* create(char const* caption, float scale) {
        return ButtonSprite::create(caption, 0, false, "goldFont.fnt", "GJ_button_01.png", .0f, scale);
    }
    static ButtonSprite* create(char const* caption, const char* font, const char* texture) {
        return ButtonSprite::create(caption, 0, false, font, texture, .0f, 1.f);
    }
    static ButtonSprite* create(char const* caption, const char* font, const char* texture, float scale) {
        return ButtonSprite::create(caption, 0, false, font, texture, .0f, scale);
    }
    static ButtonSprite* create(char const* caption, int width, int minWidth, float scale, bool absolute) {
        return ButtonSprite::create(caption, width, minWidth, scale, absolute, "goldFont.fnt", "GJ_button_01.png", .0f);
    }

    /// Create a ButtonSprite with a top sprite and a texture.
    /// @param topSprite The top sprite to add on top of the sprite
    /// @param width Sprite width; ignored if `absolute` is false
    /// @param absolute Whether to use absolute width or not
    /// @param texture The name of the background sprite file (can't be in a spritesheet)
    /// @param height The height of the button, leave 0 for automatic
    /// @param scale Scale of top sprite
    static ButtonSprite* create(cocos2d::CCSprite* topSprite, int width, bool absolute, float height, const char* texture, float scale) {
        return create(topSprite, width, 0, height, scale, absolute, texture, true);
    }
    static ButtonSprite* create(cocos2d::CCSprite* topSprite, int width, int minWidth, float height, float scale, bool absolute) {
        return ButtonSprite::create(topSprite, width, minWidth, height, scale, absolute, "GJ_button_01.png", false);
    }
    static ButtonSprite* create(char const* caption, int width, int minWidth, float scale, bool absolute, char const* font, char const* bg) {
        return ButtonSprite::create(caption, width, minWidth, scale, absolute, font, bg, .0f);
    }

    /// Create a ButtonSprite with text, a font and a texture.
    /// @param caption The text of the ButtonSprite
    /// @param width Sprite width; ignored if `absolute` is false
    /// @param absolute Whether to use absolute width or not
    /// @param font The name of the BM font file to use
    /// @param texture The name of the background sprite file (can't be in a spritesheet)
    /// @param height The height of the button, leave 0 for automatic
    /// @param scale Scale of text
    /// @returns Pointer to the created ButtonSprite, or nullptr on error
    static ButtonSprite* create(const char* caption, int width, bool absolute, const char* font, const char* texture, float height, float scale) {
        return create(caption, width, 0, scale, absolute, font, texture, height);
    }
    static ButtonSprite* create(char const* caption, int width, int minWidth, float scale, bool absolute, char const* font, char const* bg, float height) = win 0x3f1e0;
    static ButtonSprite* create(cocos2d::CCSprite* topSprite, int width, int minWidth, float height, float scale, bool absolute, char const* bgSprite, bool noScaleSpriteForBG) = win 0x3eed0;

    bool init(char const* caption, int width, int minWidth, float scale, bool absolute, char const* font, char const* bg, float height) = win 0x3f2b0;
    bool init(cocos2d::CCSprite* topSprite, int width, int minWidth, float height, float scale, bool absolute, char const* bgSprite, bool noScaleSpriteForBG) = win 0x3ef80;
    void setColor(cocos2d::ccColor3B color) = win inline {
        // i love inlined funcs
        if (m_label) m_label->setColor(color);
        if (m_subSprite) m_subSprite->setColor(color);
        if (m_subBGSprite) m_subBGSprite->setColor(color);
        if (m_BGSprite) m_BGSprite->setColor(color);
    }
    void setString(char const* text) = win 0x3fb70;
    void updateBGImage(char const* filename) = win 0x3f5b0;
    void updateSpriteBGSize() = win 0x3f6f0;
    void updateSpriteOffset(cocos2d::CCPoint offset) = win inline {
        m_spritePosition = offset;
        this->updateSpriteBGSize();
    }

    int m_mode;
    float m_width;
    float m_minWidth;
    float m_scale;
    float m_height;
    bool m_absolute;
    cocos2d::CCLabelBMFont* m_label;
    cocos2d::CCSprite* m_subSprite;
    cocos2d::CCSprite* m_subBGSprite;
    cocos2d::extension::CCScale9Sprite* m_BGSprite;
    cocos2d::CCPoint m_textOffset;
    cocos2d::CCPoint m_spritePosition;
    gd::string m_caption;
}

[[link(android)]]
class CameraTriggerGameObject : EffectGameObject {
    // virtual ~CameraTriggerGameObject();
    CameraTriggerGameObject() {
        m_exitStatic = false;
        m_followObject = false;
        m_followEasing = 1.f;
        m_edgeDirection = 0;
        m_smoothVelocity = false;
        m_velocityModifier = 0.f;
        m_exitInstant = false;
        m_previewOpacity = 1.f;
    }

    static CameraTriggerGameObject* create(char const* frame) = win inline {
        auto ret = new CameraTriggerGameObject();
        if (ret->init(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void triggerObject(GJBaseGameLayer* layer, int uniqueID, gd::vector<int> const* remapKeys) = win 0x4bd4b0;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4be750;
    virtual gd::string getSaveString(GJBaseGameLayer* layer);

    bool init(char const* frame) = win inline, ios inline {
        return EffectGameObject::init(frame);
    }

    // property 110
    bool m_exitStatic;
    // property 212
    bool m_followObject;
    // property 213
    float m_followEasing;
    // property 164
    int m_edgeDirection;
    // property 453
    bool m_smoothVelocity;
    // property 454
    float m_velocityModifier;
    // property 465
    bool m_exitInstant;
    // property 506
    float m_previewOpacity;
}

[[link(android)]]
class CCAlertCircle : cocos2d::CCNode {
    // virtual ~CCAlertCircle();

    static CCAlertCircle* create();

    virtual bool init();
    virtual void draw();

    CCCircleAlert* m_circleAlert;
}

[[link(android)]]
class CCAnimatedSprite : cocos2d::CCSprite {
    CCAnimatedSprite() = win 0x3ff40 {
        m_animationManager = nullptr;
        m_sprite = nullptr;
        m_fbfSprite = nullptr;
        m_paSprite = nullptr;
        m_spriteMode = (spriteMode)0;
        m_delegate = nullptr;
    }
    ~CCAnimatedSprite() = win 0x411d0;

    static CCAnimatedSprite* createWithType(char const* definition, cocos2d::CCTexture2D* texture, bool useTexture) = win inline {
        auto ret = new CCAnimatedSprite();
        if (ret->initWithType(definition, texture, useTexture)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void setOpacity(unsigned char opacity) = win 0x41100;
    virtual void setColor(cocos2d::ccColor3B const& color) = win 0x41160;
    virtual void animationFinished(char const* key);
    virtual void animationFinishedO(cocos2d::CCObject* str) = win 0x410a0;

    void cleanupSprite() = win inline {
        if (m_paSprite) m_paSprite->cleanup();
        if (m_fbfSprite) m_fbfSprite->cleanup();
        if (m_animationManager) m_animationManager->doCleanup();
        if (m_fbfSprite) m_fbfSprite->removeFromParentAndCleanup(true);
        if (m_paSprite) m_paSprite->removeFromParentAndCleanup(true);
        m_animationManager = nullptr;
        m_sprite = nullptr;
        m_fbfSprite = nullptr;
        m_paSprite = nullptr;
        m_spriteMode = (spriteMode)0;
    }
    bool initWithType(char const* definition, cocos2d::CCTexture2D* texture, bool useTexture) = win 0x40050;
    void loadType(char const* definition, cocos2d::CCTexture2D* texture, bool useTexture) = win 0x40270;
    void runAnimation(gd::string animation);
    void runAnimationForced(gd::string animation) = win inline {
        m_animationManager->overridePrio();
        m_animationManager->runAnimation(animation);
    }
    void stopTween() = win inline {
        m_paSprite->stopAllActions();
        this->stopActionByTag(1);
        m_activeTween = "";
    }
    void switchToMode(spriteMode mode) = win 0x40ba0;
    void tweenToAnimation(gd::string animation, float duration) = win 0x40d80;
    void tweenToAnimationFinished() = win 0x41050;
    void willPlayAnimation() = win inline {
        this->stopActionByTag(1);
        m_activeTween = "";
    }

    gd::string m_unkString1;
    gd::string m_activeTween;
    SpriteAnimationManager* m_animationManager;
    cocos2d::CCSprite* m_sprite;
    cocos2d::CCSprite* m_fbfSprite;
    CCPartAnimSprite* m_paSprite;
    spriteMode m_spriteMode;
    gd::string m_currentAnim;
    AnimatedSpriteDelegate* m_delegate;
}

[[link(android)]]
class CCAnimateFrameCache : cocos2d::CCObject {
    // virtual ~CCAnimateFrameCache();

    static CCAnimateFrameCache* get() {
        return CCAnimateFrameCache::sharedSpriteFrameCache();
    }
    static CCAnimateFrameCache* sharedSpriteFrameCache() = win 0x414e0;

    void addCustomSpriteFramesWithFile(char const* filename);
    cocos2d::CCDictionary* addDict(DS_Dictionary* dict, char const* filename) = win 0x41700;
    cocos2d::CCDictionary* addDict(cocos2d::CCDictionary* dict, char const* filename) = win inline {
        m_animateDescriptions->setObject(dict, filename);
        auto container = static_cast<cocos2d::CCDictionary*>(dict->objectForKey("animationContainer"));
        auto keys = container->allKeys();
        for (int i = 0; i < keys->count(); i++) {
            auto key = static_cast<cocos2d::CCString*>(keys->objectAtIndex(i))->getCString();
            auto animation = static_cast<cocos2d::CCDictionary*>(container->objectForKey(key));
            auto frames = cocos2d::CCArray::create();
            m_animateFrames->setObject(frames, key);
            for (int i = 0; i < animation->count(); i++) {
                auto frame = animation->objectForKey(cocos2d::CCString::createWithFormat("sprite_%i", i)->getCString());
                frames->addObject(SpriteDescription::createDescription(static_cast<cocos2d::CCDictionary*>(frame)));
            }
        }
        return dict;
    }
    cocos2d::CCDictionary* addSpriteFramesWithFile(char const* filename) = win 0x41570;
    bool init() = win inline {
        m_animateFrames = cocos2d::CCDictionary::create();
        m_animateFrames->retain();
        m_unk040 = cocos2d::CCDictionary::create();
        m_unk040->retain();
        m_animateDescriptions = cocos2d::CCDictionary::create();
        m_animateDescriptions->retain();
        return true;
    }
    void purgeSharedSpriteFrameCache() = win inline, ios inline {
        auto** instancePtr = reinterpret_cast<CCAnimateFrameCache**>(geode::base::get() + GEODE_WINDOWS(0x6a4e10) GEODE_IOS(0x85f2d0));
        if (*instancePtr) {
            (*instancePtr)->release();
            *instancePtr = nullptr;
        }
    }
    void removeSpriteFrames() = win inline {
        m_animateFrames->removeAllObjects();
        m_unk040->removeAllObjects();
        m_animateDescriptions->removeAllObjects();
    }
    cocos2d::CCArray* spriteFrameByName(char const* name);

    cocos2d::CCDictionary* m_animateFrames;
    cocos2d::CCDictionary* m_unk040;
    cocos2d::CCDictionary* m_animateDescriptions;
}

[[link(android)]]
class CCBlockLayer : cocos2d::CCLayerColor {
    CCBlockLayer() = win 0x423f0 {
        m_closeOnHide = false;
        m_forcePrioRegistered = false;
    }
    ~CCBlockLayer();

    static CCBlockLayer* create() = win inline, ios inline {
        auto ret = new CCBlockLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x42570;
    virtual void draw() = win 0x42780;
    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline { return true; }
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline {}
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline {}
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline {}
    virtual void registerWithTouchDispatcher() = win 0x42660;
    virtual void keyBackClicked() = win 0x426b0;
    virtual void customSetup() = win inline {}
    virtual void enterLayer() = win 0x42630;
    virtual void exitLayer() = win 0x426d0;
    virtual void showLayer(bool instant);
    virtual void hideLayer(bool instant);
    virtual void layerVisible();
    virtual void layerHidden();
    virtual void enterAnimFinished() = win inline {}
    virtual void disableUI() = win inline {}
    virtual void enableUI() = win inline {}

    void decrementForcePrio() = win inline {
        if (m_forcePrioRegistered) {
            m_forcePrioRegistered = false;
            cocos2d::CCDirector::sharedDirector()->getTouchDispatcher()->unregisterForcePrio(this);
        }
    }
    void incrementForcePrio() = win inline {
        if (!m_forcePrioRegistered) {
            m_forcePrioRegistered = true;
            cocos2d::CCDirector::sharedDirector()->getTouchDispatcher()->registerForcePrio(this, 2);
        }
    }

    bool m_closeOnHide;
    bool m_forcePrioRegistered;
}

[[link(android)]]
class CCCircleAlert : CCCircleWave {
    // virtual ~CCCircleAlert();

    static CCCircleAlert* create(float duration, float startRadius, float endRadius);

    bool init(float duration, float startRadius, float endRadius);
}

[[link(android)]]
class CCCircleWave : cocos2d::CCNode {
    // virtual ~CCCircleWave();
    // CCCircleWave() = win 0x418b0;

    static CCCircleWave* create(float startRadius, float endRadius, float duration, bool fadeIn) = win inline {
        return CCCircleWave::create(startRadius, endRadius, duration, fadeIn, true);
    }
    static CCCircleWave* create(float startRadius, float endRadius, float duration, bool fadeIn, bool easeOut) = win 0x42890;

    virtual void setPosition(cocos2d::CCPoint const& position) = win 0x42b80;
    virtual void removeMeAndCleanup() = win 0x42f90;
    virtual void draw() = win 0x42e60;
    virtual void updateTweenAction(float value, char const* key) = win 0x42c00;

    void baseSetup(float radius) = win inline, ios inline {
        m_target = nullptr;
        m_radius = radius;
        m_opacity = 1.f;
        m_color.r = 255;
        m_color.g = 255;
        m_color.b = 255;
        m_circleMode = CircleMode::Filled;
        m_lineWidth = 2;
        m_opacityMod = 1.f;
        m_blendAdditive = true;
    }
    void followObject(cocos2d::CCNode* newTarget, bool staticPosition) = win inline {
        if (m_target) m_target->release();

        m_target = newTarget;
        newTarget->retain();

        this->unschedule(schedule_selector(CCCircleWave::updatePosition));
        if (!staticPosition) this->schedule(schedule_selector(CCCircleWave::updatePosition));

        this->setPosition(newTarget->getPosition());
    }
    bool init(float startRadius, float endRadius, float duration, bool fadeIn, bool easeOut) = win 0x42940;
    void updatePosition(float dt) = win 0x42bc0;

    cocos2d::CCNode* m_target;
    float m_width;
    float m_radius;
    float m_opacity;
    cocos2d::ccColor3B m_color;
    cocos2d::CCPoint m_position;
    CircleMode m_circleMode;
    int m_lineWidth;
    float m_opacityMod;
    bool m_blendAdditive;
    CCCircleWaveDelegate* m_delegate;
}

[[link(android)]]
class CCCircleWaveDelegate {
    virtual void circleWaveWillBeRemoved(CCCircleWave* circleWave) {}
}

[[link(android)]]
class CCContentLayer : cocos2d::CCLayerColor {
    CCContentLayer() {}

    static CCContentLayer* create(cocos2d::ccColor4B const& color, float width, float height) = win inline {
        auto ret = new CCContentLayer();
        if (ret->initWithColor(color, width, height)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void setPosition(cocos2d::CCPoint const& position) = win 0x43000;
}

[[link(android)]]
class CCCountdown : cocos2d::CCSprite {
    // virtual ~CCCountdown();

    static CCCountdown* create();

    virtual bool init();
    virtual void setOpacity(unsigned char opacity);

    void lapFinished();
    void startTimerWithSeconds(float seconds, cocos2d::SEL_CallFunc selector, cocos2d::CCNode* target);

    cocos2d::CCProgressTimer* m_progressTimer;
    float m_unk260;
    int m_seconds;
    cocos2d::CCLabelBMFont* m_countdownLabel;
    cocos2d::SEL_CallFunc m_callbackSelector;
    cocos2d::CCNode* m_targetNode;
}

[[link(android)]]
class CCCounterLabel : cocos2d::CCLabelBMFont {
    // virtual ~CCCounterLabel();
    CCCounterLabel() {
        m_stepSize = 0;
        m_targetCount = 0;
        m_currentCount = 0;
        m_counterEnabled = false;
        m_stepCount = 10;
        m_dontSchedule = false;
        m_formatterType = FormatterType::Integer;
    }

    static CCCounterLabel* create(int count, char const* font, FormatterType type) = win inline {
        auto ret = new CCCounterLabel();
        if (ret->init(count, font, type)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    void calculateStepSize(int steps) = win inline, ios inline {
        auto diff = m_targetCount - m_currentCount;
        m_stepSize = diff / std::min<float>(std::abs(diff), steps);
    }
    void disableCounter() = win inline, ios inline {
        if (m_counterEnabled) {
            m_counterEnabled = false;
            if (!m_dontSchedule) {
                this->unscheduleAllSelectors();
            }
        }
    }
    void enableCounter() = win inline, ios inline {
        if (!m_counterEnabled) {
            m_counterEnabled = true;
            if (!m_dontSchedule) {
                this->schedule(schedule_selector(CCCounterLabel::updateCounter), 1.f / 30.f);
            }
        }
    }
    void fastUpdateCounter() = win inline, ios inline {
        m_currentCount = m_targetCount;
        this->updateString();
    }
    int getTargetCount() = win inline, ios inline {
        return m_targetCount;
    }
    bool init(int count, char const* font, FormatterType type) = win inline {
        if (!cocos2d::CCLabelBMFont::initWithString(" ", font)) return false;
        m_formatterType = type;
        m_targetCount = count;
        this->fastUpdateCounter();
        return true;
    }
    void setTargetCount(int count) = win 0x431c0;
    void updateCounter(float dt) = win 0x43250;
    void updateString() = win 0x432d0;

    int m_stepSize;
    int m_targetCount;
    int m_currentCount;
    bool m_counterEnabled;
    int m_stepCount;
    bool m_dontSchedule;
    FormatterType m_formatterType;
}

[[link(android)]]
class CCExtenderNode : cocos2d::CCNode {
    void setOpacity(unsigned int opacity) = win inline, ios inline {
        auto children = this->getChildren();
        for (int i = 0; i < children->count(); i++) {
            static_cast<cocos2d::CCNodeRGBA*>(children->objectAtIndex(i))->setOpacity(opacity);
        }
    }
}

[[link(android)]]
class CCIndexPath : cocos2d::CCObject {
    CCIndexPath() {
        m_row = 0;
        m_section = 0;
    }

    // virtual ~CCIndexPath();
    static CCIndexPath* CCIndexPathWithSectionRow(int section, int row) {
        auto ret = new CCIndexPath();
        ret->m_row = row;
        ret->m_section = section;
        ret->autorelease();
        return ret;
    }

    int m_row;
    int m_section;
}

[[link(android)]]
class CCLightFlash : cocos2d::CCNode {
    CCLightFlash() {
        m_lightStripArray = nullptr;
        m_layerColor = nullptr;
        m_dontFadeOut = false;
        m_mainLayer = nullptr;
        m_layerColorZOrder = 0;
    }
    ~CCLightFlash() = win inline {
        CC_SAFE_RELEASE(m_lightStripArray);
    }

    static CCLightFlash* create() = win inline {
        auto ret = new CCLightFlash();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        CC_SAFE_DELETE(ret);
        return nullptr;
    }

    virtual bool init() = win inline {
        return true;
    }

    void cleanupFlash() = win 0x43d10;
    void fadeAndRemove() = win inline {
        for (int i = 0; i < m_lightStripArray->count(); i++) {
            auto strip = static_cast<CCLightStrip*>(m_lightStripArray->objectAtIndex(i));
            strip->runAction(cocos2d::CCSequence::create(
                cocos2d::CCDelayTime::create(((float)rand() / RAND_MAX) * .2f),
                cocos2d::CCActionTween::create((((float)rand() / RAND_MAX) * .2f - .1f) * .1f + .5f, "opacity", strip->m_opacity, 0.f),
                cocos2d::CCCallFunc::create(this, callfunc_selector(CCNode::removeMeAndCleanup)),
                nullptr
            ));
        }
    }
    // param names from https://github.com/gd-hyperdash/Cocos2Dx/blob/master/cocos2dx/extensions/RobTop/CCLightFlash.h and confirmed to be correct
    void playEffect(cocos2d::CCPoint pos, cocos2d::ccColor3B col, float startWidth, float startWidthVariation, float endWidth, float endWidthVariation, float endHeight, float stripDuration, float stripDurationVariance, float stripInterval, float stripStartDelay, float stripStartDelayVariation, float stripRotation, float stripRotationVariation, float stripOpacity, float stripOpacityVariation, int stripCount, bool circleRotation, bool fadeIn, float delay) = win 0x43430;
    void removeLights() = win 0x43cb0;
    void showFlash() = win 0x43970;

    cocos2d::CCArray* m_lightStripArray;
    cocos2d::CCLayerColor* m_layerColor;
    bool m_dontFadeOut;
    cocos2d::CCNode* m_mainLayer;
    int m_layerColorZOrder;
}

[[link(android)]]
class CCLightStrip : cocos2d::CCNode {
    CCLightStrip() {
        m_objectWidth = .0f;
        m_toWidth = .0f;
        m_toHeight = .0f;
        m_duration = .0f;
        m_opacity = .0f;
        m_width = .0f;
        m_height = .0f;
    }

    // virtual ~CCLightStrip();
    static CCLightStrip* create(float width, float toWidth, float toHeight, float duration, float delay) = win inline {
        auto ret = new CCLightStrip();
        if (ret->init(width, toWidth, toHeight, duration, delay)) {
            ret->autorelease();
            return ret;
        }
        CC_SAFE_DELETE(ret);
        return nullptr;
    }

    virtual void draw() = win 0x43d40;
    virtual void updateTweenAction(float value, char const* keyword) = win 0x43f00;

    bool init(float width, float toWidth, float toHeight, float duration, float delay) = win inline {
        this->m_toWidth = toWidth;
        this->m_toHeight = toHeight;
        this->m_objectWidth = width;
        this->m_duration = duration;
        this->m_width = width;
        this->m_opacity = 255.f;
        this->m_height = 1.f;

        this->setVisible(false);

        auto* delayAction = cocos2d::CCDelayTime::create(delay);
        auto* heightActionTween = cocos2d::CCActionTween::create(this->m_duration, "height", this->m_height, this->m_toHeight);
        auto* widthActionTween = cocos2d::CCActionTween::create(this->m_duration, "width", this->m_width, this->m_toWidth);
        auto* heightEaseOutAction = cocos2d::CCEaseOut::create(heightActionTween, 2.f);
        auto* widthEaseOutAction = cocos2d::CCEaseOut::create(widthActionTween, 2.f);
        auto* spawnEaseOutActions = cocos2d::CCSpawn::create(heightEaseOutAction, widthEaseOutAction, nullptr);
        auto* lightStripSequence = cocos2d::CCSequence::create(delayAction, cocos2d::CCShow::create(), spawnEaseOutActions, nullptr);

        cocos2d::CCDirector::sharedDirector()->getActionManager()->addAction(lightStripSequence, this, false);

        return true;
    }

    float m_objectWidth;
    float m_toWidth;
    float m_toHeight;
    float m_duration;
    cocos2d::ccColor4B m_color;
    float m_opacity;
    float m_width;
    float m_height;
}

[[link(android)]]
class CCMenuItemSpriteExtra : cocos2d::CCMenuItemSprite {
    CCMenuItemSpriteExtra() = win 0x44a80 {
        m_animationEnabled = false; //this is changed to true in init
        m_colorEnabled = false;
        m_colorDip = 0.78431374f;
        m_scaleMultiplier = 1.f; //this is changed to 1.26f in init
        m_volume = 1.f;
        m_duration = 0.3f;
        m_unselectedDuration = 0.4f;
        m_animationType = MenuAnimationType::Scale;
        m_iconType = IconType::Cube;
        m_baseScale = 0.f; //this is changed to 1.f in init
    }

    static CCMenuItemSpriteExtra* create(cocos2d::CCNode* sprite, cocos2d::CCObject* target, cocos2d::SEL_MenuHandler callback) {
        return CCMenuItemSpriteExtra::create(sprite, nullptr, target, callback);
    }
    static CCMenuItemSpriteExtra* create(cocos2d::CCNode* sprite, cocos2d::CCNode* selectedSprite, cocos2d::CCObject* target, cocos2d::SEL_MenuHandler callback) = win 0x44bd0;

    virtual void activate() = win 0x44dd0;
    virtual void selected() = win 0x44ee0;
    virtual void unselected() = win 0x45100;

    bool init(cocos2d::CCNode* sprite, cocos2d::CCNode* selectedSprite, cocos2d::CCObject* target, cocos2d::SEL_MenuHandler callback) = win 0x44c70;
    void setSizeMult(float mult) = win inline {
        //inlined on windows, member is in CCMenuItemSprite
        m_fSizeMult = mult;
    }

    /// Set a new image for this button
    /// Prefer using this over `setNormalImage` as the latter does not actually
    /// handle any of the special sizing operations `CCMenuItemSpriteExtra` has
    /// @param sprite The sprite to replace this button's sprite with
    /// @note Geode addition
    void setSprite(cocos2d::CCSprite* sprite) {
        this->setNormalImage(sprite);
        this->updateSprite();
    }

    /// Update the sizing of this button's image
    /// If you for example have a `ButtonSprite` on this button and change the
    /// text, you need to call `updateSprite` afterwards to fix the button's
    /// content size
    /// @note Geode addition
    void updateSprite() {
        auto sprite = this->getNormalImage();
        auto size = sprite->getScaledContentSize();
        sprite->setPosition(size / 2);
        sprite->setAnchorPoint({ .5f, .5f });
        this->setContentSize(size);
    }
    void useAnimationType(MenuAnimationType type) = win inline {
        m_startPosition = this->getNormalImage()->getPosition();
        m_animationType = type;
    }

    float m_scaleMultiplier;
    float m_baseScale;
    bool m_animationEnabled;
    bool m_colorEnabled;
    float m_volume;
    gd::string m_activateSound;
    gd::string m_selectSound;
    float m_colorDip;
    cocos2d::CCPoint m_offset;
    float m_duration;
    float m_unselectedDuration;
    MenuAnimationType m_animationType;
    cocos2d::CCPoint m_startPosition;
    IconType m_iconType;
}

[[link(android)]]
class CCMenuItemToggler : cocos2d::CCMenuItem {
    CCMenuItemToggler() {
        m_offButton = nullptr;
        m_onButton = nullptr;
        m_toggled = false;
        m_notClickable = false;
    }

    // virtual ~CCMenuItemToggler();
    static CCMenuItemToggler* create(cocos2d::CCNode* off, cocos2d::CCNode* on, cocos2d::CCObject* target, cocos2d::SEL_MenuHandler callback) = win 0x45270;
    static CCMenuItemToggler* createWithSize(const char* spr1, const char* spr2, cocos2d::CCObject* target, cocos2d::SEL_MenuHandler callback, float scale) {
        auto sprOff = cocos2d::CCSprite::createWithSpriteFrameName(spr1);
        auto sprOn = cocos2d::CCSprite::createWithSpriteFrameName(spr2);

        sprOff->setScale(scale);
        sprOn->setScale(scale);

        return create(sprOff, sprOn, target, callback);
    }
    static CCMenuItemToggler* createWithStandardSprites(cocos2d::CCObject* target, cocos2d::SEL_MenuHandler callback, float scale) {
        auto sprOff = cocos2d::CCSprite::createWithSpriteFrameName("GJ_checkOff_001.png");
        auto sprOn = cocos2d::CCSprite::createWithSpriteFrameName("GJ_checkOn_001.png");

        float maxWidth = std::max(sprOff->getContentSize().width, sprOn->getContentSize().width);
        float maxHeight = std::max(sprOff->getContentSize().height, sprOn->getContentSize().height);

        sprOff->setScale(scale);
        sprOn->setScale(scale);

        auto ret = create(sprOff, sprOn, target, callback);

        ret->setContentSize({maxWidth, maxHeight});

        ret->m_offButton->setContentSize({maxWidth, maxHeight});
        ret->m_onButton->setContentSize({maxWidth, maxHeight});

        ret->m_offButton->setPosition({maxWidth/2, maxHeight/2});
        ret->m_onButton->setPosition({maxWidth/2, maxHeight/2});

        sprOff->setPosition({maxWidth/2, maxHeight/2});
        sprOn->setPosition({maxWidth/2, maxHeight/2});

        return ret;
    }

    virtual void activate();
    virtual void selected();
    virtual void unselected();
    virtual void setEnabled(bool enabled) = win 0x455c0;

    CCMenuItemSpriteExtra* activeItem() = win inline {
        return m_toggled ? m_onButton : m_offButton;
    }
    bool init(cocos2d::CCNode* off, cocos2d::CCNode* on, cocos2d::CCObject* target, cocos2d::SEL_MenuHandler callback) = win inline {
        if (!CCMenuItem::initWithTarget(target, callback)) return false;

        m_offButton = CCMenuItemSpriteExtra::create(off, nullptr, this, menu_selector(CCMenuItemToggler::normalTouch));
        m_onButton = CCMenuItemSpriteExtra::create(on, nullptr, this, menu_selector(CCMenuItemToggler::selectedTouch));

        this->addChild(m_offButton);
        this->addChild(m_onButton);

        m_offButton->getNormalImage()->setAnchorPoint({0.5f, 0.5f});
        m_onButton->getNormalImage()->setAnchorPoint({0.5f, 0.5f});

        auto imgoff = m_offButton->getNormalImage();
        auto imgon = m_onButton->getNormalImage();

        imgoff->setPosition(m_offButton->convertToNodeSpace({0.f, 0.f}));
        imgon->setPosition(m_onButton->convertToNodeSpace({0.f, 0.f}));
        m_notClickable = false;
        this->toggle(false);

        return true;
    }
    bool isOn() {
        return m_toggled;
    }
    bool isToggled() {
        return m_toggled;
    }
    void normalTouch(cocos2d::CCObject* sender) = win 0x45610;
    void selectedTouch(cocos2d::CCObject* sender) = win 0x45630;
    void setClickable(bool on) {
        m_notClickable = !on;
    }
    void setSizeMult(float mult) = win 0x454a0;
    void toggle(bool on) = win 0x45650;
    void toggleWithCallback(bool on) {
        this->activate();
        this->toggle(on);
    }

    /// Update the sizing of this toggle's image
    /// If you for example have a `ButtonSprite` on this toggle and change the
    /// text, you need to call `updateSprite` afterwards to fix the toggle's
    /// content size
    /// @note Geode addition
    void updateSprite() {
        m_offButton->updateSprite();
        m_onButton->updateSprite();
        auto size = m_offButton->getScaledContentSize();
        m_offButton->setPosition(size / 2);
        m_offButton->setAnchorPoint({ .5f, .5f });
        m_onButton->setPosition(size / 2);
        m_onButton->setAnchorPoint({ .5f, .5f });
        this->setContentSize(size);
    }

    CCMenuItemSpriteExtra* m_offButton;
    CCMenuItemSpriteExtra* m_onButton;
    bool m_toggled;
    bool m_notClickable;
}

[[link(android)]]
class CCMoveCNode : cocos2d::CCObject {
    // virtual ~CCMoveCNode();
    CCMoveCNode() {
        m_unk038 = 0.0;
        m_unk040 = 0.0;
        m_unk048 = 0.0;
        m_unk058 = 0.0;
        m_unk060 = 0.0;
        m_unk068 = 0.0;
        m_unk070 = false;
        m_unk071 = false;
        m_unk074 = 0;
        m_unk078 = false;
        m_unk07c = 0;
        m_unk080 = 1.0;
        m_unk088 = 1.0;
        m_unk090 = 0.0;
        m_unk098 = 0.0;
        m_unk0a0 = 0.0;
        m_unk0a8 = 0.0;
        m_unk0b0 = 0.0;
        m_unk0b8 = 0;
        m_unk0c0 = 0.0;
        m_groupObject = nullptr;
        m_unk0d0 = false;
        m_unk0d1 = false;
    }

    static CCMoveCNode* create() = win inline {
        auto ret = new CCMoveCNode();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init() = win inline, ios inline { return true; }
    void reset() = win inline, ios inline {
        m_unk038 = 0.0;
        m_unk040 = 0.0;
        m_unk048 = 0.0;
        m_unk058 = 0.0;
        m_unk060 = 0.0;
        m_unk068 = 0.0;
        m_unk070 = false;
        m_unk071 = false;
        m_unk074 = 0;
        m_unk078 = false;
        m_unk07c = 0;
        m_unk080 = 1.0;
        m_unk088 = 1.0;
        m_unk090 = 0.0;
        m_unk098 = 0.0;
        m_unk0a0 = 0.0;
        m_unk0a8 = 0.0;
        m_unk0b0 = 0.0;
        m_unk0b8 = 0;
        m_unk0c0 = 0.0;
        m_unk0d0 = false;
        m_groupObjects.clear();
        this->setTag(0);
        this->setObjType((cocos2d::CCObjectType)0);
    }

    double m_unk038;
    double m_unk040;
    double m_unk048;
    void* m_unk050;
    double m_unk058;
    double m_unk060;
    double m_unk068;
    bool m_unk070;
    bool m_unk071;
    int m_unk074;
    bool m_unk078;
    int m_unk07c;
    double m_unk080;
    double m_unk088;
    double m_unk090;
    double m_unk098;
    double m_unk0a0;
    double m_unk0a8;
    double m_unk0b0;
    int m_unk0b8;
    double m_unk0c0;
    GroupCommandObject2* m_groupObject;
    bool m_unk0d0;
    bool m_unk0d1;
    gd::vector<GroupCommandObject2*> m_groupObjects;
}

[[link(android)]]
class CCNodeContainer : cocos2d::CCNode {
    // virtual ~CCNodeContainer();

    static CCNodeContainer* create() = win 0x248ab0;

    virtual bool init();
    virtual void visit() = win 0x248b80;
}

[[link(android)]]
class CCPartAnimSprite : cocos2d::CCSprite {
    CCPartAnimSprite() {
        m_spritePartIDs = nullptr;
        m_spriteFrame = nullptr;
        m_hasChanged = false;
        m_spriteParts = nullptr;
    }
    ~CCPartAnimSprite() = win inline {
        CC_SAFE_RELEASE(m_spritePartIDs);
        CC_SAFE_RELEASE(m_spriteFrame);
        CC_SAFE_RELEASE(m_spriteParts);
    }

    static CCPartAnimSprite* createWithAnimDesc(char const* definition, cocos2d::CCTexture2D* texture, bool useTexture) = win inline {
        auto ret = new CCPartAnimSprite();
        if (ret->initWithAnimDesc(definition, texture, useTexture)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void setScaleX(float scaleX);
    virtual void setScaleY(float scaleY);
    virtual void setScale(float scale);
    virtual void setOpacity(unsigned char opacity) = win 0x46930;
    virtual void setBlendFunc(cocos2d::ccBlendFunc blendFunc) = win 0x46780;
    virtual void setDisplayFrame(cocos2d::CCSpriteFrame* frame) = win 0x46150;
    virtual bool isFrameDisplayed(cocos2d::CCSpriteFrame* frame) = win 0x463c0;
    virtual cocos2d::CCSpriteFrame* displayFrame();

    void changeTextureOfID(char const* key, char const* frame) = win inline, ios inline {
        if (auto spritePart = static_cast<CCSpritePart*>(m_spritePartIDs->objectForKey(key))) {
            if (frame) spritePart->updateDisplayFrame(frame);
            else spritePart->resetTextureRect();
        }
    }
    int countParts() = win inline, ios inline {
        return this->getChildren()->count();
    }
    void dirtify() = win inline, ios inline {
        CCObject* obj;
        CCARRAY_FOREACH(this->getChildren(), obj) {
            static_cast<cocos2d::CCSprite*>(obj)->setDirty(true);
        }
    }
    CCSpritePart* getSpriteForKey(char const* key) = win inline {
        return static_cast<CCSpritePart*>(m_spritePartIDs->objectForKey(key));
    }
    bool initWithAnimDesc(char const* definition, cocos2d::CCTexture2D* texture, bool useTexture) = win 0x459a0;
    void setColor(cocos2d::ccColor3B color) = win 0x46850;
    void setFlipX(bool flipX) = win inline {
        auto currentFlipX = this->isFlipX();
        if (currentFlipX != flipX) this->setScaleX(currentFlipX ? 0.f : 1.f);
        CCSprite::setFlipX(flipX);
        m_hasChanged = true;
    }
    void setFlipY(bool flipY) = win inline, ios inline {
        this->setScaleY(this->isFlipY() ? 0.f : 1.f);
        CCSprite::setFlipY(flipY);
        m_hasChanged = true;
    }
    void transformSprite(SpriteDescription* description) = win inline {
        auto spritePart = static_cast<CCSpritePart*>(m_spriteParts->objectAtIndex(description->m_tag));
        spritePart->stopAllActions();
        spritePart->setPosition(description->m_position);
        auto scaleX = description->m_scale.x;
        if (description->m_flipped.x) scaleX = -scaleX;
        auto scaleY = description->m_scale.y;
        if (description->m_flipped.y) scaleY = -scaleY;
        spritePart->setScaleX(scaleX);
        spritePart->setScaleY(scaleY);
        spritePart->setRotation(description->m_rotation);
        if (description->m_usesCustomTag) {
            spritePart->setDisplayFrame(description->m_texture);
            spritePart->frameChanged(description->m_texture->getFrameName());
        }
    }
    void tweenSpriteTo(SpriteDescription* description, float duration) = win inline {
        auto spritePart = static_cast<CCSpritePart*>(m_spriteParts->objectAtIndex(description->m_tag));
        spritePart->stopAllActions();
        auto scaleX = description->m_scale.x;
        if (description->m_flipped.x) scaleX = -scaleX;
        auto scaleY = description->m_scale.y;
        if (description->m_flipped.y) scaleY = -scaleY;
        spritePart->runAction(cocos2d::CCMoveTo::create(duration, description->m_position));
        spritePart->runAction(cocos2d::CCScaleTo::create(duration, scaleX, scaleY));
        spritePart->runAction(cocos2d::CCRotateTo::create(duration, description->m_rotation));
        if (description->m_usesCustomTag) {
            spritePart->setDisplayFrame(description->m_texture);
            spritePart->frameChanged(description->m_texture->getFrameName());
        }
        auto zValue = description->m_zValue;
        if (spritePart->getZOrder() != zValue) {
            this->reorderChild(spritePart, zValue);
        }
    }
    void tweenToFrame(cocos2d::CCSpriteFrame* frame, float duration) = win 0x463f0;

    cocos2d::CCDictionary* m_spritePartIDs;
    cocos2d::CCSpriteFrame* m_spriteFrame;
    bool m_hasChanged;
    cocos2d::CCSize m_unkSize;
    cocos2d::CCArray* m_spriteParts;
}

[[link(android), depends(CCContentLayer)]]
class CCScrollLayerExt : cocos2d::CCLayer {
    CCScrollLayerExt(cocos2d::CCRect rect) = win 0x46ae0;
    ~CCScrollLayerExt() = win 0x47120;

    virtual void visit() = win 0x47b60;
    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x47610;
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x479e0;
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x47730;
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x479b0;
    virtual void registerWithTouchDispatcher() = win 0x475c0;
    virtual void preVisitWithClippingRect(cocos2d::CCRect rect) = win 0x47c90;
    virtual void postVisit() = win 0x47d30;

    void constraintContent();
    void doConstraintContent(bool instant) = win 0x471a0;
    float getMaxY() = win inline {
        return m_scrollLimitBottom;
    }
    float getMinY() = win inline, ios inline {
        return this->getContentSize().height - m_contentLayer->getContentSize().height - m_scrollLimitTop;
    }
    void moveToTop() = win 0x47090;
    void moveToTopWithOffset(float offset) = win 0x46ff0;
    void scrollingEnd() = win 0x47350;
    void scrollLayer(float offset) = win inline {
        float y = m_contentLayer->getPositionY() + offset;
        float minY = getMinY();
        float maxY = getMaxY();
        m_contentLayer->setPositionY(y < minY ? minY : y > maxY ? maxY : y);
    }
    void setContentLayerSize(cocos2d::CCSize size) = win inline, ios inline {
        m_contentLayer->setContentSize(size);
    }
    void setContentOffset(cocos2d::CCPoint offset, bool animate) = win inline {
        if (animate) {
            m_contentLayer->runAction(cocos2d::CCSequence::create(
                cocos2d::CCEaseOut::create(cocos2d::CCMoveTo::create(.3f, offset), 3.f),
                cocos2d::CCCallFunc::create(this, callfunc_selector(CCScrollLayerExt::constraintContent)),
                nullptr
            ));
        }
        else {
            m_contentLayer->setPosition(offset);
            this->constraintContent();
        }
    }
    void updateIndicators(float dt) = win 0x47390;

    cocos2d::CCTouch* m_touch;
    cocos2d::CCPoint m_touchPosition;
    cocos2d::CCPoint m_touchStartPosition;
    cocos2d::cc_timeval m_timeValue;
    bool m_touchDown;
    bool m_notAtEndOfScroll;
    cocos2d::CCLayerColor* m_verticalScrollbar;
    cocos2d::CCLayerColor* m_horizontalScrollbar;
    CCScrollLayerExtDelegate* m_delegate;
    CCContentLayer* m_contentLayer;
    bool m_cutContent;
    bool m_vScrollbarVisible;
    bool m_hScrollbarVisible;
    bool m_disableHorizontal;
    bool m_disableVertical;
    bool m_disableMovement;
    float m_scrollLimitTop;
    float m_scrollLimitBottom;
    float m_peekLimitTop;
    float m_peekLimitBottom;
}

[[link(android)]]
class CCScrollLayerExtDelegate {
    virtual void scrllViewWillBeginDecelerating(CCScrollLayerExt* layer) {}
    virtual void scrollViewDidEndDecelerating(CCScrollLayerExt* layer) {}
    virtual void scrollViewTouchMoving(CCScrollLayerExt* layer) {}
    virtual void scrollViewDidEndMoving(CCScrollLayerExt* layer) {}
    virtual void scrollViewTouchBegin(CCScrollLayerExt* layer) {}
    virtual void scrollViewTouchEnd(CCScrollLayerExt* layer) {}
}

[[link(android)]]
class CCSpriteCOpacity : cocos2d::CCSprite {
    // virtual ~CCSpriteCOpacity();
    CCSpriteCOpacity() {}

    static CCSpriteCOpacity* createWithSpriteFrame(cocos2d::CCSpriteFrame* frame) = win inline, ios inline {
        auto ret = new CCSpriteCOpacity();
        if (ret->initWithSpriteFrame(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static CCSpriteCOpacity* createWithSpriteFrameName(char const* frameName) = win inline, ios inline {
        return CCSpriteCOpacity::createWithSpriteFrame(cocos2d::CCSpriteFrameCache::sharedSpriteFrameCache()->spriteFrameByName(frameName));
    }

    virtual void setOpacity(unsigned char opacity) = win 0x48450;
}

[[link(android)]]
class CCSpriteGrayscale : CCSpriteWithHue {
    // virtual ~CCSpriteGrayscale();
    CCSpriteGrayscale() {}

    static CCSpriteGrayscale* create(gd::string const& file) = win inline, ios inline {
        auto ret = new CCSpriteGrayscale();
        if (ret->initWithFile(file.c_str())) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static CCSpriteGrayscale* create(gd::string const& file, cocos2d::CCRect const& rect) = win inline, ios inline {
        auto ret = new CCSpriteGrayscale();
        if (ret->initWithFile(file.c_str(), rect)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static CCSpriteGrayscale* createWithSpriteFrame(cocos2d::CCSpriteFrame* frame) = win inline {
        auto ret = new CCSpriteGrayscale();
        if (ret->initWithSpriteFrame(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static CCSpriteGrayscale* createWithSpriteFrameName(gd::string const& frameName);
    static CCSpriteGrayscale* createWithTexture(cocos2d::CCTexture2D* texture) = win inline, ios inline {
        auto ret = new CCSpriteGrayscale();
        if (ret->initWithTexture(texture)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static CCSpriteGrayscale* createWithTexture(cocos2d::CCTexture2D* texture, cocos2d::CCRect const& rect, bool rotated) = win inline, ios inline {
        auto ret = new CCSpriteGrayscale();
        if (ret->initWithTexture(texture, rect, rotated)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual gd::string getShaderName() = win 0x49050;
    virtual const char* shaderBody();
}

[[link(android)]]
class CCSpritePart : CCSpritePlus {
    // virtual ~CCSpritePart();
    CCSpritePart() = win 0x458b0 {
        m_isBeingUsed = false;
        m_delegate = nullptr;
    }

    static CCSpritePart* create(cocos2d::CCTexture2D* texture) = win inline {
        auto ret = new CCSpritePart();
        if (ret->initWithTexture(texture)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static CCSpritePart* createWithSpriteFrameName(char const* frame) = win inline {
        auto ret = new CCSpritePart();
        if (ret->initWithSpriteFrameName(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void setVisible(bool visible) = win 0x46ac0;

    void frameChanged(gd::string frame) = win 0x46a10;
    bool getBeingUsed() = win inline, ios inline {
        return m_isBeingUsed;
    }
    void hideInactive() = win inline, ios inline {
        if (!m_isBeingUsed) this->setVisible(false);
    }
    void markAsNotBeingUsed() = win inline, ios inline {
        m_isBeingUsed = false;
    }
    void resetTextureRect() = win inline, ios inline {
        this->setTextureRect({ 0.f, 0.f, 0.f, 0.f });
    }
    void setBeingUsed(bool beingUsed) = win inline, ios inline {
        m_isBeingUsed = beingUsed;
    }
    void updateDisplayFrame(gd::string frame) = win inline, ios inline {
        this->frameChanged(frame);
        this->setDisplayFrame(cocos2d::CCSpriteFrameCache::sharedSpriteFrameCache()->spriteFrameByName(frame.c_str()));
    }

    bool m_isBeingUsed;
    gd::string m_spriteFrameName;
    SpritePartDelegate* m_delegate;
}

[[link(android)]]
class CCSpritePlus : cocos2d::CCSprite {
    // virtual ~CCSpritePlus();
    CCSpritePlus() = win 0x45730 {
        m_followers = nullptr;
        m_followingSprite = nullptr;
        m_hasFollower = false;
        m_propagateScaleChanges = false;
        m_propagateFlipChanges = false;
    }
    ~CCSpritePlus() = win 0x47d50;

    /// Creates a sprite by a given sprite frame
    /// @param frame the frame to give to the specific sprite
    /// @return CCSpritePlus object and returns null if initialization fails
    static CCSpritePlus* createWithSpriteFrame(cocos2d::CCSpriteFrame* frame) = win inline {
        auto ret = new CCSpritePlus();
        if (ret->initWithSpriteFrame(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    /// Creates a sprite by a given sprite's frame name
    /// @param frame the frame or filename to give to the specific sprite
    /// @return CCSpritePlus object and returns null if initialization fails
    static CCSpritePlus* createWithSpriteFrameName(char const* frame) = win 0x47da0;

    /// Sets X's scale on itself and it's followers
    /// @param scaleX the scale of X to set
    virtual void setScaleX(float scaleX) = win 0x48260;

    /// Sets Y's scale on itself and it's followers
    /// @param scaleY the scale of Y to set
    virtual void setScaleY(float scaleY);

    /// Sets the Scale of itself and it's followers
    /// @param scale the scale value to set
    virtual void setScale(float scale);

    /// Sets the position where the sprite will be at and it's followers
    /// @param position the position to place to the sprite and it's followers
    virtual void setPosition(cocos2d::CCPoint const& position) = win 0x47e60;

    /// Sets the sprite's given rotation and it's followers
    /// @param rotation the rotation value to set
    virtual void setRotation(float rotation);

    /// Sets the sprite's given rotation of X and it's followers
    /// @param rotationX the rotation of X to set.
    virtual void setRotationX(float rotationX);

    /// Sets the sprite's given rotation of Y and it's followers
    /// @param rotationY the rotation of Y to set
    virtual void setRotationY(float rotationY);

    /// Initalizes the sprite using a texture
    /// @param texture the texture to initalize the sprite with
    /// @return true if initalization succeeded.
    virtual bool initWithTexture(cocos2d::CCTexture2D* texture) = win 0x47e40;

    /// Initalizes the sprite with a frame name
    /// @param frameName the frame to initalize the sprite with
    /// @return true if initalization succeeded
    virtual bool initWithSpriteFrameName(char const* frameName);

    /// Sets flipX to itself and it's followers
    /// @param flipX the direction that the sprite should be flipped to
    virtual void setFlipX(bool flipX);

    /// Sets flipY to itself and it's followers
    /// @param flipY the direction that the sprite should be flipped to
    virtual void setFlipY(bool flipY);

    /// Adds a follower to the sprite
    /// @param follower Something that will follow this sprite
    void addFollower(cocos2d::CCNode* follower) = win inline {
        m_hasFollower = true;
        if (!m_followers) {
            m_followers = cocos2d::CCArray::create();
            m_followers->retain();
        }
        m_followers->addObject(follower);
    }

    /// Attaches a sprite to the sprite. and other way around
    /// you can think of this as attaching 2 lego blocks together and letting
    /// it drag along.
    /// @param sprite the sprite to attach to the main sprite and vice versa
    void followSprite(CCSpritePlus* sprite) = win inline {
        m_followingSprite = sprite;
        sprite->addFollower(this);
    }

    /// Obtains the first following sprite if it has a follower on hand
    /// @return nullptr if there is no follower avalible
    CCSpritePlus* getFollower() = win inline {
        return m_hasFollower ? static_cast<CCSpritePlus*>(m_followers->objectAtIndex(0)) : nullptr;
    }

    /// Removes a specific following sprite from this sprite.
    /// @param sprite follower sprite that will be removed.
    void removeFollower(cocos2d::CCNode* sprite) = win 0x48400;

    /// Stops this child sprite from following it's given parent
    void stopFollow() = win inline {
        if (m_followingSprite) m_followingSprite->removeFollower(this);
    }

    cocos2d::CCArray* m_followers;
    CCSpritePlus* m_followingSprite;
    bool m_hasFollower;
    bool m_propagateScaleChanges;
    bool m_propagateFlipChanges;
}

[[link(android)]]
class CCSpriteWithHue : cocos2d::CCSprite {
    // virtual ~CCSpriteWithHue();
    CCSpriteWithHue() {}

    static CCSpriteWithHue* create(gd::string const& file) = win inline, ios inline {
        auto ret = new CCSpriteWithHue();
        if (ret->initWithFile(file.c_str())) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static CCSpriteWithHue* create(gd::string const& file, cocos2d::CCRect const& rect) = win inline, ios inline {
        auto ret = new CCSpriteWithHue();
        if (ret->initWithFile(file.c_str(), rect)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static CCSpriteWithHue* createWithSpriteFrame(cocos2d::CCSpriteFrame* frame) = win inline {
        auto ret = new CCSpriteWithHue();
        if (ret->initWithSpriteFrame(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static CCSpriteWithHue* createWithSpriteFrameName(gd::string const& frameName) = win inline {
        return CCSpriteWithHue::createWithSpriteFrame(cocos2d::CCSpriteFrameCache::sharedSpriteFrameCache()->spriteFrameByName(frameName.c_str()));
    }
    static CCSpriteWithHue* createWithTexture(cocos2d::CCTexture2D* texture) = win inline, ios inline {
        auto ret = new CCSpriteWithHue();
        if (ret->initWithTexture(texture)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static CCSpriteWithHue* createWithTexture(cocos2d::CCTexture2D* texture, cocos2d::CCRect const& rect, bool rotated) = win inline, ios inline {
        auto ret = new CCSpriteWithHue();
        if (ret->initWithTexture(texture, rect, rotated)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void draw() = win 0x48cb0;
    virtual bool initWithTexture(cocos2d::CCTexture2D* texture) = win 0x48680;
    virtual bool initWithTexture(cocos2d::CCTexture2D* texture, cocos2d::CCRect const& rect) = win 0x486e0;
    virtual bool initWithTexture(cocos2d::CCTexture2D* texture, cocos2d::CCRect const& rect, bool rotated) = win 0x48620;
    virtual bool initWithSpriteFrame(cocos2d::CCSpriteFrame* frame) = win 0x486f0;
    virtual gd::string getShaderName() = win 0x48490;
    virtual const char* shaderBody();
    virtual void updateColor() = win 0x489a0;

    float getAlpha() = win inline, ios inline {
        return _displayedOpacity / 255.f;
    }
    float getHue() = win inline, ios inline {
        return m_hue;
    }
    void getUniformLocations() = win inline {
        m_uHueLoc = glGetUniformLocation(m_pShaderProgram->getProgram(), "u_hue");
        m_uAlphaLoc = glGetUniformLocation(m_pShaderProgram->getProgram(), "u_alpha");
        m_uLumLoc = glGetUniformLocation(m_pShaderProgram->getProgram(), "u_lum");
    }
    void initShader() = win 0x48760;
    void setCustomLuminance(float r, float g, float b) = win inline, ios inline {
        m_luminance[0] = r;
        m_luminance[1] = g;
        m_luminance[2] = b;
    }
    void setEvenLuminance(float luminance) = win inline {
        m_luminance[0] = luminance * 0.33f;
        m_luminance[1] = luminance * 0.33f;
        m_luminance[2] = luminance * 0.33f;
    }
    void setHue(float hue) = win inline, ios inline {
        m_hue = hue;
        this->updateColorMatrix();
    }
    void setHueDegrees(float degrees) = win inline {
        auto deg = degrees;
        while (deg < 0.f) deg += 360.f;
        this->setHue(deg / 360.f * 6.28318548f);
    }
    void setLuminance(float luminance) = win inline {
        m_luminance[0] = luminance * 0.21f;
        m_luminance[1] = luminance * 0.72f;
        m_luminance[2] = luminance * 0.07f;
    }
    void setupDefaultSettings() = win inline, ios inline {
        m_hue = 0.f;
        this->setLuminance(1.f);
    }
    void updateColorMatrix() = win 0x489c0;
    void updateHue(float unused) = win inline, ios inline {
        this->setHue(m_hue + 0.05235988f);
    }

    float m_hue;
    std::array<float, 3> m_luminance;
    std::array<std::array<float, 3>, 3> m_colorMatrix;
    int m_uHueLoc;
    int m_uAlphaLoc;
    int m_uLumLoc;
}

[[link(android)]]
class CCTextInputNode : cocos2d::CCLayer, cocos2d::CCIMEDelegate, cocos2d::CCTextFieldDelegate {
    CCTextInputNode() {
        m_numberInput = false;
        m_unknown1 = 0;
        m_selected = false;
        m_unknown2 = false;
        m_fontValue1 = -0.5f;
        m_fontValue2 = 8.0f;
        m_isChatFont = false;
        m_maxLabelWidth = 0.0f;
        m_maxLabelScale = 0.0f;
        m_placeholderScale = 0.0f;
        m_cursor = nullptr;
        m_textField = nullptr;
        m_delegate = nullptr;
        m_maxLabelLength = 0;
        m_textLabel = nullptr;
        m_filterSwearWords = false;
        m_usePasswordChar = false;
        m_forceOffset = false;
        m_textArea = nullptr;
        m_valueType = (InputValueType)0;
        m_kerningAmount = 0;
    }
    ~CCTextInputNode() = win inline {
        if (m_selected) CCTextInputNode::onClickTrackNode(false);
    }

    static CCTextInputNode* create(float width, float height, char const* placeholder, char const* fontPath) {
        return CCTextInputNode::create(width, height, placeholder, 0x18, fontPath);
    }
    static CCTextInputNode* create(float width, float height, char const* placeholder, int fontSize, char const* fontPath) {
        return CCTextInputNode::create(width, height, placeholder, "Thonburi", fontSize, fontPath);
    }
    static CCTextInputNode* create(float width, float height, char const* placeholder, char const* textFont, int fontSize, char const* labelFont) = win 0x4f180;

    virtual void visit() = win 0x4f7c0;
    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x51350, ios 0x1234567, imac 0x1234567, m1 0x1234567;
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline {}
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline {}
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline {}
    virtual void registerWithTouchDispatcher() = win 0x51560;
    virtual void textChanged() = win 0x504a0;
    virtual void onClickTrackNode(bool selected) = win 0x50480;
    virtual void keyboardWillShow(cocos2d::CCIMEKeyboardNotificationInfo& info) = win 0x502a0;
    virtual void keyboardWillHide(cocos2d::CCIMEKeyboardNotificationInfo& info) = win 0x50400;
    virtual bool onTextFieldInsertText(cocos2d::CCTextFieldTTF* pSender, char const* text, int nLen, cocos2d::enumKeyCodes keyCodes) = win 0x50530;
    virtual bool onTextFieldAttachWithIME(cocos2d::CCTextFieldTTF* tField) = win 0x50910;
    virtual bool onTextFieldDetachWithIME(cocos2d::CCTextFieldTTF* tField) = win 0x50c40;

    void addTextArea(TextArea* textArea) = win 0x4f5d0;
    void forceOffset() = win inline {}
    gd::string getString() = win inline {
        return m_textField->getString();
    }
    cocos2d::CCLabelBMFont* getTextLabel() {
        return m_textLabel;
    }
    bool init(float width, float height, char const* placeholder, char const* textFont, int fontSize, char const* labelFont) = win 0x4f390;
    void refreshLabel() = win 0x4fbd0;
    void setAllowedChars(gd::string filter) = win inline {
        m_allowedChars = filter;
    }
    void setDelegate(TextInputDelegate* delegate) {
        m_delegate = delegate;
    }
    void setLabelNormalColor(cocos2d::ccColor3B color) = win inline, ios inline {
        m_textColor = color;
        this->refreshLabel();
    }
    void setLabelPlaceholderColor(cocos2d::ccColor3B color) = win inline {
        m_placeholderColor = color;
        this->refreshLabel();
    }
    void setLabelPlaceholderScale(float v) = win inline {
        m_placeholderScale = v;
        this->refreshLabel();
    }
    void setMaxLabelLength(int v) {
        m_maxLabelLength = v;
        this->refreshLabel();
    }
    void setMaxLabelScale(float v) = win inline {
        m_maxLabelScale = v;
        this->refreshLabel();
    }
    void setMaxLabelWidth(float v) = win inline {
        m_maxLabelWidth = v;
        this->refreshLabel();
    }
    void setString(gd::string text) = win 0x4f830;
    void updateBlinkLabel() = win inline, ios inline {
        this->updateBlinkLabelToChar(this->m_textField->m_uCursorPos);
    }
    void updateBlinkLabelToChar(int index) = win 0x4feb0;
    void updateCursorPosition(cocos2d::CCPoint position, cocos2d::CCRect rect) = win 0x50df0;
    void updateDefaultFontValues(gd::string font) = win 0x4f6c0;
    void updateLabel(gd::string text) = win 0x4f8d0;

    bool m_numberInput;
    gd::string m_caption;
    int m_unknown1;
    bool m_selected;
    bool m_unknown2;
    float m_fontValue1;
    float m_fontValue2;
    bool m_isChatFont;
    gd::string m_allowedChars;
    float m_maxLabelWidth;
    float m_maxLabelScale;
    float m_placeholderScale;
    cocos2d::ccColor3B m_placeholderColor;
    cocos2d::ccColor3B m_textColor;
    cocos2d::CCLabelBMFont* m_cursor;
    cocos2d::CCTextFieldTTF* m_textField;
    TextInputDelegate* m_delegate;
    int m_maxLabelLength;
    cocos2d::CCLabelBMFont* m_textLabel;
    bool m_filterSwearWords;
    bool m_usePasswordChar;
    bool m_forceOffset;
    TextArea* m_textArea;
    InputValueType m_valueType;
    int m_decimalPlaces;
    int m_kerningAmount;
}

[[link(android)]]
class CCURLObject : cocos2d::CCObject {
    // virtual ~CCURLObject();

    static CCURLObject* create(gd::string name, gd::string url) = win 0x17b300;

    bool init(gd::string name, gd::string url) = win inline, ios inline {
        m_name = name;
        m_url = url;
        return true;
    }

    gd::string m_name;
    gd::string m_url;
}

[[link(android), depends(ChallengesPage), depends(GJChallengeItem)]]
class ChallengeNode : cocos2d::CCNode {
    ChallengeNode() {
        m_challengeItem = nullptr;
        m_countdownLabel = nullptr;
        m_unloaded = false;
    }
    ~ChallengeNode() = win inline {
        CC_SAFE_RELEASE(m_challengeItem);
    }

    static ChallengeNode* create(GJChallengeItem* challengeItem, ChallengesPage* challengesPage, bool isNew) = win inline {
        auto ret = new ChallengeNode();
        if (ret->init(challengeItem, challengesPage, isNew)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init(GJChallengeItem* challengeItem, ChallengesPage* challengesPage, bool isNew) = win 0x86d50;
    void onClaimReward(cocos2d::CCObject* sender) = win 0x87da0;
    void updateTimeLabel(gd::string text) = win inline, ios inline {
        if (m_countdownLabel) m_countdownLabel->setString(text.c_str());
    }

    ChallengesPage* m_challengesPage;
    GJChallengeItem* m_challengeItem;
    cocos2d::CCPoint m_unkPoint;
    cocos2d::CCLabelBMFont* m_countdownLabel;
    bool m_unloaded;
}

[[link(android)]]
class ChallengesPage : FLAlertLayer, FLAlertLayerProtocol, GJChallengeDelegate, CurrencyRewardDelegate {
    ChallengesPage() {
        m_dots = nullptr;
        m_countdownLabel = nullptr;
        m_circle = nullptr;
        m_triedToLoad = false;
        m_unkBool = false;
        m_currencyRewardLayer = nullptr;
        m_challengeNodes = nullptr;
    }
    ~ChallengesPage() = win inline {
        auto glm = GameLevelManager::sharedState();
        if (glm->m_GJChallengeDelegate == this) glm->m_GJChallengeDelegate = nullptr;
        if (m_currencyRewardLayer) m_currencyRewardLayer->m_delegate = nullptr;
        CC_SAFE_RELEASE(m_challengeNodes);
        CC_SAFE_RELEASE(m_dots);
    }

    static ChallengesPage* create() = win inline {
        auto ret = new ChallengesPage();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x85370;
    virtual void registerWithTouchDispatcher() = win 0x42660;
    virtual void keyBackClicked() = win 0x869f0;
    virtual void show();
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win inline {}
    virtual void challengeStatusFinished() = win 0x85e20;
    virtual void challengeStatusFailed() = win 0x85fb0;
    virtual void currencyWillExit(CurrencyRewardLayer* layer) = win 0x86d30;

    void claimItem(ChallengeNode* node, GJChallengeItem* item, cocos2d::CCPoint position) = win 0x86a40;
    ChallengeNode* createChallengeNode(int number, bool skipAnimation, float animLength, bool isNew) = win 0x86100;
    void exitNodeAtSlot(int position, float delay) = win 0x86430;
    void onClose(cocos2d::CCObject* sender) = win 0x869b0;
    void tryGetChallenges() = win 0x86080;
    void updateDots() = win 0x85d80;
    callback void updateTimers(float dt) = win 0x86520;

    cocos2d::CCArray* m_dots;
    cocos2d::CCLabelBMFont* m_countdownLabel;
    LoadingCircle* m_circle;
    bool m_triedToLoad;
    bool m_unkBool;
    CurrencyRewardLayer* m_currencyRewardLayer;
    cocos2d::CCDictionary* m_challengeNodes;
}

[[link(android), depends(ChanceObject)]]
class ChanceTriggerGameObject : EffectGameObject {
    // virtual ~ChanceTriggerGameObject();
    ChanceTriggerGameObject() {}

    void editChanceObject(int oldID, int newID) = win inline {
        for (auto& obj : m_chanceObjects) {
            if (obj.m_groupID == oldID) obj.m_groupID = newID;
        }
    }
    bool init(char const* frame) = win inline, ios inline {
        return EffectGameObject::init(frame);
    }
    void remapChanceObjects(gd::unordered_map<int, int> const* remap) = win 0x4b3d60;
    void revertChanceRemap() = win inline {
        for (auto& obj : m_chanceObjects) {
            obj.m_groupID = obj.m_oldGroupID;
        }
    }

    // property 435
    gd::vector<ChanceObject> m_chanceObjects;
}

[[link(android)]]
class CharacterColorDelegate {
    virtual void playerColorChanged() {}
    virtual void showUnlockPopup(int id, UnlockType type) {}
}

[[link(android)]]
class CharacterColorPage : FLAlertLayer {
    CharacterColorPage() {
        m_colorMode = 0;
        m_playerObjects = nullptr;
        m_modeButtons = nullptr;
        m_colorButtons = nullptr;
        m_cursors = nullptr;
        m_delegate = nullptr;
        m_glowToggler = nullptr;
        m_glowLabel = nullptr;
    }
    ~CharacterColorPage() = win inline {
        CC_SAFE_RELEASE(m_playerObjects);
        CC_SAFE_RELEASE(m_modeButtons);
        CC_SAFE_RELEASE(m_colorButtons);
        CC_SAFE_RELEASE(m_cursors);
    }

    static CharacterColorPage* create() = win inline {
        auto ret = new CharacterColorPage();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x87fa0;
    virtual void registerWithTouchDispatcher() = win 0x42660;
    virtual void keyBackClicked() = win 0x8a810;
    virtual void show();

    int activeColorForMode(int mode) = win 0x894b0;
    bool checkColor(int id, UnlockType type) = win inline {
        auto result = GameManager::sharedState()->isColorUnlocked(id, type);
        if (!result && m_delegate) {
            m_delegate->showUnlockPopup(id, type);
        }
        return result;
    }
    int colorForIndex(int index) = win 0x8a0c0;
    void createColorMenu() = win 0x88ec0;
    void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win inline, ios inline {}
    cocos2d::CCPoint offsetForIndex(int index) = win inline {
        float x;
        float y;
        if (index > 53 && index < 136) y = -.8f;
        else if (index > 135) y = .4f;
        else y = 0.f;
        switch (index) {
            case 4: case 5: case 6: case 7: case 13: case 14: case 15: case 16: case 22: case 23:
            case 24: case 25: case 31: case 32: case 33: case 34: case 40: case 41: case 42: case 43:
            case 49: case 50: case 51: case 52: case 58: case 59: case 60: case 61: case 67: case 68:
            case 69: case 70: case 76: case 77: case 78: case 79: case 85: case 86: case 87: case 88:
            case 94: case 95: case 96: case 97: case 103: case 104: case 105: case 106: case 112: case 113:
            case 114: case 115: case 136: case 137: case 138: case 139: case 140: case 141: case 142:
                x = 1.f;
                break;
            default:
                x = 0.f;
                break;
        }
        return { x, y };
    }
    void onClose(cocos2d::CCObject* sender) = win 0x8a7d0;
    void onMode(cocos2d::CCObject* sender) = win 0x895c0;
    void onPlayerColor(cocos2d::CCObject* sender) = win 0x89dd0;
    void toggleGlow(cocos2d::CCObject* sender);
    void toggleGlowItems(bool visible) = win inline, ios inline {
        m_glowToggler->setEnabled(visible);
        m_glowToggler->setVisible(visible);
        m_glowLabel->setVisible(visible);
    }
    void toggleShip(cocos2d::CCObject* sender) = win 0x88cf0;
    void updateColorMode(int mode) = win 0x89860;
    void updateIconColors() = win 0x8a5b0;

    int m_colorMode;
    float m_height;
    float m_width;
    cocos2d::CCArray* m_playerObjects;
    cocos2d::CCArray* m_modeButtons;
    cocos2d::CCDictionary* m_colorButtons;
    cocos2d::CCArray* m_cursors;
    CharacterColorDelegate* m_delegate;
    CCMenuItemToggler* m_glowToggler;
    cocos2d::CCLabelBMFont* m_glowLabel;
}

[[link(android)]]
class CheckpointGameObject : EffectGameObject {
    // virtual ~CheckpointGameObject();
    CheckpointGameObject() {
        m_checkpointActivated = false;
        m_respawnID = 0;
    }

    static CheckpointGameObject* create() = win inline {
        auto ret = new CheckpointGameObject();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x4b9a20;
    virtual void setupCustomSprites(gd::string frameName) = win 0x4b9e60;
    virtual void resetObject();
    virtual void triggerObject(GJBaseGameLayer* layer, int uniqueID, gd::vector<int> const* remapKeys) = win 0x4b9aa0;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4bab20;
    virtual gd::string getSaveString(GJBaseGameLayer* layer);
    virtual void triggerActivated(float xPosition) = win 0x4b9ac0;
    virtual void restoreObject() = win 0x4bae60;
    virtual void updateSyncedAnimation(float totalTime, int frameIndex) = win 0x4ba500;

    void resetCheckpoint() = win 0x4bacd0, ios inline {
        m_checkpointActivated = false;
        this->updateCheckpointSpriteVisibility();
    }
    void updateCheckpointSpriteVisibility() = win inline {
        this->getChildByTag(1125)->setVisible(!m_checkpointActivated);
        this->getChildByTag(1126)->setVisible(!m_checkpointActivated);
        this->getChildByTag(1127)->setVisible(!m_checkpointActivated);
        this->getChildByTag(1128)->setVisible(m_checkpointActivated);
        m_colorSprite->getChildByTag(1125)->setVisible(!m_checkpointActivated);
        m_colorSprite->getChildByTag(1126)->setVisible(!m_checkpointActivated);
        m_colorSprite->getChildByTag(1127)->setVisible(!m_checkpointActivated);
        m_colorSprite->getChildByTag(1128)->setVisible(m_checkpointActivated);
        if (m_checkpointActivated) this->setObjectColor({ 255, 255, 255 });
        m_isColorSpriteBlack = m_checkpointActivated;
    }

    bool m_checkpointActivated;
    // property 448
    int m_respawnID;
}

[[link(android), depends(GJGameState), depends(GJShaderState), depends(FMODAudioState), depends(EffectManagerState), depends(SavedObjectStateRef), depends(SavedActiveObjectState), depends(SavedSpecialObjectState), depends(SequenceTriggerState)]]
class CheckpointObject : cocos2d::CCNode {
    CheckpointObject() = win 0x3a4e70;
    ~CheckpointObject() = win inline {
        CC_SAFE_RELEASE(m_physicalCheckpointObject);
        CC_SAFE_RELEASE(m_player1Checkpoint);
        CC_SAFE_RELEASE(m_player2Checkpoint);
        CC_SAFE_RELEASE(m_gradientTriggerObjectArray);
    }

    static CheckpointObject* create() = win inline {
        auto ret = new CheckpointObject();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init();

    GameObject* getObject() = win inline {
        return m_physicalCheckpointObject;
    }
    void setObject(GameObject* object) = win inline {
        if (m_physicalCheckpointObject != object) {
            CC_SAFE_RETAIN(object);
            CC_SAFE_RELEASE(m_physicalCheckpointObject);
            m_physicalCheckpointObject = object;
        }
    }

    GJGameState m_gameState;
    GJShaderState m_shaderState;
    FMODAudioState m_audioState;
    GameObject* m_physicalCheckpointObject;
    PlayerCheckpoint* m_player1Checkpoint;
    PlayerCheckpoint* m_player2Checkpoint;
    int m_unke78;
    int m_unke7c;
    float m_unke80;
    bool m_ground2Invisible;
    bool m_streakBlend;
    int m_uniqueID;
    int m_respawnID;
    gd::vector<SavedObjectStateRef> m_vectorSavedObjectStateRef;
    gd::vector<SavedActiveObjectState> m_vectorActiveSaveObjectState;
    gd::vector<SavedSpecialObjectState> m_vectorSpecialSaveObjectState;
    EffectManagerState m_effectManagerState;
    cocos2d::CCArray* m_gradientTriggerObjectArray;
    bool m_unk11e8;
    gd::unordered_map<int,SequenceTriggerState> m_sequenceTriggerStateUnorderedMap;
    int m_commandIndex;
}

[[link(android)]]
class CollisionBlockPopup : FLAlertLayer, TextInputDelegate {
    // virtual ~CollisionBlockPopup();

    static CollisionBlockPopup* create(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x8a940;

    virtual void keyBackClicked();
    virtual void show() = win 0x8bb10;
    virtual void textInputClosed(CCTextInputNode* node);
    virtual void textChanged(CCTextInputNode* node) = win 0x8b880;
    virtual void textInputShouldOffset(CCTextInputNode* node, float yOffset) = win 0x7b620;
    virtual void textInputReturn(CCTextInputNode* node) = win 0x7b680;

    CCMenuItemToggler* createToggleButton(gd::string label, cocos2d::SEL_MenuHandler selector, bool toggled, cocos2d::CCMenu* menu, cocos2d::CCPoint position) = win inline, ios inline {
        auto onSprite = cocos2d::CCSprite::createWithSpriteFrameName("GJ_checkOn_001.png");
        auto offSprite = cocos2d::CCSprite::createWithSpriteFrameName("GJ_checkOff_001.png");
        onSprite->setScale(.8f);
        offSprite->setScale(.8f);
        auto toggler = CCMenuItemToggler::create(offSprite, onSprite, this, selector);
        toggler->toggle(toggled);
        menu->addChild(toggler);
        toggler->setPosition(menu->convertToNodeSpace(position));
        toggler->setSizeMult(1.5f);
        auto labelNode = cocos2d::CCLabelBMFont::create(label.c_str(), "bigFont.fnt");
        this->addChild(labelNode);
        labelNode->setAnchorPoint({ .0f, .5f });
        labelNode->setPosition(position + cocos2d::CCPoint { onSprite->getContentSize().width * .5f + 4.8f, 0.f });
        labelNode->limitLabelWidth(110.f, .35f, .0f);
        return toggler;
    }
    void determineStartValues() = win inline {
        if (m_gameObject) {
            m_blockID = m_gameObject->m_itemID;
            m_dynamicBlock = m_gameObject->m_isDynamicBlock;
        }
        else if (m_gameObjects && m_gameObjects->count() != 0) {
            m_blockID = -1;
            m_dynamicBlock = true;
            for (int i = 0; i < m_gameObjects->count(); i++) {
                auto obj = static_cast<EffectGameObject*>(m_gameObjects->objectAtIndex(i));
                if (!obj->m_isDynamicBlock) m_dynamicBlock = false;
                if (m_blockID == -1) m_blockID = obj->m_itemID;
                else if (m_blockID != obj->m_itemID) m_blockID = 0;
            }
        }
    }
    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x8aa60;
    void onClose(cocos2d::CCObject* sender) = win 0x8bb60;
    void onDynamicBlock(cocos2d::CCObject* sender);
    void onItemIDArrow(cocos2d::CCObject* sender);
    void onNextItemID(cocos2d::CCObject* sender);
    void updateEditorLabel();
    void updateItemID();
    void updateTextInputLabel();

    EffectGameObject* m_gameObject;
    cocos2d::CCArray* m_gameObjects;
    CCTextInputNode* m_blockIDInput;
    int m_blockID;
    bool m_dynamicBlock;
    bool m_disableDelegate;
}

[[link(android)]]
class CollisionTriggerAction {
    bool m_disabled;
    int m_blockAID;
    int m_blockBID;
    int m_targetGroupID;
    int m_triggerOnExit;
    bool m_activateGroup;
    int m_triggerUniqueID;
    int m_controlID;
    gd::vector<int> m_remapKeys;
}

[[link(android)]]
class ColorAction : cocos2d::CCObject {
    // virtual ~ColorAction();
    ColorAction() {
        m_stepFinished = false;
        m_paused = false;
        m_currentOpacity = 1.f;
        m_deltaTime = 0.f;
        m_duration = 0.f;
        m_blending = false;
        m_playerColor = 0;
        m_colorID = 0;
        m_fromOpacity = 1.f;
        m_toOpacity = 1.f;
        m_copyHSV = { 0.f, 1.f, 1.f, false, false };
        m_copyID = 0;
        m_copyColorCalculated = false;
        m_copyOpacity = false;
        m_copyColorLoop = false;
        m_uniqueID = 0;
        m_controlID = 0;
        m_legacyHSV = false;
        m_colorSprite = nullptr;
        m_inheritanceNode = nullptr;
        m_actionDelay = 0.f;
        m_stepInterval = 0.f;
    }

    static ColorAction* create() = win 0x258cb0;
    static ColorAction* create(cocos2d::ccColor3B color, bool blending, int playerColor) = win inline, ios inline {
        return ColorAction::create(color, color, 0.f, 0.0, blending, playerColor, 1.f, 1.f);
    }
    static ColorAction* create(cocos2d::ccColor3B fromColor, cocos2d::ccColor3B toColor, float duration, double unused, bool blending) = win inline, ios inline {
        return ColorAction::create(fromColor, toColor, duration, unused, blending, -1, 1.f, 1.f);
    }
    static ColorAction* create(cocos2d::ccColor3B fromColor, cocos2d::ccColor3B toColor, float duration, double unused, bool blending, int playerColor, float fromOpacity, float toOpacity) = win inline {
        auto ret = new ColorAction();
        if (ret->init(fromColor, toColor, duration, unused, blending, playerColor, fromOpacity, toOpacity)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    ColorAction* getCopy() = win inline, ios inline {
        return ColorAction::create(m_fromColor, m_toColor, m_duration, 0.0, m_blending, m_playerColor, m_fromOpacity, m_toOpacity);
    }
    bool init(cocos2d::ccColor3B fromColor, cocos2d::ccColor3B toColor, float duration, double unused, bool blending, int playerColor, float fromOpacity, float toOpacity) = win inline, ios inline {
        m_fromColor = fromColor;
        m_toColor = toColor;
        m_duration = duration;
        m_blending = blending;
        m_playerColor = playerColor;
        m_colorID = 0;
        m_fromOpacity = fromOpacity;
        m_toOpacity = toOpacity;
        return true;
    }
    bool isInUse() = win inline {
        return m_fromColor.r != 255 || m_fromColor.g != 255 || m_fromColor.b != 255 || m_fromOpacity != 1.f || m_copyID != 0 || m_blending || m_playerColor > 0;
    }
    void loadFromState(CAState& state) = win inline {
        m_fromColor = state.m_fromColor;
        m_toColor = state.m_toColor;
        m_color = state.m_color;
        m_paused = state.m_paused;
        m_blending = state.m_blending;
        m_copyOpacity = state.m_copyOpacity;
        m_legacyHSV = state.m_legacyHSV;
        m_playerColor = state.m_playerColor;
        m_colorID = state.m_colorID;
        m_copyID = state.m_copyID;
        m_uniqueID = state.m_uniqueID;
        m_duration = state.m_duration;
        m_fromOpacity = state.m_fromOpacity;
        m_toOpacity = state.m_toOpacity;
        m_deltaTime = state.m_deltaTime;
        m_currentOpacity = state.m_currentOpacity;
        m_copyHSV = state.m_copyHSV;
    }
    void resetAction() = win inline {
        m_stepFinished = false;
        m_paused = false;
        m_deltaTime = 0.f;
    }
    void saveToState(CAState& state) = win inline {
        state.m_fromColor = m_fromColor;
        state.m_toColor = m_toColor;
        state.m_color = m_color;
        state.m_paused = m_paused;
        state.m_blending = m_blending;
        state.m_copyOpacity = m_copyOpacity;
        state.m_legacyHSV = m_legacyHSV;
        state.m_playerColor = m_playerColor;
        state.m_colorID = m_colorID;
        state.m_copyID = m_copyID;
        state.m_uniqueID = m_uniqueID;
        state.m_duration = m_duration;
        state.m_fromOpacity = m_fromOpacity;
        state.m_toOpacity = m_toOpacity;
        state.m_deltaTime = m_deltaTime;
        state.m_currentOpacity = m_currentOpacity;
        state.m_copyHSV = m_copyHSV;
    }
    void setupFromMap(gd::map<gd::string, gd::string>& setup) = win 0x259970;
    void setupFromString(gd::string setup) = win 0x259890;
    void step(float dt) = win 0x258da0;
    void updateCustomColor(cocos2d::ccColor3B color1, cocos2d::ccColor3B color2) = win inline, ios inline {
        if (m_playerColor == 1) m_fromColor = color1;
        else if (m_playerColor == 2) m_fromColor = color2;
    }

    // void writeSaveString(fmt::BasicWriter<char>& writer) = win 0x251dd0, m1 0x269514, imac 0x2c5730, ios 0x111e0;
    bool m_stepFinished;
    bool m_paused;
    cocos2d::ccColor3B m_color;
    float m_currentOpacity;
    float m_deltaTime;
    cocos2d::ccColor3B m_fromColor;
    cocos2d::ccColor3B m_toColor;
    float m_duration;
    bool m_blending;
    int m_playerColor;
    int m_colorID;
    float m_fromOpacity;
    float m_toOpacity;
    cocos2d::ccHSVValue m_copyHSV;
    int m_copyID;
    bool m_copyColorCalculated;
    bool m_copyOpacity;
    bool m_copyColorLoop;
    int m_uniqueID;
    int m_controlID;
    bool m_legacyHSV;
    ColorActionSprite* m_colorSprite;
    InheritanceNode* m_inheritanceNode;
    float m_actionDelay;
    float m_stepInterval;
}

[[link(android)]]
class ColorAction2 {
    ColorAction2(cocos2d::ccColor3B fromColor, cocos2d::ccColor3B toColor, float duration, double unused, bool blending, int playerColor, float fromOpacity, float toOpacity);

    void resetAction();
    void step(float dt);
    void updateCustomColor(cocos2d::ccColor3B color1, cocos2d::ccColor3B color2);

    bool m_stepFinished;
    bool m_paused;
    cocos2d::ccColor3B m_color;
    float m_currentOpacity;
    float m_deltaTime;
    cocos2d::ccColor3B m_fromColor;
    cocos2d::ccColor3B m_toColor;
    float m_duration;
    bool m_blending;
    int m_playerColor;
    int m_colorID;
    float m_fromOpacity;
    float m_toOpacity;
    cocos2d::ccHSVValue m_copyHSV;
    int m_copyID;
    bool m_copyColorCalculated;
    bool m_copyOpacity;
    bool m_copyColorLoop;
    int m_uniqueID;
    bool m_legacyHSV;
    ColorActionSprite* m_colorSprite;
    float m_actionDelay;
    float m_stepInterval;
}

[[link(android)]]
class ColorActionSprite : cocos2d::CCNode {
    // virtual ~ColorActionSprite();
    ColorActionSprite() {
        m_opacity = 255.f;
        m_colorID = 0;
        m_colorAction = nullptr;
    }

    static ColorActionSprite* create() = win inline {
        auto ret = new ColorActionSprite();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x258c40;

    float m_opacity;
    cocos2d::ccColor3B m_color;
    cocos2d::ccColor3B m_copyColor;
    int m_colorID;
    cocos2d::ccColor3B m_pulseColor;
    ColorAction* m_colorAction;
}

[[link(android)]]
class ColorChannelSprite : cocos2d::CCSprite {
    // virtual ~ColorChannelSprite();

    static ColorChannelSprite* create() = win 0x258740;

    virtual bool init() = win 0x258800;

    void updateBlending(bool enabled) = win 0x258b30;
    void updateCopyLabel(int channelID, bool copyColorLoop) = win 0x258820;
    void updateOpacity(float alpha) = win 0x2589e0;
    void updateValues(ColorAction* action) = win inline {
        if (!action) {
            this->setColor(cocos2d::ccWHITE);
            this->updateCopyLabel(0, false);
            this->updateOpacity(1.f);
            this->updateBlending(false);
            return;
        }
        this->updateCopyLabel(action->m_copyID, action->m_copyColorLoop);
        this->updateOpacity(action->m_fromOpacity);
        this->updateBlending(action->m_blending);
        if (action->m_copyID != 0 && !action->m_copyOpacity) {
            this->setColor(cocos2d::ccGRAY);
        }
        else {
            this->setColor(action->m_fromColor);
        }
    }

    cocos2d::CCLabelBMFont* m_copyLabel;
    cocos2d::CCLabelBMFont* m_opacityLabel;
    cocos2d::CCLabelBMFont* m_blendingLabel;
}

[[link(android)]]
class ColorSelectDelegate {
    virtual void colorSelectClosed(cocos2d::CCNode* popup) {}
}

[[link(android)]]
class ColorSelectLiveOverlay : FLAlertLayer {
    // virtual ~ColorSelectLiveOverlay();

    static ColorSelectLiveOverlay* create(ColorAction* baseAction, ColorAction* detailAction, EffectGameObject* object) = win 0x8bd30;
    static ColorSelectLiveOverlay* createWithActions(ColorAction* baseAction, ColorAction* detailAction) = win inline {
        return ColorSelectLiveOverlay::create(baseAction, detailAction, nullptr);
    }
    static ColorSelectLiveOverlay* createWithObject(EffectGameObject* object) = win inline {
        return ColorSelectLiveOverlay::create(nullptr, nullptr, object);
    }

    virtual void keyBackClicked();
    virtual void show() = win 0x8bb10;

    void closeColorSelect(cocos2d::CCObject* sender);
    void colorValueChanged(cocos2d::ccColor3B color) = win inline, ios inline {}
    CCMenuItemToggler* createToggleButton(gd::string label, cocos2d::SEL_MenuHandler selector, bool toggled, cocos2d::CCMenu* menu, cocos2d::CCPoint position) = win inline, ios inline {
        auto onSprite = cocos2d::CCSprite::createWithSpriteFrameName("GJ_checkOn_001.png");
        auto offSprite = cocos2d::CCSprite::createWithSpriteFrameName("GJ_checkOff_001.png");
        onSprite->setScale(.7f);
        offSprite->setScale(.7f);
        auto toggler = CCMenuItemToggler::create(offSprite, onSprite, this, selector);
        toggler->toggle(toggled);
        menu->addChild(toggler);
        toggler->setPosition(menu->convertToNodeSpace(position));
        toggler->setSizeMult(1.5f);
        auto labelNode = cocos2d::CCLabelBMFont::create(label.c_str(), "bigFont.fnt");
        this->addChild(labelNode);
        labelNode->setAnchorPoint({ .0f, .5f });
        labelNode->setPosition(position + cocos2d::CCPoint { onSprite->getContentSize().width * .5f + 4.2f, 0.f });
        labelNode->limitLabelWidth(110.f, .35f, .0f);
        return toggler;
    }
    void determineStartValues() = win inline {
        if (m_effectGameObject) {
            m_targetColor = m_effectGameObject->m_triggerTargetColor;
            m_mainColor = m_targetColor;
            m_opacity = m_effectGameObject->m_opacity;
        }
        else {
            m_targetColor = m_baseColorAction->m_fromColor;
            m_mainColor = m_targetColor;
            m_opacity = m_baseColorAction->m_fromOpacity;
            if (m_detailColorAction) m_detailColor = m_detailColorAction->m_fromColor;
        }
    }
    cocos2d::ccColor3B getColorValue() = win inline, ios inline {
        return { 255, 255, 255 };
    }
    bool init(ColorAction* baseAction, ColorAction* detailAction, EffectGameObject* object) = win 0x8be80;
    void onSelectTab(cocos2d::CCObject* sender) = win 0x8d150;
    void selectColor(cocos2d::ccColor3B color) = win 0x8d2e0;
    void sliderChanged(cocos2d::CCObject* sender) = win 0x8ce10;
    void textChanged(CCTextInputNode* node) = win inline, ios inline {}
    void textInputClosed(CCTextInputNode* node) = win inline, ios inline {}
    void toggleControls(bool visible) = win 0x8d720;
    void updateColorLabel() = win 0x8d560;
    void updateColorValue() = win inline, ios inline {
        if (m_updateColor) return;
        if (m_effectGameObject) {
            m_effectGameObject->m_triggerTargetColor = m_targetColor;
        }
        else {
            if (m_detailColorSelected) m_detailColorAction->m_fromColor = m_targetColor;
            else m_baseColorAction->m_fromColor = m_targetColor;
        }
    }
    void updateOpacity() = win inline, ios inline {
        if (m_updateColor) return;
        if (m_effectGameObject) {
            m_effectGameObject->m_opacity = m_opacity;
        }
        else {
            if (m_detailColorSelected) m_detailColorAction->m_fromOpacity = m_opacity;
            else m_baseColorAction->m_fromOpacity = m_opacity;
        }
    }

    EffectGameObject* m_effectGameObject;
    cocos2d::CCArray* m_barSprites;
    cocos2d::CCArray* m_12buttons;
    ColorAction* m_baseColorAction;
    ColorAction* m_detailColorAction;
    cocos2d::ccColor3B m_mainColor;
    cocos2d::ccColor3B m_detailColor;
    cocos2d::ccColor3B m_targetColor;
    float m_unk2ac;
    int m_unk2b0;
    int m_unk2b4;
    float m_opacity;
    ColorSelectDelegate* m_delegate;
    bool m_disableTextDelegate;
    bool m_unk2c9;
    bool m_updateColor;
    Slider* m_hueSlider;
    Slider* m_saturationSlider;
    Slider* m_valueSlider;
    Slider* m_opacitySlider;
    cocos2d::CCSprite* m_colorSprite;
    cocos2d::CCSprite* m_oldColorSprite;
    cocos2d::CCSprite* m_saturationSprite;
    cocos2d::CCSprite* m_valueSprite;
    cocos2d::CCSprite* m_opacitySprite;
    double m_hue;
    double m_saturation;
    double m_value;
    cocos2d::CCLabelBMFont* m_colorLabel;
    bool m_detailColorSelected;
    bool m_closeButtonPressed;
}

[[link(android)]]
class ColorSelectPopup : SetupTriggerPopup, cocos2d::extension::ColorPickerDelegate, GJSpecialColorSelectDelegate {
    ColorSelectPopup() {
        m_colorPicker = nullptr;
        m_unk3c0 = false;
        m_opacityLabel = nullptr;
        m_fadeTimeSlider = nullptr;
        m_opacitySlider = nullptr;
        m_currentColorSprite = nullptr;
        m_originalColorSprite = nullptr;
        m_delegate = nullptr;
        m_fadeTime = 0.f;
        m_playerColor = 0;
        m_blending = 0;
        m_opacity = 1.f;
        m_colorAction = nullptr;
        m_colorInput = nullptr;
        m_backgroundTrigger = false;
        m_tintGround = false;
        m_legacyHSV = false;
        m_colorTrigger = false;
        m_noChannel = false;
        m_newColorTrigger = false;
        m_colorID = 0;
        m_initializing = false;
        m_copyColorID = 0;
        m_copyOpacity = false;
        m_hsv = { 0.f, 1.f, 1.f, false, false };
        m_fadeTimeInput = nullptr;
        m_showCopyObjects = false;
    }
    ~ColorSelectPopup() = win inline {
        CC_SAFE_RELEASE(m_colorAction);
        CC_SAFE_RELEASE(m_colorObjects);
        CC_SAFE_RELEASE(m_copyObjects);
    }

    static gd::string colorToHex(cocos2d::ccColor3B color) = win 0x927b0;
    static ColorSelectPopup* create(ColorAction* action) = win inline {
        return ColorSelectPopup::create(nullptr, nullptr, action);
    }
    static ColorSelectPopup* create(cocos2d::ccColor3B color) = win inline {
        auto action = ColorAction::create();
        action->m_color = color;
        return ColorSelectPopup::create(action);
    }
    static ColorSelectPopup* create(EffectGameObject* effect, cocos2d::CCArray* array) = win inline {
        return ColorSelectPopup::create(effect, array, nullptr);
    }
    static ColorSelectPopup* create(EffectGameObject* effect, cocos2d::CCArray* array, ColorAction* action) = win 0x8db10;
    static cocos2d::ccColor3B hexToColor(gd::string hex) = win 0x91b40;

    virtual void show();
    virtual void determineStartValues() = win 0x90470;
    virtual void textChanged(CCTextInputNode* node) = win 0x92db0;
    virtual void colorValueChanged(cocos2d::ccColor3B color) = win 0x91830;
    virtual void colorSelectClosed(GJSpecialColorSelect* select, int id) = win 0x93770;
    virtual void keyBackClicked() = win 0x91820;

    void closeColorSelect(cocos2d::CCObject* sender) = win 0x91580;
    cocos2d::ccColor3B getColorValue() = win inline, ios inline {
        return m_colorPicker->getColorValue();
    }
    bool init(EffectGameObject* object, cocos2d::CCArray* objects, ColorAction* action) = win 0x8dd00;
    void onCopy(cocos2d::CCObject* sender) = win 0x90e40;
    void onCopyOpacity(cocos2d::CCObject* sender) = win 0x90be0;
    void onDefault(cocos2d::CCObject* sender) = win 0x90f40;
    void onHSVLegacyMode(cocos2d::CCObject* sender);
    void onPaste(cocos2d::CCObject* sender) = win 0x90ec0;
    void onPlayerColor1(cocos2d::CCObject* sender);
    void onPlayerColor2(cocos2d::CCObject* sender);
    void onSelectSpecialColor(cocos2d::CCObject* sender);
    void onTintGround(cocos2d::CCObject* sender);
    void onToggleHSVMode(cocos2d::CCObject* sender) = win 0x935e0;
    void onToggleTintMode(cocos2d::CCObject* sender) = win 0x90a90;
    void onUpdateCopyColor(cocos2d::CCObject* sender) = win 0x93500;
    void onUpdateCustomColor(cocos2d::CCObject* sender) = win 0x92d30;
    void selectColor(cocos2d::ccColor3B color) = win inline, ios inline {
        m_colorPicker->setColorValue(color);
    }
    void sliderChanged(cocos2d::CCObject* sender);
    void updateColorLabels();
    void updateColorValue() = win inline {
        if (m_colorAction) {
            m_colorAction->m_fromColor = m_currentColor;
        }
        else if (m_gameObject) {
            m_gameObject->m_triggerTargetColor = m_currentColor;
        }
        else if (m_gameObjects) {
            for (int i = 0; i < m_gameObjects->count(); i++) {
                static_cast<EffectGameObject*>(m_gameObjects->objectAtIndex(i))->m_triggerTargetColor = m_currentColor;
            }
        }
    }
    void updateCopyColor() = win 0x93910;
    void updateCopyColorTextInputLabel();
    void updateCustomColorIdx() = win 0x93350;
    void updateDuration();
    void updateDurLabel();
    void updateHSVMode() = win 0x93620;
    void updateHSVValue() = win inline {
        if (m_colorAction) {
            m_colorAction->m_copyHSV = m_hsv;
        }
        else if (m_gameObject) {
            m_gameObject->m_hsvValue = m_hsv;
        }
        else if (m_gameObjects) {
            for (int i = 0; i < m_gameObjects->count(); i++) {
                static_cast<EffectGameObject*>(m_gameObjects->objectAtIndex(i))->m_hsvValue = m_hsv;
            }
        }
    }
    void updateOpacity() = win 0x91390;
    void updateOpacityLabel() = win 0x91510;
    void updateTextInputLabel();

    cocos2d::extension::CCControlColourPicker* m_colorPicker;
    bool m_unk3c0;
    cocos2d::CCLabelBMFont* m_opacityLabel;
    Slider* m_fadeTimeSlider;
    Slider* m_opacitySlider;
    CCMenuItemToggler* m_playerColor1Toggle;
    CCMenuItemToggler* m_playerColor2Toggle;
    cocos2d::ccColor3B m_originalColor;
    cocos2d::CCSprite* m_currentColorSprite;
    cocos2d::CCSprite* m_originalColorSprite;
    cocos2d::ccColor3B m_currentColor;
    ColorSelectDelegate* m_delegate;
    float m_fadeTime;
    int m_playerColor;
    int m_blending;
    float m_opacity;
    ColorAction* m_colorAction;
    CCTextInputNode* m_colorInput;
    bool m_backgroundTrigger;
    bool m_tintGround;
    bool m_legacyHSV;
    bool m_colorTrigger;
    bool m_noChannel;
    bool m_newColorTrigger;
    int m_colorID;
    bool m_initializing;
    int m_copyColorID;
    bool m_copyOpacity;
    ConfigureHSVWidget* m_hsvWidget;
    cocos2d::ccHSVValue m_hsv;
    cocos2d::CCArray* m_colorObjects;
    cocos2d::CCArray* m_copyObjects;
    CCTextInputNode* m_copyColorInput;
    CCTextInputNode* m_fadeTimeInput;
    void* m_unk488;
    void* m_unk490;
    bool m_showCopyObjects;
    CCTextInputNode* m_rInput;
    CCTextInputNode* m_gInput;
    CCTextInputNode* m_bInput;
    CCTextInputNode* m_hexInput;
}

[[link(android)]]
class ColorSetupDelegate {
    virtual void colorSetupClosed(int id) {}
}

[[link(android)]]
class CommentCell : TableViewCell, LikeItemDelegate, FLAlertLayerProtocol {
    CommentCell(char const* identifier, float width, float height) = ios inline : TableViewCell(identifier, width, height) {
        this->init();
    }
    ~CommentCell() = win inline {
        CC_SAFE_RELEASE(m_comment);
    }

    virtual bool init() = win 0xb5c00;
    virtual void draw() = win 0xade40;
    virtual void likedItem(LikeItemType type, int id, bool liked) = win 0xb7f80;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0xb81f0;

    void incrementDislikes() = win inline, ios inline {
        m_comment->m_likeCount--;
        this->updateLabelValues();
    }
    void incrementLikes() = win inline, ios inline {
        m_comment->m_likeCount++;
        this->updateLabelValues();
    }
    void loadFromComment(GJComment* comment) = win 0xb5c20;
    void onConfirmDelete(cocos2d::CCObject* sender) = win 0xb8080;
    void onDelete() = win inline {
        if (!m_comment) return;
        auto glm = GameLevelManager::sharedState();
        if (m_accountComment) glm->deleteAccountComment(m_comment->m_commentID, m_comment->m_accountID);
        else glm->deleteLevelComment(m_comment->m_commentID, m_comment->m_levelID);
        m_comment->m_commentDeleted = true;
        this->loadFromComment(m_comment);
    }
    void onGoToLevel(cocos2d::CCObject* sender) = win 0xb8350;
    void onLike(cocos2d::CCObject* sender) = win 0xb7e20;
    void onUndelete() = win inline, ios inline {
        if (!m_comment) return;
        m_comment->m_commentDeleted = false;
        this->loadFromComment(m_comment);
    }
    void onUnhide(cocos2d::CCObject* sender) = win 0xb8330;
    void onViewProfile(cocos2d::CCObject* sender) = win 0xb81b0;
    void updateBGColor(int index) = win inline {
        if (m_compactMode) {
            m_backgroundLayer->setColor(index % 2 == 0 ? cocos2d::ccColor3B { 156, 85, 42 } : cocos2d::ccColor3B { 144, 79, 39 });
        }
        else {
            m_backgroundLayer->setColor(index % 2 == 0 ? cocos2d::ccColor3B { 161, 88, 44 } : cocos2d::ccColor3B { 194, 114, 62 });
        }
    }
    void updateLabelValues() = win 0xb7fc0;

    cocos2d::CCSprite* m_iconSprite;
    cocos2d::CCLabelBMFont* m_likeLabel;
    GJComment* m_comment;
    bool m_accountComment;
    bool m_unk259;
    bool m_compactMode;
}

[[link(android)]]
class CommentUploadDelegate {
    virtual void commentUploadFinished(int parentID) {}
    virtual void commentUploadFailed(int parentID, CommentError errorType) {}
    virtual void commentDeleteFailed(int id, int parentID) {}
}

[[link(android)]]
class CommunityCreditNode : cocos2d::CCNode {
    // virtual ~CommunityCreditNode();

    static CommunityCreditNode* create(int unlockType, int iconID, int unknown, gd::string author) = win 0x93fa0;

    bool init(int unlockType, int iconID, int unknown, gd::string author) = win inline, ios inline {
        if (!CCNode::init()) return false;
        m_unlockType = unlockType;
        m_iconID = iconID;
        m_unknown = unknown;
        m_author = author;
        return true;
    }

    int m_unlockType;
    int m_iconID;
    int m_unknown;
    gd::string m_author;
}

[[link(android)]]
class CommunityCreditsPage : FLAlertLayer {
    CommunityCreditsPage() {
        m_pageObjects = nullptr;
        m_prevButton = nullptr;
        m_nextButton = nullptr;
        m_page = -1;
    }
    ~CommunityCreditsPage() = win inline {
        CC_SAFE_RELEASE(m_pageObjects);
    }

    static CommunityCreditsPage* create() = win inline {
        auto ret = new CommunityCreditsPage();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x940e0;
    virtual void registerWithTouchDispatcher() = win 0x42660;
    virtual void keyBackClicked() = win 0x846c0;
    virtual void show();

    void FLAlert_Clicked(FLAlertLayer* alert, bool btn2) = win inline, ios inline {}
    void goToPage(int page) = win 0x96120;
    void onClose(cocos2d::CCObject* sender) = win 0x84690;
    void onSwitchPage(cocos2d::CCObject* sender);

    cocos2d::CCDictionary* m_pageObjects;
    CCMenuItemSpriteExtra* m_prevButton;
    CCMenuItemSpriteExtra* m_nextButton;
    int m_page;
}

[[link(android)]]
class ConfigureHSVWidget : cocos2d::CCNode, TextInputDelegate {
    // virtual ~ConfigureHSVWidget();

    static ConfigureHSVWidget* create(cocos2d::ccHSVValue hsv, bool noBackground, bool addInputs) = win 0x96a30;
    static cocos2d::ccHSVValue getHSV(GameObject* object, cocos2d::CCArray* objects, int mode) = win 0x98180;

    virtual void textInputOpened(CCTextInputNode* node) = win inline {}
    virtual void textInputClosed(CCTextInputNode* node);
    virtual void textChanged(CCTextInputNode* node) = win 0x97640;

    void createTextInputNode(cocos2d::CCPoint position, int tag) = win 0x973e0;
    bool init(cocos2d::ccHSVValue hsv, bool noBackground, bool addInputs) = win 0x96b00;
    void onClose() = win inline, ios inline {
        cocos2d::CCDictElement* element;
        cocos2d::CCDictElement* temp;
        HASH_ITER(hh, m_inputs->m_pElements, element, temp) {
            static_cast<CCTextInputNode*>(element->getObject())->onClickTrackNode(false);
        }
    }
    void onResetHSV(cocos2d::CCObject* sender) = win 0x97bf0;
    void onToggleSConst(cocos2d::CCObject* sender);
    void onToggleVConst(cocos2d::CCObject* sender);
    void sliderChanged(cocos2d::CCObject* sender);
    void updateLabels() = win 0x97c70;
    void updateSliders() = win 0x97900;

    cocos2d::CCLabelBMFont* m_hueLabel;
    cocos2d::CCLabelBMFont* m_saturationLabel;
    cocos2d::CCLabelBMFont* m_brightnessLabel;
    Slider* m_hueSlider;
    Slider* m_saturationSlider;
    Slider* m_brightnessSlider;
    cocos2d::ccHSVValue m_hsv;
    bool m_mixed;
    HSVWidgetDelegate* m_delegate;
    bool m_addInputs;
    bool m_updating;
    cocos2d::CCDictionary* m_inputs;
}

[[link(android)]]
class ConfigureValuePopup : FLAlertLayer, TextInputDelegate {
    // virtual ~ConfigureValuePopup();

    static ConfigureValuePopup* create(ConfigureValuePopupDelegate* delegate, float value, float minimum, float maximum, gd::string title, gd::string description);

    virtual void keyBackClicked();
    virtual void textInputClosed(CCTextInputNode* node);
    virtual void textChanged(CCTextInputNode* node) = win 0x99370;

    bool init(ConfigureValuePopupDelegate* delegate, float value, float minimum, float maximum, gd::string title, gd::string description);
    void onClose(cocos2d::CCObject* sender) = win 0x99580;
    void sliderChanged(cocos2d::CCObject* sender) = win 0x990c0;
    void updateTextInputLabel();

    float m_value;
    float m_minimum;
    float m_maximum;
    bool m_enableDelegate;
    bool m_disableTextDelegate;
    ConfigureValuePopupDelegate* m_delegate;
    CCTextInputNode* m_input;
    Slider* m_slider;
}

[[link(android)]]
class ConfigureValuePopupDelegate {
    virtual void valuePopupClosed(ConfigureValuePopup* popup, float value) {}
}

[[link(android)]]
class CountTriggerAction {
    // CountTriggerAction(CountTriggerAction&&);
    CountTriggerAction() {}
    CountTriggerAction(int targetID, int targetCount, bool activateGroup, bool multiActivate, int itemID, int previousCount, gd::vector<int> const& remapKeys, int uniqueID, int controlID) {
        m_disabled = false;
        m_previousCount = previousCount;
        m_targetCount = targetCount;
        m_targetGroupID = targetID;
        m_activateGroup = activateGroup;
        m_triggerUniqueID = uniqueID;
        m_controlID = controlID;
        m_itemID = itemID;
        m_multiActivate = multiActivate;
        m_remapKeys = remapKeys;
    }

    bool m_disabled;
    int m_previousCount;
    int m_targetCount;
    int m_targetGroupID;
    bool m_activateGroup;
    int m_triggerUniqueID;
    int m_controlID;
    int m_itemID;
    bool m_multiActivate;
    gd::vector<int> m_remapKeys;
}

[[link(android)]]
class CountTriggerGameObject : EffectGameObject {
    // virtual ~CountTriggerGameObject();
    CountTriggerGameObject() {
        m_pickupCount = 0;
        m_pickupTriggerMode = 0;
        m_multiActivate = false;
        m_isOverride = false;
        m_pickupTriggerMultiplier = 1.f;
    }

    static CountTriggerGameObject* create(char const* frame) = win inline {
        auto ret = new CountTriggerGameObject();
        if (ret->init(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void triggerObject(GJBaseGameLayer* layer, int uniqueID, gd::vector<int> const* remapKeys) = win 0x4baea0;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4bb310;
    virtual gd::string getSaveString(GJBaseGameLayer* layer);

    bool init(char const* frame) = win inline, ios inline {
        return EffectGameObject::init(frame);
    }

    // property 77
    int m_pickupCount;
    // property 88
    int m_pickupTriggerMode;
    // property 104
    bool m_multiActivate;
    // property 139
    bool m_isOverride;
    // property 449
    float m_pickupTriggerMultiplier;
}

[[link(android)]]
class CreateGuidelinesLayer : FLAlertLayer, FLAlertLayerProtocol {
    CreateGuidelinesLayer() {
        m_delegate = nullptr;
        m_elapsed = 0.f;
        m_recording = false;
        m_unk2b5 = false;
    }
    ~CreateGuidelinesLayer() = win 0x99770;

    static CreateGuidelinesLayer* create(CustomSongDelegate* delegate, AudioGuidelinesType type) = win inline {
        auto ret = new CreateGuidelinesLayer();
        if (ret->init(delegate, type)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void update(float dt) = win 0x9b440;
    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x9b710;
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline {}
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x9b790;
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event);
    virtual void registerWithTouchDispatcher() = win 0x9b7f0;
    virtual void keyBackClicked() = win 0x9b690;
    virtual void keyDown(cocos2d::enumKeyCodes key) = win 0x9b840;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x9b5b0;
    virtual void onClose(cocos2d::CCObject* sender) = win 0x84690;
    virtual void keyUp(cocos2d::enumKeyCodes key) = win inline {}
    virtual void playMusic() = win 0x9acf0;
    virtual void registerTouch() = win 0x9b6b0;
    virtual void onInfo(cocos2d::CCObject* sender) = win 0x9b460;
    virtual void onRecord(cocos2d::CCObject* sender) = win 0x9ab60;
    virtual void recordingDidStop() = win 0x9ae50;

    void doClearGuidelines() = win inline {
        m_infoLabel->setString("Guidelines cleared.");
        if (m_delegate) {
            auto settings = m_delegate->getLevelSettings();
            settings->m_guidelineString = "";
            settings->m_guidelinesUpdated = true;
        }
    }
    gd::string getMergedRecordString(gd::string str1, gd::string str2) = win 0x9b0e0;
    bool init(CustomSongDelegate* delegate, AudioGuidelinesType type) = win 0x99830;
    void onClearGuidelines(cocos2d::CCObject* sender);
    void onStop(cocos2d::CCObject* sender);
    void toggleItems(bool visible) = win 0x9b360;

    CustomSongDelegate* m_delegate;
    CCTextInputNode* m_offsetInput;
    cocos2d::CCArray* m_nonRecordingObjects;
    cocos2d::CCArray* m_recordingObjects;
    cocos2d::CCLabelBMFont* m_infoLabel;
    cocos2d::CCSprite* m_circleSprite;
    float m_elapsed;
    bool m_recording;
    bool m_unk2b5;
    int m_guidelines;
    gd::string m_guidelineString;
}

[[link(android)]]
class CreateMenuItem : CCMenuItemSpriteExtra {
    // virtual ~CreateMenuItem();

    static CreateMenuItem* create(cocos2d::CCNode* normal, cocos2d::CCNode* selected, cocos2d::CCObject* target, cocos2d::SEL_MenuHandler selector) = win 0x1294f0;

    bool init(cocos2d::CCNode* normal, cocos2d::CCNode* selected, cocos2d::CCObject* target, cocos2d::SEL_MenuHandler selector) = win inline, ios inline {
        return CCMenuItemSpriteExtra::init(normal, selected, target, selector);
    }

    gd::string m_spriteFileName;
    int m_objectID;
    int m_pageIndex;
    int m_tabIndex;
}

[[link(android)]]
class CreateParticlePopup : FLAlertLayer, TextInputDelegate, ColorSelectDelegate, SliderDelegate {
    // virtual ~CreateParticlePopup();

    static CreateParticlePopup* create(gd::string str) = win inline, ios inline {
        return CreateParticlePopup::create(nullptr, nullptr, str);
    }
    static CreateParticlePopup* create(ParticleGameObject* object, cocos2d::CCArray* objects) = win inline {
        return CreateParticlePopup::create(object, objects, "");
    }
    static CreateParticlePopup* create(ParticleGameObject* object, cocos2d::CCArray* objects, gd::string str) = win 0x42bb90;

    virtual void update(float dt);
    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x434f20;
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x435020;
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x435450;
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event);
    virtual void keyBackClicked() = win 0x434f10;
    virtual void sliderBegan(Slider* slider) = win 0x434650;
    virtual void sliderEnded(Slider* slider) = win 0x434710;
    virtual void colorSelectClosed(cocos2d::CCNode* popup) = win 0x431b00;
    virtual void textInputShouldOffset(CCTextInputNode* node, float yOffset) = win 0x7b620;
    virtual void textInputReturn(CCTextInputNode* node) = win 0x7b680;
    virtual void textInputClosed(CCTextInputNode* node);
    virtual void textChanged(CCTextInputNode* node) = win 0x432560;

    void centerAlignParticle(cocos2d::CCObject* sender) = win 0x431ff0;
    void createParticleSlider(gjParticleValue value, int page, bool centerLabel, cocos2d::CCPoint position, cocos2d::CCArray* displayNodes) = win 0x4305c0;
    cocos2d::CCNode* getPage(int page) = win inline, ios inline {
        return static_cast<cocos2d::CCNode*>(m_pageNodes->objectAtIndex(page - 1));
    }
    CCMenuItemSpriteExtra* getPageButton(int page) = win inline, ios inline {
        return static_cast<CCMenuItemSpriteExtra*>(m_pageButtons->objectAtIndex(page - 1));
    }
    cocos2d::CCArray* getPageContainer(int page) = win inline, ios inline {
        return static_cast<cocos2d::CCArray*>(m_pageObjectArrays->objectAtIndex(page - 1));
    }
    cocos2d::CCDictionary* getPageInputNodes(int page) = win inline, ios inline {
        return static_cast<cocos2d::CCDictionary*>(m_inputDicts->objectAtIndex(page));
    }
    cocos2d::CCMenu* getPageMenu(int page) = win inline, ios inline {
        return m_buttonMenu;
    }
    cocos2d::CCDictionary* getPageSliders(int page) = win inline, ios inline {
        return static_cast<cocos2d::CCDictionary*>(m_sliderDicts->objectAtIndex(page));
    }
    bool init(ParticleGameObject* object, cocos2d::CCArray* objects, gd::string str);
    float maxSliderValueForType(gjParticleValue type) = win 0x433750;
    float minSliderValueForType(gjParticleValue type) = win 0x433820;
    void onAnimateActiveOnly(cocos2d::CCObject* sender);
    void onAnimateOnTrigger(cocos2d::CCObject* sender);
    void onCalcEmission(cocos2d::CCObject* sender) = win 0x432750;
    void onClose(cocos2d::CCObject* sender) = win 0x434dd0;
    void onCopySettings(cocos2d::CCObject* sender) = win 0x431720;
    void onDuplicateColor(cocos2d::CCObject* sender) = win 0x4315f0;
    void onDurationForever(cocos2d::CCObject* sender) = win 0x4326b0;
    void onDynamicColor(cocos2d::CCObject* sender) = win 0x4312c0;
    void onDynamicRotation(cocos2d::CCObject* sender);
    void onEmitterMode(cocos2d::CCObject* sender) = win 0x434a70;
    void onEndRGBVarSync(cocos2d::CCObject* sender);
    void onMaxEmission(cocos2d::CCObject* sender) = win 0x432700;
    void onMode(cocos2d::CCObject* sender) = win 0x431de0;
    void onOrderSensitive(cocos2d::CCObject* sender);
    void onPage(cocos2d::CCObject* sender) = win 0x432040;
    void onPasteSettings(cocos2d::CCObject* sender) = win 0x431970;
    void onPosType(cocos2d::CCObject* sender) = win 0x4349f0;
    void onQuickStart(cocos2d::CCObject* sender);
    void onSelectColor(cocos2d::CCObject* sender) = win 0x4314c0;
    void onSelectParticleTexture(cocos2d::CCObject* sender) = win 0x431ec0;
    void onStartRGBVarSync(cocos2d::CCObject* sender);
    void onToggleBlending(cocos2d::CCObject* sender);
    void onToggleStartRadiusEqualToEnd(cocos2d::CCObject* sender);
    void onToggleStartRotationIsDir(cocos2d::CCObject* sender);
    void onToggleStartSizeEqualToEnd(cocos2d::CCObject* sender);
    void onToggleStartSpinEqualToEnd(cocos2d::CCObject* sender);
    void onUniformColor(cocos2d::CCObject* sender) = win 0x4313e0;
    bool particleValueIsInt(gjParticleValue type) = win 0x4347d0, ios inline {
        switch (type) {
            case gjParticleValue::MaxParticles: case gjParticleValue::Emission:
            case gjParticleValue::Angle: case gjParticleValue::AngleVar:
            case gjParticleValue::Speed: case gjParticleValue::SpeedVar:
            case gjParticleValue::PosVarX: case gjParticleValue::PosVarY:
            case gjParticleValue::GravityX: case gjParticleValue::GravityY:
            case gjParticleValue::AccelRad: case gjParticleValue::AccelRadVar:
            case gjParticleValue::AccelTan: case gjParticleValue::AccelTanVar:
            case gjParticleValue::StartSize: case gjParticleValue::StartSizeVar:
            case gjParticleValue::EndSize: case gjParticleValue::EndSizeVar:
            case gjParticleValue::StartSpin: case gjParticleValue::StartSpinVar:
            case gjParticleValue::EndSpin: case gjParticleValue::EndSpinVar:
            case gjParticleValue::StartRad: case gjParticleValue::StartRadVar:
            case gjParticleValue::EndRad: case gjParticleValue::EndRadVar:
            case gjParticleValue::RotSec: case gjParticleValue::RotSecVar:
                return true;
            default:
                return false;
        }
    }
    void sliderChanged(cocos2d::CCObject* sender);
    gd::string titleForParticleValue(gjParticleValue type) = win 0x432810;
    void toggleGravityMode(bool gravityMode) = win 0x434af0;
    void updateColorSprite(int tag) = win inline {
        if (tag == 1) {
            auto color = m_particle->getStartColor();
            m_startColorSprite->setColor({ (uint8_t)(color.r * 255.f), (uint8_t)(color.g * 255.f), (uint8_t)(color.b * 255.f) });
        }
        else if (tag == 2) {
            auto color = m_particle->getEndColor();
            m_endColorSprite->setColor({ (uint8_t)(color.r * 255.f), (uint8_t)(color.g * 255.f), (uint8_t)(color.b * 255.f) });
        }
    }
    void updateInputNodeStringForType(gjParticleValue type) = win 0x434840;
    void updateParticleValueForType(float value, gjParticleValue type, cocos2d::CCParticleSystemQuad* particle) = win 0x433940;
    void updateSliderForType(gjParticleValue type) = win 0x4345b0;
    float valueForParticleValue(gjParticleValue type) = win 0x4330c0;
    void willClose() = win 0x434d40;

    ParticleGameObject* m_targetObject;
    cocos2d::CCArray* m_targetObjects;
    cocos2d::CCArray* m_particles;
    bool m_disableTextDelegate;
    cocos2d::CCParticleSystemQuad* m_particle;
    cocos2d::CCParticleSystemQuad* m_standaloneParticle;
    int m_touchID;
    cocos2d::CCPoint m_touchDelta;
    cocos2d::CCArray* m_inputDicts;
    cocos2d::CCArray* m_sliderDicts;
    cocos2d::CCArray* m_pageNodes;
    cocos2d::CCArray* m_pageButtons;
    cocos2d::CCArray* m_pageMenus;
    cocos2d::CCArray* m_pageObjectArrays;
    ParticlePreviewLayer* m_previewLayer;
    CCMenuItemSpriteExtra* m_mode1Button;
    CCMenuItemSpriteExtra* m_mode2Button;
    CCMenuItemSpriteExtra* m_mode3Button;
    float m_elapsed;
    int m_selectedMode;
    CCMenuItemToggler* m_freeToggler;
    CCMenuItemToggler* m_relativeToggler;
    CCMenuItemToggler* m_groupedToggler;
    CCMenuItemToggler* m_objColorToggler;
    CCMenuItemToggler* m_uniformColorToggler;
    CCMenuItemToggler* m_gravityToggler;
    CCMenuItemToggler* m_radiusToggler;
    cocos2d::CCSprite* m_selectSprite;
    cocos2d::CCSprite* m_particleColorSprite;
    cocos2d::CCSprite* m_startColorSprite;
    cocos2d::CCSprite* m_endColorSprite;
    cocos2d::CCArray* m_gravityObjects;
    cocos2d::CCArray* m_radiusObjects;
    int m_particleIndex;
    int m_page;
    bool m_useObjectColor;
    bool m_animateOnTrigger;
    bool m_onlyAnimateActive;
    bool m_quickStart;
    float m_respawnResult;
}

[[link(android)]]
class CreatorLayer : cocos2d::CCLayer, cocos2d::CCSceneTransitionDelegate, DialogDelegate {
    // virtual ~CreatorLayer();
    CreatorLayer() {
        m_secretDoorSprite = nullptr;
        m_questsSprite = nullptr;
        m_vaultDialogIndex = -1;
        m_versusDialogIndex = 0;
    }

    static CreatorLayer* create() = win inline {
        auto ret = new CreatorLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static cocos2d::CCScene* scene() = win 0x9bff0;

    virtual bool init() = win 0x9c160;
    virtual void keyBackClicked() = win 0x9f9e0;
    virtual void sceneWillResume();
    virtual void dialogClosed(DialogLayer* layer) = win 0x9f760;

    bool canPlayOnlineLevels() = win inline, ios inline {
        return true;
    }
    void checkQuestsStatus() = win 0x9f640;
    void onAdventureMap(cocos2d::CCObject* sender) = win 0x9e270;
    void onBack(cocos2d::CCObject* sender);
    void onChallenge(cocos2d::CCObject* sender) = win 0x9e440;
    void onDailyLevel(cocos2d::CCObject* sender);
    void onEventLevel(cocos2d::CCObject* sender) = win 0x9e420;
    void onFameLevels(cocos2d::CCObject* sender) = win inline, ios inline {
        cocos2d::CCDirector::sharedDirector()->pushScene(cocos2d::CCTransitionFade::create(0.5f, LevelBrowserLayer::scene(GJSearchObject::create(SearchType::HallOfFame))));
        GameManager::sharedState()->m_sceneEnum = 1;
    }
    void onFeaturedLevels(cocos2d::CCObject* sender) = win 0x9d930;
    void onGauntlets(cocos2d::CCObject* sender);
    void onLeaderboards(cocos2d::CCObject* sender);
    void onMapPacks(cocos2d::CCObject* sender) = win 0x9db60;
    void onMultiplayer(cocos2d::CCObject* sender) = win 0x9dca0;
    void onMyLevels(cocos2d::CCObject* sender) = win 0x9d330;
    void onOnlineLevels(cocos2d::CCObject* sender) = win 0x9dae0;
    void onOnlyFullVersion(cocos2d::CCObject* sender);
    void onPaths(cocos2d::CCObject* sender);
    void onSavedLevels(cocos2d::CCObject* sender) = win 0x9d540;
    void onSecretVault(cocos2d::CCObject* sender) = win 0x9e5b0;
    void onTopLists(cocos2d::CCObject* sender);
    void onTreasureRoom(cocos2d::CCObject* sender) = win 0x9edc0;
    void onWeeklyLevel(cocos2d::CCObject* sender) = win 0x9e400;

    cocos2d::CCSprite* m_secretDoorSprite;
    cocos2d::CCSprite* m_questsSprite;
    int m_vaultDialogIndex;
    int m_versusDialogIndex;
}

[[link(android)]]
class CurrencyRewardDelegate {
    virtual void currencyWillExit(CurrencyRewardLayer* layer) {}
}

[[link(android)]]
class CurrencyRewardLayer : cocos2d::CCLayer {
    // virtual ~CurrencyRewardLayer();
    // CurrencyRewardLayer();

    static CurrencyRewardLayer* create(int orbs, int stars, int moons, int diamonds, CurrencySpriteType demonKey, int keyCount, CurrencySpriteType shardType, int shardsCount, cocos2d::CCPoint position, CurrencyRewardType rewardType, float yOffset, float time) = win 0x9fc30;

    virtual void update(float dt) = win 0xa2960;

    void createObjects(CurrencySpriteType type, int count, cocos2d::CCPoint position, float time) = win inline {
        this->createObjectsFull(type, count, nullptr, position, time);
    }
    void createObjectsFull(CurrencySpriteType type, int count, cocos2d::CCSprite* sprite, cocos2d::CCPoint position, float time) = win 0xa1c50;
    void createUnlockObject(cocos2d::CCSprite* sprite, cocos2d::CCPoint position, float time) = win inline {
        this->createObjectsFull(CurrencySpriteType::Icon, 1, sprite, position, time);
    }
    void incrementCount(int count) = win inline {
        if (m_orbsLabel == nullptr) return;
        m_orbs += count;
        this->pulseSprite(m_orbsSprite);
        m_orbsLabel->setString(cocos2d::CCString::createWithFormat("%i", count)->getCString());
    }
    void incrementDiamondsCount(int count) = win inline {
        if (m_diamondsLabel == nullptr) return;
        m_diamonds += count;
        this->pulseSprite(m_diamondsSprite);
        m_diamondsLabel->setString(cocos2d::CCString::createWithFormat("%i", count)->getCString());
    }
    void incrementMoonsCount(int count) = win inline {
        if (m_moonsLabel == nullptr) return;
        m_moons += count;
        this->pulseSprite(m_moonsSprite);
        m_moonsLabel->setString(cocos2d::CCString::createWithFormat("%i", count)->getCString());
    }
    void incrementSpecialCount1(int count) = win inline {
        if (m_keysLabel == nullptr) return;
        m_keys += count;
        this->pulseSprite(m_keysSprite);
        m_keysLabel->setString(cocos2d::CCString::createWithFormat("%i", count)->getCString());
    }
    void incrementSpecialCount2(int count) = win inline {
        if (m_shardsLabel == nullptr) return;
        m_shards += count;
        this->pulseSprite(m_shardsSprite);
        m_shardsLabel->setString(cocos2d::CCString::createWithFormat("%i", count)->getCString());
    }
    void incrementStarsCount(int count) = win inline {
        if (m_starsLabel == nullptr) return;
        m_stars += count;
        this->pulseSprite(m_starsSprite);
        m_starsLabel->setString(cocos2d::CCString::createWithFormat("%i", count)->getCString());
    }
    bool init(int orbs, int stars, int moons, int diamonds, CurrencySpriteType demonKey, int keyCount, CurrencySpriteType shardType, int shardsCount, cocos2d::CCPoint position, CurrencyRewardType rewardType, float yOffset, float time) = win 0x9fe80;
    void pulseSprite(cocos2d::CCSprite* sprite) = win 0xa3330;

    CurrencyRewardDelegate* m_delegate;
    cocos2d::CCArray* m_objects;
    cocos2d::CCLabelBMFont* m_orbsLabel;
    cocos2d::CCLabelBMFont* m_starsLabel;
    cocos2d::CCLabelBMFont* m_moonsLabel;
    cocos2d::CCLabelBMFont* m_diamondsLabel;
    cocos2d::CCLabelBMFont* m_keysLabel;
    cocos2d::CCLabelBMFont* m_shardsLabel;
    cocos2d::CCSprite* m_orbsSprite;
    cocos2d::CCSprite* m_starsSprite;
    cocos2d::CCSprite* m_moonsSprite;
    cocos2d::CCSprite* m_diamondsSprite;
    CurrencySprite* m_keysSprite;
    CurrencySprite* m_shardsSprite;
    cocos2d::CCSpriteBatchNode* m_currencyBatchNode;
    cocos2d::CCSpriteBatchNode* m_orbBatchNode;
    int m_orbs;
    int m_stars;
    int m_moons;
    int m_diamonds;
    int m_keys;
    int m_shards;
    float m_elapsed;
    float m_unknown;
    float m_time;
    cocos2d::CCPoint m_orbsPosition;
    cocos2d::CCPoint m_starsPosition;
    cocos2d::CCPoint m_moonsPosition;
    cocos2d::CCPoint m_diamondsPosition;
    cocos2d::CCPoint m_keysPosition;
    cocos2d::CCPoint m_shardsPosition;
    bool m_particlesAdded;
    bool m_objectsAdded;
    cocos2d::CCNode* m_mainNode;
    int m_rewardCount;
    CurrencyRewardType m_rewardType;
}

[[link(android)]]
class CurrencySprite : CCSpritePlus {
    CurrencySprite() {
        m_unkFloat1 = 0.f;
        m_unkFloat2 = 0.f;
        m_unkFloat3 = 0.f;
        m_remaining = 0.f;
        m_count = 1;
        m_particleSystem = nullptr;
        m_spriteType = CurrencySpriteType::Orb;
        m_burstSprite = nullptr;
    }
    ~CurrencySprite() = win inline {
        CC_SAFE_RELEASE(m_burstSprite);
    }

    static CurrencySprite* create(CurrencySpriteType type, bool burst) = win inline {
        auto ret = new CurrencySprite();
        if (ret->init(type, burst)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static CurrencySprite* createWithSprite(cocos2d::CCSprite* sprite) = win 0xa4be0;
    static CurrencySpriteType rewardToSpriteType(int rewardType) = win 0xa4e00;
    static gd::string spriteTypeToStat(CurrencySpriteType type) = win 0xa4eb0;

    bool init(CurrencySpriteType type, bool burst) = win 0xa3400;
    bool initWithSprite(cocos2d::CCSprite* sprite) = win inline {
        if (!cocos2d::CCSprite::init()) return false;
        this->addChild(sprite);
        sprite->setPosition({ 0.f, 0.f });
        m_burstSprite = cocos2d::CCSprite::createWithSpriteFrameName("shineBurst_001.png");
        m_burstSprite->retain();
        auto factor = (float)rand() / (float)RAND_MAX > .5f ? 1.f : -1.f;
        m_burstSprite->runAction(cocos2d::CCRepeatForever::create(cocos2d::CCRotateBy::create(1.f, 90.f * factor)));
        m_burstSprite->setScale(2.f);
        m_burstSprite->setColor({ 255, 255, 255 });
        auto shineBurst = cocos2d::CCSprite::createWithSpriteFrameName("shineBurst_001.png");
        m_burstSprite->addChild(shineBurst);
        shineBurst->setPosition(m_burstSprite->convertToNodeSpace({ 0.f, 0.f }));
        shineBurst->setScale(.8f);
        shineBurst->setColor({ 255, 255, 255 });
        shineBurst->runAction(cocos2d::CCRepeatForever::create(cocos2d::CCRotateBy::create(1.f, -180.f * factor)));
        return true;
    }

    float m_unkFloat1;
    float m_unkFloat2;
    float m_unkFloat3;
    float m_remaining;
    int m_count;
    cocos2d::CCParticleSystemQuad* m_particleSystem;
    CurrencySpriteType m_spriteType;
    cocos2d::CCPoint m_position;
    cocos2d::CCSprite* m_burstSprite;
}

[[link(android)]]
class CustomizeObjectLayer : FLAlertLayer, TextInputDelegate, HSVWidgetDelegate, ColorSelectDelegate, ColorSetupDelegate {
    // virtual ~CustomizeObjectLayer();
    //CustomizeObjectLayer() = ios 0x577b8;

    static CustomizeObjectLayer* create(GameObject* object, cocos2d::CCArray* objects) = win 0xa5290;

    virtual void keyBackClicked();
    virtual void textInputOpened(CCTextInputNode* node) = win 0xa96a0;
    virtual void textInputClosed(CCTextInputNode* node);
    virtual void textChanged(CCTextInputNode* node) = win 0xa9830;
    virtual void hsvPopupClosed(HSVWidgetPopup* popup, cocos2d::ccHSVValue value) = win 0xa8dd0;
    virtual void colorSelectClosed(cocos2d::CCNode* popup) = win 0xa8760;
    virtual void colorSetupClosed(int id) = win 0xa83c0;

    CCMenuItemToggler* createToggleButton(gd::string text, cocos2d::SEL_MenuHandler selector, bool toggled, cocos2d::CCMenu* menu, cocos2d::CCPoint position) = win inline, ios inline {
        auto onSprite = cocos2d::CCSprite::createWithSpriteFrameName("GJ_checkOn_001.png");
        onSprite->setScale(.8f);
        auto offSprite = cocos2d::CCSprite::createWithSpriteFrameName("GJ_checkOff_001.png");
        offSprite->setScale(.8f);
        auto toggler = CCMenuItemToggler::create(offSprite, onSprite, this, selector);
        toggler->toggle(toggled);
        menu->addChild(toggler);
        toggler->setPosition(menu->convertToNodeSpace(position));
        toggler->setSizeMult(1.5f);
        m_detailTabNodes->addObject(toggler);
        auto label = cocos2d::CCLabelBMFont::create(text.c_str(), "bigFont.fnt");
        m_mainLayer->addChild(label);
        label->setAnchorPoint({ .0f, .5f });
        label->setPosition(m_mainLayer->convertToNodeSpace(position + cocos2d::CCPoint { onSprite->getContentSize().width * .5f + 5.6f, 0.f }));
        label->setScale(.5f);
        m_detailTabNodes->addObject(label);
        return toggler;
    }
    void determineStartValues() = win 0xa8770;
    int getActiveMode(bool ignoreDefault) = win 0xa93e0;
    ButtonSprite* getButtonByTag(int tag) = win 0xa9c50;
    cocos2d::ccHSVValue getHSV() = win inline, ios inline {
        return ConfigureHSVWidget::getHSV(m_targetObject, m_targetObjects, m_selectedMode);
    }
    void highlightSelected(ButtonSprite* sprite) = win 0xa9f00;
    bool init(GameObject* object, cocos2d::CCArray* objects) = win 0xa5430;
    void onBreakApart(cocos2d::CCObject* sender) = win 0xa9b40;
    void onBrowse(cocos2d::CCObject* sender);
    void onClear(cocos2d::CCObject* sender) = win 0xa9ab0;
    void onClose(cocos2d::CCObject* sender) = win 0xaa030;
    void onCopy(cocos2d::CCObject* sender);
    void onEditColor(cocos2d::CCObject* sender) = win 0xa84a0;
    void onHSV(cocos2d::CCObject* sender) = win 0xa8ba0;
    void onLiveEdit(cocos2d::CCObject* sender) = win 0xa7f30;
    void onNextColorChannel(cocos2d::CCObject* sender);
    void onPaste(cocos2d::CCObject* sender) = win 0xa8090;
    void onSelectColor(cocos2d::CCObject* sender) = win 0xa9cd0;
    void onSelectMode(cocos2d::CCObject* sender) = win 0xa9010;
    void onSettings(cocos2d::CCObject* sender) = win 0xa81e0;
    void onUpdateCustomColor(cocos2d::CCObject* sender) = win 0x99110;
    void recreateLayer() = win inline {
        CC_SAFE_RETAIN(m_targetObject);
        CC_SAFE_RETAIN(m_targetObjects);
        cocos2d::CCDirector::sharedDirector()->getTouchDispatcher()->unregisterForcePrio(this);
        this->onClose(nullptr);
        CustomizeObjectLayer::create(m_targetObject, m_targetObjects)->show();
        CC_SAFE_RELEASE(m_targetObject);
        CC_SAFE_RELEASE(m_targetObjects);
    }
    void sliderChanged(cocos2d::CCObject* sender);
    void toggleVisible() = win 0xa9220;
    void updateChannelLabel(int channel) = win inline {
        if (channel > 999) {
            m_selectedColorLabel->setString(GJSpecialColorSelect::textForColorIdx(channel));
        }
        else if (channel > 0) {
            m_selectedColorLabel->setString(cocos2d::CCString::createWithFormat("%i", channel)->getCString());
        }
        else {
            m_selectedColorLabel->setString(" ");
        }
    }
    void updateColorSprite() = win 0xa8550;
    void updateCurrentSelection() = win 0xa9570;
    void updateCustomColorLabels() = win 0xa9bc0;
    void updateHSVButtons() = win 0xa89a0;
    void updateKerningLabel() = win 0xa7d30;
    void updateSelected(int id) = win 0xa9d90;

    GameObject* m_targetObject;
    cocos2d::CCArray* m_targetObjects;
    cocos2d::CCArray* m_colorButtons;
    cocos2d::CCArray* m_colorTabNodes;
    cocos2d::CCArray* m_textTabNodes;
    cocos2d::CCArray* m_unkArray;
    cocos2d::CCArray* m_detailTabNodes;
    int m_selectedMode;
    int m_customColorChannel;
    bool m_hasBaseColor;
    bool m_hasDetailColor;
    bool m_glowDisabled;
    CCMenuItemSpriteExtra* m_baseButton;
    CCMenuItemSpriteExtra* m_detailButton;
    CCMenuItemSpriteExtra* m_textButton;
    CCMenuItemSpriteExtra* m_baseColorHSV;
    CCMenuItemSpriteExtra* m_detailColorHSV;
    cocos2d::CCLabelBMFont* m_titleLabel;
    cocos2d::CCLabelBMFont* m_selectedColorLabel;
    CCTextInputNode* m_customColorInput;
    CCTextInputNode* m_textInput;
    int m_kerningAmount;
    cocos2d::CCLabelBMFont* m_kerningLabel;
    Slider* m_kerningSlider;
    ButtonSprite* m_customColorButtonSprite;
    CCMenuItemSpriteExtra* m_customColorButton;
    CCMenuItemSpriteExtra* m_arrowDown;
    CCMenuItemSpriteExtra* m_arrowUp;
    cocos2d::extension::CCScale9Sprite* m_customColorInputBG;
    ColorChannelSprite* m_colorSprite;
    CCMenuItemSpriteExtra* m_colorSpriteButton;
    CCMenuItemSpriteExtra* m_liveSelectButton;
    bool m_showTextInput;
    bool m_customColorSelected;
    bool m_disableTextDelegate;
}

[[link(android)]]
class CustomizeObjectSettingsPopup : SetupTriggerPopup {
    // virtual ~CustomizeObjectSettingsPopup();
    CustomizeObjectSettingsPopup() {
        m_customizeLayer = nullptr;
        m_settingsChanged = false;
    }

    static CustomizeObjectSettingsPopup* create(GameObject* object, cocos2d::CCArray* objects, CustomizeObjectLayer* layer) = win inline {
        auto ret = new CustomizeObjectSettingsPopup();
        if (ret->init(object, objects, layer)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void onClose(cocos2d::CCObject* sender) = win 0xaa580;
    virtual void onCustomToggleTriggerValue(cocos2d::CCObject* sender) = win 0xaa4d0;

    bool init(GameObject* object, cocos2d::CCArray* objects, CustomizeObjectLayer* layer) = win 0xaa120;

    CustomizeObjectLayer* m_customizeLayer;
    bool m_settingsChanged;
}

[[link(android)]]
class CustomListView : BoomListView {
    CustomListView() {
        m_cellMode = 0;
    }

    static CustomListView* create(cocos2d::CCArray* entries, BoomListType type, float height, float width) {
        return CustomListView::create(entries, nullptr, height, width, 0, type, 0.0f);
    }
    static CustomListView* create(cocos2d::CCArray* entries, TableViewCellDelegate* delegate, float height, float width, int page, BoomListType type, float y) = win 0xaa740;
    static float getCellHeight(BoomListType type) = win 0xab520;

    virtual void setupList(float yOffset) = win 0xabcf0;
    virtual TableViewCell* getListCell(char const* identifier) = win 0xaa870;
    virtual void loadCell(TableViewCell* cell, int index) = win 0xab630;

    void reloadAll() = win 0xac3c0;

    int m_cellMode;
}

[[link(android)]]
class CustomMusicCell : CustomSongCell {
    // virtual ~CustomMusicCell();
    CustomMusicCell(char const* identifier, float width, float height) = win inline, ios inline : CustomSongCell(identifier, width, height) {
        this->init();
    }

    void loadFromObject(SongInfoObject* object) = win 0xb4e90;
    void updateBGColor(int index) = win inline {
        m_backgroundLayer->setColor(index % 2 == 0 ? cocos2d::ccColor3B { 50, 50, 50 } : cocos2d::ccColor3B { 75, 75, 75 });
        m_backgroundLayer->setOpacity(255);
    }
}

[[link(android)]]
class CustomSFXCell : TableViewCell, CustomSFXDelegate {
    // virtual ~CustomSFXCell();
    CustomSFXCell(char const* identifier, float width, float height) = ios inline : TableViewCell(identifier, width, height) {
        this->init();
    }

    virtual bool init() = win 0xb4bb0;
    virtual void draw() = win 0xade40;
    virtual void sfxObjectSelected(SFXInfoObject* object) = win 0xb4cc0;
    virtual int getActiveSFXID() = win 0xb48b0;

    void loadFromObject(SFXInfoObject* object) = win 0xb4bd0;
    bool shouldReload() = win inline, ios inline {
        return (m_sfxObject->m_sfxID == this->getActiveSFXID()) != m_selected;
    }
    void updateBGColor(int index) = win 0xb4d00;

    SFXInfoObject* m_sfxObject;
    bool m_selected;
    bool m_compactMode;
}

[[link(android)]]
class CustomSFXDelegate {
    virtual void sfxObjectSelected(SFXInfoObject* object) {}
    virtual int getActiveSFXID() { return 0; }
    virtual bool overridePlaySFX(SFXInfoObject* object) { return false; }
}

[[link(android)]]
class CustomSFXWidget : cocos2d::CCNode, MusicDownloadDelegate, FLAlertLayerProtocol {
    // virtual ~CustomSFXWidget();

    static CustomSFXWidget* create(SFXInfoObject* object, CustomSFXDelegate* delegate, bool showDelete, bool showPlay, bool showDownload, bool noBackground, bool compactMode) = win 0xc0660;

    virtual void downloadSFXFinished(int id) = win 0xc2620;
    virtual void downloadSFXFailed(int id, GJSongError errorType) = win 0xc26a0;
    virtual void songStateChanged() = win 0xc1f70;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0xc27a0;

    void deleteSFX() = win inline {
        FMODAudioEngine::sharedEngine()->stopAllEffects();
        MusicDownloadManager::sharedState()->deleteSFX(m_sfxObject->m_sfxID);
        this->updateSFXInfo();
        m_errorLabel->setVisible(true);
        m_errorLabel->setColor({ 255, 100, 0 });
        m_errorLabel->setString("SFX Deleted");
        m_errorLabel->limitLabelWidth(230.f, .4f, .0f);
    }
    void downloadFailed() = win inline {
        this->hideLoadingArt();
        this->unschedule(schedule_selector(CustomSFXWidget::updateDownloadProgress));
        m_showCancel = false;
        this->updateSFXInfo();
    }
    void hideLoadingArt() = win 0xc1930;
    bool init(SFXInfoObject* object, CustomSFXDelegate* delegate, bool showDelete, bool showPlay, bool showDownload, bool noBackground, bool compactMode) = win 0xc07a0;
    void onCancelDownload(cocos2d::CCObject* sender);
    void onDelete(cocos2d::CCObject* sender) = win 0xc1690;
    void onDownload(cocos2d::CCObject* sender) = win 0xc1a50;
    void onPlayback(cocos2d::CCObject* sender) = win 0xc1c20;
    void onSelect(cocos2d::CCObject* sender) = win 0xc1c00;
    void showLoadingArt() = win 0xc17d0;
    void startDownload() = win inline {
        m_showCancel = false;
        MusicDownloadManager::sharedState()->downloadSFX(m_sfxID);
        this->startMonitorDownload();
    }
    void startMonitorDownload() = win 0xc1b50;
    void updateDownloadProgress(float dt) = win 0xc1e40;
    void updateError(GJSongError errorType) = win inline {
        m_errorLabel->setVisible(true);
        m_errorLabel->setColor({ 255, 50, 25 });
        switch (errorType) {
            case GJSongError::FailedToFetch:
                m_errorLabel->setString("Failed to fetch SFX info.");
                break;
            case GJSongError::NotAllowed:
                m_errorLabel->setString("SFX is not allowed for use.");
                break;
            case GJSongError::DownloadCancelled:
                m_errorLabel->setString("Download canceled.");
                break;
            default:
                m_errorLabel->setString("Download failed. Please try again later.");
                break;
        }
        m_errorLabel->limitLabelWidth(230.f, .4f, .0f);
    }
    void updateLengthMod(float mod) = win inline {
        m_lengthMod = mod;
        this->updateSFXInfo();
    }
    void updatePlaybackBtn() = win inline, ios inline {}
    void updateProgressBar(int progress);
    void updateSFXInfo() = win 0xc1f80;
    void updateSFXObject(SFXInfoObject* object) = win inline {
        m_errorLabel->setVisible(false);
        if (m_sfxObject != object) {
            CC_SAFE_RETAIN(object);
            CC_SAFE_RELEASE(m_sfxObject);
            m_sfxObject = object;
        }
        if (m_sfxObject) m_sfxID = m_sfxObject->m_sfxID;
        else m_sfxID = 0;
        this->updateSFXInfo();
    }
    bool verifySFXID(int id) = win inline, ios inline {
        return m_sfxID == id && m_sfxID != 0;
    }

    SFXInfoObject* m_sfxObject;
    cocos2d::CCMenu* m_buttonMenu;
    cocos2d::CCLabelBMFont* m_titleLabel;
    cocos2d::CCLabelBMFont* m_idLabel;
    cocos2d::CCLabelBMFont* m_errorLabel;
    CCMenuItemSpriteExtra* m_downloadButton;
    CCMenuItemSpriteExtra* m_cancelButton;
    CCMenuItemSpriteExtra* m_selectButton;
    CCMenuItemSpriteExtra* m_playButton;
    CCMenuItemSpriteExtra* m_deleteButton;
    cocos2d::CCSprite* m_progressOutlineSprite;
    cocos2d::CCSprite* m_progressBarSprite;
    cocos2d::CCSprite* m_clockSprite;
    CustomSFXDelegate* m_delegate;
    bool m_showDelete;
    bool m_showPlay;
    bool m_showDownload;
    bool m_showCancel;
    bool m_compactMode;
    int m_sfxID;
    float m_lengthMod;
}

[[link(android)]]
class CustomSongCell : TableViewCell, CustomSongDelegate {
    // virtual ~CustomSongCell();
    CustomSongCell(char const* identifier, float width, float height) = ios inline : TableViewCell(identifier, width, height) {
        this->init();
    }

    virtual bool init();
    virtual void draw() = win 0xade40;
    virtual void songIDChanged(int id) = win 0xb4870;
    virtual int getActiveSongID() = win 0xb48b0;
    virtual gd::string getSongFileName() = win 0xb48d0;
    virtual LevelSettingsObject* getLevelSettings() = win inline { return nullptr; }

    void loadFromObject(SongInfoObject* object) = win 0xb46b0;
    void onDelete(cocos2d::CCObject* sender) = win 0xb4900;
    bool shouldReload() = win inline, ios inline {
        return (m_songInfoObject->m_songID == this->getActiveSongID()) != m_selected;
    }
    void updateBGColor(int index) = win inline {
        m_backgroundLayer->setColor(index % 2 == 0 ? cocos2d::ccColor3B { 50, 50, 50 } : cocos2d::ccColor3B { 75, 75, 75 });
        m_backgroundLayer->setOpacity(255);
    }

    SongInfoObject* m_songInfoObject;
    bool m_selected;
}

[[link(android)]]
class CustomSongDelegate {
    virtual void songIDChanged(int id) {}
    virtual int getActiveSongID() { return 0; }
    virtual gd::string getSongFileName() { return ""; }
    virtual LevelSettingsObject* getLevelSettings() { return nullptr; }
}

[[link(android)]]
class CustomSongLayer : FLAlertLayer, TextInputDelegate, GJDropDownLayerDelegate, MusicBrowserDelegate {
    // virtual ~CustomSongLayer();
    CustomSongLayer() {
        m_songDelegate = nullptr;
        m_songIDInput = nullptr;
        m_delegate = nullptr;
    }

    static CustomSongLayer* create(CustomSongDelegate* delegate) = win inline {
        auto ret = new CustomSongLayer();
        if (ret->init(delegate)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyBackClicked() = win 0xc44a0;
    virtual void show() = win 0xc44b0;
    virtual void textChanged(CCTextInputNode* node) = win 0xc3e50;
    virtual void textInputOpened(CCTextInputNode* node) = win 0xc3da0;
    virtual void textInputClosed(CCTextInputNode* node) = win 0xc3da0;
    virtual void textInputShouldOffset(CCTextInputNode* node, float yOffset) = win 0x7b620;
    virtual void textInputReturn(CCTextInputNode* node) = win 0x7b680;
    virtual void dropDownLayerWillClose(GJDropDownLayer* layer);
    virtual void musicBrowserClosed(MusicBrowser* browser);

    bool init(CustomSongDelegate* delegate) = win 0xc2c40;
    void onClose(cocos2d::CCObject* sender) = win 0xc43d0;
    void onCreateLines(cocos2d::CCObject* sender);
    void onMusicBrowser(cocos2d::CCObject* sender) = win 0xc3ee0;
    void onNCSBrowser(cocos2d::CCObject* sender);
    void onNewgroundsBrowser(cocos2d::CCObject* sender) = win 0xc4040;
    void onOptions(cocos2d::CCObject* sender);
    void onSearch(cocos2d::CCObject* sender) = win 0xc39c0;
    void onSongBrowser(cocos2d::CCObject* sender);
    void showNewgroundsMessage() = win inline {
        FLAlertLayer::create(
            nullptr,
            "Newgrounds Info",
            "There are thousands of great custom songs for you to choose from Newgrounds. "
            "Please do not upload music you did not create. "
            "You are only allowed to use songs from artists that have been scouted on Newgrounds. "
            "For more information, please check the <cy>Audio Guidelines</c>.",
            "OK",
            nullptr,
            380.f
        )->show();
    }

    CustomSongDelegate* m_songDelegate;
    CCTextInputNode* m_songIDInput;
    CustomSongWidget* m_songWidget;
    CustomSongLayerDelegate* m_delegate;
}

[[link(android)]]
class CustomSongLayerDelegate {
    virtual void customSongLayerClosed() {}
}

[[link(android), depends(GJAssetDownloadAction)]]
class CustomSongWidget : cocos2d::CCNode, MusicDownloadDelegate, FLAlertLayerProtocol {
    CustomSongWidget() {
        m_songInfoObject = nullptr;
        m_songLabel = nullptr;
        m_artistLabel = nullptr;
        m_songIDLabel = nullptr;
        m_downloadBtn = nullptr;
        m_selectSongBtn = nullptr;
        m_playbackBtn = nullptr;
        m_deleteBtn = nullptr;
        m_sliderGroove = nullptr;
        m_sliderBar = nullptr;
        m_ncsLogo = nullptr;
        m_bgSpr = nullptr;
        m_songDelegate = nullptr;
        m_showSelectSongBtn = false;
        m_showPlayMusicBtn = false;
        m_showDownloadBtn = false;
        m_isNotDownloading = false;
        m_isRobtopSong = false;
        m_isMusicLibrary = false;
        m_customSongID = 0;
        m_lengthMod = 0.f;
        m_isInCell = false;
        m_playbackDelegate = nullptr;
        m_hasLibrarySongs = false;
        m_hasSFX = false;
        m_unkBool2 = false;
        m_totalBytes = 0;
        m_nextSongID = 0;
    }
    ~CustomSongWidget() = win inline {
        MusicDownloadManager::sharedState()->removeMusicDownloadDelegate(this);
        CC_SAFE_RELEASE(m_songInfoObject);
    }

    static CustomSongWidget* create(SongInfoObject* songInfo, CustomSongDelegate* songDelegate, bool showSongSelect, bool showPlayMusic, bool showDownload, bool isRobtopSong, bool unkBool, bool isMusicLibrary, int unk) = win 0xc8250;

    virtual void loadSongInfoFinished(SongInfoObject* object);
    virtual void loadSongInfoFailed(int id, GJSongError errorType);
    virtual void downloadSongFinished(int id) = win 0xccf40;
    virtual void downloadSongFailed(int id, GJSongError errorType) = win 0xcd000;
    virtual void downloadSFXFinished(int id);
    virtual void downloadSFXFailed(int id, GJSongError errorType);
    virtual void musicActionFinished(GJMusicAction action) = win 0xcd650;
    virtual void musicActionFailed(GJMusicAction action) = win 0xcd680;
    virtual void songStateChanged() = win 0xcb4e0;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0xcd9f0;

    void addExtraVisuals(bool newMusic, bool newLibraryMusic) = win inline {
        if (newMusic && !newLibraryMusic) {
            auto newMusicIcon = cocos2d::CCSprite::createWithSpriteFrameName("newMusicIcon_001.png");
            this->addChild(newMusicIcon, 4);
            newMusicIcon->setPosition({ -157.f, 20.f });
        }
        if (!newMusic && newLibraryMusic) {
            auto newMusicIcon = cocos2d::CCSprite::createWithSpriteFrameName("newMusicIcon2_001.png");
            this->addChild(newMusicIcon, 4);
            newMusicIcon->setPosition({ -157.f, 20.f });
            auto background = cocos2d::extension::CCScale9Sprite::create("GJ_square07.png", { 0.f, 0.f, 80.f, 80.f });
            background->setColor({ 255, 255, 0 });
            background->setContentSize({ 320.f, 30.f });
            this->addChild(background, -1);
        }
    }
    void deleteSong() = win 0xca040;
    void downloadAssetFailed(int id, GJAssetType type, GJSongError errorType);
    void downloadAssetFinished(int id, GJAssetType type) = win 0xcd4c0;
    void downloadFailed() = win inline {
        m_sliderGroove->setVisible(false);
        this->unschedule(schedule_selector(CustomSongWidget::updateDownloadProgress));
        m_isNotDownloading = true;
        this->updateSongInfo();
    }
    void getSongInfoIfUnloaded() = win 0xcaa00;
    bool init(SongInfoObject* songInfo, CustomSongDelegate* songDelegate, bool showSongSelect, bool showPlayMusic, bool showDownload, bool isRobtopSong, bool unkBool, bool isMusicLibrary, int unk) = win 0xc8490;
    void onCancelDownload(cocos2d::CCObject* sender);
    void onDelete(cocos2d::CCObject* sender) = win 0xc9f20;
    void onDownload(cocos2d::CCObject* sender) = win 0xcabe0;
    void onGetSongInfo(cocos2d::CCObject* sender) = win 0xcab50;
    void onInfo(cocos2d::CCObject* sender) = win 0xc9c30;
    void onMore(cocos2d::CCObject* sender) = win 0xca240;
    void onPlayback(cocos2d::CCObject* sender) = win 0xcaee0;
    void onSelect(cocos2d::CCObject* sender) = win 0xcae80;
    void positionInfoObjects() = win 0x2940b0;
    void processNextMultiAsset();
    void showError(bool fast) = win 0xcd7a0;
    void startDownload() = win 0xcadc0;
    void startMonitorDownload() = win inline {
        this->updateProgressBar(0);
        m_sliderGroove->setVisible(true);
        this->unschedule(schedule_selector(CustomSongWidget::updateDownloadProgress));
        this->schedule(schedule_selector(CustomSongWidget::updateDownloadProgress), 1.f / 30.f);
    }
    void startMultiAssetDownload() = win 0xcd0c0;
    void toggleUpdateButton(bool enabled) = win inline, ios inline {
        m_getSongInfoBtn->setColor(enabled ? cocos2d::ccColor3B { 255, 255, 255 } : cocos2d::ccColor3B { 166, 166, 166 });
        m_getSongInfoBtn->setEnabled(enabled);
    }
    void updateDownloadProgress(float dt) = win 0xcb3b0;
    void updateError(GJSongError errorType) = win 0xcd6d0;
    void updateLengthMod(float lengthMod) = win inline {
        this->m_lengthMod = lengthMod;
        this->updateSongInfo();
    }
    void updateMultiAssetInfo(bool update) = win 0xcc6c0;
    void updatePlaybackBtn() = win 0xcb2c0;
    void updateProgressBar(int progress);
    void updateSongInfo() = win 0xcb510;
    void updateSongObject(SongInfoObject* songInfo) = win inline {
        m_errorLabel->setVisible(false);
        if (m_bgSpr) m_bgSpr->setVisible(false);
        if (m_songInfoObject != songInfo) {
            CC_SAFE_RETAIN(songInfo);
            CC_SAFE_RELEASE(m_songInfoObject);
            m_songInfoObject = songInfo;
        }
        m_customSongID = songInfo ? songInfo->m_songID : 0;
        this->updateSongInfo();
    }
    void updateWithMultiAssets(gd::string songList, gd::string sfxList, int bytes) = win 0xcc370;
    bool verifySongID(int id) = win inline, ios inline {
        return m_customSongID == id && m_customSongID != 0;
    }

    SongInfoObject* m_songInfoObject;
    cocos2d::CCMenu* m_buttonMenu;
    cocos2d::CCLabelBMFont* m_songLabel;
    cocos2d::CCLabelBMFont* m_artistLabel;
    cocos2d::CCLabelBMFont* m_songIDLabel;
    cocos2d::CCLabelBMFont* m_errorLabel;
    CCMenuItemSpriteExtra* m_downloadBtn;
    CCMenuItemSpriteExtra* m_cancelDownloadBtn;
    CCMenuItemSpriteExtra* m_selectSongBtn;
    CCMenuItemSpriteExtra* m_getSongInfoBtn;
    CCMenuItemSpriteExtra* m_playbackBtn;
    CCMenuItemSpriteExtra* m_moreBtn;
    CCMenuItemSpriteExtra* m_deleteBtn;
    CCMenuItemSpriteExtra* m_infoBtn;
    cocos2d::CCSprite* m_sliderGroove;
    cocos2d::CCSprite* m_sliderBar;
    cocos2d::CCSprite* m_ncsLogo;
    cocos2d::extension::CCScale9Sprite* m_bgSpr;
    CustomSongDelegate* m_songDelegate;
    bool m_showSelectSongBtn;
    bool m_showPlayMusicBtn;
    bool m_showDownloadBtn;
    bool m_isNotDownloading;
    bool m_isRobtopSong;
    bool m_isMusicLibrary;
    int m_customSongID;
    float m_lengthMod;
    bool m_isInCell;
    SongPlaybackDelegate* m_playbackDelegate;
    bool m_hasLibrarySongs;
    bool m_hasSFX;
    bool m_unkBool2;
    gd::map<int, bool> m_songs;
    gd::map<int, bool> m_sfx;
    gd::vector<GJAssetDownloadAction> m_undownloadedAssets;
    int m_totalBytes;
    int m_nextSongID;
}

[[link(android)]]
class DailyLevelNode : cocos2d::CCNode, FLAlertLayerProtocol {
    DailyLevelNode() {
        m_level = nullptr;
        m_page = nullptr;
        m_timeLabel = nullptr;
        m_unkBool = false;
        m_needsDownloading = false;
    }
    ~DailyLevelNode() = win inline {
        cocos2d::CCDirector::sharedDirector()->getTouchDispatcher()->unregisterForcePrio(this);
        CC_SAFE_RELEASE(m_level);
    }

    static DailyLevelNode* create(GJGameLevel* level, DailyLevelPage* page, bool isNew) = win inline {
        auto ret = new DailyLevelNode();
        if (ret->init(level, page, isNew)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0xd3180;

    bool init(GJGameLevel* level, DailyLevelPage* page, bool isNew) = win 0xd20e0;
    void onClaimReward(cocos2d::CCObject* sender) = win 0xd2e40;
    void onSkipLevel(cocos2d::CCObject* sender) = win 0xd2f60;
    void showSkipButton() = win 0xd2de0;
    void updateTimeLabel(gd::string text) = win inline, ios inline {
        if (m_timeLabel) m_timeLabel->setString(text.c_str());
    }

    GJGameLevel* m_level;
    DailyLevelPage* m_page;
    cocos2d::CCLabelBMFont* m_timeLabel;
    cocos2d::CCPoint m_unkPoint;
    CCMenuItemSpriteExtra* m_skipButton;
    bool m_unkBool;
    bool m_needsDownloading;
}

[[link(android)]]
class DailyLevelPage : FLAlertLayer, FLAlertLayerProtocol, GJDailyLevelDelegate, LevelDownloadDelegate {
    // virtual ~DailyLevelPage();
    //DailyLevelPage() = ios 0x1c66c0;

    static DailyLevelPage* create(GJTimedLevelType type) = win 0xce420;

    virtual void registerWithTouchDispatcher() = win 0x42660;
    virtual void keyBackClicked() = win 0x869f0;
    virtual void show();
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win inline {}
    virtual void dailyStatusFinished(GJTimedLevelType type) = win 0xcf9b0;
    virtual void dailyStatusFailed(GJTimedLevelType type, GJErrorCode errorType) = win 0xcfcb0;
    virtual void levelDownloadFinished(GJGameLevel* level) = win 0xcffe0;
    virtual void levelDownloadFailed(int response) = win 0xd0040;

    void claimLevelReward(DailyLevelNode* node, GJGameLevel* level, cocos2d::CCPoint position) = win 0xd1b00;
    void createDailyNode(GJGameLevel* level, bool instant, float delay, bool isNew) = win 0xd0290;
    void createNodeIfLoaded() = win 0xd01a0;
    void downloadAndCreateNode() = win 0xd00f0;
    void exitDailyNode(DailyLevelNode* node, float delay) = win 0xd0580;
    int getDailyTime() = win inline {
        __timeb64 current;
        _ftime64_s(&current);
        auto currentTime = ((current.time & 0xfffff) * 1000 + current.millitm) / 1000.0;
        return std::max<int>(GameLevelManager::sharedState()->getDailyTimer(m_type) - currentTime, 0);
    }
    gd::string getDailyTimeString(int timeLeft) = win 0xd0650;
    bool init(GJTimedLevelType type) = win 0xb84b0;
    void onClose(cocos2d::CCObject* sender) = win 0x869b0;
    void onTheSafe(cocos2d::CCObject* sender) = win 0xd2000;
    void refreshDailyPage() = win inline {
        if (auto dailyNode = m_dailyNode) {
            if (dailyNode->m_needsDownloading) return;
            if (auto level = dailyNode->m_level) {
                m_dailyNode = nullptr;
                this->createDailyNode(level, true, 0.f, false);
                dailyNode->removeMeAndCleanup();
            }
        }
    }
    void skipDailyLevel(DailyLevelNode* node, GJGameLevel* level) = win 0xd1dd0;
    void tryGetDailyStatus() = win 0xd0060;
    callback void updateTimers(float dt) = win 0xd17b0;

    cocos2d::CCLabelBMFont* m_timeLabel;
    LoadingCircle* m_timeCircle;
    LoadingCircle* m_nodeCircle;
    bool m_gettingDailyStatus;
    DailyLevelNode* m_dailyNode;
    bool m_downloadStarted;
    GJTimedLevelType m_type;
    int m_downloadLevelID;
}

[[link(android)]]
class DashRingObject : RingObject {
    // virtual ~DashRingObject();
    DashRingObject() {
        m_dashSpeed = 1.f;
        m_endBoost = 1.f;
        m_maxDuration = 0.f;
        m_allowCollide = false;
        m_stopSlide = false;
    }

    static DashRingObject* create(char const* frame) = win inline {
        auto ret = new DashRingObject();
        if (ret->init(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4a2120;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x4a2360;

    bool init(char const* frame) = win inline, ios inline {
        return RingObject::init(frame);
    }

    // property 586
    float m_dashSpeed;
    // property 588
    float m_endBoost;
    // property 590
    float m_maxDuration;
    // property 587
    bool m_allowCollide;
    // property 589
    bool m_stopSlide;
}

[[link(android)]]
class DelayedSpawnNode {
    EffectGameObject* m_gameObject;
    float m_spawnDelay;
}

[[link(android)]]
class DemonFilterDelegate {
    virtual void demonFilterSelectClosed(int filter) {}
}

[[link(android)]]
class DemonFilterSelectLayer : FLAlertLayer {
    DemonFilterSelectLayer() {
        m_demons = nullptr;
        m_unkPtr = nullptr;
        m_currentDemon = 0;
        m_delegate = nullptr;
    }
    ~DemonFilterSelectLayer() = win inline {
        CC_SAFE_RELEASE(m_demons);
    }

    static DemonFilterSelectLayer* create() = win inline {
        auto ret = new DemonFilterSelectLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x3176d0;
    virtual void keyBackClicked() = win 0x317e20;

    void onClose(cocos2d::CCObject* sender) = win 0x317dd0;
    void selectRating(cocos2d::CCObject* sender) = win 0x317d10;

    cocos2d::CCArray* m_demons;
    void* m_unkPtr;
    int m_currentDemon;
    DemonFilterDelegate* m_delegate;
}

[[link(android)]]
class DemonInfoPopup : FLAlertLayer {
    // ~DemonInfoPopup();

    static DemonInfoPopup* create(int easyClassic, int mediumClassic, int hardClassic, int insaneClassic, int extremeClassic, int easyPlatformer, int mediumPlatformer, int hardPlatformer, int insanePlatformer, int extremePlatformer, int weekly, int gauntlet) = win 0x3c6ce0;
    static DemonInfoPopup* createFromString(gd::string str) = win 0x3c6910;

    virtual void keyBackClicked() = win 0x846c0;

    bool init(int easyClassic, int mediumClassic, int hardClassic, int insaneClassic, int extremeClassic, int easyPlatformer, int mediumPlatformer, int hardPlatformer, int insanePlatformer, int extremePlatformer, int weekly, int gauntlet) = win 0x3c6e40;
    void onClose(cocos2d::CCObject* sender) = win 0x84690;
}

[[link(android)]]
class DialogDelegate {
    virtual void dialogClosed(DialogLayer* layer) {}
}

[[link(android)]]
class DialogLayer : cocos2d::CCLayerColor, TextAreaDelegate {
    DialogLayer() {
        m_animateTime = 0.f;
        m_mainLayer = nullptr;
        m_characterLabel = nullptr;
        m_textArea = nullptr;
        m_characterSprite = nullptr;
        m_dialogObjects = nullptr;
        m_touchID = -1;
        m_navButtonSprite = nullptr;
        m_animating = false;
        m_skippable = false;
        m_delegate = nullptr;
        m_handleTap = false;
        m_animationType = DialogAnimationType::FromCenter;
        m_noRemove = false;
    }
    ~DialogLayer() = win inline {
        cocos2d::CCDirector::sharedDirector()->getTouchDispatcher()->unregisterForcePrio(this);
        CC_SAFE_RELEASE(m_dialogObjects);
    }

    static DialogLayer* create(DialogObject* object, int background) = win inline {
        return DialogLayer::createDialogLayer(object, nullptr, background);
    }
    static DialogLayer* createDialogLayer(DialogObject* object, cocos2d::CCArray* objects, int background) = win 0xd34b0;
    static DialogLayer* createWithObjects(cocos2d::CCArray* objects, int background) = win inline {
        return DialogLayer::createDialogLayer(nullptr, objects, background);
    }

    virtual void onEnter();
    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0xd40b0;
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline {}
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event);
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0xd4100;
    virtual void registerWithTouchDispatcher() = win 0x52df0;
    virtual void keyBackClicked() = win 0xd4020;
    virtual void keyDown(cocos2d::enumKeyCodes key) = win 0xd43d0;
    virtual void fadeInTextFinished(TextArea* textArea) = win 0xd4120;

    void addToMainScene() = win 0xd3fc0;
    void animateIn(DialogAnimationType type) = win inline {
        __timeb64 current;
        _ftime64_s(&current);
        m_animateTime = ((current.time & 0xfffff) * 1000 + current.millitm) / 1000.0;
        auto director = cocos2d::CCDirector::sharedDirector();
        switch (type) {
            case DialogAnimationType::FromCenter: {
                m_mainLayer->setScale(.1f);
                m_mainLayer->runAction(cocos2d::CCEaseElasticOut::create(cocos2d::CCScaleTo::create(.5f, 1.f), .6f));
                break;
            }
            case DialogAnimationType::FromLeft: {
                auto position = m_mainLayer->getPosition();
                m_mainLayer->setPosition({ -191.f, position.y });
                m_mainLayer->runAction(cocos2d::CCEaseElasticOut::create(cocos2d::CCMoveTo::create(.5f, position), .6f));
                break;
            }
            case DialogAnimationType::FromRight: {
                auto position = m_mainLayer->getPosition();
                m_mainLayer->setPosition({ director->getScreenRight() + 191.f, position.y });
                m_mainLayer->runAction(cocos2d::CCEaseElasticOut::create(cocos2d::CCMoveTo::create(.5f, position), .6f));
                break;
            }
            case DialogAnimationType::FromTop: {
                auto position = m_mainLayer->getPosition();
                m_mainLayer->setPosition({ position.x, director->getScreenTop() + 51.f });
                m_mainLayer->runAction(cocos2d::CCEaseElasticOut::create(cocos2d::CCMoveTo::create(.5f, position), .6f));
                break;
            }
            case DialogAnimationType::FromTop2: {
                auto position = m_mainLayer->getPosition();
                m_mainLayer->setPosition({ position.x, director->getScreenTop() - 51.f });
                m_mainLayer->runAction(cocos2d::CCEaseElasticOut::create(cocos2d::CCMoveTo::create(.5f, position), .6f));
                break;
            }
            default: break;
        }

        auto opacity = this->getOpacity();
        if (opacity > 0) {
            this->setOpacity(0);
            this->runAction(cocos2d::CCFadeTo::create(.14f, opacity));
        }
    }
    void animateInDialog() = win inline, ios inline {
        this->animateIn(m_animationType);
    }
    void animateInRandomSide() = win 0xd4190;
    void displayDialogObject(DialogObject* object) = win 0xd3ac0;
    void displayNextObject() = win 0xd3a60;
    void finishCurrentAnimation() = win inline {
        m_animating = false;
        if (m_textArea) {
            m_textArea->m_delegate = nullptr;
            m_textArea->stopAllCharacterActions();
            m_textArea->showAll();
        }
        m_navButtonSprite->stopAllActions();
        m_navButtonSprite->setOpacity(255);
        this->updateNavButtonFrame();
    }
    void handleDialogTap() = win 0xd3e90;
    bool init(DialogObject* object, cocos2d::CCArray* objects, int background) = win 0xd3600;
    void onClose() = win 0xd4030;
    void updateChatPlacement(DialogChatPlacement placement) = win inline {
        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
            switch (placement) {
                case DialogChatPlacement::Center:
                        m_mainLayer->setPosition({winSize.width * 0.5F, winSize.height * 0.5F});
                        break;
                case DialogChatPlacement::Top:
                        m_mainLayer->setPosition({winSize.width * 0.5F, (winSize.height - 50.F) - 20.F});
                        break;
                case DialogChatPlacement::Bottom:
                        m_mainLayer->setPosition({winSize.width * 0.5F, 70.F});
                        break;
            }
    }
    void updateNavButtonFrame() = win 0xd3e10;

    float m_animateTime;
    cocos2d::CCLayer* m_mainLayer;
    cocos2d::CCLabelBMFont* m_characterLabel;
    TextArea* m_textArea;
    cocos2d::CCSprite* m_characterSprite;
    cocos2d::CCArray* m_dialogObjects;
    int m_touchID;
    cocos2d::CCSprite* m_navButtonSprite;
    bool m_animating;
    bool m_skippable;
    DialogDelegate* m_delegate;
    bool m_handleTap;
    DialogAnimationType m_animationType;
    bool m_noRemove;
}

[[link(android)]]
class DialogObject : cocos2d::CCObject {
    // virtual ~DialogObject();
    DialogObject() {
        m_characterFrame = 0;
        m_textScale = 1.f;
        m_skippable = false;
    }

    static DialogObject* create(gd::string character, gd::string text, int characterFrame, float textScale, bool skippable, cocos2d::ccColor3B color) = win 0xd32f0;

    bool init(gd::string character, gd::string text, int characterFrame, float textScale, bool skippable, cocos2d::ccColor3B color) = win inline, ios inline {
        m_character = character;
        m_text = text;
        m_characterFrame = characterFrame;
        m_textScale = textScale;
        m_color = color;
        m_skippable = skippable;
        return true;
    }

    gd::string m_text;
    gd::string m_character;
    int m_characterFrame;
    cocos2d::ccColor3B m_color;
    float m_textScale;
    bool m_skippable;
}

[[link(android)]]
class DownloadMessageDelegate {
    virtual void downloadMessageFinished(GJUserMessage* message) {}
    virtual void downloadMessageFailed(int id) {}
}

[[link(android)]]
class DrawGridLayer : cocos2d::CCLayer {
    // virtual ~DrawGridLayer();

    static DrawGridLayer* create(cocos2d::CCNode* parent, LevelEditorLayer* layer) = win 0x2e8950;

    virtual void update(float dt) = win 0x2e8e50;
    virtual void draw() = win 0x2e9050;

    void addAudioLineObject(AudioLineGuideGameObject* object) = win inline, ios inline {
        m_audioLineObjects[object->m_uniqueID] = object;
    }
    void addToEffects(EffectGameObject* object) = win inline {
        if (!m_effectGameObjects->containsObject(object)) {
            m_effectGameObjects->addObject(object);
            m_sortEffects = true;
        }
    }
    void addToGuides(GameObject* object) = win inline {
        if (!m_guideObjects->containsObject(object)) {
            m_guideObjects->addObject(object);
        }
    }
    void addToSpeedObjects(EffectGameObject* object) = win inline {
        if (!m_speedObjects->containsObject(object)) {
            m_speedObjects->addObject(object);
            m_updateSpeedObjects = true;
            object->updateSpeedModType();
        }
    }
    cocos2d::CCPoint getPortalMinMax(GameObject* object) = win inline {
        auto objectType = object->getType();
        float height;
        if (objectType == GameObjectType::BallPortal) height = 240.f;
        else if (objectType == GameObjectType::SpiderPortal) height = 270.f;
        else height = 300.f;
        auto minimum = std::max((int)((object->getPosition().y - height * .5f) / 30.f) * 30.f, 90.f);
        return { minimum, minimum + height };
    }
    bool init(cocos2d::CCNode* parent, LevelEditorLayer* layer) = win inline {
        if (!cocos2d::CCLayer::init()) return false;
        m_objectLayer = parent;
        m_editorLayer = layer;
        m_timeMarkers = nullptr;
        m_effectGameObjects = cocos2d::CCArray::create();
        m_effectGameObjects->retain();
        m_guideObjects = cocos2d::CCArray::create();
        m_guideObjects->retain();
        m_speedObjects = cocos2d::CCArray::create();
        m_speedObjects->retain();
        m_slowSpeed = 251.16008f;
        m_normalSpeed = 311.5801f;
        m_fastSpeed = 387.42014f;
        m_fasterSpeed = 468.00015f;
        m_fastestSpeed = 576.0002f;
        m_currentSpeed = 311.5801f;
        m_pointArray1 = new std::array<cocos2d::CCPoint, 400>();
        m_pointArray2 = new std::array<cocos2d::CCPoint, 400>();
        m_pointArray3 = new std::array<cocos2d::CCPoint, 400>();
        return true;
    }
    void loadTimeMarkers(gd::string markers) = win 0x2e8b30;
    cocos2d::CCPoint posForTime(float time) = win inline, ios inline {
        return LevelTools::posForTime(time, m_speedObjects, (int)m_editorLayer->m_levelSettings->m_startSpeed, m_editorLayer->m_levelSettings->m_platformerMode, m_editorLayer->m_gameState.m_rotateChannel);
    }
    void postUpdate() = win inline, ios inline {
        m_oldPlaybackTime = m_playbackTime;
    }
    void removeAudioLineObject(AudioLineGuideGameObject* object) = win inline, ios inline {
        m_audioLineObjects.erase(object->m_uniqueID);
    }
    void removeFromEffects(EffectGameObject* object) = win inline, ios inline {
        m_effectGameObjects->removeObject(object);
        m_sortEffects = true;
    }
    void removeFromGuides(GameObject* object) = win inline {
        m_guideObjects->removeObject(object);
    }
    void removeFromSpeedObjects(EffectGameObject* object) = win inline {
        if (m_speedObjects->containsObject(object)) {
            m_speedObjects->removeObject(object);
            m_updateSpeedObjects = true;
        }
    }
    void sortSpeedObjects() = win inline, ios inline {
        LevelTools::sortSpeedObjects(m_speedObjects, m_editorLayer);
    }
    float timeForPos(cocos2d::CCPoint position, int order, int channel, bool songTriggers, bool ignoreWarp, bool ignoreRotate, int id) = win inline {
        return LevelTools::timeForPos(position, m_speedObjects, (int)m_editorLayer->m_levelSettings->m_startSpeed, order, channel, songTriggers, m_editorLayer->m_levelSettings->m_platformerMode, ignoreWarp, ignoreRotate, id);
    }
    void updateMusicGuideTime(float time) = win inline {
        m_musicTime = time;
        m_playbackTime = time;
        m_oldPlaybackTime = time;
    }
    void updateTimeMarkers() = win inline {
        m_updateTimeMarkers = true;
        m_updateSpeedObjects = false;
        this->sortSpeedObjects();
        this->loadTimeMarkers(m_timeMarkerString);
    }

    std::array<cocos2d::CCPoint, 400>* m_pointArray1;
    std::array<cocos2d::CCPoint, 400>* m_pointArray2;
    std::array<cocos2d::CCPoint, 400>* m_pointArray3;
    gd::unordered_map<int, AudioLineGuideGameObject*> m_audioLineObjects;
    float m_musicTime;
    float m_playbackTime;
    float m_oldPlaybackTime;
    float m_playbackX;
    float m_playbackY;
    bool m_sortEffects;
    LevelEditorLayer* m_editorLayer;
    gd::string m_timeMarkerString;
    cocos2d::CCNode* m_objectLayer;
    cocos2d::CCArray* m_timeMarkers;
    cocos2d::CCArray* m_effectGameObjects;
    cocos2d::CCArray* m_guideObjects;
    cocos2d::CCArray* m_speedObjects;
    double m_unk258;
    float m_currentSpeed;
    float m_slowSpeed;
    float m_normalSpeed;
    float m_fastSpeed;
    float m_fasterSpeed;
    float m_fastestSpeed;
    bool m_updateTimeMarkers;
    bool m_updateSpeedObjects;
    float m_gridSize;
}

[[link(android)]]
class DungeonBarsSprite : cocos2d::CCNode {
    // virtual ~DungeonBarsSprite();
    DungeonBarsSprite() {
        m_barsSprite = nullptr;
    }

    static DungeonBarsSprite* create() = win inline {
        auto ret = new DungeonBarsSprite();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x3ef470;
    virtual void visit() = win 0x3ef4f0;

    void animateOutBars() = win inline {
        auto a1 = cocos2d::CCMoveBy::create(0.08, { -1.5f, 0.0f });
        auto a2 = cocos2d::CCMoveBy::create(0.08, { 1.5f, 0.0f });
        auto a3 = cocos2d::CCMoveBy::create(0.08, { -1.5f, 0.0f });
        auto a4 = cocos2d::CCMoveBy::create(0.08, { 1.5f, 0.0f });
        auto a5 = cocos2d::CCMoveBy::create(0.08, { -1.5f, 0.0f });
        auto a6 = cocos2d::CCMoveBy::create(0.08, { 1.5f, 0.0f });
        auto a7 = cocos2d::CCMoveBy::create(2.5, { 0.0f, -130.0f });

        auto seq = cocos2d::CCSequence::create(
            a1, a2, a3, a4, a5, a6,
            cocos2d::CCEaseElasticIn::create(a7, 1.6f),
            nullptr
        );
        this->m_barsSprite->runAction(seq);
    }

    cocos2d::CCSprite* m_barsSprite;
}

[[link(android)]]
class DynamicBitset {
    void resize(size_t size) = win 0x3a49b0 {
        m_bits.resize(size / 32 + 1);
    }

    gd::vector<unsigned int> m_bits;
}

[[link(android)]]
class DynamicScrollDelegate {
    virtual void updatePageWithObject(cocos2d::CCObject* layer, cocos2d::CCObject* object) {}
}

[[link(android)]]
class EditButtonBar : cocos2d::CCNode {
    // virtual ~EditButtonBar();

    static EditButtonBar* create(cocos2d::CCArray* objects, cocos2d::CCPoint position, int tab, bool hasCreateItems, int columns, int rows) = win 0xd4490;

    int getPage() = win inline {
        return m_scrollLayer->getRelativePageForNum(m_scrollLayer->m_page);
    }
    void goToPage(int page) = win 0xd4f10;
    bool init(cocos2d::CCArray* objects, cocos2d::CCPoint position, int tab, bool hasCreateItems, int columns, int rows) = win inline {
        if (!cocos2d::CCNode::init()) return false;
        m_buttonArray = cocos2d::CCArray::create();
        m_buttonArray->retain();
        m_buttonArray->addObjectsFromArray(objects);
        m_pagesArray = cocos2d::CCArray::create();
        m_pagesArray->retain();
        m_position = position;
        m_tabIndex = tab;
        m_hasCreateItems = hasCreateItems;
        this->loadFromItems(m_buttonArray, rows, columns, false);
        return true;
    }
    void loadFromItems(cocos2d::CCArray* objects, int rows, int columns, bool keepPage) = win 0xd45f0;
    void onLeft(cocos2d::CCObject* sender) = win 0xd4fe0;
    void onRight(cocos2d::CCObject* sender) = win 0xd4f70;
    void reloadItems(int rowCount, int columnCount) = win inline {
        if (m_buttonArray) this->loadFromItems(m_buttonArray, rowCount, columnCount, false);
    }

    cocos2d::CCPoint m_position;
    int m_tabIndex;
    bool m_hasCreateItems;
    cocos2d::CCArray* m_buttonArray;
    BoomScrollLayer* m_scrollLayer;
    cocos2d::CCArray* m_pagesArray;
}

[[link(android)]]
class EditGameObjectPopup : SetupTriggerPopup {
    // virtual ~EditGameObjectPopup();
    EditGameObjectPopup() {}

    static EditGameObjectPopup* create(EffectGameObject* object, cocos2d::CCArray* objects, bool platformer) = win inline {
        auto ret = new EditGameObjectPopup();
        if (ret->init(object, objects, platformer)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init(EffectGameObject* object, cocos2d::CCArray* objects, bool platformer) = win 0x29ada0;
}

[[link(android)]]
class EditLevelLayer : cocos2d::CCLayer, TextInputDelegate, FLAlertLayerProtocol, UploadActionDelegate, UploadPopupDelegate, SetIDPopupDelegate {
    EditLevelLayer() {
        m_buttonMenu = nullptr;
        m_level = nullptr;
        m_textInputs = nullptr;
        m_folderLabel = nullptr;
        m_exiting = false;
        m_levelType = GJLevelType::Default;
        m_descriptionPopup = nullptr;
    }
    ~EditLevelLayer() = win inline {
        CC_SAFE_RELEASE(m_textInputs);
        CC_SAFE_RELEASE(m_level);
        CC_SAFE_RELEASE(m_descriptionPopup);
        auto glm = GameLevelManager::sharedState();
        if (glm->m_uploadActionDelegate == this) glm->m_uploadActionDelegate = nullptr;
    }

    static EditLevelLayer* create(GJGameLevel* level) = win inline {
        auto ret = new EditLevelLayer();
        if (ret && ret->init(level)) {
            ret->autorelease();
            return ret;
        }
        CC_SAFE_DELETE(ret);
        return nullptr;
    }
    static cocos2d::CCScene* scene(GJGameLevel* level) = win 0xd52d0;

    virtual void keyBackClicked() = win 0xd9ac0;
    virtual void keyDown(cocos2d::enumKeyCodes key) = win 0xd9ad0;
    virtual void setIDPopupClosed(SetIDPopup* popup, int value);
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0xd8c60;
    virtual void textInputOpened(CCTextInputNode* node) = win 0xd7b10;
    virtual void textInputClosed(CCTextInputNode* node) = win 0xd7510;
    virtual void textChanged(CCTextInputNode* node) = win 0xd7c80;
    virtual void uploadActionFinished(int id, int response) = win 0xd9b40;
    virtual void uploadActionFailed(int id, int response) = win 0xd9c80;
    virtual void onClosePopup(UploadActionPopup* popup);

    void closeTextInputs() = win 0xd74b0;
    void confirmClone(cocos2d::CCObject* sender);
    void confirmDelete(cocos2d::CCObject* sender);
    void confirmMoveToTop(cocos2d::CCObject* sender);
    bool init(GJGameLevel* level) = win 0xd5460;
    void onBack(cocos2d::CCObject* sender) = win 0xd9630;
    void onClone() = win inline {
        auto director = cocos2d::CCDirector::sharedDirector();
        if (director->getIsTransitioning() || m_exiting) return;
        this->setKeypadEnabled(false);
        m_exiting = true;
        GameManager::sharedState()->m_sceneEnum = 2;
        auto level = GameLevelManager::sharedState()->createNewLevel();
        level->copyLevelInfo(m_level);
        this->verifyLevelName();
        level->m_originalLevel = m_level->m_originalLevel;
        director->replaceScene(cocos2d::CCTransitionFade::create(.5f, EditLevelLayer::scene(level)));
    }
    void onDelete() = win inline {
        m_buttonMenu->setEnabled(false);
        GameLevelManager::sharedState()->deleteLevel(m_level);
        this->onBack(nullptr);
    }
    void onEdit(cocos2d::CCObject* sender) = win 0xd82d0;
    void onGuidelines(cocos2d::CCObject* sender) = win 0xd6830;
    void onHelp(cocos2d::CCObject* sender);
    void onLevelInfo(cocos2d::CCObject* sender) = win 0xd6a50;
    void onLevelLeaderboard(cocos2d::CCObject* sender);
    void onLevelOptions(cocos2d::CCObject* sender);
    void onMoveToTop() = win inline, ios inline {
        LocalLevelManager::sharedState()->moveLevelToTop(m_level);
    }
    void onPlay(cocos2d::CCObject* sender) = win 0xd7e70;
    void onSetFolder(cocos2d::CCObject* sender) = win 0xd9510;
    void onShare(cocos2d::CCObject* sender) = win 0xd8470;
    void onTest(cocos2d::CCObject* sender) = win inline, ios inline {
        this->closeTextInputs();
        GameManager::sharedState()->m_sceneEnum = 3;
        cocos2d::CCDirector::sharedDirector()->replaceScene(cocos2d::CCTransitionFade::create(.5f, PlayLayer::scene(m_level, false, false)));
    }
    void onUpdateDescription(cocos2d::CCObject* sender);
    void playStep2();
    void playStep3();
    void setupLevelInfo() = win 0xd6c70;
    void updateDescText(char const* text) = win inline, ios inline {}
    void verifyLevelName() = win 0xd97e0;

    cocos2d::CCMenu* m_buttonMenu;
    GJGameLevel* m_level;
    cocos2d::CCArray* m_textInputs;
    cocos2d::CCLabelBMFont* m_folderLabel;
    bool m_exiting;
    GJLevelType m_levelType;
    gd::string m_levelName;
    UploadActionPopup* m_descriptionPopup;
}

[[link(android)]]
class EditorOptionsLayer : GJOptionsLayer {
    // virtual ~EditorOptionsLayer();
    EditorOptionsLayer() {
        m_buttonsPerRow = 0;
        m_buttonRows = 0;
    }

    static EditorOptionsLayer* create() = win inline {
        auto ret = new EditorOptionsLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x290ea0;
    virtual void onClose(cocos2d::CCObject* sender) = win 0x2918f0;
    virtual void setupOptions() = win 0x290ed0;

    void onButtonRows(cocos2d::CCObject* sender) = win 0x291860;
    void onButtonsPerRow(cocos2d::CCObject* sender) = win 0x2917d0;

    int m_buttonsPerRow;
    int m_buttonRows;
    cocos2d::CCLabelBMFont* m_buttonsPerRowLabel;
    cocos2d::CCLabelBMFont* m_buttonRowsLabel;
}

[[link(android)]]
class EditorPauseLayer : CCBlockLayer, FLAlertLayerProtocol {
    // virtual ~EditorPauseLayer();
    EditorPauseLayer() {
        m_saved = false;
        m_guidelinesOffButton = nullptr;
        m_guidelinesOnButton = nullptr;
        m_editorLayer = nullptr;
    }

    static EditorPauseLayer* create(LevelEditorLayer* layer) = win inline {
        auto ret = new EditorPauseLayer();
        if (ret && ret->init(layer)) {
            ret->autorelease();
            return ret;
        }
        CC_SAFE_DELETE(ret);
        return nullptr;
    }

    virtual void keyBackClicked();
    virtual void keyDown(cocos2d::enumKeyCodes key) = win 0xde630;
    virtual void customSetup() = win 0xda570;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0xde500;

    void doResetUnused() = win inline, ios inline {
        m_editorLayer->resetUnusedColorChannels();
    }
    bool init(LevelEditorLayer* layer) = win 0xd9ee0;
    void onAlignX(cocos2d::CCObject* sender);
    void onAlignY(cocos2d::CCObject* sender);
    void onBuildHelper(cocos2d::CCObject* sender);
    void onCopyWColor(cocos2d::CCObject* sender);
    void onCreateExtras(cocos2d::CCObject* sender);
    void onCreateLoop(cocos2d::CCObject* sender);
    void onCreateTemplate(cocos2d::CCObject* sender) = win inline, ios inline {
        auto objects = cocos2d::CCArray::create();
        auto lel = GameManager::sharedState()->m_levelEditorLayer;
        if (auto selectedObject = lel->m_editorUI->m_selectedObject) {
            objects->addObject(selectedObject);
        }
        else if (auto selectedObjects = lel->m_editorUI->getSelectedObjects()) {
            objects->addObjectsFromArray(selectedObjects);
        }
    }
    void onExitEditor(cocos2d::CCObject* sender) = win 0xde2c0;
    void onExitNoSave(cocos2d::CCObject* sender) = win 0xde390;
    void onHelp(cocos2d::CCObject* sender);
    void onKeybindings(cocos2d::CCObject* sender);
    void onNewGroupX(cocos2d::CCObject* sender);
    void onNewGroupY(cocos2d::CCObject* sender);
    void onOptions(cocos2d::CCObject* sender) = win 0xdc8e0;
    void onPasteWColor(cocos2d::CCObject* sender);
    void onReGroup(cocos2d::CCObject* sender);
    void onResetUnusedColors(cocos2d::CCObject* sender) = win 0xdcb10;
    void onResume(cocos2d::CCObject* sender) = win 0xdd690;
    void onSave(cocos2d::CCObject* sender) = win 0xde150;
    void onSaveAndExit(cocos2d::CCObject* sender) = win 0xde280;
    void onSaveAndPlay(cocos2d::CCObject* sender) = win 0xddf00;
    void onSelectAll(cocos2d::CCObject* sender) = win 0xdcdc0;
    void onSelectAllLeft(cocos2d::CCObject* sender);
    void onSelectAllRight(cocos2d::CCObject* sender);
    void onSong(cocos2d::CCObject* sender);
    void onUnlockAllLayers(cocos2d::CCObject* sender) = win 0xdcc70;
    void playStep2() = win 0xddf80;
    void playStep3() = win 0xde0b0;
    void saveLevel() = win 0xdd860;
    void toggleDebugDraw(cocos2d::CCObject* sender);
    void toggleEditorBackground(cocos2d::CCObject* sender) = win inline, ios inline {
        auto gameManager = GameManager::sharedState();
        gameManager->toggleGameVariable("0078");
        m_editorLayer->toggleBackground(!gameManager->getGameVariable("0078"));
    }
    void toggleEditorColorMode(cocos2d::CCObject* sender);
    void toggleEditorGrid(cocos2d::CCObject* sender);
    void toggleEditorGround(cocos2d::CCObject* sender);
    void toggleEffectDuration(cocos2d::CCObject* sender) = win inline, ios inline {
        GameManager::sharedState()->toggleGameVariable("0058");
    }
    void toggleEffectLines(cocos2d::CCObject* sender) = win inline, ios inline {
        GameManager::sharedState()->toggleGameVariable("0043");
    }
    void toggleFollowPlayer(cocos2d::CCObject* sender) = win inline, ios inline {
        GameManager::sharedState()->toggleGameVariable("0001");
    }
    void toggleGridOnTop(cocos2d::CCObject* sender) = win inline, ios inline {
        auto gameManager = GameManager::sharedState();
        gameManager->toggleGameVariable("0039");
        m_editorLayer->m_drawGridLayer->getParent()->reorderChild(m_editorLayer->m_drawGridLayer, gameManager->getGameVariable("0039") ? 1399 : -1599);
    }
    void toggleHideInvisible(cocos2d::CCObject* sender);
    void toggleIgnoreDamage(cocos2d::CCObject* sender);
    void togglePlaytestMusic(cocos2d::CCObject* sender) = win inline, ios inline {
        GameManager::sharedState()->toggleGameVariable("0002");
    }
    void togglePreviewAnim(cocos2d::CCObject* sender) = win 0xdd160;
    void togglePreviewParticles(cocos2d::CCObject* sender);
    void togglePreviewShaders(cocos2d::CCObject* sender);
    void toggleRecordOrder(cocos2d::CCObject* sender) = win inline, ios inline {
        GameManager::sharedState()->toggleGameVariable("0104");
    }
    void toggleSelectFilter(cocos2d::CCObject* sender);
    void toggleShowObjectInfo(cocos2d::CCObject* sender);
    void uncheckAllPortals(cocos2d::CCObject* sender) = win 0xdca30;
    void updateSongButton() = win 0xdd5e0;

    bool m_saved;
    CCMenuItemSpriteExtra* m_guidelinesOffButton;
    CCMenuItemSpriteExtra* m_guidelinesOnButton;
    LevelEditorLayer* m_editorLayer;
    PAD = win 0x20, android32 0x10, android64 0x20, imac 0x20, m1 0x20, ios 0x20;
}

[[link(android), depends(GameObjectEditorState), depends(GJTransformState)]]
class EditorUI : cocos2d::CCLayer, FLAlertLayerProtocol, ColorSelectDelegate, GJRotationControlDelegate, GJScaleControlDelegate, GJTransformControlDelegate, MusicDownloadDelegate, SetIDPopupDelegate {
    EditorUI() = win 0xdea00;
    ~EditorUI() = win inline {
        CC_SAFE_RELEASE(m_selectedObjects);
        CC_SAFE_RELEASE(m_deleteObjects);
        CC_SAFE_RELEASE(m_createButtonArray);
        CC_SAFE_RELEASE(m_customObjectButtonArray);
        CC_SAFE_RELEASE(m_createButtonBars);
        CC_SAFE_RELEASE(m_tabsArray);
        CC_SAFE_RELEASE(m_editButtonDict);
        CC_SAFE_RELEASE(m_rotationControl);
        CC_SAFE_RELEASE(m_scaleControl);
        CC_SAFE_RELEASE(m_transformControl);
        CC_SAFE_RELEASE(m_snapPositions);
        CC_SAFE_RELEASE(m_uiItems);
        CC_SAFE_RELEASE(m_customTabControls);
    }

    static EditorUI* create(LevelEditorLayer* editorLayer) = win inline {
        auto ret = new EditorUI();
        if (ret->init(editorLayer)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static EditorUI* get() {
        auto lel = LevelEditorLayer::get();
        if (!lel) return nullptr;
        return lel->m_editorUI;
    }
    static int getRandomStartKey(int specialTemplate) = win 0x12d560;
    static int getSmartObjectKey(int key, GJSmartDirection direction) = win 0x12d800;
    static int smartTypeForKey(int key) = win 0x12d4c0;

    virtual void draw() = win 0x122d10;
    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x123850;
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x123ed0;
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x124620;
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event);
    virtual void registerWithTouchDispatcher() = win 0x9b7f0;
    virtual void keyBackClicked();
    virtual void keyDown(cocos2d::enumKeyCodes key) = win 0x125360;
    virtual EditorUI* getUI() = win 0xdee40 { return this; }
    virtual void setIDPopupClosed(SetIDPopup* popup, int value) = win 0xe6c90;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0xe6a90;
    virtual void updateTransformControl() = win 0x115440;
    virtual void transformChangeBegin() = win 0x115930;
    virtual void transformChangeEnded() = win inline {}
    virtual cocos2d::CCNode* getTransformNode();
    virtual void transformScaleXChanged(float scaleX) = win 0x121860;
    virtual void transformScaleYChanged(float scaleY) = win 0x121880;
    virtual void transformScaleXYChanged(float scaleX, float scaleY) = win 0x1218a0;
    virtual void transformSkewXChanged(float skewX) = win 0x1218c0;
    virtual void transformSkewYChanged(float skewY) = win 0x1218e0;
    virtual void transformRotationXChanged(float rotationX) = win 0x121900;
    virtual void transformRotationYChanged(float rotationY) = win 0x121920;
    virtual void transformRotationChanged(float rotation) = win 0x121940;
    virtual void transformResetRotation() = win 0x121960;
    virtual void transformRestoreRotation() = win 0x121990;
    virtual void songStateChanged() = win 0x1120e0;
    virtual void colorSelectClosed(cocos2d::CCNode* popup) = win 0x11f730;
    virtual void keyUp(cocos2d::enumKeyCodes key) = win 0x1267f0;
    virtual void scrollWheel(float y, float x) = win 0x126830;
    virtual void angleChangeBegin() = win 0x123150;
    virtual void angleChangeEnded() = win inline {}
    virtual void angleChanged(float rotation) = win 0x123160;
    virtual void updateScaleControl() = win 0x114e30;
    virtual void anchorPointMoved(cocos2d::CCPoint anchorPoint) = win 0x115940;
    virtual void scaleChangeBegin() = win 0x114f90;
    virtual void scaleChangeEnded() = win inline {}
    virtual void scaleXChanged(float scaleX, bool lock);
    virtual void scaleYChanged(float scaleY, bool lock);
    virtual void scaleXYChanged(float scaleX, float scaleY, bool lock) = win 0x115100;

    void activateRotationControl(cocos2d::CCObject* sender) = win 0x123010;
    void activateScaleControl(cocos2d::CCObject* sender) = win 0x114b60;
    void activateTransformControl(cocos2d::CCObject* sender) = win 0x1151b0;
    void addObjectsToSmartTemplate(GJSmartTemplate* smartTemplate, cocos2d::CCArray* objects) = win 0x115c70;
    void addSnapPosition(cocos2d::CCPoint position) = win inline, ios inline {
        auto node = cocos2d::CCNode::create();
        node->setPosition(position);
        m_snapPositions->addObject(node);
    }
    void alignObjects(cocos2d::CCArray* objects, bool axisY) = win 0x121f60;
    void applyOffset(GameObject* object);
    cocos2d::CCPoint applySpecialOffset(cocos2d::CCPoint position, GameObject* object, cocos2d::CCPoint offset) = win 0x1226a0;
    bool arrayContainsClass(cocos2d::CCArray* objects, int classType) = win inline {
        for (int i = 0; i < objects->count(); i++) {
            if ((int)static_cast<GameObject*>(objects->objectAtIndex(i))->m_classType == classType) return true;
        }
        return false;
    }
    void assignNewGroups(bool groupY);
    bool canAllowMultiActivate(GameObject* object, cocos2d::CCArray* objects) = win inline {
        if (object) {
            return object->canAllowMultiActivate();
        }
        else {
            for (int i = 0; i < objects->count(); i++) {
                auto obj = static_cast<GameObject*>(objects->objectAtIndex(i));
                if (!obj->canAllowMultiActivate()) {
                    return false;
                }
            }
            return true;
        }
    }
    bool canSelectObject(GameObject* object) = win 0x110350;
    void centerCameraOnObject(GameObject* object) = win inline {
        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        auto scale = m_editorLayer->m_objectLayer->getScale();
        m_editorLayer->m_objectLayer->setPosition(winSize * .5f - object->getPosition() * scale);
        this->constrainGameLayerPosition();
    }
    void changeSelectedObjects(cocos2d::CCArray* objects, bool ignoreFilter) = win inline {
        this->deselectAll();
        if (objects->count() == 0) return;
        this->selectObjects(objects, ignoreFilter);
        m_canActivateControls = true;
        this->updateObjectInfoLabel();
        this->updateScaleControl();
    }
    void checkDiffAfterTransformAnchor(cocos2d::CCPoint diff, cocos2d::CCArray* objects) = win 0x1159c0;
    void checkLiveColorSelect() = win 0x110670;
    void clickOnPosition(cocos2d::CCPoint position) = win 0xe2720;
    void closeLiveColorSelect() = ios inline {
        if (m_colorOverlay) {
            m_colorOverlay->closeColorSelect(nullptr);
            m_colorOverlay = nullptr;
        }
    }
    void closeLiveHSVSelect() = ios inline {
        if (m_hsvOverlay) {
            m_hsvOverlay->closeColorSelect(nullptr);
            m_hsvOverlay = nullptr;
        }
    }
    void colorSelectClosed(cocos2d::ccColor3B color) = win inline, ios inline {}
    void constrainGameLayerPosition() = win inline, ios inline {
        this->constrainGameLayerPosition(-100.f, -100.f);
    }
    void constrainGameLayerPosition(float x, float y) = win 0x1229c0;
    int convertKeyBasedOnNeighbors(int smartKey, int objectID, cocos2d::CCPoint position, cocos2d::CCArray* objects) = win 0x12def0;
    int convertToBaseKey(int objectID) = win 0x12ddf0;
    gd::string copyObjects(cocos2d::CCArray* objects, bool copyColors, bool sort) = win 0x112e40;
    gd::string copyObjectsDetailed(cocos2d::CCArray* objects) = win inline {
        qsort(objects->data->arr, objects->data->num, sizeof(GameObject*), [](void const* a, void const* b) {
            auto objA = *static_cast<GameObject* const*>(a);
            auto objB = *static_cast<GameObject* const*>(b);
            return objA->m_uniqueID - objB->m_uniqueID;
        });
        auto groupCenter = this->getGroupCenter(objects, false);
        std::string result = "";
        CCObject* obj;
        CCARRAY_FOREACH(objects, obj) {
            auto object = static_cast<GameObject*>(obj);
            if (object->m_objectID == 749) continue;
            auto position = object->getPosition();
            object->setPosition(position - groupCenter);
            result += object->getSaveString(m_editorLayer) + ";";
            object->setPosition(position);
        }
        return result;
    }
    cocos2d::CCArray* createCustomItems() = win 0xe47c0;
    GameObject* createEdgeForObject(GameObject* object, int type) = win 0x12e6d0;
    void createExtraObject(int id, cocos2d::CCPoint position, GameObject* object, cocos2d::CCArray* objects, int zOrder, int editorLayer) = win 0x132cc0;
    cocos2d::CCArray* createExtras(cocos2d::CCArray* objects) = win inline {
        if (!objects || objects->count() == 0) return nullptr;
        auto extras = cocos2d::CCArray::create();
        for (int i = 0; i < objects->count(); i++) {
            auto object = static_cast<GameObject*>(objects->objectAtIndex(i));
            if (object->m_objectID > 2807 && object->m_objectID < 2838) {
                this->createExtrasForObject(object->m_objectID, object, extras);
            }
        }
        return extras;
    }
    void createExtrasForObject(int id, GameObject* object, cocos2d::CCArray* objects) = win 0x12ff60;
    void createGlow() = win inline, ios inline {}
    void createLoop();
    void createMoveMenu() = win 0x11ad70;
    void createNewKeyframeAnim() = win 0x1193d0;
    GameObject* createObject(int objectID, cocos2d::CCPoint position) = win 0x10ff60;
    cocos2d::CCArray* createOutlines(cocos2d::CCArray* objects) = win 0x12ed30;
    void createPrefab(GJSmartTemplate* smartTemplate, gd::string key, int id) = win 0x1179e0;
    cocos2d::CCArray* createRockBases(cocos2d::CCArray* objects) = win 0x12f630;
    cocos2d::CCArray* createRockEdges(cocos2d::CCArray* objects) = win 0x12e360;
    void createSmartObjectsFromTemplate(GJSmartTemplate* smartTemplate, cocos2d::CCArray* objects, bool useNearby, bool dontDelete, bool referenceOnly, bool dontPaste);
    void createSmartObjectsFromType(int type, cocos2d::CCArray* objects, bool extras, bool dontDelete);
    UndoObject* createUndoObject(UndoCommand command, bool addToList) = win 0x110f70;
    void createUndoSelectObject(bool redo) = win 0x111290;
    void deactivateRotationControl() = win inline {
        m_rotationTouchID = -1;
        if (m_rotationControl->isVisible()) {
            m_rotationControl->setVisible(false);
            m_rotationControl->finishTouch();
        }
    }
    void deactivateScaleControl() = win 0x114d60;
    void deactivateTransformControl() = win 0x1153b0;
    void deleteObject(GameObject* object, bool noUndo) = win inline {
        if (!object) return;
        object->m_wasSelected = object->m_isSelected;
        m_editorLayer->removeObject(object, noUndo);
        this->deactivateRotationControl();
        this->deactivateScaleControl();
        this->deactivateTransformControl();
    }
    void deleteSmartBlocksFromObjects(cocos2d::CCArray* objects) = win 0x117df0;
    void deleteTypeFromObjects(int id, cocos2d::CCArray* objects) = win inline {
        for (int i = 0; i < objects->count(); i++) {
            auto obj = static_cast<GameObject*>(objects->objectAtIndex(i));
            if (obj->m_objectID != id) continue;
            if (obj->m_linkedGroup > 0) {
                if (auto stickyGroup = m_editorLayer->getStickyGroup(obj->m_linkedGroup)) stickyGroup->removeObject(obj, true);
            }
            this->deleteObject(obj, true);
            objects->removeObjectAtIndex(i, true);
        }
    }
    void deselectAll() = win 0x1114c0;
    void deselectObject() = win inline {
        this->stopActionByTag(124);
        if (m_selectedObject) m_selectedObject->deselectObject();
        m_selectedObject = nullptr;
        this->toggleEditObjectButton();
        m_canActivateControls = true;
        m_lastTouchPoint = cocos2d::CCPoint { 0.f, 0.f };
    }
    void deselectObject(GameObject* object) = win 0x1113a0;
    void deselectObjectsColor() = win 0x1107d0;
    void deselectTargetPortals() = win 0xe68b0;
    void disableButton(CreateMenuItem* button) = win inline {
        auto sprite = static_cast<ButtonSprite*>(button->getNormalImage());
        if (sprite->m_subBGSprite) sprite->m_subBGSprite->setColor({ 127, 127, 127 });
        else if (sprite->m_BGSprite) sprite->m_BGSprite->setColor({ 127, 127, 127 });
        if (button->m_objectID < 0) return;
        auto object = static_cast<EffectGameObject*>(sprite->m_subSprite);
        if (object->m_classType == GameObjectClassType::Effect && object->isColorObject() && object->m_shouldPreview) {
            object->setObjectColor({ 127, 100, 100 });
        }
        else {
            object->setObjectColor({ 127, 127, 127 });
        }
        object->setChildColor({ 127, 100, 100 });
    }
    void doCopyObjects(bool withColor) = win 0x1131e0;
    void doPasteInPlace(bool withColor) = win inline, ios inline {
        auto& clipboard = GameManager::sharedState()->m_editorClipboard;
        if (clipboard.empty()) return;
        this->pasteObjects(clipboard, withColor, false);
        this->updateButtons();
        this->updateObjectInfoLabel();
    }
    void doPasteObjects(bool withColor) = win 0x113370;
    void dynamicGroupUpdate(bool reGroup) = win 0x1188f0;
    int edgeForObject(int id, int type) = win inline {
        if (id == 1348) {
            switch (type) {
                case 0: return 1359;
                case 3: return 1395;
                case 7: return 1363;
            }
        }
        else if (id == 1349) {
            switch (type) {
                case 0: return 1360;
                case 1: return 1357;
                case 4: return 1364;
            }
        }
        else if (id == 1350) {
            switch (type) {
                case 2: return 1361;
                case 3: return 1356;
                case 6: return 1365;
            }
        }
        else if (id == 1351) {
            switch (type) {
                case 1: return 1358;
                case 2: return 1362;
                case 5: return 1366;
            }
        }
        else if (id == 1431 || id == 1432 || id == 1433) {
            switch (type) {
                case 0: return 1435;
                case 1: return 1436;
                case 2: return 1437;
                case 3: return 1434;
                case 4: return 1439;
                case 5: return 1441;
                case 6: return 1440;
                case 7: return 1438;
            }
        }
        else if (id == 1461) {
            switch (type) {
                case 0: return 1629;
                case 1: return 1625;
                case 2: return 1633;
                case 3: return 1621;
                case 4: return 1638;
                case 5: return 1640;
                case 6: return 1639;
                case 7: return 1637;
            }
        }
        else if (id == 1462) {
            switch (type) {
                case 0: return 1630;
                case 1: return 1627;
                case 2: return 1634;
                case 3: return 1623;
                case 4: return 1642;
                case 5: return 1644;
                case 6: return 1643;
                case 7: return 1641;
            }
        }
        else if (id == 1463) {
            switch (type) {
                case 0: return 1631;
                case 1: return 1626;
                case 2: return 1635;
                case 3: return 1622;
                case 4: return 1646;
                case 5: return 1648;
                case 6: return 1647;
                case 7: return 1645;
            }
        }
        else if (id == 1464) {
            switch (type) {
                case 0: return 1632;
                case 1: return 1628;
                case 2: return 1636;
                case 3: return 1624;
                case 4: return 1650;
                case 5: return 1652;
                case 6: return 1651;
                case 7: return 1649;
            }
        }
        return 0;
    }
    bool editButton2Usable() = win 0x11a560;
    bool editButtonUsable() = win 0x119d10;
    void editColor() = win 0x11edd0;
    bool editColorButtonUsable() = win inline, ios inline {
        return m_selectedObject || m_selectedObjects->count() != 0;
    }
    void editGroup(cocos2d::CCObject* sender);
    void editHSV() = win 0x11f050;
    void editObject(cocos2d::CCObject* sender) = win 0x11bf30;
    void editObject2(cocos2d::CCObject* sender);
    void editObject3(cocos2d::CCObject* sender) = win inline, ios inline {
        this->editObjectSpecial(1);
    }
    void editObjectSpecial(int type) = win 0x11ded0;
    int editorLayerForArray(cocos2d::CCArray* objects, bool layer2) = win inline {
        if (!objects) return 0;
        auto previousLayer = -1;
        auto currentLayer = -1;
        for (int i = 0; i < objects->count(); i++) {
            auto obj = static_cast<GameObject*>(objects->objectAtIndex(i));
            currentLayer = layer2 ? obj->m_editorLayer2 : obj->m_editorLayer;
            if (previousLayer != -1 && previousLayer != currentLayer) return 0;
            previousLayer = currentLayer;
        }
        return currentLayer != -1 ? currentLayer : 0;
    }
    void enableButton(CreateMenuItem* button) = win inline {
        auto sprite = static_cast<ButtonSprite*>(button->getNormalImage());
        if (sprite->m_subBGSprite) sprite->m_subBGSprite->setColor({ 255, 255, 255 });
        else if (sprite->m_BGSprite) sprite->m_BGSprite->setColor({ 255, 255, 255 });
        if (button->m_objectID < 0) return;
        auto object = static_cast<EffectGameObject*>(sprite->m_subSprite);
        if (object->m_classType == GameObjectClassType::Effect && object->isColorObject() && object->m_shouldPreview) {
            object->setObjectColor({ 200, 200, 255 });
        }
        else {
            auto objectID = object->m_objectID;
            if (objectID == 918 || objectID == 919 || (objectID != 1584 && objectID != 2012) && object->getMainColorMode() != 1010) {
                object->setObjectColor({ 255, 255, 255 });
            }
            else {
                object->setObjectColor({ 0, 0, 0 });
            }
        }
        object->setChildColor({ 200, 200, 255 });
    }
    void findAndSelectObject(int id, bool useUniqueID) = win 0xe6f20;
    void findSnapObject(cocos2d::CCArray* objects, float offset) = win 0x123380;
    void findSnapObject(cocos2d::CCPoint position, float offset) = win 0x123280;
    void findTriggerTest() = win inline, ios inline {
        auto objects = m_editorLayer->getAllObjects();
        for (int i = 0; i < objects->count(); i++) {
            auto obj = static_cast<GameObject*>(objects->objectAtIndex(i));
        }
    }
    void flipObjectsX(cocos2d::CCArray* objects);
    void flipObjectsY(cocos2d::CCArray* objects);
    CCMenuItemSpriteExtra* getButton(char const* text, int width, cocos2d::SEL_MenuHandler selector, cocos2d::CCMenu* menu) = win inline, ios inline {
        auto sprite = ButtonSprite::create(text, width, 0, 1.f, true, "goldFont.fnt", "GJ_button_01.png", 0.f);
        auto button = CCMenuItemSpriteExtra::create(sprite, this, selector);
        if (menu) menu->addChild(button);
        return button;
    }
    CreateMenuItem* getCreateBtn(int id, int bg) = win 0x10e9c0;
    CreateMenuItem* getCreateMenuItemButton(cocos2d::CCSprite* sprite, cocos2d::SEL_MenuHandler selector, cocos2d::CCMenu* menu, float scale, int background, cocos2d::CCPoint offset) = win inline {
        const char* backgroundImage;
        switch (background) {
            case 2: backgroundImage = "GJ_button_02.png"; break;
            case 3: backgroundImage = "GJ_button_03.png"; break;
            case 4: backgroundImage = "GJ_button_04.png"; break;
            case 5: backgroundImage = "GJ_button_05.png"; break;
            case 6: backgroundImage = "GJ_button_06.png"; break;
            default: backgroundImage = "GJ_button_01.png"; break;
        }
        auto buttonSprite = ButtonSprite::create(sprite, 32, 0, 32.f, 1.f, true, backgroundImage, true);
        auto button = CreateMenuItem::create(buttonSprite, nullptr, this, selector);
        button->setScale(scale);
        button->m_baseScale = scale;
        if (menu) menu->addChild(button);
        buttonSprite->updateSpriteOffset(offset);
        return button;
    }
    GameObject* getCycledObject(cocos2d::CCArray* objects, bool dontSkipSelected) = win inline {
        GameObject* cycledObject = nullptr;
        for (int i = 0; i < objects->count(); i++) {
            auto obj = static_cast<GameObject*>(objects->objectAtIndex(i));
            if ((!dontSkipSelected && obj->m_isSelected) || (cycledObject && cycledObject->m_unk460 <= obj->m_unk460 )) break;
            if (this->canSelectObject(obj)) cycledObject = obj;
        }
        if (cycledObject) cycledObject->m_unk460 = m_cycledObjectIndex;
        return cycledObject;
    }
    void getEditColorTargets(ColorAction*& mainColor, ColorAction*& detailColor, EffectGameObject*& object) = win 0x11eb40;
    cocos2d::CCPoint getGridSnappedPos(cocos2d::CCPoint pos) = win inline {
        auto size = m_editorLayer->m_drawGridLayer->m_gridSize;
        auto xVal = std::floorf(pos.x / size);
        auto yVal = std::floorf(pos.y / size);
        return this->getLimitedPosition(ccp((xVal + 0.5) * size, (yVal + 0.5) * size));
    }
    cocos2d::CCPoint getGroupCenter(cocos2d::CCArray* objects, bool absolute) = win 0x122d80;
    void getGroupInfo(GameObject* selectedObject, cocos2d::CCArray* selectedObjects, int& objectID, int& classType, int& objectType) = win inline {
        objectID = classType = objectType = -1;
        if (selectedObject) {
            objectID = selectedObject->m_objectID;
            classType = (int)selectedObject->m_classType;
            objectType = (int)selectedObject->m_savedObjectType;
        } else if (selectedObjects) {
            for (int i = 0; i < selectedObjects->count(); i++) {
                auto obj = static_cast<GameObject*>(selectedObjects->objectAtIndex(i));
                if (objectID != 0) {
                    if (objectID == -1) objectID = obj->m_objectID;
                    else if (objectID != obj->m_objectID) objectID = 0;
                }
                if (classType != 0) {
                    if (classType == -1) classType = (int)obj->m_classType;
                    else if (classType != (int)obj->m_classType) classType = 0;
                }
                if (objectType != 0) {
                    if (objectType == -1) objectType = (int)obj->m_savedObjectType;
                    else if (objectType != (int)obj->m_savedObjectType) objectType = 0;
                }
            }
        }
    }
    cocos2d::CCPoint getLimitedPosition(cocos2d::CCPoint position) = win 0x120150;
    CCMenuItemSpriteExtra* getModeBtn(char const* frameName, int tag) = win inline, ios inline {
        auto button = CCMenuItemSpriteExtra::create(cocos2d::CCSprite::createWithSpriteFrameName(frameName), this, menu_selector(EditorUI::toggleMode));
        button->setTag(tag);
        return button;
    }
    cocos2d::CCNode* getNeighbor(int smartKey, cocos2d::CCPoint position, GJSmartDirection direction, cocos2d::CCArray* objects) = win 0x118820;
    cocos2d::CCPoint getRelativeOffset(GameObject* object) = win inline {
        return GameToolbox::getRelativeOffset(object, this->offsetForKey(object->m_objectID));
    }
    cocos2d::CCArray* getSelectedObjects() = win 0x110ec0;
    CCMenuItemSpriteExtra* getSimpleButton(gd::string frameName, cocos2d::SEL_MenuHandler selector, cocos2d::CCMenu* menu) = win inline, ios inline {
        auto sprite = cocos2d::CCSprite::createWithSpriteFrameName(frameName.c_str());
        sprite->setScale(std::min(18.f / sprite->getContentSize().width, 18.f / sprite->getContentSize().height));
        auto button = CCMenuItemSpriteExtra::create(sprite, this, selector);
        if (menu) menu->addChild(button);
        return button;
    }
    SmartGameObject* getSmartNeighbor(SmartGameObject* object, cocos2d::CCPoint position, GJSmartDirection direction, cocos2d::CCArray* objects) = win 0x118700;
    float getSnapAngle(GameObject* object, cocos2d::CCArray* objects) = win inline {
        if (objects && objects->count() > 0) {
            for (int i = 0; i < objects->count(); i++) {
                auto rotation = m_editorLayer->rotationForSlopeNearObject(static_cast<GameObject*>(objects->objectAtIndex(i)));
                if (rotation != -1.f) return rotation;
            }
            return -1.f;
        }
        else if (object) return m_editorLayer->rotationForSlopeNearObject(object);
        else return -1.f;
    }
    CCMenuItemSpriteExtra* getSpriteButton(char const* spriteFrameName, cocos2d::SEL_MenuHandler selector, cocos2d::CCMenu* menu, float scale) = win inline, ios inline {
        return this->getSpriteButton(spriteFrameName, selector, menu, scale, 1, {0, 0});
    }
    CCMenuItemSpriteExtra* getSpriteButton(char const* spriteFrameName, cocos2d::SEL_MenuHandler selector, cocos2d::CCMenu* menu, float scale, int buttonKind, cocos2d::CCPoint offset) = win 0xe28b0;
    CCMenuItemSpriteExtra* getSpriteButton(cocos2d::CCSprite* sprite, cocos2d::SEL_MenuHandler selector, cocos2d::CCMenu* menu, float scale, int buttonKind, cocos2d::CCPoint offset) = win 0xe2940;
    cocos2d::CCPoint getTouchPoint(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline {
        return this->convertToWorldSpace(cocos2d::CCDirector::sharedDirector()->convertToGL(touch->getLocationInView()));
    }
    GJTransformState& getTransformState() = win inline, ios inline {
        m_transformControl->saveToState(m_transformState);
        return m_transformState;
    }
    float getXMin(int offset) = win 0x122c00;
    bool init(LevelEditorLayer* editorLayer) = win 0xdf3b0;
    bool isLiveColorSelectTrigger(GameObject* object) = win inline, ios inline {
        return object && object->m_classType == GameObjectClassType::Effect && (object->m_isColorTrigger || object->m_objectID == 1006);
    }
    bool isSpecialSnapObject(int id) = win 0x1290a0;
    bool liveEditColorUsable() = win inline, ios inline {
        return m_selectedObject || m_selectedObjects->count() != 0;
    }
    CreateMenuItem* menuItemFromObjectString(gd::string str, int id) = win 0x10e7b0;
    cocos2d::CCPoint moveForCommand(EditCommand command) = win 0x11f880;
    void moveGamelayer(cocos2d::CCPoint offset) = win 0xe2d90;
    void moveObject(GameObject* object, cocos2d::CCPoint offset) = win 0x11fcf0;
    void moveObjectCall(EditCommand command) = win 0x11fa60;
    void moveObjectCall(cocos2d::CCObject* sender);
    cocos2d::CCPoint offsetForKey(int id) = win 0x1269e0;
    void onAssignNewGroupID() = ios inline {
        auto selectedObjects = m_selectedObject ? cocos2d::CCArray::createWithObject(m_selectedObject) : m_selectedObjects;
        if (selectedObjects->count() == 0) return;
        auto groupID = m_editorLayer->getNextFreeGroupID(nullptr);
        for (int i = 0; i < selectedObjects->count(); i++) {
            auto obj = static_cast<GameObject*>(selectedObjects->objectAtIndex(i));
            if (obj->addToGroup(groupID) == 1) m_editorLayer->addToGroup(obj, groupID, false);
        }
        this->updateObjectInfoLabel();
    }
    void onColorFilter(cocos2d::CCObject* sender);
    void onCopy(cocos2d::CCObject* sender);
    void onCopyState(cocos2d::CCObject* sender) = win 0x1143a0;
    bool onCreate() = win 0x10f430;
    void onCreateButton(cocos2d::CCObject* sender) = win 0x10efa0;
    void onCreateObject(int id) = win 0x10f630;
    void onDelete(cocos2d::CCObject* sender) = win 0xe5e40;
    void onDeleteAll(cocos2d::CCObject* sender) = win inline, ios inline {
        this->deselectAll();
        m_editorLayer->removeAllObjects();
    }
    void onDeleteCustomItem(cocos2d::CCObject* sender) = win 0xe4560;
    void onDeleteInfo(cocos2d::CCObject* sender) = win 0xe5cf0;
    void onDeleteSelected(cocos2d::CCObject* sender) = win 0xe6470;
    void onDeleteSelectedType(cocos2d::CCObject* sender) = win 0xe6a10;
    void onDeleteStartPos(cocos2d::CCObject* sender);
    void onDeselectAll(cocos2d::CCObject* sender) = win 0x111480;
    void onDuplicate(cocos2d::CCObject* sender) = win 0x112cc0;
    void onEditColor(cocos2d::CCObject* sender) = win 0x11ead0;
    void onFindObject(cocos2d::CCObject* sender) = win 0xe7ed0;
    void onGoToBaseLayer(cocos2d::CCObject* sender) = win 0x114820;
    void onGoToLayer(cocos2d::CCObject* sender) = win 0x1146c0;
    void onGroupDown(cocos2d::CCObject* sender) = win 0x11f4f0;
    void onGroupIDFilter(cocos2d::CCObject* sender) = win 0xe7190;
    void onGroupSticky(cocos2d::CCObject* sender);
    void onGroupUp(cocos2d::CCObject* sender) = win 0x11f4d0;
    void onLockLayer(cocos2d::CCObject* sender);
    void onNewCustomItem(cocos2d::CCObject* sender) = win 0xe4070;
    void onPaste(cocos2d::CCObject* sender);
    void onPasteColor(cocos2d::CCObject* sender) = win 0x1145b0;
    void onPasteInPlace(cocos2d::CCObject* sender) = win inline, ios inline {
        this->doPasteInPlace(false);
    }
    void onPasteState(cocos2d::CCObject* sender) = win 0x114420;
    void onPause(cocos2d::CCObject* sender) = win 0xe1a80;
    void onPlayback(cocos2d::CCObject* sender) = win 0x111ae0;
    void onPlaytest(cocos2d::CCObject* sender) = win 0x1120f0;
    void onResetSpecialFilter(cocos2d::CCObject* sender);
    void onSelectBuildTab(cocos2d::CCObject* sender);
    void onSettings(cocos2d::CCObject* sender) = win 0xe1a00;
    void onStopPlaytest(cocos2d::CCObject* sender) = win 0x112570;
    void onTargetIDChange(int change) = win 0x122420;
    void onToggleGuide(EffectGameObject* object) = win inline {
        object->m_shouldPreview = !object->m_shouldPreview;
        if (m_editorLayer->tryUpdateSpeedObject(object, false)) m_speedObjectsUpdated = true;
        this->tryUpdateTimeMarkers();
    }
    void onToggleSelectedOrder(EffectGameObject* object) = win inline {
        auto playbackObject = m_editorLayer->m_playbackObject;
    }
    void onUngroupSticky(cocos2d::CCObject* sender);
    void onUpdateDeleteFilter(cocos2d::CCObject* sender) = win 0xe7540;
    void orderDownCustomItem(cocos2d::CCObject* sender);
    void orderUpCustomItem(cocos2d::CCObject* sender);
    cocos2d::CCArray* pasteObjects(gd::string str, bool withColor, bool noUndo) = win 0x1135f0;
    void playCircleAnim(cocos2d::CCPoint position, float radius, float duration) = win inline, ios inline {
        auto circleWave = CCCircleWave::create(1.f, radius, duration, false, false);
        circleWave->m_color.r = 255;
        circleWave->m_color.g = 255;
        circleWave->m_color.b = 255;
        circleWave->setPosition(position);
        this->addChild(circleWave, 0);
        circleWave->m_circleMode = CircleMode::Outline;
    }
    void playerTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline, ios inline {
        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        auto touchLocation = this->convertToNodeSpace(touch->getLocation());
        if (m_editorLayer->m_gameState.m_isDualMode) {
            if (winSize.width * .5f < touchLocation.x) {
                if (m_playerTouchID2 == -1) {
                    m_playerTouchID2 = touch->getID();
                    m_editorLayer->queueButton(1, true, true);
                }
            }
        }
        else if (GameManager::sharedState()->getGameVariable("0011")) {
            if (m_playerTouchID2 == -1) {
                m_playerTouchID2 = touch->getID();
                m_editorLayer->queueButton(1, true, true);
            }
        }
        if (m_playerTouchID1 == -1) {
            m_playerTouchID1 = touch->getID();
            m_editorLayer->queueButton(1, true, false);
        }
    }
    void playerTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline, ios inline {
        if (touch->getID() == m_playerTouchID1) {
            m_playerTouchID1 = -1;
            m_editorLayer->queueButton(1, false, false);
        }
        else if (touch->getID() == m_playerTouchID2) {
            m_playerTouchID2 = -1;
            m_editorLayer->queueButton(1, false, true);
        }
    }
    void playtestStopped() = win 0x1125b0;
    bool positionIsInSnapped(cocos2d::CCPoint position) = win inline {
        for (int i = 0; i < m_snapPositions->count(); i++) {
            auto& snapPos = static_cast<cocos2d::CCNode*>(m_snapPositions->objectAtIndex(i))->getPosition();
            if (snapPos.x == position.x && snapPos.y == position.y) return true;
        }
        return false;
    }
    cocos2d::CCPoint positionWithoutOffset(GameObject* object) = win inline {
        return object->getPosition() - this->getRelativeOffset(object);
    }
    void processSelectObjects(cocos2d::CCArray* objects) = win 0x1117a0;
    void processSmartObjectsFromType(int type, cocos2d::CCArray* objects, cocos2d::CCArray* objects2, cocos2d::CCArray* objects3, cocos2d::CCArray* objects4) = win 0x118470;
    void recreateButtonTabs() = win inline {
        m_reloadItems = false;
        auto gameManager = GameManager::sharedState();
        auto buttonsPerRow = gameManager->getIntGameVariable("0049");
        auto buttonRows = gameManager->getIntGameVariable("0050");
        for (int i = 0; i < m_createButtonBars->count(); i++) {
            static_cast<EditButtonBar*>(m_createButtonBars->objectAtIndex(i))->reloadItems(buttonsPerRow, buttonRows);
        }
        m_editButtonBar->reloadItems(buttonsPerRow, buttonRows);
    }
    void redoLastAction(cocos2d::CCObject* sender) = win 0x1118d0;
    void reloadCustomItems() = win 0xe4cd0;
    void removeOffset(GameObject* object);
    void replaceGroupID(GameObject* object, int oldID, int newID) = win 0x119020;
    void repositionObjectsToCenter(cocos2d::CCArray* objects, cocos2d::CCPoint position, bool absolute) = win 0x114300;
    void resetObjectEditorValues(cocos2d::CCArray* objects) = win inline {
        if (!objects) return;
        for (int i = 0; i < objects->count(); i++) {
            auto obj = static_cast<GameObject*>(objects->objectAtIndex(i));
            obj->updateStartPos();
            m_objectEditorStates[obj->m_uniqueID].loadValues(obj);
        }
    }
    void resetSelectedObjectsColor() = win 0x11f7b0;
    void resetUI() = win 0xe4db0;
    void rotateObjects(cocos2d::CCArray* objects, float rotation, cocos2d::CCPoint pivotPoint) = win 0x121070;
    float rotationforCommand(EditCommand command) = win inline, ios inline {
        switch (command) {
            case EditCommand::RotateCW: return 90.f;
            case EditCommand::RotateCCW: return -90.f;
            case EditCommand::RotateCW45: return 45.f;
            case EditCommand::RotateCCW45: return -45.f;
            default: return 0.f;
        }
    }
    void scaleObjects(cocos2d::CCArray* objects, float scaleX, float scaleY, cocos2d::CCPoint pivotPoint, ObjectScaleType type, bool move) = win 0x121490;
    void selectAll() = win inline {
        auto objects = m_editorLayer->m_objects;
        auto selected = cocos2d::CCArray::create();
        for (int i = 0; i < objects->count(); i++) {
            auto obj = static_cast<GameObject*>(objects->objectAtIndex(i));
            if (m_editorLayer->validGroup(obj, false)) {
                selected->addObject(obj);
            }
        }
    }
    void selectAllWithDirection(bool left) = win 0x1115f0;
    void selectBuildTab(int tab) = win 0x114870;
    void selectObject(GameObject* object, bool ignoreFilter) = win 0x110570;
    void selectObjects(cocos2d::CCArray* objects, bool ignoreFilter);
    void selectObjectsInRect(cocos2d::CCRect rect) = win inline {
        auto objects = m_editorLayer->objectsInRect(rect, false);
        if (objects->count() > 0) {
            for (int i = 0; i < objects->count(); i++) {
                auto obj = static_cast<GameObject*>(objects->objectAtIndex(i));
                if ((m_selectedObject && m_selectedObject->m_uniqueID != obj->m_uniqueID) || !m_selectedObjects->containsObject(obj)) {
                    this->createUndoSelectObject(false);
                    break;
                }
            }
            this->selectObjects(objects, false);
            this->updateSpecialUIElements();
        }
    }
    void setupCreateMenu() = win 0xe8020;
    void setupDeleteMenu() = win 0xe4fb0;
    void setupEditMenu() = win inline, ios inline {
        this->createMoveMenu();
        this->updateEditMenu();
    }
    void setupTransformControl() = win inline, ios inline {}
    bool shouldDeleteObject(GameObject* object) = win 0xe6340;
    bool shouldSnap(GameObject* object) = win inline, ios inline {
        return (int)object->getRotation() % 90 == 0;
    }
    void showDeleteConfirmation() = win inline, ios inline {
        FLAlertLayer::create(
            this,
            "Delete All",
            "Are you sure you want to <cr>Delete</c> all objects? (<cy>This action cannot be undone</c>)",
            "Cancel",
            "Yes",
            300.f
        )->show();
    }
    void showLiveColorSelectForMode(int colorID) = win 0x11ef20;
    void showLiveColorSelectForModeSpecial(int colorID) = win inline {
        if (m_selectedObject) {
            m_selectedObject->deselectObject();
        }
        else {
            CCObject* obj;
            CCARRAY_FOREACH(m_selectedObjects, obj) {
                static_cast<GameObject*>(obj)->deselectObject();
            }
        }
        this->showLiveColorSelectForMode(colorID);
    }
    void showMaxBasicError() = win 0x112b80;
    void showMaxCoinError() = win inline {
        auto alert = FLAlertLayer::create(
            this,
            "Max Coins",
            "You cannot add more than <cy>3</c> <cg>coins</c> in a single level.",
            "OK",
            nullptr,
            300.f,
            false,
            0.f,
            1.f
        );
        alert->setTag(122);
        alert->show();
    }
    void showMaxError() = win 0x112a50;
    void showUI(bool show) = win 0x111940;
    void sliderChanged(cocos2d::CCObject* sender) = win 0xe2a80;
    cocos2d::CCSprite* spriteFromObjectString(gd::string str, bool absoluteCenter, bool useGroup, int objLimit, cocos2d::CCArray* objects, cocos2d::CCArray* group, GameObject* groupParent) = win 0x10dea0;
    void toggleDuplicateButton() = win inline {
        if (m_selectedObject || m_selectedObjects->count() != 0) {
            m_copyPasteBtn->m_animationEnabled = true;
            m_copyPasteBtn->setColor({ 255, 255, 255 });
            m_copyPasteBtn->setOpacity(255);
            m_copyBtn->m_animationEnabled = true;
            m_copyBtn->setColor({ 255, 255, 255 });
            m_copyBtn->setOpacity(255);
        }
        else {
            m_copyPasteBtn->m_animationEnabled = false;
            m_copyPasteBtn->setColor({ 166, 166, 166 });
            m_copyPasteBtn->setOpacity(175);
            m_copyBtn->m_animationEnabled = false;
            m_copyBtn->setColor({ 166, 166, 166 });
            m_copyBtn->setOpacity(175);
        }
        auto hasClipboard = !GameManager::sharedState()->m_editorClipboard.empty();
        m_pasteBtn->m_animationEnabled = hasClipboard;
        if (hasClipboard) {
            m_pasteBtn->setColor({ 255, 255, 255 });
            m_pasteBtn->setOpacity(255);
        }
        else {
            m_pasteBtn->setColor({ 166, 166, 166 });
            m_pasteBtn->setOpacity(175);
        }
    }
    void toggleEditObjectButton() = win 0x11a930;
    void toggleEnableRotate(cocos2d::CCObject* sender);
    void toggleFreeMove(cocos2d::CCObject* sender);
    void toggleLockUI(bool lockUI) = win inline {
        m_isPaused = lockUI;
    }
    void toggleMode(cocos2d::CCObject* sender) = win 0xe4ed0;
    void toggleObjectInfoLabel();
    void toggleSnap(cocos2d::CCObject* sender);
    void toggleSpecialEditButtons() = win 0x11aa30;
    void toggleStickyControls(bool enable) = win inline {
        m_stickyControlsEnabled = enable;
        m_linkBtn->setEnabled(enable);
              m_linkBtn->setVisible(enable);
              m_unlinkBtn->setEnabled(enable);
              m_unlinkBtn->setVisible(enable);
    }
    void toggleSwipe(cocos2d::CCObject* sender);
    void transformObject(GameObject* object, EditCommand command, bool noOffset);
    void transformObjectCall(EditCommand command) = win 0x120210;
    void transformObjectCall(cocos2d::CCObject* sender);
    void transformObjects(cocos2d::CCArray* objs, cocos2d::CCPoint anchor, float scaleX, float scaleY, float rotateX, float rotateY, float warpX, float warpY) = win 0x121a80;
    void transformObjectsActive() = win 0x1219c0;
    void transformObjectsReset() = win inline {
        auto selectedObjects = m_selectedObjects;
        if (!selectedObjects || selectedObjects->count() == 0) {
            if (!m_selectedObject) return;
            selectedObjects = cocos2d::CCArray::createWithObject(m_selectedObject);
        }
        if (selectedObjects) this->transformObjects(selectedObjects, m_pivotPoint, 1.f, 1.f, 0.f, 0.f, m_transformState.m_skewX, m_transformState.m_skewY);
    }
    void triggerSwipeMode() = win 0x123770;
    void tryUpdateTimeMarkers() = win inline, ios inline {}
    void undoLastAction(cocos2d::CCObject* object) = win 0x111860;
    void updateButtons();
    void updateCreateMenu(bool selectTab) = win 0x10efe0;
    void updateDeleteButtons() = win 0xe76c0;
    void updateDeleteMenu() = win inline, ios inline {
        m_deleteMenu->setVisible(m_selectedMode == 1);
        this->updateDeleteButtons();
    }
    void updateEditButtonColor(int tag, cocos2d::ccColor3B color) = win 0x1149d0;
    void updateEditColorButton() = win 0x11e960;
    void updateEditMenu() = win inline, ios inline {
        m_editButtonBar->setVisible(m_selectedMode == 3);
    }
    void updateGridNodeSize() = win 0xe2c40;
    void updateGridNodeSize(int objectID) = win inline, ios inline {
        auto size = ObjectToolbox::sharedState()->gridNodeSizeForKey(objectID);
        m_gridSize = size;
        m_editorLayer->m_drawGridLayer->m_gridSize = size;
    }
    void updateGroupIDBtn2() = win inline, ios inline {
        m_goToBaseBtn->setVisible(m_editorLayer->m_currentLayer >= 0);
    }
    void updateGroupIDLabel() = win 0x11f520;
    void updateObjectInfoLabel() = win 0xe2ea0;
    void updatePlaybackBtn() = win 0x111fa0;
    void updateSlider() = win 0xe2b80;
    void updateSpecialUIElements() = win inline, ios inline {
        this->updateObjectInfoLabel();
        this->updateScaleControl();
    }
    void updateZoom(float zoom) = win 0x112720;
    float valueFromXPos(float xPos) = win inline {
        auto xMin = this->getXMin(0);
        auto sectionCount = std::max(m_editorLayer->getSectionCount(), 100);
        auto scale = m_editorLayer->m_objectLayer->getScale();
        return std::clamp(-(xPos - xMin) / (sectionCount * 100.f * scale), 0.f, 1.f);
    }
    float xPosFromValue(float value) = win inline {
        auto xMin = this->getXMin(0);
        auto sectionCount = std::max(m_editorLayer->getSectionCount(), 100);
        auto scale = m_editorLayer->m_objectLayer->getScale();
        return sectionCount * 100.f * scale * value - xMin;
    }
    void zoomGameLayer(bool zoomingIn) = win inline, ios inline {
        auto scale = m_editorLayer->m_objectLayer->getScale();
        this->updateZoom(std::clamp(zoomingIn ? scale + .1f : scale - .1f, .1f, 4.f));
    }
    void zoomIn(cocos2d::CCObject* sender) = win 0x112680;
    void zoomOut(cocos2d::CCObject* sender) = win 0x1126d0;

    gd::unordered_map<int, GameObjectEditorState> m_objectEditorStates;
    GJTransformState m_transformState;
    bool m_isPlayingMusic;
    EditButtonBar* m_customTabBar;
    bool m_alertShown;
    cocos2d::CCArray* m_uiItems;
    float m_gridSize;
    int m_playerTouchID1;
    int m_playerTouchID2;
    bool m_playbackActive;
    float m_playbackStartWarp;
    float m_playbackStartTime;
    UndoObject* m_undoObject;
    bool m_spaceSwiping;
    bool m_noSnapUndo;
    bool m_editingObject;
    bool m_increaseScale;
    bool m_refreshPosition;
    int m_rotationTouchID;
    int m_scaleTouchID;
    int m_touchID;
    int m_transformTouchID;
    cocos2d::CCLabelBMFont* m_objectInfoLabel;
    GJRotationControl* m_rotationControl;
    cocos2d::CCPoint m_pivotPoint;
    bool m_canActivateControls;
    GJScaleControl* m_scaleControl;
    GJTransformControl* m_transformControl;
    cocos2d::CCNode* m_transformNode;
    cocos2d::CCNode* m_transformChild;
    cocos2d::CCDictionary* m_editButtonDict;
    EditButtonBar* m_createButtonBar;
    EditButtonBar* m_editButtonBar;
    Slider* m_positionSlider;
    float m_unk308;
    float m_constrainedHeight;
    float m_toolbarHeight;
    bool m_swipeEnabled;
    bool m_swipeActive;
    bool m_swipeSelected;
    bool m_continuousSnap;
    bool m_freeMoveEnabled;
    bool m_snapObjectExists;
    bool m_snapSelected;
    bool m_stickyControlsEnabled;
    bool m_speedObjectsUpdated;
    cocos2d::CCPoint m_createPosition;
    cocos2d::CCArray* m_snapPositions;
    cocos2d::CCPoint m_snapPosition;
    cocos2d::CCArray* m_selectedObjects;
    cocos2d::CCMenu* m_deleteMenu;
    cocos2d::CCArray* m_customTabControls;
    CCMenuItemSpriteExtra* m_deleteModeBtn;
    CCMenuItemSpriteExtra* m_buildModeBtn;
    CCMenuItemSpriteExtra* m_editModeBtn;
    CCMenuItemSpriteExtra* m_swipeBtn;
    CCMenuItemSpriteExtra* m_freeMoveBtn;
    CCMenuItemSpriteExtra* m_deselectBtn;
    CCMenuItemSpriteExtra* m_snapBtn;
    CCMenuItemSpriteExtra* m_rotateBtn;
    CCMenuItemSpriteExtra* m_playbackBtn;
    CCMenuItemSpriteExtra* m_playtestBtn;
    CCMenuItemSpriteExtra* m_playtestStopBtn;
    CCMenuItemSpriteExtra* m_trashBtn;
    CCMenuItemSpriteExtra* m_linkBtn;
    CCMenuItemSpriteExtra* m_unlinkBtn;
    CCMenuItemSpriteExtra* m_undoBtn;
    CCMenuItemSpriteExtra* m_redoBtn;
    CCMenuItemSpriteExtra* m_editObjectBtn;
    CCMenuItemSpriteExtra* m_editGroupBtn;
    CCMenuItemSpriteExtra* m_editHSVBtn;
    CCMenuItemSpriteExtra* m_editSpecialBtn;
    cocos2d::CCObject* m_unk3F0;
    CCMenuItemSpriteExtra* m_copyPasteBtn;
    CCMenuItemSpriteExtra* m_copyBtn;
    CCMenuItemSpriteExtra* m_pasteBtn;
    CCMenuItemSpriteExtra* m_copyValuesBtn;
    CCMenuItemSpriteExtra* m_pasteStateBtn;
    CCMenuItemSpriteExtra* m_pasteColorBtn;
    CCMenuItemSpriteExtra* m_goToLayerBtn;
    cocos2d::CCArray* m_createButtonBars;
    cocos2d::CCMenu* m_tabsMenu;
    cocos2d::CCArray* m_tabsArray;
    cocos2d::CCSprite* m_deleteAllSprite;
    cocos2d::CCSprite* m_customDeleteSprite;
    CCMenuItemSpriteExtra* m_deleteButton;
    CCMenuItemSpriteExtra* m_deleteAllButton;
    CCMenuItemSpriteExtra* m_deleteFilterNone;
    CCMenuItemSpriteExtra* m_deleteFilterStatic;
    CCMenuItemSpriteExtra* m_deleteFilterDetails;
    CCMenuItemSpriteExtra* m_deleteFilterCustom;
    cocos2d::CCLabelBMFont* m_currentLayerLabel;
    CCMenuItemSpriteExtra* m_layerNextBtn;
    CCMenuItemSpriteExtra* m_layerPrevBtn;
    CCMenuItemSpriteExtra* m_goToBaseBtn;
    ButtonSprite* m_deleteGroupSprite;
    ButtonSprite* m_deleteColorSprite;
    void* m_unk4b8;
    void* m_unk4c0;
    int m_selectedObjectIndex;
    cocos2d::CCArray* m_createButtonArray;
    cocos2d::CCArray* m_customObjectButtonArray;
    cocos2d::CCArray* m_deleteObjects;
    int m_selectedMode;
    LevelEditorLayer* m_editorLayer;
    cocos2d::CCPoint m_swipeStart;
    cocos2d::CCPoint m_swipeEnd;
    cocos2d::CCPoint m_swipePosition;
    cocos2d::CCPoint m_lastTouchPoint;
    cocos2d::CCPoint m_cameraTest;
    cocos2d::CCPoint m_clickAtPosition;
    GameObject* m_selectedObject;
    GameObject* m_snapObject;
    bool m_isDraggingCamera;
    bool m_continueSwipe;
    bool m_findSnap;
    void* m_unk540;
    int m_selectedTab;
    int m_cycledObjectIndex;
    ColorSelectLiveOverlay* m_colorOverlay;
    HSVLiveOverlay* m_hsvOverlay;
    double m_keyTime;
    double m_keyTime2;
    bool m_swipeModeTriggered;
    cocos2d::CCSprite* m_layerLockSprite;
    void* m_unk580;
    bool m_pressedSpace;
    float m_editorZoom;
    bool m_isPaused;
    bool m_reloadItems;
}

[[link(android)]]
class EditTriggersPopup : SetupTriggerPopup {
    // virtual ~EditTriggersPopup();

    static EditTriggersPopup* create(EffectGameObject* object, cocos2d::CCArray* objects);

    virtual void determineStartValues();
    virtual void onClose(cocos2d::CCObject* sender);

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x28ed40;
}

[[link(android)]]
class EffectGameObject : EnhancedGameObject {
    // virtual ~EffectGameObject();
    EffectGameObject();

    static EffectGameObject* create(char const* frame) = win inline {
        auto ret = new EffectGameObject();
        if (ret->init(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void setOpacity(unsigned char opacity);
    virtual void firstSetup();
    virtual void customSetup();
    virtual void triggerObject(GJBaseGameLayer* layer, int uniqueID, gd::vector<int> const* remapKeys) = win 0x4a5bc0;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4a8760;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x4ab8b0;
    virtual void setRScaleX(float scaleX) = win 0x4a5580;
    virtual void setRScaleY(float scaleY) = win 0x4a55d0;
    virtual void triggerActivated(float xPosition) = win 0x4a8420;
    virtual void restoreObject() = win 0x4a8210;
    virtual float spawnXPosition() = win 0x4a83e0;
    virtual bool canReverse() = win 0x4ab6d0;
    virtual bool isSpecialSpawnObject() = win inline { return false; }
    virtual bool canBeOrdered() = win 0x4ab840;
    virtual cocos2d::CCLabelBMFont* getObjectLabel();
    virtual void setObjectLabel(cocos2d::CCLabelBMFont* label) = win 0x495630;
    virtual void stateSensitiveOff(GJBaseGameLayer* layer) = win 0x4a8160;

    int getTargetColorIndex() = win inline {
        switch (m_objectID) {
            case 29: return 1000;
            case 30: return 1001;
            case 105: return 1004;
            case 744: return 1003;
            case 900: return 1009;
            case 915: return 1002;
            default: return m_targetColor;
        }
    }
    bool init(char const* frame) = win 0x4a5510, ios inline {
        if (!EnhancedGameObject::init(frame)) return false;
        m_classType = GameObjectClassType::Effect;
        m_triggerTargetColor.r = 255;
        m_triggerTargetColor.g = 255;
        m_triggerTargetColor.b = 255;
        m_legacyHSV = true;
        m_duration = .5f;
        return true;
    }
    void playTriggerEffect();
    void resetSpawnTrigger() = win inline {
        m_activatedByPlayer1 = false;
        m_activatedByPlayer2 = false;
        m_spawnXPosition = this->getPosition().x;
    }
    void setTargetID(int id) = win inline {
        m_targetGroupID = std::clamp(id, 0, 9999);
    }
    void setTargetID2(int id) = win inline {
        m_centerGroupID = std::clamp(id, 0, 9999);
    }
    void triggerEffectFinished();
    void updateInteractiveHover(float offset) = win 0x4a82c0;
    void updateSpecialColor() = win 0x4a8240;
    void updateSpeedModType() = win 0x4ab580;

    // this is probably pretty wrong :D
    bool m_unknownBool;
    cocos2d::ccColor3B m_triggerTargetColor;
    // property 10
    float m_duration;
    // property 35
    float m_opacity;
    bool m_triggerEffectPlaying;
    // property 51
    int m_targetGroupID;
    // property 71
    int m_centerGroupID;
    // property 11
    bool m_isTouchTriggered;
    // property 62
    bool m_isSpawnTriggered;
    // property 369
    bool m_hasCenterEffect;
    // property 75
    float m_shakeStrength;
    // property 84
    float m_shakeInterval;
    // property 14
    bool m_tintGround;
    // property 15
    bool m_usesPlayerColor1;
    // property 16
    bool m_usesPlayerColor2;
    // property 17
    bool m_usesBlending;
    // property 28, property 29
    cocos2d::CCPoint m_moveOffset;
    // property 30
    EasingType m_easingType;
    // property 85
    float m_easingRate;
    // property 58
    bool m_lockToPlayerX;
    // property 59
    bool m_lockToPlayerY;
    // property 141
    bool m_lockToCameraX;
    // property 142
    bool m_lockToCameraY;
    // property 100
    bool m_useMoveTarget;
    // property 101
    MoveTargetType m_moveTargetMode;
    // property 143
    float m_moveModX;
    // property 144
    float m_moveModY;
    // property 393
    bool m_smallStep;
    // property 394
    bool m_isDirectionFollowSnap360;
    // property 395
    int m_targetModCenterID;
    // property 396
    float m_directionModeDistance;
    // property 397
    bool m_isDynamicMode;
    // property 544
    bool m_isSilent;
    // property 538
    int m_specialTarget;
    // property 68
    float m_rotationDegrees;
    // property 69
    int m_times360;
    // property 70
    bool m_lockObjectRotation;
    // property 401
    int m_rotationTargetID;
    // property 402
    float m_rotationOffset;
    // property 403
    int m_dynamicModeEasing;
    // property 72
    float m_followXMod;
    // property 73
    float m_followYMod;
    // property 90
    float m_followYSpeed;
    // property 91
    float m_followYDelay;
    // property 92
    int m_followYOffset;
    // property 105
    float m_followYMaxSpeed;
    // property 45
    float m_fadeInDuration;
    // property 46
    float m_holdDuration;
    // property 47
    float m_fadeOutDuration;
    // property 48
    int m_pulseMode;
    // property 52
    int m_pulseTargetType;
    // property 49
    cocos2d::ccHSVValue m_hsvValue;
    // property 50
    int m_copyColorID;
    // property 60
    bool m_copyOpacity;
    // property 65
    bool m_pulseMainOnly;
    // property 66
    bool m_pulseDetailOnly;
    // property 86
    bool m_pulseExclusive;
    // property 210
    bool m_legacyHSV;
    // property 56
    bool m_activateGroup;
    // property 81
    bool m_touchHoldMode;
    // property 82
    TouchTriggerType m_touchToggleMode;
    // property 198
    TouchTriggerControl m_touchPlayerMode;
    // property 89
    bool m_isDualMode;
    // property 76
    int m_animationID;
    float m_spawnXPosition;
    int m_spawnOrder;
    // property 87
    bool m_isMultiTriggered;
    // property 102
    bool m_previewDisable;
    // property 441
    bool m_spawnOrdered;
    // property 93
    bool m_triggerOnExit;
    // property 95
    int m_itemID2;
    // property 534
    int m_controlID;
    // property 535
    bool m_targetControlID;
    // property 94
    bool m_isDynamicBlock;
    // property 80
    int m_itemID;
    // property 138
    bool m_targetPlayer1;
    // property 200
    bool m_targetPlayer2;
    // property 201
    bool m_followCPP;
    // property 78
    bool m_subtractCount;
    // property 381
    bool m_collectibleIsPickupItem;
    // property 382
    bool m_collectibleIsToggleTrigger;
    // property 440
    int m_collectibleParticleID;
    // property 383
    int m_collectiblePoints;
    // property 463
    bool m_hasNoAnimation;
    void* m_unk698;
    int m_forceModID;
    bool m_rotateFollowP1;
    bool m_rotateFollowP2;
    float m_unk6a8;
    float m_unk6ac;
    float m_unk6b0;
    bool m_unk6b4;
    // property 148
    float m_gravityValue;
    // property 284
    bool m_isSinglePTouch;
    // property 371
    float m_zoomValue;
    // property 111
    bool m_cameraIsFreeMode;
    // property 112
    bool m_cameraEditCameraSettings;
    // property 113
    float m_cameraEasingValue;
    // property 114
    float m_cameraPaddingValue;
    // property 370
    bool m_cameraDisableGridSnap;
    // property 118
    bool m_endReversed;
    // property 120
    float m_timeWarpTimeMod;
    // property 13
    bool m_shouldPreview;
    // property 115
    int m_ordValue;
    // property 170
    int m_channelValue;
    // property 117
    bool m_isReverse;
    short m_speedModType;
    cocos2d::CCPoint m_speedStart;
    // property 12
    int m_secretCoinID;
    bool m_unk6f4;
    bool m_unk6f5;
    cocos2d::CCPoint m_endPosition;
    float m_spawnTriggerDelay;
    float m_gravityMod;
    bool m_unk708;
    cocos2d::CCLabelBMFont* m_objectLabel;
    // property 280
    bool m_ignoreGroupParent;
    // property 281
    bool m_ignoreLinkedObjects;
    bool m_channelChanged;
}

[[link(android), depends(CAState), depends(PulseEffectAction), depends(CountTriggerAction), depends(OpacityEffectAction), depends(TouchToggleAction), depends(CollisionTriggerAction), depends(ToggleTriggerAction), depends(SpawnTriggerAction), depends(GroupCommandObject2), depends(TimerItem), depends(TimerTriggerAction)]]
class EffectManagerState {
    // ~EffectManagerState();
    // EffectManagerState();

    gd::vector<CAState> m_unkVecCAState;
    gd::vector<PulseEffectAction> m_unkVecPulseEffectAction;
    gd::unordered_map<int,gd::vector<PulseEffectAction>> m_unorderedMapInt_vectorPulseEffectAction;
    gd::unordered_map<int,gd::vector<CountTriggerAction>> m_unorderedMapInt_vectorCountTriggerAction;
    gd::unordered_set<int> m_unorderedSet_int1;
    gd::map<int,int> m_mapInt_Int;
    gd::unordered_map<int,OpacityEffectAction> m_unorderedMapInt_OpacityEffectAction;
    gd::vector<TouchToggleAction> m_vectorTouchToggleAction;
    gd::vector<CollisionTriggerAction> m_vectorCollisionTriggerAction;
    gd::vector<ToggleTriggerAction> m_vectorToggleTriggerAction;
    gd::vector<SpawnTriggerAction> m_vectorSpawnTriggerAction;
    gd::unordered_map<int,int> m_itemCountMap;
    gd::unordered_map<int,bool> m_unorderedMapInt_bool;
    gd::vector<GroupCommandObject2> m_vectorGroupCommandObject2;
    gd::unordered_map<int,std::pair<double,double>> m_unorderedMapInt_pair_double_double;
    gd::unordered_set<int> m_unorderedSet_int2;
    gd::unordered_map<int,TimerItem> m_timerItemMap;
    gd::unordered_map<int,gd::vector<TimerTriggerAction>> m_unorderedMapInt_vectorTimerTriggerAction;
}

[[link(android)]]
class EndLevelLayer : GJDropDownLayer {
    EndLevelLayer() {
        m_playLayer = nullptr;
        m_notLocal = false;
        m_coinsVerified = false;
        m_unknown3 = false;
        m_exiting = false;
        m_animateCoins = false;
        m_endEffectPlayed = false;
        m_sideMenu = nullptr;
        m_coinsToAnimate = nullptr;
        m_orbs = 0;
        m_stars = 0;
        m_moons = 0;
        m_diamonds = 0;
        m_hidden = false;
    }
    ~EndLevelLayer() = win inline {
        CC_SAFE_RELEASE(m_coinsToAnimate);
    }

    static EndLevelLayer* create(PlayLayer* playLayer) = win inline {
        auto ret = new EndLevelLayer();
        if (ret->init(playLayer)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyBackClicked() = win 0x135710;
    virtual void keyDown(cocos2d::enumKeyCodes key) = win 0x136db0;
    virtual void customSetup() = win 0x132e90;
    virtual void showLayer(bool instant) = win 0x134ce0;
    virtual void enterAnimFinished() = win inline {}
    virtual void keyUp(cocos2d::enumKeyCodes key) = win inline {}

    void coinEnterFinished(cocos2d::CCPoint position) = win 0x135ea0;
    void coinEnterFinishedO(cocos2d::CCObject* sender) = win 0x135e60;
    void currencyEnterFinished();
    void diamondEnterFinished();
    gd::string getCoinString() = win 0x1349a0;
    const char* getEndText() = win 0x136e00;
    void goEdit() = win 0x135350;
    bool init(PlayLayer* playLayer) = win inline, ios inline {
        m_playLayer = playLayer;
        return GJDropDownLayer::init(" ", 230.f, true);
    }
    void onEdit(cocos2d::CCObject* sender) = win 0x135250;
    void onEveryplay(cocos2d::CCObject* sender) = win inline, ios inline {}
    void onHideLayer(cocos2d::CCObject* sender) = win 0x135420;
    void onLevelLeaderboard(cocos2d::CCObject* sender) = win 0x1348a0;
    void onMenu(cocos2d::CCObject* sender) = win 0x1350d0;
    void onReplay(cocos2d::CCObject* sender) = win 0x134ec0;
    void onRestartCheckpoint(cocos2d::CCObject* sender) = win 0x135500;
    void playCoinEffect(float duration) = win 0x135c20;
    void playCurrencyEffect(float duration);
    void playDiamondEffect(float duration);
    void playEndEffect() = win 0x136af0;
    void playStarEffect(float duration) = win 0x135720;
    void starEnterFinished() = win 0x135ac0;
    void tryShowBanner(float dt);

    PlayLayer* m_playLayer;
    bool m_notLocal;
    bool m_coinsVerified;
    bool m_unknown3;
    bool m_exiting;
    bool m_animateCoins;
    bool m_endEffectPlayed;
    cocos2d::CCMenu* m_sideMenu;
    cocos2d::CCArray* m_coinsToAnimate;
    cocos2d::CCPoint m_starsPosition;
    cocos2d::CCPoint m_orbsPosition;
    cocos2d::CCPoint m_diamondsPosition;
    int m_orbs;
    int m_stars;
    int m_moons;
    int m_diamonds;
    bool m_secretKey;
    bool m_hidden;
}

[[link(android)]]
class EndPortalObject : GameObject {
    // virtual ~EndPortalObject();
    EndPortalObject() {
        m_gradientBar = nullptr;
        m_flippedX = false;
        m_startPosHeightRelated = false;
    }

    static EndPortalObject* create() = win inline {
        auto ret = new EndPortalObject();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x137d90;
    virtual void setPosition(cocos2d::CCPoint const& position) = win 0x1382a0;
    virtual void setVisible(bool visible) = win 0x138400;

    cocos2d::CCPoint getSpawnPos() = win 0x1381e0;
    void triggerObject(GJBaseGameLayer* layer) = win inline {
        auto playLayer = GameManager::sharedState()->m_playLayer;
        if (!playLayer->m_player1->m_isDead) {
            playLayer->m_levelEndAnimationStarted = true;
            playLayer->m_uiLayer->disableMenu();
            playLayer->playEndAnimationToPos(this->getStartPos());
        }
    }
    void updateColors(cocos2d::ccColor3B color) = win inline {
        if (m_particle) {
            m_particle->setStartColor({ color.r / 255.f, color.g / 255.f, color.b / 255.f, 1.f });
            m_particle->setEndColor({ color.r / 255.f, color.g / 255.f, color.b / 255.f, 1.f });
        }
        m_gradientBar->setColor(color);
    }
    void updateEndPos(bool updateParticle) = win 0x138450;

    cocos2d::CCSprite* m_gradientBar;
    bool m_flippedX;
    bool m_startPosHeightRelated;
}

[[link(android)]]
class EndTriggerGameObject : EffectGameObject {
    // virtual ~EndTriggerGameObject();
    EndTriggerGameObject() {
        m_noEffects = false;
        m_noSFX = false;
        m_instant = false;
    }

    static EndTriggerGameObject* create() = win inline {
        auto ret = new EndTriggerGameObject();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init();
    virtual void triggerObject(GJBaseGameLayer* layer, int uniqueID, gd::vector<int> const* remapKeys) = win 0x4bc960;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists);
    virtual gd::string getSaveString(GJBaseGameLayer* layer);

    // property 460
    bool m_noEffects;
    // property 461
    bool m_noSFX;
    // property 487
    bool m_instant;
}

[[link(android)]]
class EnhancedGameObject : GameObject {
    // virtual ~EnhancedGameObject();
    EnhancedGameObject() {
        m_poweredOn = false;
        m_state = 0;
        m_animationRandomizedStartValue = 0;
        m_animationStart = 0.f;
        m_unk540 = 0.f;
        m_unk544 = 0.f;
        m_unk548 = false;
        m_randomFrameTime = 1.f;
        m_visible = false;
        m_shouldNotHideAnimFreeze = false;
        m_usesSpecialAnimation = false;
        m_frameTime = 1.f;
        m_frames = 1;
        m_hasCustomAnimation = false;
        m_hasCustomRotation = false;
        m_disableRotation = false;
        m_rotationSpeed = 0.f;
        m_rotationAngle = 0.f;
        m_rotationDelta = 0.f;
        m_rotationAnimationSpeed = 0.f;
        m_animationRandomizedStart = false;
        m_animationSpeed = 1.f;
        m_animationShouldUseSpeed = false;
        m_animateOnTrigger = false;
        m_disableDelayedLoop = false;
        m_disableAnimShine = false;
        m_singleFrame = 0;
        m_animationOffset = false;
        m_animationTriggered = false;
        m_unkAnimationInt = 0;
        m_maybeAnimationVariableXInt = 0;
        m_maybeAnimationVariableYInt = 0;
        m_animateOnlyWhenActive = false;
        m_isNoMultiActivate = false;
        m_isMultiActivate = false;
        m_activated = false;
        m_activatedByPlayer1 = false;
        m_activatedByPlayer2 = false;
        m_hasUniqueCoin = false;
    }

    static EnhancedGameObject* create(char const* frame) = win inline {
        auto ret = new EnhancedGameObject();
        if (ret->init(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void customSetup() = win 0x1a4fb0;
    virtual void resetObject() = win 0x1a4970;
    virtual void deactivateObject(bool deactivate) = win 0x1a6ab0;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x1a4c80;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x1a6c10;
    virtual void triggerActivated(float xPosition);
    virtual void restoreObject() = win 0x1a4a20;
    virtual void animationTriggered() = win 0x1a4bb0;
    virtual void activatedByPlayer(PlayerObject* player) = win 0x1a4ad0;
    virtual bool hasBeenActivatedByPlayer(PlayerObject* player) = win 0x1a4b30;
    virtual bool hasBeenActivated() = win 0x1a4b90;
    virtual void saveActiveColors() = win 0x1a4c10;
    virtual bool canAllowMultiActivate() = win 0x1a4810;
    virtual bool getHasSyncedAnimation();
    virtual bool getHasRotateAction();
    virtual bool canMultiActivate(bool multiActivate) = win 0x1a4aa0;
    virtual void powerOnObject(int state) = win 0x1a4a60;
    virtual void powerOffObject() = win 0x1a4a80;
    virtual void stateSensitiveOff(GJBaseGameLayer* layer) {}
    virtual void updateSyncedAnimation(float totalTime, int frameIndex) = win 0x1a7df0;
    virtual void updateAnimateOnTrigger(bool animate) = win 0x1a9ab0;

    void createRotateAction(float angle, int clockwiseDirection) = win 0x1a72c0;
    bool init(char const* frame) = win 0x1a47c0;
    void previewAnimateOnTrigger() = win inline {
        m_animateOnTrigger = false;
        m_isDisabled2 = false;
        this->updateSyncedAnimation(0.f, -1);
        m_animateOnTrigger = true;
    }
    void refreshRotateAction() = win inline {
        this->createRotateAction(m_rotationAngle, 0);
    }
    void resetSyncedAnimation() = win inline {
        m_unk544 = 0.f;
        m_animationStart = m_unk548 ? -1.f : 0.f;
        m_unkAnimationInt = 0;
        this->updateSyncedAnimation(-m_animationRandomizedStartValue, -1);
    }
    void setupAnimationVariables() = win 0x1a9bb0;
    void triggerAnimation() = win inline {
        if (!m_animateOnlyWhenActive || m_isActivated) {
            m_animationTriggered = true;
            m_isDisabled2 = false;
            m_maybeAnimationVariableXInt = -1;
            this->updateSyncedAnimation(0.f, -1);
            m_animationRandomizedStartValue = 0;
        }
    }
    void updateRotateAction(float dt) = win 0x1a7350;
    void updateState(int state) = win inline {
        if (m_state < state) m_poweredOn = false;
        if (!m_poweredOn) this->powerOffObject();
    }
    void updateUserCoin() = win 0x1a6930;
    void waitForAnimationTrigger() = win inline {
        m_animationTriggered = false;
        m_isDisabled2 = true;
        m_animationRandomizedStartValue = 0;
        m_animationStart = 0.f;
        m_unk540 = 0.f;
        m_unk544 = 0.f;
        this->setOpacity(0);
    }

    bool m_poweredOn;
    int m_state;
    int m_animationRandomizedStartValue;
    float m_animationStart;
    float m_unk540;
    float m_unk544;
    bool m_unk548;
    float m_randomFrameTime;
    bool m_visible;
    bool m_shouldNotHideAnimFreeze;
    bool m_usesSpecialAnimation;
    float m_frameTime;
    short m_frames;
    bool m_hasCustomAnimation;
    bool m_hasCustomRotation;
    // property 98
    bool m_disableRotation;
    // property 97
    float m_rotationSpeed;
    float m_rotationAngle;
    float m_rotationDelta;
    float m_rotationAnimationSpeed;
    // property 106
    bool m_animationRandomizedStart;
    // property 107
    float m_animationSpeed;
    // property 122
    bool m_animationShouldUseSpeed;
    // property 123
    bool m_animateOnTrigger;
    // property 126
    bool m_disableDelayedLoop;
    // property 127
    bool m_disableAnimShine;
    // property 462
    int m_singleFrame;
    // property 592
    bool m_animationOffset;
    bool m_animationTriggered;
    int m_unkAnimationInt;
    int m_maybeAnimationVariableXInt;
    int m_maybeAnimationVariableYInt;
    // property 214
    bool m_animateOnlyWhenActive;
    // property 444
    bool m_isNoMultiActivate;
    // property 99
    bool m_isMultiActivate;
    bool m_activated;
    bool m_activatedByPlayer1;
    bool m_activatedByPlayer2;
    bool m_hasUniqueCoin;
}

[[link(android)]]
class EnhancedTriggerObject : EffectGameObject {
    // virtual ~EnhancedTriggerObject();
    EnhancedTriggerObject() {
        m_minXID = 0;
        m_minYID = 0;
        m_maxXID = 0;
        m_maxYID = 0;
    }

    static EnhancedTriggerObject* create(char const* frame) = win inline {
        auto ret = new EnhancedTriggerObject();
        if (ret->init(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists);
    virtual gd::string getSaveString(GJBaseGameLayer* layer);

    bool init(char const* frame) = win inline, ios inline {
        return EffectGameObject::init(frame);
    }

    // property 516
    int m_minXID;
    // property 517
    int m_minYID;
    // property 518
    int m_maxXID;
    // property 519
    int m_maxYID;
}

[[link(android)]]
class EnterEffectInstance {
    // ~EnterEffectInstance();
    // EnterEffectInstance(EnterEffectInstance const&);
    // EnterEffectInstance(EnterEffectInstance&&);
    // Sabe: idk why but this makes it so my mod works :shrug:
    EnterEffectInstance() {}
    EnterEffectInstance(EnterEffectObject* object, int targetID, int centerID, int unknown, int targetGroupIndex, int easeIndexCount, int controlID) = win 0x204330 {
        m_gameObject = object;
        m_reversed = false;
        m_targetID = targetID;
        m_centerID = centerID;
        m_unkFloat3 = unknown;
        m_easeIndex = 0;
        m_paused = false;
        m_paused2 = false;
        m_unkBool4 = false;
        m_targetGroupIndex = targetGroupIndex;
        m_controlID = controlID;
        if (easeIndexCount > 0) m_easeIndices.resize(easeIndexCount);
        this->loadValuesFromObject(m_gameObject);
    }

    void animateValue(int key, float value, float distance, float duration, int easingType, float easingRate, int easingBuffer) = win 0x139560;
    float getValue(int key) = win inline, ios inline {
        switch (key) {
            case 0: return m_length;
            case 1: return m_lengthVariance;
            case 2: return m_offset;
            case 3: return m_offsetVariance;
            case 4: return m_modFront;
            case 5: return m_modBack;
            case 6: return m_deadzone;
            case 7: return m_moveDistance;
            case 8: return m_moveDistanceVariance;
            case 9: return m_moveAngle;
            case 10: return m_moveAngleVariance;
            case 11: return m_moveX;
            case 12: return m_moveXVariance;
            case 13: return m_moveY;
            case 14: return m_moveYVariance;
            case 15: return m_scaleX;
            case 16: return m_scaleXVariance;
            case 17: return m_scaleY;
            case 18: return m_scaleYVariance;
            case 19: return m_rotation;
            case 20: return m_rotationVariance;
            case 21: return m_tint;
            case 22: return m_unk074;
            case 23: return m_toOpacity;
            case 24: return m_fromOpacity;
            case 25: return m_offsetY;
            case 26: return m_offsetYVariance;
            case 27: return m_relativeFade;
            case 28: return m_hue;
            case 29: return m_saturation;
            case 30: return m_value;
            default: return 0;
        }
    }
    void loadTransitions(EnterEffectObject* object, float time) = win 0x138980;
    void loadValuesFromObject(EnterEffectObject* object) = win 0x1387e0;
    void setValue(int key, float value) = win 0x139980;
    void updateTransitions(float dt, GJBaseGameLayer* layer) = win 0x139750;

    gd::map<int,EnterEffectAnimValue> m_enterEffectAnimMap;
    float m_length;
    float m_lengthVariance;
    float m_offset;
    float m_offsetVariance;
    float m_offsetY;
    float m_offsetYVariance;
    float m_modFront;
    float m_modBack;
    float m_deadzone;
    float m_moveDistance;
    float m_moveDistanceVariance;
    float m_moveAngle;
    float m_moveAngleVariance;
    float m_moveX;
    float m_moveXVariance;
    float m_moveY;
    float m_moveYVariance;
    float m_relativeFade;
    float m_scaleX;
    float m_scaleXVariance;
    float m_scaleY;
    float m_scaleYVariance;
    float m_rotation;
    float m_rotationVariance;
    float m_tint;
    float m_unk074;
    float m_toOpacity;
    float m_fromOpacity;
    cocos2d::ccHSVValue m_hsvValue;
    float m_hue;
    float m_saturation;
    float m_value;
    EnterEffectObject* m_gameObject;
    bool m_reversed;
    int m_targetID;
    int m_centerID;
    int m_unkFloat3;
    int m_easeIndex;
    bool m_paused;
    bool m_paused2;
    bool m_unkBool4;
    int m_targetGroupIndex;
    gd::vector<int> m_easeIndices;
    int m_controlID;
}

[[link(android)]]
class EnterEffectObject : EffectGameObject {
    // virtual ~EnterEffectObject();
    // make every member zero
    EnterEffectObject() {
        m_enterType = 0;
        m_length = 0;
        m_lengthVariance = 0;
        m_offset = 0;
        m_offsetVariance = 0;
        m_offsetY = 0;
        m_offsetYVariance = 0;
        m_moveDistance = 0;
        m_moveDistanceVariance = 0;
        m_areaScaleX = 0.0f;
        m_areaScaleXVariance = 0.0f;
        m_areaScaleY = 0.0f;
        m_areaScaleYVariance = 0.0f;
        m_moveAngle = 0;
        m_moveAngleVariance = 0;
        m_startAngle = false;
        m_relative = false;
        m_relativeFade = 0.0f;
        m_easingInType = EasingType::None;
        m_easingInRate = 2.0f;
        m_easingInBuffer = 0;
        m_easingOutType = EasingType::None;
        m_easingOutRate = 2.0f;
        m_easingOutBuffer = 0;
        m_moveX = 0;
        m_moveXVariance = 0;
        m_moveY = 0;
        m_moveYVariance = 0;
        m_tintChannelID = 0;
        m_property224 = 0;
        m_directionType = 0;
        m_xyMode = false;
        m_easeOutEnabled = false;
        m_modFront = 1.0f;
        m_modBack = 1.0f;
        m_areaTint = 0.0f;
        m_property285 = 0.0f;
        m_effectID = 0;
        m_areaRotation = 0.0f;
        m_areaRotationVariance = 0.0f;
        m_toOpacity = 0.0f;
        m_fromOpacity = 0.0f;
        m_inbound = false;
        m_hsvEnabled = false;
        m_deadzone = 0.0f;
        m_twoDirections = false;
        m_dontEditAreaParent = false;
        m_priority = 0;
        m_unk7d8 = 0;
        m_enterChannel = 0;
        m_useEffectID = false;
        m_negativeTargetX = false;
        m_areaRange = 0;
        m_unk7fc = 0;
    }

    static EnterEffectObject* create(char const* frame) = win inline {
        auto ret = new EnterEffectObject();
        if (ret->init(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void customSetup();
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4980c0;
    virtual gd::string getSaveString(GJBaseGameLayer* layer);

    bool init(char const* frame) = win inline, ios inline {
        if (!EffectGameObject::init(frame)) return false;
        m_objectType = GameObjectType::EnterEffectObject;
        m_unk390 = 45;
        return true;
    }
    void resetEnterAnimValues() = win inline {
        m_length = -99;
        m_lengthVariance = -99;
        m_offset = -99;
        m_offsetVariance = -99;
        m_offsetY = -99;
        m_offsetYVariance = -99;
        m_modFront = -99.f;
        m_modBack = -99.f;
        m_deadzone = -99.f;
        m_moveDistance = -99;
        m_moveDistanceVariance = -99;
        m_moveAngle = -99;
        m_moveAngleVariance = -99;
        m_moveX = -99;
        m_moveXVariance = -99;
        m_moveY = -99;
        m_moveYVariance = -99;
        m_areaScaleX = -99.f;
        m_areaScaleXVariance = -99.f;
        m_areaScaleY = -99.f;
        m_areaScaleYVariance = -99.f;
        m_areaRotation = -99.f;
        m_areaRotationVariance = -99.f;
        m_areaTint = -99.f;
        m_property285 = -99.f;
        m_toOpacity = -99.f;
        m_fromOpacity = -99.f;
        m_relativeFade = -99.f;
    }

    // property 217
    int m_enterType;
    // property 222
    int m_length;
    // property 223
    int m_lengthVariance;
    // property 220
    int m_offset;
    // property 221
    int m_offsetVariance;
    // property 252
    int m_offsetY;
    // property 253
    int m_offsetYVariance;
    // property 218
    int m_moveDistance;
    // property 219
    int m_moveDistanceVariance;
    // property 233
    float m_areaScaleX;
    // property 234
    float m_areaScaleXVariance;
    // property 235
    float m_areaScaleY;
    // property 236
    float m_areaScaleYVariance;
    // property 231
    int m_moveAngle;
    // property 232
    int m_moveAngleVariance;
    bool m_startAngle;
    cocos2d::CCPoint m_anglePosition;
    // property 287
    bool m_relative;
    // property 288
    float m_relativeFade;
    // property 242
    EasingType m_easingInType;
    // property 243
    float m_easingInRate;
    int m_easingInBuffer;
    // property 248
    EasingType m_easingOutType;
    // property 249
    float m_easingOutRate;
    int m_easingOutBuffer;
    // property 237
    int m_moveX;
    // property 238
    int m_moveXVariance;
    // property 239
    int m_moveY;
    // property 240
    int m_moveYVariance;
    // property 260
    int m_tintChannelID;
    // property 224
    int m_property224;
    // property 262
    int m_directionType;
    // property 241
    bool m_xyMode;
    // property 261
    bool m_easeOutEnabled;
    // property 263
    float m_modFront;
    // property 264
    float m_modBack;
    // property 265
    float m_areaTint;
    // property 285
    float m_property285;
    // property 225
    int m_effectID;
    // property 270
    float m_areaRotation;
    // property 271
    float m_areaRotationVariance;
    // property 275
    float m_toOpacity;
    // property 286
    float m_fromOpacity;
    // property 276
    bool m_inbound;
    // property 278
    bool m_hsvEnabled;
    // property 282
    float m_deadzone;
    // property 283
    bool m_twoDirections;
    // property 539
    bool m_dontEditAreaParent;
    // property 341
    int m_priority;
    int m_unk7d8;
    // property 344
    int m_enterChannel;
    // property 355
    bool m_useEffectID;
    cocos2d::CCPoint m_unk7e4;
    cocos2d::CCPoint m_unk7ec;
    bool m_negativeTargetX;
    int m_areaRange;
    int m_unk7fc;
}

[[link(android)]]
class EventLinkTrigger : EffectGameObject {
    // virtual ~EventLinkTrigger();
    EventLinkTrigger() {
        m_resetRemap = false;
        m_extraID = 0;
        m_extraID2 = 0;
    }

    static EventLinkTrigger* create() = win inline {
        auto ret = new EventLinkTrigger();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init();
    virtual void triggerObject(GJBaseGameLayer* layer, int uniqueID, gd::vector<int> const* remapKeys) = win 0x4b8530;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4b8a00;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x4b8610;

    // property 430
    gd::set<int> m_eventIDs;
    // property 431
    bool m_resetRemap;
    // property 447
    int m_extraID;
    // property 525
    int m_extraID2;
}

[[link(android)]]
class ExplodeItemNode : cocos2d::CCNode {
    // virtual ~ExplodeItemNode();

    static ExplodeItemNode* create(cocos2d::CCRenderTexture* texture) = win 0x384220;

    virtual void update(float dt) = win 0x384c90;

    void createSprites(int countX, int countY, float xVel, float xVar, float yVel, float yVar, float dur, float durVar, cocos2d::ccColor4F startColor, cocos2d::ccColor4F endColor, bool noParticles) = win 0x3842e0;
    bool init(cocos2d::CCRenderTexture* texture) = win inline {
        if (!cocos2d::CCNode::init()) return false;
        m_floorHeight = 90.f;
        m_renderTexture = texture;
        texture->retain();
        m_sprites = cocos2d::CCArray::create();
        m_sprites->retain();
        return true;
    }

    cocos2d::CCRenderTexture* m_renderTexture;
    cocos2d::CCArray* m_sprites;
    float m_unk1;
    float m_floorHeight;
    bool m_noGravity;
}

[[link(android)]]
class ExplodeItemSprite : cocos2d::CCSprite {
    // virtual ~ExplodeItemSprite();
    ExplodeItemSprite() {
        m_xVelocity = 0.f;
        m_yVelocity = 0.f;
        m_timeRemaining = 0.f;
        m_fadeOutTime = 0.f;
        m_rotVelocity = 0.f;
        m_particles = nullptr;
    }

    static ExplodeItemSprite* create() = win inline {
        auto ret = new ExplodeItemSprite();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init();

    float m_xVelocity;
    float m_yVelocity;
    float m_timeRemaining;
    float m_fadeOutTime;
    float m_rotVelocity;
    cocos2d::CCParticleSystemQuad* m_particles;
}

[[link(android)]]
class ExtendedLayer : cocos2d::CCLayer {
    // virtual ~ExtendedLayer();
    ExtendedLayer() {
        m_delegate = nullptr;
    }

    static ExtendedLayer* create() = win inline {
        auto ret = new ExtendedLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init();
    virtual void setPosition(cocos2d::CCPoint const& position) = win 0x3ed40;

    BoomScrollLayerDelegate* m_delegate;
}

[[link(android)]]
class FileOperation {
    static gd::string getFilePath();
    static void readFile();
    static void saveFile();
}

[[link(android)]]
class FileSaveManager : GManager {
    // virtual ~FileSaveManager();

    static FileSaveManager* sharedState();

    virtual bool init();
    virtual void firstLoad();

    cocos2d::CCDictionary* getStoreData();
    void loadDataFromFile(char const* filename);

    cocos2d::CCDictionary* m_storeData;
}

[[link(android)]]
class FindBPMLayer : CreateGuidelinesLayer {
    // virtual ~FindBPMLayer();

    static FindBPMLayer* create(int songID) = win 0x9b8d0;

    virtual void onClose(cocos2d::CCObject* sender);
    virtual void playMusic();
    virtual void registerTouch() = win 0x9bdd0;
    virtual void onInfo(cocos2d::CCObject* sender) = win inline {}
    virtual void onRecord(cocos2d::CCObject* sender) = win 0x9baf0;
    virtual void recordingDidStop() = win 0x9bcb0;

    void calculateBPM() = win inline, ios inline {
        if (m_beats > 1) {
            m_beatsPerMinute = roundf(60.f / ((m_elapsed - m_startOffset) / (float)(m_beats - 1)));
        }
    }
    bool init(int songID) = win inline {
        if (!CreateGuidelinesLayer::init(nullptr, AudioGuidelinesType::BPMFinder)) return false;
        m_songID = songID;
        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        m_bpmLabel = cocos2d::CCLabelBMFont::create("BPM", "bigFont.fnt");
        m_mainLayer->addChild(m_bpmLabel, 1);
        m_bpmLabel->setPosition(winSize * .5f);
        m_recordingObjects->addObject(m_bpmLabel);
        auto songObject = MusicDownloadManager::sharedState()->getSongInfoObject(m_songID);
        if (songObject && songObject->m_BPM > 0) {
            m_infoLabel->setString(cocos2d::CCString::createWithFormat("BPM: %i", songObject->m_BPM)->getCString());
        }
        this->toggleItems(false);
        return true;
    }

    int m_songID;
    cocos2d::CCLabelBMFont* m_bpmLabel;
    float m_startOffset;
    int m_beats;
    int m_beatsPerMinute;
}

[[link(android)]]
class FindObjectPopup : SetIDPopup {
    // virtual ~FindObjectPopup();
    FindObjectPopup() {
        m_unknownBool = false;
    }

    static FindObjectPopup* create() = win inline {
        auto ret = new FindObjectPopup();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x29c270;

    void onFindObjectID(cocos2d::CCObject* sender) = win inline, ios inline {
        m_unknownBool = !m_unknownBool;
    }

    bool m_unknownBool;
}

[[link(android)]]
class FLAlertLayer : cocos2d::CCLayerColor {
    FLAlertLayer() = win 0x51740 {
        m_buttonMenu = nullptr;
        m_controlConnected = -1;
        m_mainLayer = nullptr;
        m_ZOrder = 0;
        m_noElasticity = false;
        m_reverseKeyBack = false;
        m_scene = nullptr;
        m_alertProtocol = nullptr;
        m_scrollingLayer = nullptr;
        m_button2 = nullptr;
        m_button1 = nullptr;
        m_joystickConnected = -1;
        m_containsBorder = 0;
        m_forcePrioRegistered = false;
    }
    ~FLAlertLayer();

    static FLAlertLayer* create(char const* title, const gd::string& desc, char const* btn) {
        return FLAlertLayer::create(nullptr, title, desc, btn, nullptr, 300.0);
    }
    static FLAlertLayer* create(FLAlertLayerProtocol* delegate, char const* title, gd::string desc, char const* btn1, char const* btn2) {
        return FLAlertLayer::create(delegate, title, desc, btn1, btn2, 300.0);
    }
    static FLAlertLayer* create(FLAlertLayerProtocol* delegate, char const* title, gd::string desc, char const* btn1, char const* btn2, float width) = win 0x51920;
    static FLAlertLayer* create(FLAlertLayerProtocol* delegate, char const* title, gd::string desc, char const* btn1, char const* btn2, float width, bool scroll, float height, float textScale) = win 0x519d0;

    virtual void onEnter();
    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x52a90;
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event);
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x52b30;
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event);
    virtual void registerWithTouchDispatcher() = win 0x52df0;
    virtual void keyBackClicked() = win 0x52910;
    virtual void keyDown(cocos2d::enumKeyCodes key) = win 0x52890;
    virtual void show() = win 0x52c20;

    void incrementForcePrio() = win inline {
        if (!m_forcePrioRegistered) {
            m_forcePrioRegistered = true;
            cocos2d::CCDirector::sharedDirector()->getTouchDispatcher()->registerForcePrio(this, 2);
        }
    }
    bool init(int opacity) = win 0x51ae0;
    bool init(FLAlertLayerProtocol* delegate, char const* title, gd::string desc, char const* btn1, char const* btn2, float width, bool scroll, float height, float textScale) = win 0x51bf0;
    void onBtn1(cocos2d::CCObject* sender) = win 0x529d0;
    void onBtn2(cocos2d::CCObject* sender) = win 0x52a30;

    cocos2d::CCMenu* m_buttonMenu;
    FLAlertLayerProtocol* m_alertProtocol;
    cocos2d::CCNode* m_scene;
    bool m_reverseKeyBack;
    cocos2d::ccColor3B m_color;
    cocos2d::CCLayer* m_mainLayer;
    int m_ZOrder;
    bool m_noElasticity;
    cocos2d::ccColor3B m_color2;
    ButtonSprite* m_button1;
    ButtonSprite* m_button2;
    ScrollingLayer* m_scrollingLayer;
    int m_controlConnected;
    bool m_containsBorder;
    bool m_noAction;
    int m_joystickConnected;
    bool m_forcePrioRegistered;
}

[[link(android)]]
class FLAlertLayerProtocol {
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) {}
}

[[link(android), depends(FMODAudioState), depends(FMODSoundState), depends(FMODMusic), depends(FMODSound), depends(FMODQueuedEffect), depends(FMODQueuedMusic), depends(FMODSoundTween)]]
class FMODAudioEngine : cocos2d::CCNode {
    FMODAudioEngine() = win 0x53120 {
        m_musicVolume = 1.f;
        m_sfxVolume = 1.f;
        m_backgroundMusicFade = .0f;
        m_musicFadeStart = .0f;
        m_pulse1 = .0f;
        m_pulse2 = .0f;
        m_pulse3 = .0f;
        m_pulseCounter = 0;
        m_metering = false;
        m_backgroundMusicChannel = nullptr;
        m_system = nullptr;
        m_mainDSP = nullptr;
        m_globalChannelDSP = nullptr;
        m_globalChannel = nullptr;
        m_reverbChannel = nullptr;
        m_lastResult = FMOD_RESULT::FMOD_OK;
        m_sampleRate = 0;
        m_reducedQuality = false;
        m_allAudioPaused = false;
        m_musicOffset = 0;
        m_stopped = false;
        m_reverbPreset = FMODReverbPreset::Generic;
        m_showAudioVisualizer = false;
        m_musicVisualizerTime = .0f;
        m_musicVisualizerPeak = .0f;
        m_musicVisualizerVolume = .0f;
        m_sfxVisualizerTime = .0f;
        m_sfxVisualizerPeak = .0f;
        m_sfxVisualizerVolume = .0f;
    }
    ~FMODAudioEngine() = win inline {
        m_system->close();
        if (m_system) m_system->release();
    }

    static FMODAudioEngine* get() {
        return FMODAudioEngine::sharedEngine();
    }
    static float pitchForIdx(int index) = win 0x56a00;
    static gd::string reverbToString(FMODReverbPreset preset) = win 0x54d10;
    static FMODAudioEngine* sharedEngine() = win inline {
        auto** instancePtr = reinterpret_cast<FMODAudioEngine**>(geode::base::get() + 0x6a4e18);
        if (!*instancePtr) {
            *instancePtr = new FMODAudioEngine();
            (*instancePtr)->init();
        }
        return *instancePtr;
    }

    virtual void update(float dt) = win 0x553e0;

    void activateQueuedMusic(int channel) = win inline {
        if (m_audioState.m_queuedMusicForChannels2.count(channel) != 0) {
            this->triggerQueuedMusic(m_audioState.m_queuedMusicForChannels2[channel]);
            m_audioState.m_queuedMusicForChannels2.erase(channel);
        }
        else if (m_audioState.m_queuedMusicForChannels1.count(channel) != 0) {
            m_audioState.m_queuedMusicForChannels1[channel].m_noPrepare = true;
        }
    }
    FMOD::Channel* channelForChannelID(int id) = win 0x584d0;
    FMOD::Channel* channelForUniqueID(int id) = win inline, ios inline {
        return this->channelForChannelID(this->channelIDForUniqueID(id));
    }
    int channelIDForUniqueID(int id) = win 0x58410;
    void channelLinkSound(int id, FMODSound* sound) = win inline {
        sound->m_playCount++;
        sound->m_playIndex = (*reinterpret_cast<int*>(geode::base::get() + 0x6a4e04))++;
        m_channelIDToSoundPath[id] = sound->m_filePath;
    }
    void channelStopped(FMOD::Channel* channel, bool remove) = win 0x58100;
    void channelUnlinkSound(int id) = win 0x57e70;
    void clearAllAudio() = win 0x55330;
    int countActiveEffects() = win inline {
        return m_channelIDToChannel.size() - countActiveMusic();
    }
    int countActiveMusic() = win inline {
        int count = 0;
        for (auto& music : m_fmodMusic) {
            if (music.second.m_channelID > 0) {
                ++count;
            }
        }
        return count;
    }
    FMOD::Sound* createStream(gd::string path) = win 0x5cbc0;
    void disableMetering() = win inline {
        this->m_metering = false;
    }
    void enableMetering() = win inline {
        this->m_metering = true;
        this->m_pulse1 = 0.1f;
        this->m_pulse2 = 0.1f;
        this->m_pulse3 = 0.0f;
    }
    void fadeInBackgroundMusic(float value) = win inline {
        m_backgroundMusicChannel->setVolume(value);
        m_backgroundMusicFade = value;
        m_musicFadeStart = -1.f;
    }
    void fadeInMusic(float duration, int channel) = win 0x5c410;
    void fadeMusic(float duration, int channel, float startVolume, float endVolume) = win 0x5c690;
    void fadeOutMusic(float duration, int channel) = win 0x5c550;
    gd::string getActiveMusic(int id) = win inline {
        if (m_fmodMusic.count(id) == 0) return "";
        return m_fmodMusic[id].m_filePath;
    }
    FMOD::Channel* getActiveMusicChannel(int musicID) = win inline {
        if (m_fmodMusic.count(musicID) == 0) return nullptr;
        return this->channelForChannelID(m_fmodMusic[musicID].m_channelID);
    }
    float getBackgroundMusicVolume() = win inline {
        return m_musicVolume;
    }
    FMOD::ChannelGroup* getChannelGroup(int id, bool reverb) = win 0x56b70;
    float getEffectsVolume() = win inline {
        return m_sfxVolume;
    }
    gd::string getFMODStatus(int unused) = win 0x5ce00;
    float getMeteringValue() = win inline {
        return m_pulse1;
    }
    int getMusicChannelID(int musicID) = win inline {
        if (m_fmodMusic.count(musicID) == 0) return 0;
        return m_fmodMusic[musicID].m_channelID;
    }
    unsigned int getMusicLengthMS(int channel) = win 0x5c380;
    float getMusicTime(int channel) = win inline {
        return this->getMusicTimeMS(channel) / 1000.f;
    }
    unsigned int getMusicTimeMS(int channel) = win 0x5c320;
    int getNextChannelID() = win inline, ios inline {
        return (*reinterpret_cast<int*>(geode::base::get() + GEODE_WINDOWS(0x69c0e4) GEODE_IOS(0x83ef50)))++;
    }
    gd::map<std::pair<int, int>, FMODSoundTween>& getTweenContainer(AudioTargetType type) = win inline, ios inline {
        switch (type) {
            case AudioTargetType::SFXGroup:
                return m_audioState.m_tweensForEffectGroups;
            case AudioTargetType::MusicChannel:
                return m_audioState.m_tweensForMusicChannels;
            default:
                return m_audioState.m_tweensForEffectChannels;
        }
    }
    bool isAnyPersistentPlaying() = win inline {
        for (auto& [id, music] : m_fmodMusic) {
            if (music.m_dontReset) return true;
        }
        return false;
    }
    bool isChannelStopping(int channel) = win inline, ios inline {
        return m_stoppedChannels.count(channel) != 0;
    }
    bool isEffectLoaded(gd::string path) = win inline, ios inline {
        return m_fmodSounds.count(path) != 0;
    }
    bool isMusicPlaying(int musicID) = win 0x59d50;
    bool isMusicPlaying(gd::string path, int musicID) = win 0x59f30;
    bool isPersistentMatchPlaying(gd::string path, int musicID) = win 0x5ada0;
    bool isSoundReady(FMOD::Sound* sound) = win inline, ios inline {
        FMOD_OPENSTATE state;
        m_lastResult = sound->getOpenState(&state, nullptr, nullptr, nullptr);
        return state == FMOD_OPENSTATE_READY || state == FMOD_OPENSTATE_ERROR || state == FMOD_OPENSTATE_PLAYING;
    }
    int lengthForSound(gd::string path) = win 0x59a20;
    void loadAndPlayMusic(gd::string path, unsigned int time, int musicID) = win 0x5a060;
    void loadAudioState(FMODAudioState& state) = win 0x55f70;
    void loadMusic(gd::string path) = win inline {
        this->loadMusic(path, 1.f, 0.f, 1.f, false, 0, 0, false);
    }
    void loadMusic(gd::string path, float speed, float unknown, float volume, bool shouldLoop, int musicID, int channelID, bool dontReset) = win 0x5a2d0;
    void pauseAllAudio() = win inline {
        if (m_allAudioPaused) return;
        m_allAudioPaused = true;
        m_backgroundMusicChannel->setPaused(true);
        m_globalChannel->setPaused(true);
    }
    void pauseAllEffects() = win inline {
        m_globalChannel->setPaused(true);
    }
    void pauseAllMusic(bool force) = win inline {
        for (auto& [id, music] : m_fmodMusic) {
            if (force || !music.m_dontReset) {
                if (auto ch = this->channelForChannelID(music.m_channelID))
                    ch->setPaused(true);
            }
        }
    }
    void pauseEffect(unsigned int effect) = win inline, ios inline {}
    void pauseMusic(int musicChannel) = win inline, ios inline {
        auto* channel = this->getActiveMusicChannel(musicChannel);
        if (channel)
            channel->setPaused(true);
    }
    int playEffect(gd::string path) = win 0x56de0;
    int playEffect(gd::string path, float speed, float unknown, float volume) = win 0x56e60;
    int playEffectAdvanced(gd::string path, float speed, float unknown, float volume, float pitch, bool fastFourierTransform, bool reverb, int startMillis, int endMillis, int fadeIn, int fadeOut, bool loopEnabled, int effectID, bool override, bool noPreload, int channelID, int uniqueID, float minInterval, int sfxGroup) = win 0x56f50;
    int playEffectAsync(gd::string path) = win inline {
        return this->playEffectAdvanced(path, 1.f, 0.f, 1.f, 0.f, false, false, 0, 0, 0, 0, false, 0, false, true, 0, 0, 0.f, 0);
    }
    void playMusic(gd::string path, bool shouldLoop, float fadeInTime, int channel) = win 0x5a160;
    FMODSound* preloadEffect(gd::string path) = win 0x592b0;
    FMOD::Sound* preloadEffectAsync(gd::string path) = win 0x596a0;
    FMOD::Sound* preloadMusic(gd::string path, bool noRelease, int musicID) = win 0x5c7e0;
    void printResult(FMOD_RESULT result) = win inline, ios inline {}
    void queuedEffectFinishedLoading(gd::string path) = win 0x5b0c0;
    int queuePlayEffect(gd::string audioFilename, float speed, float unknown, float volume, float pitch, bool fastFourierTransform, bool reverb, int start, int end, int fadeIn, int fadeOut, bool loop, int effectID, bool override, int uniqueID, float minInterval, int group) = win 0x57970;
    void queueStartMusic(gd::string audioFilename, float pitch, float unknown, float volume, bool loop, int start, int end, int fadeIn, int fadeOut, int musicID, bool, int channelID, bool noPrepare, bool dontReset) = win 0x5aac0;
    int registerChannel(FMOD::Channel* channel, int channelID, int effectID) = win 0x57b40;
    void releaseRemovedSounds() = win inline {
        for (int i = 0; i < m_removedSounds.size();) {
            auto sound = m_removedSounds[i];
            FMOD_OPENSTATE state;
            m_lastResult = sound->getOpenState(&state, nullptr, nullptr, nullptr);
            if (state == FMOD_OPENSTATE_READY || state == FMOD_OPENSTATE_ERROR) {
                sound->release();
                m_removedSounds.erase(m_removedSounds.begin() + i);
            }
            else i++;
        }
    }
    void resumeAllAudio() = win inline {
        if (!m_allAudioPaused) return;
        m_allAudioPaused = false;
        m_backgroundMusicChannel->setPaused(false);
        m_globalChannel->setPaused(false);
    }
    void resumeAllEffects() = win inline {
        m_globalChannel->setPaused(false);
    }
    void resumeAllMusic() = win 0x59ed0;
    void resumeAudio() = win inline {
        this->start();
    }
    void resumeEffect(unsigned int effect) = win inline, ios inline {}
    void resumeMusic(int musicChannel) = win inline {
        auto* channel = this->getActiveMusicChannel(musicChannel);
        if (channel)
            channel->setPaused(false);
    }
    void saveAudioState(FMODAudioState& state) = win 0x55940;
    void setBackgroundMusicVolume(float volume) = win inline {
        m_musicVolume = volume;
        m_musicFadeStart = 0.f;
        if (m_backgroundMusicChannel) m_backgroundMusicChannel->setVolume(volume);
    }
    void setChannelPitch(int id, AudioTargetType type, float pitch) = win 0x591a0;
    void setChannelVolume(int id, AudioTargetType type, float volume) = win 0x58e00;
    void setChannelVolumeMod(int id, AudioTargetType type, float volumeMod) = win 0x58fd0;
    void setEffectsVolume(float volume) = win inline {
        m_sfxVolume = volume;
        if (m_globalChannel) m_globalChannel->setVolume(volume);
    }
    void setMusicTimeMS(unsigned int time, bool dontWait, int musicID) = win 0x5c1e0;
    void setup() = win 0x53c10;
    void setupAudioEngine() = win 0x540f0;
    void start() = win 0x552d0;
    void startMusic(int start, int end, int fadeIn, int fadeOut, bool loop, int musicID, bool noResume, bool dontReset) = win 0x5a640;
    void stop() = win inline {
        if (m_stopped) return;
        m_stopped = true;
        m_system->mixerSuspend();
        m_system->update();
        this->pauseSchedulerAndActions();
    }
    void stopAllEffects() = win 0x59900;
    void stopAllMusic(bool clear) = win 0x59dc0;
    float stopAndGetFade(FMOD::Channel* channel) = win 0x58a70;
    void stopAndRemoveMusic(int id) = win 0x5cad0;
    void stopChannel(int id) = win inline {
        this->stopChannel(id, AudioTargetType::SFXChannel, false, 0.f);
    }
    void stopChannel(FMOD::Channel* channel, bool loop, float delay) = win 0x58860;
    void stopChannel(int id, AudioTargetType type, bool loop, float delay) = win 0x58590;
    void stopChannelTween(int id, AudioTargetType target, AudioModType mod) = win inline, ios inline {
        this->getTweenContainer(target).erase({ id, (int)mod });
    }
    void stopChannelTweens(int id, AudioTargetType target) = win inline, ios inline {
        this->stopChannelTween(id, target, AudioModType::Volume);
        this->stopChannelTween(id, target, AudioModType::Pitch);
    }
    void stopMusic(int id) = win inline {
        this->stopAndRemoveMusic(id);
    }
    void stopMusicNotInSet(gd::unordered_set<int>& musicIDs) = win inline {
        std::unordered_set<int> totalIDs;
        for (auto& [id, _] : m_fmodMusic) {
            totalIDs.insert(id);
        }
        for (auto& id : totalIDs) {
            if (musicIDs.count(id) == 0) {
                this->stopMusic(id);
            }
        }
    }
    FMODSound* storeEffect(FMOD::Sound* sound, gd::string path) = win 0x59560;
    void swapMusicIndex(int musicID, int channelID) = win 0x5bd30;
    void testFunction(int unknown) = win inline, ios inline {}
    void triggerQueuedMusic(FMODQueuedMusic music) = win 0x5b9f0;
    void unloadAllEffects() = win 0x59af0;
    void unloadEffect(gd::string path) = win inline, ios inline {}
    void unregisterChannel(int id) = win 0x57c70;
    void updateBackgroundFade() = win inline {
        if (m_musicFadeStart == 0.f) return;
        if (m_musicFadeStart < 0.f) m_musicFadeStart = m_audioState.m_elapsed;
        auto backgroundFade = m_backgroundMusicFade;
        auto fade = m_audioState.m_elapsed - m_musicFadeStart;
        if (backgroundFade <= 0.f || fade / backgroundFade > 1.f) backgroundFade = 1.f;
        else if (fade / backgroundFade >= 0.f) backgroundFade = fade / backgroundFade;
        else backgroundFade = 0.f;
        backgroundFade *= m_musicVolume;
        m_backgroundMusicChannel->setVolume(backgroundFade);
        if (m_backgroundMusicFade <= fade) m_musicFadeStart = 0.f;
    }
    void updateChannel(int channel, AudioTargetType target, AudioModType mod, float duration, float value) = win 0x58bb0;
    void updateChannelTweens(float dt) = win 0x56810;
    void updateMetering() = win inline {
        FMOD_DSP_METERING_INFO info{};
        m_mainDSP->getMeteringInfo(nullptr, &info);
        auto peak = info.numchannels == 2 ? (info.peaklevel[0] + info.peaklevel[1]) / 2.f : info.peaklevel[0];
        auto volume = m_musicVolume;
        if (volume > 0.f) peak /= volume;
        peak += .1f;
        m_pulse1 = peak;
        auto counter = m_pulseCounter;
        if (counter < 3 || peak < m_pulse2 * 1.1f || (peak < m_pulse3 * .95f && peak > m_pulse3 * .2f)) {
            peak = m_pulse2 * .93f;
        }
        else {
            m_pulse3 = peak;
            peak *= 1.1f;
            counter = 0;
        }
        m_pulse1 = peak;
        if (peak <= .1f) m_pulse3 = 0.f;
        m_pulse2 = peak;
        m_pulseCounter = counter + 1;
    }
    void updateQueuedEffects() = win 0x5af10;
    void updateQueuedMusic() = win 0x5b6f0;
    void updateReverb(FMODReverbPreset preset, bool force) = win 0x54450;
    void updateTemporaryEffects() = win 0x5b460;
    FMOD_OPENSTATE waitUntilSoundReady(FMOD::Sound* sound) = win inline {
        if (!sound) return FMOD_OPENSTATE_ERROR;
        FMOD_OPENSTATE state;
        m_lastResult = sound->getOpenState(&state, nullptr, nullptr, nullptr);
        while (state != FMOD_OPENSTATE_READY && state != FMOD_OPENSTATE_ERROR && state != FMOD_OPENSTATE_PLAYING) {
            m_lastResult = sound->getOpenState(&state, nullptr, nullptr, nullptr);
        }
        return state;
    }

    gd::unordered_map<int, FMODMusic> m_fmodMusic;
    gd::unordered_map<gd::string, FMODSound> m_fmodSounds;
    gd::unordered_set<gd::string> m_temporarySoundPaths;
    float m_musicVolume;
    float m_sfxVolume;
    float m_backgroundMusicFade;
    float m_musicFadeStart;
    float m_pulse1;
    float m_pulse2;
    float m_pulse3;
    int m_pulseCounter;
    bool m_metering;
    FMOD::ChannelGroup* m_backgroundMusicChannel;
    FMOD::System* m_system;
    FMOD::DSP* m_mainDSP;
    FMOD::DSP* m_globalChannelDSP;
    FMOD::ChannelGroup* m_globalChannel;
    FMOD::ChannelGroup* m_reverbChannel;
    FMOD_RESULT m_lastResult;
    int m_sampleRate;
    bool m_reducedQuality;
    bool m_allAudioPaused;
    int m_musicOffset;
    bool m_stopped;
    FMODAudioState m_audioState;
    gd::vector<FMOD::Sound*> m_removedSounds;
    gd::unordered_map<int, FMOD::DSP*> m_channelIDToDSP;
    gd::unordered_map<int, FMOD::Channel*> m_channelIDToChannel;
    gd::unordered_set<int> m_stoppedChannels;
    FMODReverbPreset m_reverbPreset;
    gd::unordered_map<int, int> m_channelIDToEffectID;
    gd::unordered_map<int, int> m_effectIDToChannelID;
    gd::unordered_map<int, gd::string> m_channelIDToSoundPath;
    gd::vector<FMODQueuedEffect> m_queuedEffects;
    gd::unordered_map<gd::string, FMOD::Sound*> m_soundPathToSound;
    gd::unordered_map<int, FMOD::ChannelGroup*> m_globalChannelGroups;
    gd::unordered_map<int, FMOD::ChannelGroup*> m_reverbChannelGroups;
    bool m_showAudioVisualizer;
    float m_musicVisualizerTime;
    float m_musicVisualizerPeak;
    float m_musicVisualizerVolume;
    float m_sfxVisualizerTime;
    float m_sfxVisualizerPeak;
    float m_sfxVisualizerVolume;
}

[[link(android), depends(FMODSoundTween), depends(FMODQueuedMusic), depends(FMODSoundState)]]
class FMODAudioState {
    // ~FMODAudioState();
    FMODAudioState() = win 0x52e90 {
        m_interval = 0.f;
        m_elapsed = 0.f;
    }

    float m_interval;
    float m_elapsed;
    gd::map<std::pair<int,int>,FMODSoundTween> m_tweensForEffectChannels;
    gd::map<std::pair<int,int>,FMODSoundTween> m_tweensForEffectGroups;
    gd::map<std::pair<int,int>,FMODSoundTween> m_tweensForMusicChannels;
    gd::unordered_map<int,float> m_volumeForEffectChannels;
    gd::unordered_map<int,float> m_volumeModForEffectChannels;
    gd::unordered_map<int,float> m_pitchForEffectChannels;
    gd::unordered_map<int,float> m_volumeForEffectGroups;
    gd::unordered_map<int,float> m_volumeModForEffectGroups;
    gd::unordered_map<int,float> m_pitchForEffectGroups;
    gd::unordered_map<int,float> m_volumeForMusicChannels;
    gd::unordered_map<int,float> m_volumeModForMusicChannels;
    gd::unordered_map<int,float> m_pitchForMusicChannels;
    gd::unordered_map<int,float> m_intervalForEffects;
    gd::unordered_map<int,FMODQueuedMusic> m_queuedMusicForChannels1;
    gd::unordered_map<int,FMODQueuedMusic> m_queuedMusicForChannels2;
    gd::unordered_map<int,FMODSoundState> m_soundStateForChannels;
    uint64_t m_unkUint64_1;
}

[[link(android)]]
class FMODLevelVisualizer : cocos2d::CCNode {
    // virtual ~FMODLevelVisualizer();

    static FMODLevelVisualizer* create() = win 0x29e610;

    virtual bool init() = win 0x29e690;

    void updateVisualizer(float volume, float peak, float time) = win 0x29eb50;

    float m_width;
}

class FMODMusic {
    int m_channelID;
    FMOD::Sound* m_sound;
    gd::string m_filePath;
    bool m_ogg;
    bool m_dontReset;
}

[[link(android)]]
class FMODQueuedEffect {
    gd::string m_filePath;
    float m_speed;
    float m_unk024;
    float m_volume;
    float m_pitch;
    bool m_fastFourierTransform;
    bool m_reverb;
    int m_start;
    int m_end;
    int m_fadeIn;
    int m_fadeOut;
    bool m_loop;
    int m_effectID;
    bool m_override;
    bool m_unk04d;
    int m_channelID;
    FMOD::Sound* m_sound;
    int m_uniqueID;
    int m_minInterval;
    int m_group;
}

[[link(android)]]
class FollowRewardPage : FLAlertLayer, FLAlertLayerProtocol, GameRateDelegate, RewardedVideoDelegate {
    // virtual ~FollowRewardPage();

    static FollowRewardPage* create() = win 0x139c40;

    virtual bool init() = win 0x139d60;
    virtual void registerWithTouchDispatcher() = win 0x42660;
    virtual void keyBackClicked() = win 0x846c0;
    virtual void show();
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x13d270;
    virtual void rewardedVideoFinished();
    virtual void updateRate() = win 0x13ba80;

    void onClose(cocos2d::CCObject* sender) = win 0x84690;
    void onRewardedVideo(cocos2d::CCObject* sender);
    void onSpecialItem(cocos2d::CCObject* sender) = win 0x13bfc0;
    void switchToOpenedState(CCMenuItemSpriteExtra* button) = win 0x13d190;

    cocos2d::CCArray* m_chests;
    bool m_videoPlaying;
}

[[link(android)]]
class FontObject : cocos2d::CCObject {
    // virtual ~FontObject();
    FontObject() {
        m_fontWidths = {};
    }

    static FontObject* createWithConfigFile(char const* font, float scale) = win inline {
        auto ret = new FontObject();
        if (ret->initWithConfigFile(font, scale)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    int getFontWidth(int character) = win inline {
        return m_fontWidths[character];
    }
    bool initWithConfigFile(char const* font, float scale) = win inline, ios inline {
        this->parseConfigFile(font, scale);
        return true;
    }
    void parseConfigFile(char const* font, float scale) = win 0x3b680;

    std::array<int, 300> m_fontWidths;
}

[[link(android)]]
class ForceBlockGameObject : EffectGameObject {
    // virtual ~ForceBlockGameObject();
    ForceBlockGameObject() {
        m_force = 0.f;
        m_minForce = 0.f;
        m_maxForce = 0.f;
        m_relativeForce = false;
        m_forceRange = false;
        m_forceID = 0;
    }

    static ForceBlockGameObject* create(char const* frame) = win inline {
        auto ret = new ForceBlockGameObject();
        if (ret->init(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists);
    virtual gd::string getSaveString(GJBaseGameLayer* layer);

    cocos2d::CCPoint calculateForceToTarget(GameObject* target) = win 0x4c1b50;
    bool init(char const* frame) = win inline, ios inline {
        return EffectGameObject::init(frame);
    }

    // property 149
    float m_force;
    // property 526
    float m_minForce;
    // property 527
    float m_maxForce;
    // property 528
    bool m_relativeForce;
    // property 529
    bool m_forceRange;
    // property 530
    int m_forceID;
}

[[link(android)]]
class FRequestProfilePage : FLAlertLayer, FLAlertLayerProtocol, UploadActionDelegate, UploadPopupDelegate, FriendRequestDelegate {
    // virtual ~FRequestProfilePage();

    static FRequestProfilePage* create(bool sent) = win 0x13d910;

    virtual void registerWithTouchDispatcher() = win 0x42660;
    virtual void keyBackClicked();
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x13ecf0;
    virtual void onClosePopup(UploadActionPopup* popup) = win 0x13ef20;
    virtual void uploadActionFinished(int id, int response);
    virtual void uploadActionFailed(int id, int response) = win 0x13f0e0;
    virtual void loadFRequestsFinished(cocos2d::CCArray* scores, char const* key) = win 0x13f850;
    virtual void loadFRequestsFailed(char const* key, GJErrorCode errorType) = win 0x13f8d0;
    virtual void setupPageInfo(gd::string info, char const* key) = win 0x13f970;
    virtual void forceReloadRequests(bool sent) = win 0x13f950;

    void deleteSelected() = win 0x13ea80;
    bool init(bool sent) = win 0x13dab0;
    bool isCorrect(char const* key);
    void loadPage(int page);
    void onClose(cocos2d::CCObject* sender) = win 0x13edb0;
    void onDeleteSelected(cocos2d::CCObject* sender);
    void onNextPage(cocos2d::CCObject* sender) = win 0x13fb00;
    void onPrevPage(cocos2d::CCObject* sender) = win 0x13fb10;
    void onSentRequests(cocos2d::CCObject* sender) = win 0x13ed20;
    void onToggleAllObjects(cocos2d::CCObject* sender);
    void onUpdate(cocos2d::CCObject* sender);
    void setupCommentsBrowser(cocos2d::CCArray* scores) = win 0x13f6b0;
    void untoggleAll();
    void updateLevelsLabel() = win inline, ios inline {}
    void updatePageArrows() = win inline, ios inline {
        m_prevButton->setVisible(m_pageStartIdx != 0);
        m_nextButton->setVisible(m_pageStartIdx + m_pageEndIdx < m_itemCount);
    }

    bool m_sent;
    gd::string m_key;
    cocos2d::CCLabelBMFont* m_pageLabel;
    cocos2d::CCLabelBMFont* m_errorLabel;
    GJCommentListLayer* m_listLayer;
    LoadingCircle* m_circle;
    UploadActionPopup* m_uploadPopup;
    void* m_unk2e8;
    CCMenuItemSpriteExtra* m_nextButton;
    CCMenuItemSpriteExtra* m_prevButton;
    CCMenuItemSpriteExtra* m_refreshButton;
    int m_itemCount;
    int m_pageStartIdx;
    int m_pageEndIdx;
    int m_page;
    bool m_toggledAll;
}

[[link(android)]]
class FriendRequestDelegate {
    virtual void loadFRequestsFinished(cocos2d::CCArray* scores, char const* key) {}
    virtual void loadFRequestsFailed(char const* key, GJErrorCode errorType) {}
    virtual void setupPageInfo(gd::string info, char const* key) {}
    virtual void forceReloadRequests(bool sent) {}
}

[[link(android)]]
class FriendRequestPopup : FLAlertLayer, UploadActionDelegate, UploadPopupDelegate, FLAlertLayerProtocol {
    // virtual ~FriendRequestPopup();

    static FriendRequestPopup* create(GJFriendRequest* request) = win 0x295830;

    virtual void keyBackClicked() = win 0x296e10;
    virtual void uploadActionFinished(int id, int response) = win 0x296e20;
    virtual void uploadActionFailed(int id, int response) = win 0x296fd0;
    virtual void onClosePopup(UploadActionPopup* popup) = win 0x297090;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x2970f0;

    void blockUser() = win inline {
        if (GameLevelManager::sharedState()->blockUser(m_request->m_accountID)) {
            m_popup = UploadActionPopup::create(this, "Blocking user...");
            m_popup->show();
        }
    }
    bool init(GJFriendRequest* request) = win 0x295970;
    void loadFromGJFriendRequest(GJFriendRequest* request) = win 0x295fe0;
    void onAccept(cocos2d::CCObject* sender);
    void onBlock(cocos2d::CCObject* sender) = win 0x296bb0;
    void onClose(cocos2d::CCObject* sender) = win 0x296900;
    void onRemove(cocos2d::CCObject* sender);

    void* m_unk;
    GJFriendRequest* m_request;
    LoadingCircle* m_circle;
    CCMenuItemSpriteExtra* m_closeBtn;
    UploadActionPopup* m_popup;
}

[[link(android)]]
class FriendsProfilePage : FLAlertLayer, FLAlertLayerProtocol, UploadActionDelegate, UploadPopupDelegate, UserListDelegate {
    // virtual ~FriendsProfilePage();

    static FriendsProfilePage* create(UserListType type) = win 0x13fc90;

    virtual void registerWithTouchDispatcher() = win 0x42660;
    virtual void keyBackClicked();
    virtual void getUserListFinished(cocos2d::CCArray* scores, UserListType type) = win 0x140850;
    virtual void getUserListFailed(UserListType type, GJErrorCode errorType) = win 0x1409a0;
    virtual void userListChanged(cocos2d::CCArray* scores, UserListType type);
    virtual void forceReloadList(UserListType type) = win 0x140a10;

    bool init(UserListType type) = win 0x13fde0;
    void onBlocked(cocos2d::CCObject* sender) = win 0x140bd0;
    void onClose(cocos2d::CCObject* sender) = win 0x140c60;
    void onUpdate(cocos2d::CCObject* sender);
    void setupUsersBrowser(cocos2d::CCArray* users, UserListType type) = win 0x1404f0;

    UserListType m_type;
    cocos2d::CCLabelBMFont* m_noInternet;
    cocos2d::CCLabelBMFont* m_totalFriends;
    GJCommentListLayer* m_listLayer;
    LoadingCircle* m_circle;
    void* m_unk532;
    cocos2d::CCArray* m_users;
    CCMenuItemSpriteExtra* m_refreshBtn;
}

[[link(android)]]
class GameCell : TableViewCell {
    // virtual ~GameCell();
    GameCell(char const* identifier, float width, float height) = win inline, ios inline : TableViewCell(identifier, width, height) {
        this->init();
    }

    virtual bool init();
    virtual void draw() = win 0x3cc50;

    void loadFromString(gd::string str) = win 0x3c860;
    void onTouch(cocos2d::CCObject* sender);
    void updateBGColor(int index) = win inline, ios inline {
        m_backgroundLayer->setColor(index % 2 == 0 ? cocos2d::ccColor3B { 0, 255, 0 } : cocos2d::ccColor3B { 255, 255, 255 });
        m_backgroundLayer->setOpacity(255);
    }

    void* m_unk230;
    gd::string m_gameLink;
}

[[link(android)]]
class GameEffectsManager : cocos2d::CCNode {
    // virtual ~GameEffectsManager();

    static GameEffectsManager* create(PlayLayer* playLayer);

    void addParticleEffect(cocos2d::CCParticleSystemQuad* particle, int unused);
    bool init(PlayLayer* playLayer);
    void scaleParticle(cocos2d::CCParticleSystemQuad* particle, float scale);

    PlayLayer* m_playLayer;
}

[[link(android)]]
class GameLevelManager : cocos2d::CCNode {
    static GameLevelManager* get() {
        return GameLevelManager::sharedState();
    }
    static cocos2d::CCDictionary* responseToDict(gd::string response, bool colon) = win 0x16abd0;
    // virtual ~GameLevelManager();
    static GameLevelManager* sharedState();

    virtual bool init() = win 0x1442d0;

    bool acceptFriendRequest(int accountID, int requestID) = win 0x1611b0;
    int accountIDForUserID(int userID);
    void addDLToActive(char const* key);
    bool areGauntletsLoaded() = win inline {
        return m_savedGauntlets->count() != 0;
    }
    void banUser(int accountID) = win inline {}
    bool blockUser(int accountID) = win 0x161f40;
    void cleanupDailyLevels() = win 0x14a720;
    cocos2d::CCArray* createAndGetAccountComments(gd::string str, int accountID) = win inline {
        return this->createAndGetCommentsFull(str, accountID, true);
    }
    cocos2d::CCArray* createAndGetCommentsFull(gd::string str, int parentID, bool account) = win 0x15d020;
    cocos2d::CCArray* createAndGetLevelComments(gd::string str, int levelID) = win inline {
        return this->createAndGetCommentsFull(str, levelID, false);
    }
    cocos2d::CCArray* createAndGetLevelLists(gd::string str);
    cocos2d::CCArray* createAndGetLevels(gd::string str);
    cocos2d::CCArray* createAndGetMapPacks(gd::string str);
    cocos2d::CCArray* createAndGetScores(gd::string str, GJScoreType type) = win 0x1471b0;
    GJGameLevel* createNewLevel() = win 0x1448b0;
    GJLevelList* createNewLevelList() = win 0x145360;
    gd::string createPageInfo(int total, int start, int count) = win inline {
        return cocos2d::CCString::createWithFormat("%i%s%i%s%i", total, ":", start, ":", count)->getCString();
    }
    GJSmartTemplate* createSmartTemplate() = win inline {
        auto smartTemplate = GJSmartTemplate::create();
        smartTemplate->m_nameIndex = this->getNextFreeTemplateID();
        m_smartTemplates->insertObject(smartTemplate, 0);
        return smartTemplate;
    }
    void dataLoaded(DS_Dictionary* dict) = win 0x14b450;
    void deleteAccountComment(int id, int accountID) = win inline {
        this->deleteComment(id, CommentType::Account, accountID);
    }
    void deleteComment(int id, CommentType type, int parentID) = win 0x15f0b0;
    bool deleteFriendRequests(int accountID, cocos2d::CCArray* accounts, bool sent) = win 0x160bb0;
    void deleteLevel(GJGameLevel* level) = win 0x145090;
    void deleteLevelComment(int id, int levelID) = win inline {
        this->deleteComment(id, CommentType::Level, levelID);
    }
    void deleteLevelList(GJLevelList* list) = win 0x145940;
    bool deleteSentFriendRequest(int accountID) = win inline {
        return this->deleteFriendRequests(accountID, nullptr, true);
    }
    void deleteServerLevel(int id) = win 0x154520;
    void deleteServerLevelList(int id) = win 0x150460;
    void deleteSmartTemplate(GJSmartTemplate* smartTemplate) = win inline {
        if (!smartTemplate) return;
        if (m_smartTemplate && m_smartTemplate->m_nameIndex == smartTemplate->m_nameIndex) m_smartTemplate = nullptr;
        m_smartTemplates->removeObject(smartTemplate);
    }
    bool deleteUserMessages(GJUserMessage* message, cocos2d::CCArray* messages, bool isSender) = win 0x15b4f0;
    void downloadLevel(int id, bool gauntletLevel);
    void downloadUserMessage(int id, bool sent) = win 0x15aac0;
    void encodeDataTo(DS_Dictionary* dict) = win 0x14af40;
    void firstSetup() = win 0x14ab80;
    void followUser(int id) = win inline {
        m_followedCreators->setObject(cocos2d::CCString::create("1"), cocos2d::CCString::createWithFormat("%i", id)->getCString());
    }
    GJFriendRequest* friendRequestFromAccountID(int id) = win inline {
        return static_cast<GJFriendRequest*>(m_friendRequests->objectForKey(id));
    }
    void friendRequestWasRemoved(int accountID, bool sent);
    const char* getAccountCommentKey(int accountID, int page) = win inline {
        return cocos2d::CCString::createWithFormat("%i_%i", accountID, page)->getCString();
    }
    void getAccountComments(int accountID, int page, int total) = win 0x15c8b0;
    int getActiveDailyID(GJTimedLevelType type) = win inline {
        if (type == GJTimedLevelType::Daily) return m_activeDailyID;
        if (type == GJTimedLevelType::Weekly) return m_activeWeeklyID;
        if (type == GJTimedLevelType::Event) return m_activeEventID;
        return 0;
    }
    GJSmartTemplate* getActiveSmartTemplate() = win inline {
        return m_smartTemplate;
    }
    cocos2d::CCArray* getAllSmartTemplates() = win inline {
        auto smartTemplates = cocos2d::CCArray::create();
        smartTemplates->addObjectsFromArray(m_smartTemplates);
        return smartTemplates;
    }
    cocos2d::CCDictionary* getAllUsedSongIDs() = win inline {
        auto dict = cocos2d::CCDictionary::create();
        cocos2d::CCDictElement* element;
        cocos2d::CCDictElement* temp;
        HASH_ITER(hh, m_onlineLevels->m_pElements, element, temp) {
            auto level = static_cast<GJGameLevel*>(element->getObject());
            if (!level->m_levelNotDownloaded && level->m_songID > 0 && !dict->objectForKey(level->m_songID)) {
                dict->setObject(cocos2d::CCNode::create(), level->m_songID);
            }
        }
        auto localLevels = LocalLevelManager::sharedState()->m_localLevels;
        for (int i = 0; i < localLevels->count(); i++) {
            auto level = static_cast<GJGameLevel*>(localLevels->objectAtIndex(i));
            if (!level->m_levelNotDownloaded && level->m_songID > 0 && !dict->objectForKey(level->m_songID)) {
                dict->setObject(cocos2d::CCNode::create(), level->m_songID);
            }
        }
        return dict;
    }
    gd::string getBasePostString() = win 0x14c5f0;
    bool getBoolForKey(char const* key) = win inline {
        return m_searchFilters->valueForKey(key)->boolValue();
    }
    gd::string getCommentKey(int ID, int page, int mode, CommentKeyType keytype) = win inline {
        return cocos2d::CCString::createWithFormat("comment_%i_%i_%i_%i", ID, page, mode, (int) keytype)->getCString();
    }
    int getCompletedDailyLevels() = win 0x148740;
    int getCompletedEventLevels(int minStars, int maxStars) = win 0x148940;
    int getCompletedGauntletDemons() = win inline {
        auto completed = 0;
        auto gsm = GameStatsManager::get();
        cocos2d::CCDictElement* element;
        cocos2d::CCDictElement* temp;
        HASH_ITER(hh, m_gauntletLevels->m_pElements, element, temp) {
            if (auto level = geode::cast::typeinfo_cast<GJGameLevel*>(element->getObject())) {
                if (level->m_stars.value() == 10 && level->m_normalPercent.value() == 100 && gsm->hasCompletedLevel(level)) {
                    completed++;
                }
            }
        }
        return completed;
    }
    int getCompletedGauntletLevels() = win inline {
        auto completed = 0;
        auto gsm = GameStatsManager::get();
        cocos2d::CCDictElement* element;
        cocos2d::CCDictElement* temp;
        HASH_ITER(hh, m_gauntletLevels->m_pElements, element, temp) {
            if (auto level = geode::cast::typeinfo_cast<GJGameLevel*>(element->getObject())) {
                if (level->m_stars.value() < 10 && level->m_normalPercent.value() == 100 && gsm->hasCompletedLevel(level)) {
                    completed++;
                }
            }
        }
        return completed;
    }
    cocos2d::CCArray* getCompletedLevels(bool useOrbCompletion) = win 0x1478e0;
    int getCompletedWeeklyLevels() = win 0x148530;
    int getDailyID(GJTimedLevelType type) = win inline {
        if (type == GJTimedLevelType::Daily) return m_dailyID;
        if (type == GJTimedLevelType::Weekly) return m_weeklyID;
        if (type == GJTimedLevelType::Event) return m_eventID;
        return 0;
    }
    int getDailyTimer(GJTimedLevelType type) = win inline {
        if (type == GJTimedLevelType::Daily) return m_dailyTimeLeft;
        if (type == GJTimedLevelType::Weekly) return m_weeklyTimeLeft;
        if (type == GJTimedLevelType::Event) return m_eventTimeLeft;
        return 0;
    }
    const char* getDeleteCommentKey(int parentID, int id, int type) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("delcomment_%i_%i_%i", id, type, parentID)->getCString();
    }
    const char* getDeleteMessageKey(int id, bool sent) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("delMsg_%i_%i", id, (int)sent)->getCString();
    }
    gd::string getDemonLevelsString() = win 0x147a70;
    const char* getDescKey(int levelID) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("desc_%i", levelID)->getCString();
    }
    gd::string getDifficultyStr(bool isNA, bool isEasy, bool isNormal, bool isHard, bool isHarder, bool isInsane, bool isDemon, bool isAuto) = win 0x14d4f0;
    const char* getDiffKey(int diff) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("Diff%i", diff)->getCString();
    }
    bool getDiffVal(int diff) = win inline {
        return m_searchFilters->valueForKey(this->getDiffKey(diff))->boolValue();
    }
    gd::string getFolderName(int id, bool local) = win 0x14aa50;
    const char* getFriendRequestKey(bool sent, int page) = win inline {
        return cocos2d::CCString::createWithFormat("fReq_%i_%i", (int)sent, page)->getCString();
    }
    void getFriendRequests(bool sent, int page, int total);
    const char* getGauntletKey(int id) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("%i", id)->getCString();
    }
    void getGauntletLevels(int id) = win 0x151af0;
    void getGauntlets() = win 0x151240;
    gd::string getGauntletSearchKey(int id) = win inline {
        return cocos2d::CCString::createWithFormat("gauntlet_%i", id)->getCString();
    }
    bool getGJChallenges() = win 0x167550;
    bool getGJDailyLevelState(GJTimedLevelType type) = win 0x168950;
    bool getGJRewards(int type) = win 0x166060;
    bool getGJSecretReward(gd::string key) = win 0x164f30;
    void getGJUserInfo(int id) = win 0x159e50;
    int getHighestLevelOrder() = win inline {
        auto result = 0;
        cocos2d::CCDictElement* element;
        cocos2d::CCDictElement* temp;
        HASH_ITER(hh, m_onlineLevels->m_pElements, element, temp) {
            auto level = static_cast<GJGameLevel*>(element->getObject());
            if (level->m_levelIndex > result) result = level->m_levelIndex;
        }
        return result;
    }
    int getIntForKey(char const* key) = win inline {
        return m_searchFilters->valueForKey(key)->intValue();
    }
    void getLeaderboardScores(char const* key);
    gd::string getLengthStr(bool isTiny, bool isShort, bool isMedium, bool isLong, bool isXL, bool isPlat) = win 0x14d7a0;
    const char* getLenKey(int len) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("Len%i", len)->getCString();
    }
    bool getLenVal(int len) = win inline {
        return m_searchFilters->valueForKey(this->getLenKey(len))->boolValue();
    }
    void getLevelComments(int ID, int page, int total, int mode, CommentKeyType keytype) = win 0x15be40;
    const char* getLevelDownloadKey(int levelID, bool isGauntlet) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("%i_%i", levelID, isGauntlet)->getCString();
    }
    const char* getLevelKey(int levelID) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("%i", levelID)->getCString();
    }
    void getLevelLeaderboard(GJGameLevel* level, LevelLeaderboardType type, LevelLeaderboardMode mode);
    const char* getLevelLeaderboardKey(int levelID, LevelLeaderboardType type, LevelLeaderboardMode mode) = win inline {
        return cocos2d::CCString::createWithFormat("ll_%i_%i_%i", levelID, (int)type, (int)mode)->getCString();
    }
    const char* getLevelListKey(int listID) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("%i", listID)->getCString();
    }
    void getLevelLists(GJSearchObject* object) = win 0x1507a0;
    void getLevelSaveData() = win 0x14ee00;
    const char* getLikeAccountItemKey(LikeItemType type, int id, bool liked, int parentID) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("like_%i_%i_%i_%i", type, id, (int)liked, parentID)->getCString();
    }
    const char* getLikeItemKey(LikeItemType type, int id, bool liked, int parentID) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("like_%i_%i_%i_%i", type, id, (int)liked, parentID)->getCString();
    }
    GJGameLevel* getLocalLevel(int uniqueID);
    GJGameLevel* getLocalLevelByName(gd::string name) = win inline, ios inline {
        auto localLevels = LocalLevelManager::sharedState()->m_localLevels;
        for (int i = 0; i < localLevels->count(); i++) {
            auto level = static_cast<GJGameLevel*>(localLevels->objectAtIndex(i));
            if (level->m_levelName == name) return level;
        }
        return nullptr;
    }
    GJLevelList* getLocalLevelList(int uniqueID);
    int getLowestLevelOrder() = win inline {
        auto result = INT_MAX;
        cocos2d::CCDictElement* element;
        cocos2d::CCDictElement* temp;
        HASH_ITER(hh, m_onlineLevels->m_pElements, element, temp) {
            auto level = static_cast<GJGameLevel*>(element->getObject());
            if (level->m_levelIndex < result) result = level->m_levelIndex;
        }
        return result;
    }
    GJGameLevel* getMainLevel(int levelID, bool dontGetLevelString) = win 0x144490;
    const char* getMapPackKey(int pack) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("pack_%i", pack)->getCString();
    }
    void getMapPacks(GJSearchObject* object) = win 0x14f530;
    const char* getMessageKey(int id) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("message_%i", id)->getCString();
    }
    const char* getMessagesKey(bool sent, int page) = win inline {
        return cocos2d::CCString::createWithFormat("messages_%i_%i", (int)sent, page)->getCString();
    }
    void getNews() = win inline, ios inline {
        if (!m_testedNetwork) m_testedNetwork = true;
    }
    int getNextFreeTemplateID() = win inline {
        auto result = 0;
        auto dict = cocos2d::CCDictionary::create();
        auto node = cocos2d::CCNode::create();
        for (int i = 0; i < m_smartTemplates->count(); i++) {
            auto index = static_cast<GJSmartTemplate*>(m_smartTemplates->objectAtIndex(i))->m_nameIndex;
            if (index > result) result = index;
            dict->setObject(node, index);
        }
        for (int i = 0; i < 1001; i++) {
            if (!dict->objectForKey(i)) return i;
        }
        return result;
    }
    gd::string getNextLevelName(gd::string name) = win 0x144b70;
    void getOnlineLevels(GJSearchObject* object) = win 0x14dcb0;
    const char* getPageInfo(char const* key);
    const char* getPostCommentKey(int parentID) = win inline {
        return cocos2d::CCString::createWithFormat("c%i", parentID)->getCString();
    }
    const char* getRateStarsKey(int levelID) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("%i", levelID)->getCString();
    }
    const char* getReportKey(int levelID) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("%i", levelID)->getCString();
    }
    GJGameLevel* getSavedDailyLevel(int dailyID);
    GJGameLevel* getSavedDailyLevelFromLevelID(int id) = win inline {
        cocos2d::CCDictElement* element;
        cocos2d::CCDictElement* temp;
        HASH_ITER(hh, m_dailyLevels->m_pElements, element, temp) {
            auto level = static_cast<GJGameLevel*>(element->getObject());
            if (level->m_levelID.value() == id) return level;
        }
        return nullptr;
    }
    GJMapPack* getSavedGauntlet(int id) = win inline {
        return static_cast<GJMapPack*>(m_savedGauntlets->objectForKey(this->getGauntletKey(id)));
    }
    GJGameLevel* getSavedGauntletLevel(int id);
    GJGameLevel* getSavedLevel(GJGameLevel* level) = win inline {
        if (!level) return nullptr;
        else if (level->m_dailyID.value() > 0) return this->getSavedDailyLevel(level->m_dailyID.value());
        else if (level->m_gauntletLevel) return this->getSavedGauntletLevel(level->m_levelID.value());
        else return this->getSavedLevel(level->m_levelID.value());
    }
    GJGameLevel* getSavedLevel(int id);
    GJLevelList* getSavedLevelList(int listID) = win inline {
        return static_cast<GJLevelList*>(m_favoriteLists->objectForKey(this->getLevelListKey(listID)));
    }
    cocos2d::CCArray* getSavedLevelLists(int folder) = win 0x147650;
    cocos2d::CCArray* getSavedLevels(bool favorite, int folder) = win 0x147490;
    GJMapPack* getSavedMapPack(int id) = win inline {
        return static_cast<GJMapPack*>(m_savedPacks->objectForKey(this->getMapPackKey(id)));
    }
    cocos2d::CCScene* getSearchScene(char const* key) = win inline {
        if (auto searchObject = GJSearchObject::createFromKey(key)) {
            return LevelBrowserLayer::scene(searchObject);
        }
        return nullptr;
    }
    int getSplitIntFromKey(char const* key, int index) = win 0x15d5e0;
    gd::string getStarLevelsString() = win 0x147c70;
    cocos2d::CCArray* getStoredLevelComments(char const* key);
    cocos2d::CCArray* getStoredOnlineLevels(char const* key) = win 0x1498c0;
    cocos2d::CCArray* getStoredUserList(UserListType type) = win 0x1630e0;
    GJUserMessage* getStoredUserMessage(int id) = win inline {
        return static_cast<GJUserMessage*>(m_userMessages->objectForKey(id));
    }
    GJUserMessage* getStoredUserMessageReply(int id) = win inline {
        return static_cast<GJUserMessage*>(m_userReplies->objectForKey(id));
    }
    int getTimeLeft(char const* key, float length);
    void getTopArtists(int page, int total) = win 0x158ff0;
    const char* getTopArtistsKey(int page) = win inline {
        return cocos2d::CCString::createWithFormat("topArtists_%i", page)->getCString();
    }
    const char* getUploadMessageKey(int accountID) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("uMsg_%i", accountID)->getCString();
    }
    const char* getUserInfoKey(int id) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("account_%i", id)->getCString();
    }
    void getUserList(UserListType type) = win 0x1629d0;
    void getUserMessages(bool sent, int page, int total);
    void getUsers(GJSearchObject* object) = win 0x159790;
    void gotoLevelPage(GJGameLevel* level);
    void handleIt(bool success, gd::string response, gd::string tag, GJHttpType type) = win 0x143030;
    void handleItDelayed(bool success, gd::string response, gd::string tag, GJHttpType type) = win inline, ios inline {
        auto result = GJHttpResult::create(true, response, tag, type);
        result->retain();
        m_pActionManager->addAction(cocos2d::CCSequence::create(
            cocos2d::CCDelayTime::create(.1f),
            cocos2d::CCCallFuncND::create(this, callfuncND_selector(GJMultiplayerManager::handleItND), result),
            nullptr
        ), this, false);
    }
    void handleItND(cocos2d::CCNode* node, void* data) = win inline, ios inline {
        auto result = static_cast<GJHttpResult*>(data);
        this->handleIt(result->m_success, result->m_response, result->m_requestTag, result->m_httpType);
        result->release();
    }
    bool hasDailyStateBeenLoaded(GJTimedLevelType type) = win inline {
        if (type == GJTimedLevelType::Daily) return m_dailyTimeLeft > 0;
        if (type == GJTimedLevelType::Weekly) return m_weeklyTimeLeft > 0;
        if (type == GJTimedLevelType::Event) return m_eventTimeLeft > 0;
        return false;
    }
    bool hasDownloadedLevel(int id);
    bool hasDownloadedList(int id) = win inline, ios inline {
        return this->hasDownloadedLevel(-id);
    }
    bool hasLikedAccountItem(LikeItemType type, int id, bool liked, int parentID) = win 0x164e50;
    bool hasLikedItem(LikeItemType type, int id, bool liked, int parentID) = win 0x164e50;
    bool hasLikedItemFullCheck(LikeItemType type, int id, bool liked, int parentID) = win 0x164dc0;
    bool hasRatedDemon(int id);
    bool hasRatedLevelStars(int id);
    bool hasReportedLevel(int id);
    void invalidateMessages(bool sent, bool reload);
    void invalidateRequests(bool sent, bool reload);
    void invalidateUserList(UserListType type, bool reload) = win inline {
        this->resetStoredUserList(type);
        if (reload && m_userListDelegate) m_userListDelegate->forceReloadList(type);
    }
    bool isDLActive(char const* tag);
    bool isFollowingUser(int id);
    bool isTimeValid(char const* key, float length);
    bool isUpdateValid(int id) = win inline {
        const char* str = cocos2d::CCString::createWithFormat("%i", id)->getCString();

        return this->isTimeValid(str, 3600.f);
    }
    int itemIDFromLikeKey(char const* key) = win inline {
        std::string keyStr = key;
        auto parts = cocos2d::CCArray::create();
        auto start = 0;
        auto index = keyStr.find_first_of(",");
        auto size = keyStr.size();
        while (index != std::string::npos) {
            auto str = keyStr.substr(start, index - start);
            if (!str.empty() || start != size) {
                parts->addObject(cocos2d::CCString::create(str));
            }
            start = index + 1;
            index = keyStr.find_first_of(",", start);
        }
        return parts->count() > 4 ? atoi(static_cast<cocos2d::CCString*>(parts->objectAtIndex(2))->getCString()) : 0;
    }
    bool keyHasTimer(char const* key);
    int levelIDFromCommentKey(char const* key) = win 0x15d6e0;
    int levelIDFromPostCommentKey(char const* key) = win inline {
        std::string keyStr = key;
        auto parts = cocos2d::CCArray::create();
        auto start = 0;
        auto index = keyStr.find_first_of(",");
        auto size = keyStr.size();
        while (index != std::string::npos) {
            auto str = keyStr.substr(start, index - start);
            if (!str.empty() || start != size) {
                parts->addObject(cocos2d::CCString::create(str));
            }
            start = index + 1;
            index = keyStr.find_first_of(",", start);
        }
        return parts->count() > 1 ? atoi(static_cast<cocos2d::CCString*>(parts->objectAtIndex(1))->getCString()) : 0;
    }
    int likeFromLikeKey(char const* key) = win inline {
        std::string keyStr = key;
        auto parts = cocos2d::CCArray::create();
        auto start = 0;
        auto index = keyStr.find_first_of(",");
        auto size = keyStr.size();
        while (index != std::string::npos) {
            auto str = keyStr.substr(start, index - start);
            if (!str.empty() || start != size) {
                parts->addObject(cocos2d::CCString::create(str));
            }
            start = index + 1;
            index = keyStr.find_first_of(",", start);
        }
        return parts->count() > 4 ? atoi(static_cast<cocos2d::CCString*>(parts->objectAtIndex(3))->getCString()) : 0;
    }
    void likeItem(LikeItemType type, int id, bool liked, int parentID) = win 0x163ca0;
    void limitSavedLevels() = win 0x14a1d0;
    void makeTimeStamp(char const* key) = win 0x149cd0;
    void markItemAsLiked(LikeItemType type, int id, bool liked, int parentID) = win 0x164c50;
    void markLevelAsDownloaded(int id) = win 0x1536d0;
    void markLevelAsRatedDemon(int id) = win inline {
        if (m_ratedDemons->count() > 999) m_ratedDemons->removeObjectForKey(m_ratedDemons->getFirstKey());
        m_ratedDemons->setObject(m_trueString, cocos2d::CCString::createWithFormat("%i", id)->getCString());
    }
    void markLevelAsRatedStars(int id) = win inline {
        if (m_ratedLevels->count() > 999) m_ratedLevels->removeObjectForKey(m_ratedLevels->getFirstKey());
        m_ratedLevels->setObject(m_trueString, this->getRateStarsKey(id));
    }
    void markLevelAsReported(int id) = win inline {
        if (m_reportedLevels->count() > 9) m_reportedLevels->removeObjectForKey(m_reportedLevels->getFirstKey());
        m_reportedLevels->setObject(m_trueString, this->getReportKey(id));
    }
    void markListAsDownloaded(int id) = win inline {
        this->markLevelAsDownloaded(-id);
    }
    void messageWasRemoved(int id, bool sent);
    void onAcceptFriendRequestCompleted(gd::string response, gd::string tag) = win 0x1614d0;
    void onBanUserCompleted(gd::string response, gd::string tag) = win inline {
        if (response != "-1") this->resetTimerForKey("leaderboard_top");
    }
    void onBlockUserCompleted(gd::string response, gd::string tag) = win 0x162250;
    void onDeleteCommentCompleted(gd::string response, gd::string tag) = win 0x15f590;
    void onDeleteFriendRequestCompleted(gd::string response, gd::string tag) = win 0x160fb0;
    void onDeleteServerLevelCompleted(gd::string response, gd::string tag);
    void onDeleteServerLevelListCompleted(gd::string response, gd::string tag) = win inline {
        m_queuedLists.erase(tag);
        auto responseInt = atoi(response.c_str());
        if (response == "-1") {
            if (m_levelListDeleteDelegate) m_levelListDeleteDelegate->levelListDeleteFailed(responseInt);
        }
        else {
            if (m_levelListDeleteDelegate) m_levelListDeleteDelegate->levelListDeleteFinished(responseInt);
        }
    }
    void onDeleteUserMessagesCompleted(gd::string response, gd::string tag) = win 0x15b960;
    void onDownloadLevelCompleted(gd::string response, gd::string tag) = win inline {
        this->processOnDownloadLevelCompleted(response, tag, false);
    }
    void onDownloadUserMessageCompleted(gd::string response, gd::string tag) = win 0x15ad00;
    void onGetAccountCommentsCompleted(gd::string response, gd::string tag) = win 0x15cae0;
    void onGetFriendRequestsCompleted(gd::string response, gd::string tag) = win 0x15ff40;
    void onGetGauntletsCompleted(gd::string response, gd::string tag);
    void onGetGJChallengesCompleted(gd::string response, gd::string tag) = win 0x1679b0;
    void onGetGJDailyLevelStateCompleted(gd::string response, gd::string tag) = win 0x168e30;
    void onGetGJRewardsCompleted(gd::string response, gd::string tag) = win 0x1667d0;
    void onGetGJSecretRewardCompleted(gd::string response, gd::string tag) = win 0x1653e0;
    void onGetGJUserInfoCompleted(gd::string response, gd::string tag) = win 0x15a070;
    void onGetLeaderboardScoresCompleted(gd::string response, gd::string tag);
    void onGetLevelCommentsCompleted(gd::string response, gd::string tag) = win 0x15c370;
    void onGetLevelLeaderboardCompleted(gd::string response, gd::string tag) = win inline {
        this->removeDLFromActive(tag.c_str());
        if (response == "-1") {
            if (m_leaderboardManagerDelegate) m_leaderboardManagerDelegate->loadLeaderboardFailed(tag.c_str());
        }
        else {
            auto scores = this->createAndGetScores(response, GJScoreType::LevelScore);
            this->storeSearchResult(scores, " ", tag.c_str());
            if (m_leaderboardManagerDelegate) m_leaderboardManagerDelegate->loadLeaderboardFinished(scores, tag.c_str());
        }
    }
    void onGetLevelListsCompleted(gd::string response, gd::string tag) = win 0x150a30;
    void onGetLevelSaveDataCompleted(gd::string response, gd::string tag) = win 0x14f0e0;
    void onGetMapPacksCompleted(gd::string response, gd::string tag) = win 0x14f740;
    void onGetNewsCompleted(gd::string response, gd::string tag) = win inline, ios inline {}
    void onGetOnlineLevelsCompleted(gd::string response, gd::string tag);
    void onGetTopArtistsCompleted(gd::string response, gd::string tag) = win 0x159310;
    void onGetUserListCompleted(gd::string response, gd::string tag) = win 0x162be0;
    void onGetUserMessagesCompleted(gd::string response, gd::string tag) = win 0x15a440;
    void onGetUsersCompleted(gd::string response, gd::string tag) = win 0x1599f0;
    void onLikeItemCompleted(gd::string response, gd::string tag) = win 0x1642b0;
    void onProcessHttpRequestCompleted(cocos2d::extension::CCHttpClient* client, cocos2d::extension::CCHttpResponse* response) = win 0x142f40;
    void onRateDemonCompleted(gd::string response, gd::string tag) = win 0x1557c0;
    void onRateStarsCompleted(gd::string response, gd::string tag) = win 0x154190;
    void onReadFriendRequestCompleted(gd::string response, gd::string tag) = win inline {
        m_friendReqAndUserBlocks->removeObjectForKey(tag);
    }
    void onRemoveFriendCompleted(gd::string response, gd::string tag) = win 0x161cf0;
    void onReportLevelCompleted(gd::string response, gd::string tag) = win 0x16a560;
    void onRequestUserAccessCompleted(gd::string response, gd::string tag) = win 0x1649e0;
    void onRestoreItemsCompleted(gd::string response, gd::string tag) = win 0x169b80;
    void onSetLevelFeaturedCompleted(gd::string response, gd::string tag) = win inline {}
    void onSetLevelStarsCompleted(gd::string response, gd::string tag);
    void onSubmitUserInfoCompleted(gd::string response, gd::string tag) = win inline {}
    void onSuggestLevelStarsCompleted(gd::string response, gd::string tag) = win 0x1550f0;
    void onUnblockUserCompleted(gd::string response, gd::string tag) = win 0x162770;
    void onUpdateDescriptionCompleted(gd::string response, gd::string tag) = win 0x163a40;
    void onUpdateLevelCompleted(gd::string response, gd::string tag) = win inline {
        this->processOnDownloadLevelCompleted(response, tag, true);
    }
    void onUpdateUserScoreCompleted(gd::string response, gd::string tag) = win 0x157690;
    void onUploadCommentCompleted(gd::string response, gd::string tag) = win 0x15e3b0;
    void onUploadFriendRequestCompleted(gd::string response, gd::string tag) = win 0x1609e0;
    void onUploadLevelCompleted(gd::string response, gd::string tag) = win 0x14d2e0;
    void onUploadLevelListCompleted(gd::string response, gd::string tag) = win inline {
        m_queuedLists.erase(tag);
        auto listID = atoi(response.c_str());
        auto uniqueID = atoi(tag.c_str());
        if (listID < 0) {
            if (m_listUploadDelegate) m_listUploadDelegate->listUploadFailed(this->getLocalLevelList(uniqueID), listID);
        }
        else {
            auto levelList = this->getLocalLevelList(uniqueID);
            if (levelList) {
                levelList->m_listID = listID;
                levelList->m_uploaded = true;
            }
            if (m_listUploadDelegate) m_listUploadDelegate->listUploadFinished(levelList);
        }
    }
    void onUploadUserMessageCompleted(gd::string response, gd::string tag) = win 0x15b2d0;
    int pageFromCommentKey(char const* key) = win inline {
        std::string keyStr = key;
        auto parts = cocos2d::CCArray::create();
        auto start = 0;
        auto index = keyStr.find_first_of(",");
        auto size = keyStr.size();
        while (index != std::string::npos) {
            auto str = keyStr.substr(start, index - start);
            if (!str.empty() || start != size) {
                parts->addObject(cocos2d::CCString::create(str));
            }
            start = index + 1;
            index = keyStr.find_first_of(",", start);
        }
        return parts->count() > 2 ? atoi(static_cast<cocos2d::CCString*>(parts->objectAtIndex(2))->getCString()) : 0;
    }
    void parseRestoreData(gd::string str) = win inline, ios inline {}
    void performNetworkTest() = win inline {
        if (m_testedNetwork) return;
        m_testedNetwork = true;
        auto request = new cocos2d::extension::CCHttpRequest();
        request->setUrl("https://www.google.com");
        request->setReadTimeout(1);
        request->setRequestType(cocos2d::extension::CCHttpRequest::kHttpPost);
        request->setResponseCallback(this, httpresponse_selector(GameLevelManager::onProcessHttpRequestCompleted));
        request->setRequestData("temp", 4);
        request->setTag("tag");
        request->setType(56);
        cocos2d::extension::CCHttpClient::getInstance()->send(request);
        request->release();
    }
    void ProcessHttpRequest(gd::string endpoint, gd::string params, gd::string tag, GJHttpType httpType) = win 0x142da0;
    void processOnDownloadLevelCompleted(gd::string response, gd::string tag, bool update);
    void purgeUnusedLevels() = win 0x14a470;
    bool rateDemon(int id, int diff, bool moderator) = win 0x155390;
    void rateStars(int id, int diff) = win 0x153b00;
    void readFriendRequest(int id) = win 0x1616c0;
    void removeDelimiterChars(gd::string str, bool colon) = win 0x16a9a0;
    void removeDLFromActive(char const* key);
    bool removeFriend(int accountID) = win 0x1619d0;
    void removeLevelDownloadedKeysFromDict(cocos2d::CCDictionary* dict);
    void removeUserFromList(int id, UserListType type) = win 0x162920;
    void reportLevel(int id) = win 0x16a2c0;
    bool requestUserAccess() = win 0x164700;
    void resetAccountComments(int accountID) = win inline {
        for(int i = 0; i <= 1; i++) {
            auto key = getAccountCommentKey(accountID, i);
            if(getStoredOnlineLevels(key)) {
                m_storedLevels->removeObjectForKey(key);
            }
        }
    }
    void resetAllTimers() = win inline, ios inline {
        m_timerDict->removeAllObjects();
    }
    void resetCommentTimersForAccountID(int id) = win 0x15ef10;
    void resetCommentTimersForLevelID(int id, CommentKeyType type) = win 0x15ed40;
    void resetDailyLevelState(GJTimedLevelType type) = win inline {
        if (type == GJTimedLevelType::Daily) {
            m_dailyTimeLeft = 0;
            m_dailyID = 0;
        }
        else if (type == GJTimedLevelType::Weekly) {
            m_weeklyTimeLeft = 0;
            m_weeklyID = 0;
        }
        else if (type == GJTimedLevelType::Event) {
            m_eventTimeLeft = 0;
            m_eventID = 0;
        }
    }
    void resetGauntlets() = win inline {
        m_savedGauntlets->removeAllObjects();
    }
    void resetStoredUserInfo(int id) = win inline {
        m_storedUserInfo->removeObjectForKey(id);
    }
    void resetStoredUserList(UserListType type) = win 0x163270;
    void resetTimerForKey(char const* key);
    void restoreItems();
    void saveFetchedLevelLists(cocos2d::CCArray* lists) = win inline, ios inline {
        for (int i = 0; i < lists->count(); i++) {
            this->saveLevelList(static_cast<GJLevelList*>(lists->objectAtIndex(i)));
        }
    }
    void saveFetchedLevels(cocos2d::CCArray* levels) = win 0x1469e0;
    void saveFetchedMapPacks(cocos2d::CCArray* packs) = win inline {
        for (int i = 0; i < packs->count(); i++) {
            this->saveMapPack(static_cast<GJMapPack*>(packs->objectAtIndex(i)));
        }
    }
    void saveGauntlet(GJMapPack* gauntlet) = win inline {
        m_savedGauntlets->setObject(gauntlet, this->getGauntletKey(gauntlet->m_packID));
    }
    void saveLevel(GJGameLevel* level) = win 0x148dc0;
    void saveLevelList(GJLevelList* list);
    void saveLocalScore(int id, int value, int type) = win inline, ios inline {}
    void saveMapPack(GJMapPack* pack) = win inline {
        m_savedPacks->setObject(pack, this->getMapPackKey(pack->m_packID));
    }
    void setActiveSmartTemplate(GJSmartTemplate* smartTemplate) = win inline, ios inline {
        m_smartTemplate = smartTemplate;
    }
    void setBoolForKey(bool value, char const* key) = win inline {
        m_searchFilters->setObject(cocos2d::CCString::createWithFormat("%i", (int)value), key);
    }
    void setDiffVal(int diff, bool value);
    void setFolderName(int id, gd::string name, bool local) = win inline {
        auto dict = local ? m_localLevelsFolders : m_onlineFolders;
        dict->setObject(cocos2d::CCString::create(name), cocos2d::CCString::createWithFormat("%i", id)->getCString());
    }
    void setIntForKey(int value, char const* key) = win inline {
        m_searchFilters->setObject(cocos2d::CCString::createWithFormat("%i", value), key);
    }
    void setLenVal(int diff, bool value);
    void setLevelFeatured(int id, int rank, bool epic) = win inline, ios inline {}
    bool setLevelStars(int id, int stars, bool coins) = win inline, ios inline { return false; }
    int specialFromLikeKey(char const* key) = win inline, ios inline {
        std::string keyStr = key;
        auto parts = cocos2d::CCArray::create();
        auto start = 0;
        auto index = keyStr.find_first_of(",");
        auto size = keyStr.size();
        while (index != std::string::npos) {
            auto str = keyStr.substr(start, index - start);
            if (!str.empty() || start != size) {
                parts->addObject(cocos2d::CCString::create(str));
            }
            start = index + 1;
            index = keyStr.find_first_of(",", start);
        }
        return parts->count() > 4 ? atoi(static_cast<cocos2d::CCString*>(parts->objectAtIndex(4))->getCString()) : 0;
    }
    void storeCommentsResult(cocos2d::CCArray* comments, gd::string pageInfo, char const* key) = win 0x15d7f0;
    void storeDailyLevelState(int id, int remaining, GJTimedLevelType type) = win inline {
        if (type != GJTimedLevelType::Daily && type != GJTimedLevelType::Weekly && type != GJTimedLevelType::Event) return;
        __timeb64 current;
        _ftime64_s(&current);
        auto currentTime = ((current.time & 0xfffff) * 1000 + current.millitm) / 1000.0;
        if (type == GJTimedLevelType::Daily) {
            m_dailyID = id;
            m_dailyTimeLeft = currentTime + remaining;
        }
        else if (type == GJTimedLevelType::Weekly) {
            m_weeklyID = id;
            m_weeklyTimeLeft = currentTime + remaining;
        }
        else if (type == GJTimedLevelType::Event) {
            m_eventID = id;
            m_eventTimeLeft = currentTime + remaining;
        }
    }
    void storeFriendRequest(GJFriendRequest* request) = win inline, ios inline {
        if (request && request->m_accountID > 0) m_friendRequests->setObject(request, request->m_accountID);
    }
    void storeSearchResult(cocos2d::CCArray* levels, gd::string pageInfo, char const* searchKey) = win 0x1496b0;
    void storeUserInfo(GJUserScore* score) = win inline, ios inline {
        if (score && score->m_accountID > 0) m_storedUserInfo->setObject(score, score->m_accountID);
    }
    void storeUserMessage(GJUserMessage* message) = win inline, ios inline {
        if (message) m_userMessages->setObject(message, message->m_messageID);
    }
    void storeUserMessageReply(int id, GJUserMessage* message) = win inline {
        if (message) m_userReplies->setObject(message, id);
    }
    void storeUserName(int userID, int accountID, gd::string userName) = win 0x145d50;
    void storeUserNames(gd::string usernameString) = win 0x145a50;
    void submitUserInfo() = win 0x169e80;
    void suggestLevelStars(int id, int stars, int feature) = win 0x154dd0;
    gd::string tryGetUsername(int accountID) = win 0x1460b0;
    CommentType typeFromCommentKey(char const* key) = win inline {
        std::string keyStr = key;
        auto parts = cocos2d::CCArray::create();
        auto start = 0;
        auto index = keyStr.find_first_of(",");
        auto size = keyStr.size();
        while (index != std::string::npos) {
            auto str = keyStr.substr(start, index - start);
            if (!str.empty() || start != size) {
                parts->addObject(cocos2d::CCString::create(str));
            }
            start = index + 1;
            index = keyStr.find_first_of(",", start);
        }
        return parts->count() > 3 ? (CommentType)atoi(static_cast<cocos2d::CCString*>(parts->objectAtIndex(3))->getCString()) : CommentType::Level;
    }
    LikeItemType typeFromLikeKey(char const* key) = win inline {
        std::string keyStr = key;
        auto parts = cocos2d::CCArray::create();
        auto start = 0;
        auto index = keyStr.find_first_of(",");
        auto size = keyStr.size();
        while (index != std::string::npos) {
            auto str = keyStr.substr(start, index - start);
            if (!str.empty() || start != size) {
                parts->addObject(cocos2d::CCString::create(str));
            }
            start = index + 1;
            index = keyStr.find_first_of(",", start);
        }
        return parts->count() > 4 ? (LikeItemType)atoi(static_cast<cocos2d::CCString*>(parts->objectAtIndex(1))->getCString()) : LikeItemType::Unknown;
    }
    bool unblockUser(int id) = win 0x162450;
    void unfollowUser(int id) = win inline {
        m_followedCreators->removeObjectForKey(cocos2d::CCString::createWithFormat("%i", id)->getCString());
    }
    bool updateDescription(int id, gd::string description) = win 0x1636f0;
    void updateLevel(GJGameLevel* level) = win 0x1538c0;
    void updateLevelOrders() = win 0x147700;
    void updateLevelRewards(GJGameLevel* level) = win 0x146400;
    void updateSavedLevelList(GJLevelList* list) = win 0x151000;
    void updateUsernames() = win inline {
        cocos2d::CCDictElement* element;
        cocos2d::CCDictElement* temp;
        HASH_ITER(hh, m_onlineLevels->m_pElements, element, temp) {
            auto level = static_cast<GJGameLevel*>(element->getObject());
            this->storeUserName(level->m_userID.value(), level->m_accountID.value(), level->m_creatorName);
        }
    }
    void updateUserScore() = win 0x155ca0;
    void uploadAccountComment(gd::string content) = win inline {
        this->uploadComment(content, CommentType::Account, 0, 0);
    }
    void uploadComment(gd::string content, CommentType type, int levelID, int percent) = win 0x15dae0;
    bool uploadFriendRequest(int accountID, gd::string content) = win 0x1605d0;
    void uploadLevel(GJGameLevel* level) = win 0x14c800;
    void uploadLevelComment(int levelID, gd::string content, int percent) = win inline {
        this->uploadComment(content, CommentType::Level, levelID, percent);
    }
    void uploadLevelList(GJLevelList* list) = win 0x14fe30;
    void uploadUserMessage(int accountID, gd::string subject, gd::string content) = win 0x15ae80;
    int userIDForAccountID(int id) = win inline {
        return m_userIDtoAccountIDDict->valueForKey(id)->intValue();
    }
    GJUserScore* userInfoForAccountID(int id) = win inline {
        return static_cast<GJUserScore*>(m_storedUserInfo->objectForKey(id));
    }
    gd::string userNameForUserID(int id) = win 0x145f30;
    bool verifyContainerOnlyHasLevels(cocos2d::CCDictionary* dict) = win 0x14b1e0;
    void verifyLevelState(GJGameLevel* level) = win inline {
        auto gsm = GameStatsManager::sharedState();
        if (gsm->hasCompletedLevel(level) && level->shouldCheatReset()) {
            gsm->uncompleteLevel(level);
            level->m_normalPercent = 0;
            level->m_orbCompletion = 0;
            level->m_newNormalPercent2 = 0;
            level->m_bestTime = 0;
            level->m_bestPoints = 0;
            level->m_isCompletionLegitimate = true;
        }
    }
    gd::string writeSpecialFilters(GJSearchObject* object) = win 0x14d9f0;

    gd::set<gd::string> m_queuedLists;
    cocos2d::CCDictionary* m_mainLevels;
    cocos2d::CCDictionary* m_searchFilters; //"value dict"
    cocos2d::CCDictionary* m_onlineLevels;
    cocos2d::CCDictionary* m_storedLevelData;
    cocos2d::CCDictionary* m_followedCreators;
    cocos2d::CCDictionary* m_favoriteLists;
    cocos2d::CCDictionary* m_downloadedLevels;
    cocos2d::CCDictionary* m_likedLevels;
    cocos2d::CCDictionary* m_ratedLevels;
    cocos2d::CCDictionary* m_ratedDemons;
    cocos2d::CCDictionary* m_reportedLevels;
    cocos2d::CCDictionary* m_onlineFolders;
    cocos2d::CCDictionary* m_localLevelsFolders;
    cocos2d::CCDictionary* m_dailyLevels;
    int m_dailyTimeLeft;
    int m_dailyID;
    int m_activeDailyID;
    int m_weeklyTimeLeft;
    int m_weeklyID;
    int m_activeWeeklyID;
    int m_eventTimeLeft;
    int m_eventID;
    int m_activeEventID;
    cocos2d::CCDictionary* m_gauntletLevels;
    gd::map<gd::string, bool> m_availableFilters;
    cocos2d::CCDictionary* m_timerDict;
    cocos2d::CCDictionary* m_knownUsers;
    cocos2d::CCDictionary* m_accountIDtoUserIDDict;
    cocos2d::CCDictionary* m_userIDtoAccountIDDict;
    cocos2d::CCDictionary* m_storedLevels;
    cocos2d::CCDictionary* m_pageInfo;
    cocos2d::CCDictionary* m_unkDict20;
    cocos2d::CCDictionary* m_savedPacks;
    cocos2d::CCDictionary* m_savedGauntlets;
    cocos2d::CCDictionary* m_downloadObjects;
    cocos2d::CCDictionary* m_friendReqAndUserBlocks;
    cocos2d::CCDictionary* m_storedUserInfo;
    cocos2d::CCDictionary* m_friendRequests;
    cocos2d::CCDictionary* m_userMessages;
    cocos2d::CCDictionary* m_userReplies;
    gd::string m_searchKey;
    gd::string m_mapPackKey;
    LeaderboardState m_leaderboardState;
    bool m_returnToLocalLevels;
    LevelManagerDelegate* m_levelManagerDelegate;
    LevelDownloadDelegate* m_levelDownloadDelegate;
    LevelCommentDelegate* m_levelCommentDelegate;
    CommentUploadDelegate* m_commentUploadDelegate;
    LevelUploadDelegate* m_levelUploadDelegate;
    ListUploadDelegate* m_listUploadDelegate;
    LevelUpdateDelegate* m_levelUpdateDelegate;
    LeaderboardManagerDelegate* m_leaderboardManagerDelegate;
    LevelDeleteDelegate* m_levelDeleteDelegate;
    LevelListDeleteDelegate* m_levelListDeleteDelegate;
    UserInfoDelegate* m_userInfoDelegate;
    UploadActionDelegate* m_uploadActionDelegate;
    UserListDelegate* m_userListDelegate;
    FriendRequestDelegate* m_friendRequestDelegate;
    MessageListDelegate* m_messageListDelegate;
    DownloadMessageDelegate* m_downloadMessageDelegate;
    UploadMessageDelegate* m_uploadMessageDelegate;
    GJRewardDelegate* m_GJRewardDelegate;
    GJOnlineRewardDelegate* m_GJOnlineRewardDelegate;
    GJChallengeDelegate* m_GJChallengeDelegate;
    GJDailyLevelDelegate* m_GJDailyLevelDelegate;
    OnlineListDelegate* m_onlineListDelegate;
    SearchType m_searchType;
    int m_mapPack;
    gd::string m_tempSave;
    cocos2d::CCString* m_trueString;
    cocos2d::CCArray* m_smartTemplates;
    GJSmartTemplate* m_smartTemplate;
    bool m_testedNetwork;
}

[[link(android)]]
class GameLevelOptionsLayer : GJOptionsLayer {
    // virtual ~GameLevelOptionsLayer();

    static GameLevelOptionsLayer* create(GJGameLevel* level) = win 0x2a08e0;

    virtual void setupOptions() = win 0x2a0a40;
    virtual void didToggle(int tag) = win 0x2a0ac0;

    bool init(GJGameLevel* level) = win inline {
        m_gap = 40.f;
        m_maxLabelScale = .4f;
        if (level) {
            m_level = level;
            level->retain();
        }
        if (!GJOptionsLayer::init(2)) return false;
        this->preSetup();
        this->postSetup();
        return true;
    }

    GJGameLevel* m_level;
}

[[link(android), depends(UIButtonConfig)]]
class GameManager : GManager {
    // virtual ~GameManager();
    // GameManager() = win 0x177af0, ios 0x32eafc;

    static GameManager* get() {
        return GameManager::sharedState();
    }
    static GameManager* sharedState() = win 0x17b4e0;

    virtual void update(float dt) = win 0x189c00;
    virtual bool init() = win 0x17b530;
    virtual void encodeDataTo(DS_Dictionary* dict) = win 0x188ff0;
    virtual void dataLoaded(DS_Dictionary* dict) = win 0x186ad0;
    virtual void firstLoad() = win 0x1886f0;

    void accountStatusChanged() = win inline {
        if (m_menuLayer) m_menuLayer->updateUserProfileButton();
    }
    int activeIconForType(IconType type) = win 0x181ad0;
    void addCustomAnimationFrame(int objectID, int frameIndex, gd::string mainFrame, gd::string detailFrame) = win 0x1aeba0;
    void addDuplicateLastFrame(int objectID) = win inline, ios inline {
        auto frames = this->framesForAnimation(objectID);
        auto mainFrame = static_cast<cocos2d::CCArray*>(m_mainFramesForAnimation->objectForKey(objectID))->stringAtIndex(frames - 1)->getCString();
        auto detailFrame = static_cast<cocos2d::CCArray*>(m_detailFramesForAnimation->objectForKey(objectID))->stringAtIndex(frames - 1)->getCString();
        this->addCustomAnimationFrame(objectID, frames, mainFrame, detailFrame);
        m_framesForAnimation->setObject(cocos2d::CCInteger::create(frames + 1), objectID);
    }
    void addGameAnimation(int objectID, int frames, float frameTime, gd::string mainAnimFrame, gd::string detailAnimFrame, int defaultFrame) = win 0x1aea30;
    void addIconDelegate(cocos2d::CCObject* delegate, int key);
    void addNewCustomObject(gd::string str) = win 0x183830;
    void addToGJLog(cocos2d::CCString* str) = win inline, ios inline {}
    void applicationDidEnterBackground() = win inline {}
    void applicationWillEnterForeground() = win 0x189c90;
    void calculateBaseKeyForIcons() = win inline {
        m_keyStartForIcon.resize(9);
        m_keyStartForIcon[0] = 0;
        m_keyStartForIcon[1] = 485;
        m_keyStartForIcon[2] = 654;
        m_keyStartForIcon[3] = 772;
        m_keyStartForIcon[4] = 921;
        m_keyStartForIcon[5] = 1017;
        m_keyStartForIcon[6] = 1085;
        m_keyStartForIcon[7] = 1154;
        m_keyStartForIcon[8] = 1197;
        for (int i = 0; i < 1205; i++) {
            m_iconLoadCounts[i] = 0;
        }
    }
    bool canShowRewardedVideo();
    void checkSteamAchievementUnlock() = ios inline {}
    void checkUsedIcons() = win 0x184210;
    void claimItemsResponse(gd::string str) = win inline, ios inline {}
    void clearGJLog() = win inline {
        m_gjLog->removeAllObjects();
    }
    cocos2d::ccColor3B colorForIdx(int index) = win 0x181390;
    int colorForPos(int pos) = win inline, ios inline {
        switch (pos) {
            case 4: return 16;
            case 5: return 4;
            case 6: return 5;
            case 7: return 6;
            case 8: return 13;
            case 9: return 7;
            case 10: return 8;
            case 11: return 9;
            case 12: return 29;
            case 13: return 10;
            case 15: return 11;
            case 16: return 12;
            case 19: return 15;
            case 20: return 27;
            case 21: return 32;
            case 22: return 28;
            case 23: return 38;
            case 24: return 20;
            case 25: return 33;
            case 26: return 21;
            case 27: return 34;
            case 28: return 22;
            case 29: return 39;
            case 30: return 23;
            case 31: return 35;
            case 32: return 24;
            case 33: return 36;
            case 34: return 25;
            case 35: return 37;
            case 36: return 30;
            case 37: return 26;
            case 38: return 31;
            case 39: return 19;
            default: return pos;
        }
    }
    gd::string colorKey(int id, UnlockType type) = win 0x17c7f0;
    void completedAchievement(gd::string key) = win 0x17d230;
    int countForType(IconType type) = win 0x181c40;
    int defaultFrameForAnimation(int objectID) = win inline, ios inline {
        if (auto frame = static_cast<cocos2d::CCInteger*>(m_defaultFrames->objectForKey(objectID))) {
            return frame->getValue();
        }
        return 1;
    }
    void didExitPlayscene() = win inline {
        if (this->m_unkBool8) {
            this->m_unkBool8 = false;
            if (cocos2d::CCDirector::sharedDirector()->getSmoothFixCounter() >= 10) {
                this->setGameVariable("0023", false);
            }
        }
    }
    void doQuickSave() = win inline {
        m_quickSave = true;
        this->save();
        m_quickSave = false;
    }
    gd::string dpadConfigToString(UIButtonConfig& config) = win 0x1864d0;
    void eventUnlockFeature(char const* key) = win inline, ios inline {}
    void fadeInMenuMusic() = win 0x17baf0;
    void fadeInMusic(gd::string path) = win 0x17bbe0;
    void finishedLoadingBGAsync(cocos2d::CCObject* obj) = win 0x182990;
    void finishedLoadingGAsync(int index) = win 0x182e30;
    void finishedLoadingGAsync1(cocos2d::CCObject* obj);
    void finishedLoadingGAsync2(cocos2d::CCObject* obj);
    void finishedLoadingIconAsync(cocos2d::CCObject* obj);
    void finishedLoadingMGAsync(int index) = win 0x182bd0;
    void finishedLoadingMGAsync1(cocos2d::CCObject* obj);
    void finishedLoadingMGAsync2(cocos2d::CCObject* obj);
    void followTwitch() = win inline {
        if (GameToolbox::doWeHaveInternet()) {
            cocos2d::CCApplication::sharedApplication()->openURL("https://www.twitch.tv/directory/category/geometry-dash");
            m_clickedTwitch = true;
            __timeb64 current;
            _ftime64_s(&current);
            m_socialsDuration = ((current.time & 0xfffff) * 1000 + current.millitm) / 1000.0;
        }
    }
    void followTwitter() = win inline {
        if (GameToolbox::doWeHaveInternet()) {
            cocos2d::CCApplication::sharedApplication()->openURL("https://twitter.com/robtopgames");
            m_clickedTwitter = true;
            __timeb64 current;
            _ftime64_s(&current);
            m_socialsDuration = ((current.time & 0xfffff) * 1000 + current.millitm) / 1000.0;
        }
    }
    int framesForAnimation(int objectID) = win inline, ios inline {
        if (auto frames = static_cast<cocos2d::CCInteger*>(m_framesForAnimation->objectForKey(objectID))) {
            return frames->getValue();
        }
        return 1;
    }
    float frameTimeForAnimation(int objectID) = win inline, ios inline {
        if (auto time = static_cast<cocos2d::CCFloat*>(m_frameTimeForAnimation->objectForKey(objectID))) {
            return time->getValue();
        }
        return 1.f;
    }
    int generateSecretNumber() = win 0x185d30;
    const char* getBGTexture(int index) = win inline {
        index = std::clamp(index, 0, 59);
        this->loadBackground(index);
        return cocos2d::CCString::createWithFormat("game_bg_%02d_001.png", index)->getCString();
    }
    LevelEditorLayer* getEditorLayer() {
        return m_levelEditorLayer;
    }
    const char* getFontFile(int index) = win inline {
        index = std::clamp(index, 0, 59);
        this->loadFont(index);
        if (index != 0) {
            return cocos2d::CCString::createWithFormat("gjFont%02d.fnt", index)->getCString();
        }
        return "bigFont.fnt";
    }
    const char* getFontTexture(int index) = win inline {
        index = std::clamp(index, 0, 59);
        this->loadFont(index);
        if (index != 0) {
            return cocos2d::CCString::createWithFormat("gjFont%02d.png", index)->getCString();
        }
        return "bigFont.png";
    }
    GJBaseGameLayer* getGameLayer() {
        return m_gameLayer;
    }
    bool getGameVariable(char const* key) = win 0x183150;
    bool getGameVariableDefault(const char* key, bool defaultValue) {
        //helper function
        auto object = static_cast<cocos2d::CCString*>(m_valueKeeper->objectForKey(std::string("gv_") + key));
        if (object == nullptr)
            return defaultValue;
        return object->boolValue();
    }
    const char* getGTexture(int index) = win inline {
        index = std::clamp(index, 0, 22);
        this->loadGround(index);
        return cocos2d::CCString::createWithFormat("groundSquare_%02d_001.png", index)->getCString();
    }
    int getIconRequestID() = win inline {
        return m_iconRequestID++;
    }
    int getIntGameVariable(char const* key) = win 0x183750;
    int getIntGameVariableDefault(const char* key, int defaultValue) {
        //helper function
        auto object = static_cast<cocos2d::CCString*>(m_valueKeeper->objectForKey(std::string("gv_") + key));
        if (object == nullptr)
            return defaultValue;
        return object->intValue();
    }
    gd::string getMenuMusicFile() = win 0x17b760;
    const char* getMGTexture(int index) = win inline {
        index = std::clamp(index, 0, 3);
        this->loadMiddleground(index);
        return cocos2d::CCString::createWithFormat("fg_%02d_001.png", index)->getCString();
    }
    int getNextUniqueObjectKey() = win inline {
        auto customKeys = this->getOrderedCustomObjectKeys();
        auto result = -1;
        CCObject* obj;
        CCARRAY_FOREACH(customKeys, obj) {
            auto key = static_cast<cocos2d::CCString*>(obj)->intValue();
            if (key < result) result = key;
        }
        return result;
    }
    int getNextUsedKey(int index, bool up) = win inline {
        auto previous = 0;
        auto customKeys = this->getOrderedCustomObjectKeys();
        for (int i = 0; i < customKeys->count(); i++) {
            auto key = customKeys->stringAtIndex(i)->intValue();
            if (key == index) {
                if (up) return previous;
                else return i + 1 < customKeys->count() ? customKeys->stringAtIndex(i + 1)->intValue() : 0;
            }
            previous = key;
        }
        return 0;
    }
    cocos2d::CCArray* getOrderedCustomObjectKeys() = win inline {
        auto keys = m_customObjectDict->allKeys();
        if (keys->count() != 0) {
            qsort(keys->data->arr, keys->data->num, sizeof(cocos2d::CCString*), [](void const* a, void const* b) {
                auto sa = *static_cast<cocos2d::CCString* const*>(a);
                auto sb = *static_cast<cocos2d::CCString* const*>(b);
                return sa->intValue() - sb->intValue();
            });
        }
        return keys;
    }
    int getPlayerBall() {
        return m_playerBall;
    }
    int getPlayerBird() {
        return m_playerBird;
    }
    int getPlayerColor() {
        return m_playerColor;
    }
    int getPlayerColor2() {
        return m_playerColor2;
    }
    int getPlayerDart() {
        return m_playerDart;
    }
    int getPlayerDeathEffect() {
        return m_playerDeathEffect;
    }
    int getPlayerFrame() {
        return m_playerFrame;
    }
    bool getPlayerGlow() {
        return m_playerGlow;
    }
    int getPlayerGlowColor() {
        return m_playerGlowColor;
    }
    int getPlayerJetpack() {
        return m_playerJetpack;
    }
    int getPlayerRobot() {
        return m_playerRobot;
    }
    int getPlayerShip() {
        return m_playerShip;
    }
    int getPlayerShipFire() {
        return m_playerShipFire;
    }
    int getPlayerSpider() {
        return m_playerSpider;
    }
    int getPlayerStreak() {
        return m_playerStreak;
    }
    int getPlayerSwing() {
        return m_playerSwing;
    }
    PlayLayer* getPlayLayer() {
        return m_playLayer;
    }
    gd::string getPracticeMusicFile() = win inline {
        auto mdm = MusicDownloadManager::sharedState();
        if (m_customPracticeSongID > 0) {
            if (mdm->isSongDownloaded(m_customPracticeSongID)) {
                if (m_customPracticeSongID > 0) {
                    return mdm->pathForSong(m_customPracticeSongID);
                }
            }
            else {
                m_customPracticeSongID = 0;
            }
        }
        return "StayInsideMe.mp3";
    }
    bool getUGV(char const* key) = win 0x1834e0;
    void getUnlockForAchievement(gd::string key, int& id, UnlockType& type) = win 0x17c9e0;
    bool groundHasSecondaryColor(int index) = win inline, ios inline {
        return index == 8 || index == 9 || index == 10 || index == 11;
    }
    void iconAndTypeForKey(int key, int& id, int& type) = win inline, ios inline {
        for (int i = 0; i < 8; i++) {
            if (key < m_keyStartForIcon[i + 1]) {
                id = key - m_keyStartForIcon[i] + 1;
                type = i;
                return;
            }
        }
    }
    gd::string iconKey(int id, IconType type) = win 0x17c310;
    UnlockType iconTypeToUnlockType(IconType type) = win 0x17c620;
    bool isColorUnlocked(int id, UnlockType type) = win 0x17c920;
    bool isIconLoaded(int id, int type) = win inline {
        return m_iconLoadCounts[this->keyForIcon(id, type)] > 0;
    }
    bool isIconUnlocked(int id, IconType type) = win 0x17c540;
    void itemPurchased(char const* key) = win inline, ios inline {}
    void joinDiscord() = win inline {
        if (GameToolbox::doWeHaveInternet()) {
            cocos2d::CCApplication::sharedApplication()->openURL("https://discord.com/invite/geometrydash");
            m_clickedDiscord = true;
            __timeb64 current;
            _ftime64_s(&current);
            m_socialsDuration = ((current.time & 0xfffff) * 1000 + current.millitm) / 1000.0;
        }
    }
    void joinReddit() = win inline {
        if (GameToolbox::doWeHaveInternet()) {
            cocos2d::CCApplication::sharedApplication()->openURL("https://www.reddit.com/r/geometrydash/");
            m_clickedReddit = true;
            __timeb64 current;
            _ftime64_s(&current);
            m_socialsDuration = ((current.time & 0xfffff) * 1000 + current.millitm) / 1000.0;
        }
    }
    int keyForIcon(int id, int type) = win inline, ios inline {
        return m_keyStartForIcon[type] + id - 1;
    }
    bool levelIsPremium(int unk1, int unk2) = win inline, ios inline { return false; }
    void likeFacebook() = win inline {
        if (GameToolbox::doWeHaveInternet()) {
            cocos2d::CCApplication::sharedApplication()->openURL("https://www.facebook.com/geometrydash");
            m_clickedFacebook = true;
            __timeb64 current;
            _ftime64_s(&current);
            m_socialsDuration = ((current.time & 0xfffff) * 1000 + current.millitm) / 1000.0;
        }
    }
    void loadBackground(int index) = win 0x1828e0;
    void loadBackgroundAsync(int index) = win inline {
        index = std::clamp(index, 0, 59);
        if (m_loadingBG || m_loadedBgID == index) return;
        m_loadingBG = true;
        cocos2d::CCTextureCache::sharedTextureCache()->addImageAsync(
            cocos2d::CCString::createWithFormat("game_bg_%02d_001.png", index)->getCString(),
            this,
            callfuncO_selector(GameManager::finishedLoadingBGAsync),
            index,
            cocos2d::kCCTexture2DPixelFormat_RGBA8888
        );
    }
    void loadDeathEffect(int id) = win inline {
        if (id < 1) id = 1;
        if (id > 19) id = 20;
        if (id != m_loadedDeathEffect) {
            if (1 < m_loadedDeathEffect) {
                cocos2d::CCTextureCache::sharedTextureCache()->removeTextureForKey(
                    cocos2d::CCString::createWithFormat("PlayerExplosion_%02d.png", m_loadedDeathEffect-1)->getCString()
                );
            }
            if (1 < id) {
                cocos2d::CCTextureCache::sharedTextureCache()->addImage(
                    cocos2d::CCString::createWithFormat("PlayerExplosion_%02d.png", id-1)->getCString(),
                    false
                );
                cocos2d::CCSpriteFrameCache::sharedSpriteFrameCache()->addSpriteFramesWithFile(
                    cocos2d::CCString::createWithFormat("PlayerExplosion_%02d.plist", id-1)->getCString()
                );
            }
            m_loadedDeathEffect = id;
        }
    }
    void loadDpadFromString(UIButtonConfig& config, gd::string str) = win 0x1867c0;
    void loadDPadLayout(int index, bool dual) = win 0x186220;
    void loadFont(int index) = win 0x182830;
    void loadGround(int index) = win 0x182c90;
    void loadGroundAsync(int index) = win inline {
        index = std::clamp(index, 0, 22);
        if (m_loadingG || m_loadedGroundID == index) return;
        m_loadingG = true;
        auto hasSecondary = this->groundHasSecondaryColor(index);
        m_finishedLoadingG1 = false;
        m_finishedLoadingG2 = !hasSecondary;
        cocos2d::CCTextureCache::sharedTextureCache()->addImageAsync(
            cocos2d::CCString::createWithFormat("groundSquare_%02d_001.png", index)->getCString(),
            this,
            callfuncO_selector(GameManager::finishedLoadingGAsync1),
            index,
            cocos2d::kCCTexture2DPixelFormat_RGBA8888
        );
        if (!hasSecondary) return;
        cocos2d::CCTextureCache::sharedTextureCache()->addImageAsync(
            cocos2d::CCString::createWithFormat("groundSquare_%02d_2_001.png", index)->getCString(),
            this,
            callfuncO_selector(GameManager::finishedLoadingGAsync2),
            index,
            cocos2d::kCCTexture2DPixelFormat_RGBA8888
        );
    }
    cocos2d::CCTexture2D* loadIcon(int id, int type, int requestID) = win 0x181d50;
    void loadIconAsync(int id, int type, int requestID, cocos2d::CCObject* delegate);
    void loadMiddleground(int index) = win 0x182a40;
    void loadMiddlegroundAsync(int index) = win inline {
        index = std::clamp(index, 0, 3);
        if (m_loadingG1 || m_loadedMG == index) return;
        m_loadingG1 = true;
        m_finishedLoadingMG1 = false;
        m_finishedLoadingMG2 = false;
        cocos2d::CCTextureCache::sharedTextureCache()->addImageAsync(
            cocos2d::CCString::createWithFormat("fg_%02d_001.png", index)->getCString(),
            this,
            callfuncO_selector(GameManager::finishedLoadingMGAsync1),
            index,
            cocos2d::kCCTexture2DPixelFormat_RGBA8888
        );
        cocos2d::CCTextureCache::sharedTextureCache()->addImageAsync(
            cocos2d::CCString::createWithFormat("fg_%02d_2_001.png", index)->getCString(),
            this,
            callfuncO_selector(GameManager::finishedLoadingMGAsync2),
            index,
            cocos2d::kCCTexture2DPixelFormat_RGBA8888
        );
    }
    void loadVideoSettings() = win inline {
        auto application = cocos2d::CCApplication::sharedApplication();
        application->toggleVerticalSync(this->getGameVariable("0030"));
        application->setForceTimer(this->getGameVariable("0032"));
        application->setSmoothFix(this->getGameVariable("0023"));
    }
    void lockColor(int id, UnlockType type) = win inline {
        m_valueKeeper->removeObjectForKey(this->colorKey(id, type));
    }
    void lockIcon(int id, IconType type) = win inline {
        m_valueKeeper->removeObjectForKey(this->iconKey(id, type));
    }
    void logLoadedIconInfo();
    void openEditorGuide() = win inline {
        m_showedEditorGuide = true;
        cocos2d::CCApplication::sharedApplication()->openURL("https://www.boomlings.com/GDEditor");
    }
    void playMenuMusic() = win 0x17b870;
    int playSFXTrigger(SFXTriggerGameObject* object) = win 0x17bd00;
    void prepareDPadSettings() = win 0x186a30;
    void printGJLog() = win inline {}
    void queueReloadMenu() = win inline {
        m_pActionManager->addAction(cocos2d::CCSequence::create(
            cocos2d::CCDelayTime::create(.1f),
            cocos2d::CCCallFunc::create(this, callfunc_selector(GameManager::reloadMenu)),
            nullptr
        ), this, false);
    }
    void rateGame() = win inline {
        if (GameToolbox::doWeHaveInternet()) {
            GameToolbox::openAppPage();
            m_ratedGame = true;
            m_hasRatedGame = true;
        }
    }
    void recountUserStats(gd::string str);
    void reloadAll(bool switchingModes, bool toFullscreen, bool unused) {
        return this->reloadAll(switchingModes, toFullscreen, false, false, unused);
    }
    void reloadAll(bool switchingModes, bool toFullscreen, bool borderless, bool fix, bool unused) = win 0x18a450;
    void reloadAllStep2() = win 0x18a500;
    void reloadAllStep3() = win 0x18a660;
    void reloadAllStep4() = win 0x18a770;
    void reloadAllStep5() = win 0x18a810;
    void reloadMenu() = win 0x18a420;
    void removeCustomObject(int key) = win inline {
        m_customObjectDict->removeObjectForKey(cocos2d::CCString::createWithFormat("%i", key)->getCString());
    }
    void removeIconDelegate(int requestID) = win inline {
        for (auto it = m_iconDelegates.begin(); it != m_iconDelegates.end(); it++) {
            auto& delegates = it->second;
            for (int i = 0; i < delegates.size();) {
                if (static_cast<SimplePlayer*>(delegates[i])->m_iconRequestID == requestID) {
                    delegates.erase(delegates.begin() + i);
                }
                else i++;
            }
        }
    }
    int reorderKey(int index, bool up) = win 0x183b00;
    void reportAchievementWithID(char const* key, int percent, bool dontNotify) = win 0x17e030;
    void reportPercentageForLevel(int levelID, int percentage, bool isPlatformer) = win 0x17d650;
    void resetAchievement(gd::string key) = win 0x17d3f0;
    void resetAdTimer() = win inline, ios inline {
        m_adTimer = 0.0;
    }
    void resetAllIcons() = win 0x183ee0;
    void resetCoinUnlocks() = win 0x180bb0;
    void resetDPadSettings(bool dual) = win inline {
        if (dual) {
            m_dpad2.reset();
            m_dpad3.reset();
            m_dpad4.resetOneBtn();
            m_dpad5.resetOneBtn();
        }
        else m_dpad1.reset();
    }
    cocos2d::CCSize resolutionForKey(int key) = win 0x18a850;
    void resumeAudio() = win inline, ios inline {
        auto engine = FMODAudioEngine::sharedEngine();
        engine->resumeAudio();
        engine->resumeAllAudio();
        AppDelegate::get()->resumeSound();
        engine->m_system->update();
    }
    void resumeAudioDelayed() = win inline, ios inline {
        auto action = cocos2d::CCSequence::create(
            cocos2d::CCDelayTime::create(.05f),
            cocos2d::CCCallFunc::create(this, callfunc_selector(GameManager::resumeAudio)),
            nullptr
        );
        action->setTag(11);
        m_pActionManager->addAction(action, this, false);
    }
    void returnToLastScene(GJGameLevel* level) = win 0x189ff0;
    void rewardedVideoAdFinished(int unused);
    void rewardedVideoHidden();
    void rewardedVideoHiddenDelayed();
    // partially inlined on windows
    bool safePopScene() = win 0x18a3a0;
    void saveAdTimer();
    void saveDPadLayout(int index, bool dual) = win 0x185e60;
    void setGameVariable(char const* key, bool value) = win 0x182ef0;
    void setHasRatingPower(int hasRP) {
        m_hasRP = hasRP;
    }
    void setIntGameVariable(char const* key, int value) = win 0x183650;
    void setPlayerBall(int id) {
        m_playerBall = id;
    }
    void setPlayerBird(int id) {
        m_playerBird = id;
    }
    void setPlayerColor(int id) {
        m_playerColor = id;
    }
    void setPlayerColor2(int id) {
        m_playerColor2 = id;
    }
    void setPlayerColor3(int id) {
        m_playerGlowColor = id;
    }
    void setPlayerDart(int id) {
        m_playerDart = id;
    }
    void setPlayerDeathEffect(int id) {
        m_playerDeathEffect = id;
    }
    void setPlayerFrame(int id) {
        m_playerFrame = id;
    }
    void setPlayerGlow(bool v) {
        m_playerGlow = v;
    }
    void setPlayerJetpack(int id) {
        m_playerJetpack = id;
    }
    void setPlayerRobot(int id) {
        m_playerRobot = id;
    }
    void setPlayerShip(int id) {
        m_playerShip = id;
    }
    void setPlayerShipStreak(int id) {
        m_playerShipFire = id;
    }
    void setPlayerSpider(int id) {
        m_playerSpider = id;
    }
    void setPlayerStreak(int id) {
        m_playerStreak = id;
    }
    void setPlayerSwing(int id) {
        m_playerSwing = id;
    }
    void setPlayerUserID(int id) {
        m_playerUserID = id;
    }
    void setUGV(char const* key, bool value) = win 0x183380;
    void setupGameAnimations() = win 0x1ab830;
    gd::string sheetNameForIcon(int id, int type) = win 0x1824d0;
    void shortenAdTimer(float time) = win inline, ios inline {
        m_adTimer -= time;
    }
    bool shouldShowInterstitial(int unk1, int unk2, int unk3) = win inline, ios inline { return false; }
    bool showInterstitial() = win inline, ios inline { return true; }
    bool showInterstitialForced() = win inline, ios inline { return false; }
    bool showMainMenuAd() = win inline, ios inline { return false; }
    void startUpdate() = win inline {
        cocos2d::CCDirector::sharedDirector()->getScheduler()->scheduleSelector(
            schedule_selector(GameManager::update), this, 0.f, kCCRepeatForever, 0.f, false);
    }
    gd::string stringForCustomObject(int customObjectID) = win 0x1839b0;
    void subYouTube() = win inline {
        if (GameToolbox::doWeHaveInternet()) {
            cocos2d::CCApplication::sharedApplication()->openURL("https://www.youtube.com/user/RobTopGames");
            m_clickedYouTube = true;
            __timeb64 current;
            _ftime64_s(&current);
            m_socialsDuration = ((current.time & 0xfffff) * 1000 + current.millitm) / 1000.0;
        }
    }
    void switchCustomObjects(int key1, int key2) = win 0x183c00;
    void switchScreenMode(bool fullscreen, bool borderless, bool fix, bool unused) = win inline, ios inline {
        this->reloadAll(true, fullscreen, borderless, fix, unused);
    }
    void syncPlatformAchievements() = win inline {}
    bool toggleGameVariable(char const* key) = win 0x1832d0;
    void tryCacheAd();
    void tryShowInterstitial(int unk1, int unk2, int unk3) = win inline, ios inline {}
    void unloadBackground() = win inline {
        if (m_loadedBgID == 0) return;
        cocos2d::CCTextureCache::sharedTextureCache()->removeTextureForKey(
            cocos2d::CCString::createWithFormat("game_bg_%02d_001.png", m_loadedBgID)->getCString());
        m_loadedBgID = 0;
        auto fileUtils = cocos2d::CCFileUtils::sharedFileUtils();
        for (int i = 1; i < 60; i++) {
            fileUtils->removeFullPath(cocos2d::CCString::createWithFormat("game_bg_%02d_001.png", i)->getCString());
        }
    }
    void unloadIcon(int id, int type, int requestID) = win 0x1820b0;
    void unloadIcons(int requestID) = win 0x182370;
    void unlockColor(int id, UnlockType type) = win inline {
        m_valueKeeper->setObject(cocos2d::CCString::create("1"), this->colorKey(id, type));
    }
    void unlockedPremium() = win inline, ios inline {}
    void unlockIcon(int id, IconType type) = win inline {
        m_valueKeeper->setObject(cocos2d::CCString::create("1"), this->iconKey(id, type));
    }
    IconType unlockTypeToIconType(int type) = win 0x17c740;
    void updateCustomFPS();
    void updateMusic() = win inline {
        auto engine = FMODAudioEngine::sharedEngine();
        engine->setBackgroundMusicVolume(m_bgVolume);
        engine->setEffectsVolume(m_sfxVolume);
        engine->m_musicOffset = m_timeOffset;
    }
    void verifyAchievementUnlocks() = win inline {
        auto achievementManager = AchievementManager::sharedState();
        auto allAchievements = achievementManager->getAllAchievements();
        for (int i = 0; i < allAchievements->count(); i++) {
            auto achievement = static_cast<cocos2d::CCDictionary*>(allAchievements->objectAtIndex(i));
            auto key = static_cast<cocos2d::CCString*>(achievement->objectForKey("identifier"))->getCString();
            if (achievementManager->isAchievementEarned(key)) this->completedAchievement(key);
        }
    }
    void verifyCoinUnlocks() = win 0x17e5e0;
    void verifyStarUnlocks() = win inline {
        auto glm = GameLevelManager::sharedState();
        auto gsm = GameStatsManager::sharedState();
        for (int i = 1; i < 23; i++) {
            auto level = glm->getMainLevel(i, false);
            if (gsm->hasCompletedLevel(level)) gsm->completedStarLevel(level);
        }
    }
    void verifySyncedCoins() = win inline, ios inline {
        auto coins = 0;
        auto glm = GameLevelManager::sharedState();
        auto gsm = GameStatsManager::sharedState();
        for (int i = 1; i < 23; i++) {
            auto level = glm->getMainLevel(i, false);
            if (gsm->hasCompletedLevel(level)) {
                if (gsm->hasSecretCoin(level->getCoinKey(1))) coins++;
                if (gsm->hasSecretCoin(level->getCoinKey(2))) coins++;
                if (gsm->hasSecretCoin(level->getCoinKey(3))) coins++;
            }
        }
        for (int i = 5001; i < 5005; i++) {
            auto level = glm->getMainLevel(i, false);
            if (gsm->hasCompletedLevel(level)) {
                if (gsm->hasSecretCoin(level->getCoinKey(1))) coins++;
                if (gsm->hasSecretCoin(level->getCoinKey(2))) coins++;
                if (gsm->hasSecretCoin(level->getCoinKey(3))) coins++;
            }
        }
        if (gsm->hasSecretCoin("secret04")) coins++;
        if (gsm->hasSecretCoin("secret06")) coins++;
        if (gsm->hasSecretCoin("secretB03")) coins++;
        gsm->setStatIfHigher("8", coins);
    }
    void videoAdHidden() = win inline, ios inline {
        if (m_musicPaused) FMODAudioEngine::sharedEngine()->resumeAllMusic();
        m_musicPaused = false;
    }
    void videoAdShowed() = win inline, ios inline {
        auto engine = FMODAudioEngine::sharedEngine();
        if (engine->isMusicPlaying(0)) {
            engine->pauseAllMusic(true);
            m_musicPaused = true;
        }
        else m_musicPaused = false;
    }

    cocos2d::CCDictionary* m_mainFramesForAnimation;
    cocos2d::CCDictionary* m_detailFramesForAnimation;
    cocos2d::CCDictionary* m_frameTimeForAnimation;
    cocos2d::CCDictionary* m_framesForAnimation;
    cocos2d::CCDictionary* m_defaultFrames;
    bool m_switchModes;
    bool m_toFullscreen;
    bool m_reloading;
    bool m_fix;
    bool m_reloadTextures;
    bool m_unkBool2;
    bool m_vsyncEnabled;
    cocos2d::CCDictionary* m_valueKeeper;
    cocos2d::CCDictionary* m_unlockValueKeeper;
    cocos2d::CCDictionary* m_customObjectDict;
    double m_adTimer;
    double m_adCache;
    bool m_unkBool3;
    int m_unkSize4_1;
    double m_unkDouble2;
    int m_unkSize4_2;
    int m_unkSize4_3;
    bool m_loaded;
    bool m_googlePlaySignedIn;
    gd::string m_editorClipboard;
    int m_copiedObjectCount;
    PlayLayer* m_playLayer;
    LevelEditorLayer* m_levelEditorLayer;
    GJBaseGameLayer* m_gameLayer;
    LevelSelectLayer* m_levelSelectLayer;
    MenuLayer* m_menuLayer;
    bool m_inMenuLayer;
    void* m_premiumPopup;
    bool m_firstSetup;
    bool m_showedMenu;
    bool m_unknownBool4;
    bool m_unknownBool5;
    gd::string m_playerUDID;
    gd::string m_playerName;
    bool m_scoreUpdated; //playerScoreValid
    geode::SeedValueRSV m_playerUserID;
    float m_bgVolume;
    float m_sfxVolume;
    float m_timeOffset;
    bool m_ratedGame;
    bool m_clickedFacebook;
    bool m_clickedTwitter;
    bool m_clickedYouTube;
    bool m_clickedTwitch;
    bool m_clickedDiscord;
    bool m_clickedReddit;
    double m_socialsDuration;
    bool m_musicPaused; //didPauseBGMusic
    bool m_isParticleObject;
    bool m_editorEnabled;
    int m_sceneEnum;
    bool m_searchObjectBool;
    geode::SeedValueRSV m_playerFrame;
    geode::SeedValueRSV m_playerShip;
    geode::SeedValueRSV m_playerBall;
    geode::SeedValueRSV m_playerBird;
    geode::SeedValueRSV m_playerDart;
    geode::SeedValueRSV m_playerRobot;
    geode::SeedValueRSV m_playerSpider;
    geode::SeedValueRSV m_playerSwing;
    geode::SeedValueRSV m_playerColor;
    geode::SeedValueRSV m_playerColor2;
    geode::SeedValueRSV m_playerGlowColor;
    geode::SeedValueRSV m_playerStreak;
    geode::SeedValueRSV m_playerShipFire;
    geode::SeedValueRSV m_playerDeathEffect;
    geode::SeedValueRSV m_playerJetpack;
    geode::SeedValueRS m_chk;
    geode::SeedValueSR m_secretNumber;
    bool m_playerGlow;
    IconType m_playerIconType;
    bool m_everyPlaySetup;
    bool m_showSongMarkers;
    bool m_showBPMMarkers;
    bool m_recordGameplay;
    bool m_showProgressBar;
    bool m_performanceMode;
    bool m_addGlow;
    bool m_clickedGarage;
    bool m_clickedEditor;
    bool m_clickedName;
    bool m_clickedPractice;
    bool m_showedEditorGuide;
    bool m_showedRateDiffDialog;
    bool m_showedRateStarDialog;
    bool m_showedLowDetailDialog;
    GameRateDelegate* m_gameRateDelegate1;
    GameRateDelegate* m_gameRateDelegate2;
    cocos2d::ccColor3B m_copiedColor;
    int m_currentLevelID;
    int m_currentColorChannel;
    int m_currentGroupID;
    int m_loadedBgID;
    int m_loadedGroundID;
    int m_loadedMG;
    int m_loadedFont;
    int m_loadedDeathEffect;
    bool m_loadingBG;
    bool m_loadingG;
    bool m_loadingG1;
    bool m_finishedLoadingG1;
    bool m_finishedLoadingG2;
    bool m_finishedLoadingMG1;
    bool m_finishedLoadingMG2;
    int m_sessionAttempts;
    int m_sessionAttempts2;
    int m_sessionNormalAttempts;
    int m_bootups;
    bool m_hasRatedGame;
    bool m_unkBool6;
    bool m_shouldLoadUnlockValueKeeper;
    bool m_unkBool7;
    bool m_unkBool8;
    geode::SeedValueRSV m_hasRP;
    bool m_canGetLevelSaveData;
    int m_resolution;
    int m_texQuality;
    bool m_somethingInMenuLayer;
    DailyLevelPage* m_dailyLevelPage;
    bool m_ropeGarageEnter;
    int m_currentGauntlet;
    int m_unkSize4_13;
    bool m_unkBool10;
    int m_unkSize4_14;
    bool m_disableThumbstick;
    float m_customFPSTarget;
    bool m_loadingLevel;
    int m_customMenuSongID;
    int m_customPracticeSongID;
    gd::map<int, int> m_iconLoadCounts;
    gd::map<int, gd::map<int, int>> m_iconRequests;
    gd::map<int, bool> m_isIconBeingLoaded;
    gd::vector<int> m_keyStartForIcon;
    gd::map<int, gd::vector<cocos2d::CCObject*>> m_iconDelegates;
    int m_iconRequestID;
    cocos2d::CCArray* m_gjLog;
    RewardedVideoDelegate* m_rewardedVideoDelegate;
    SearchType m_localSearchType;
    SearchType m_savedSearchType;
    int m_levelSearchType;
    UIButtonConfig m_dpad1;
    UIButtonConfig m_dpad2;
    UIButtonConfig m_dpad3;
    UIButtonConfig m_dpad4;
    UIButtonConfig m_dpad5;
    gd::string m_dpadLayout1;
    gd::string m_dpadLayout2;
    gd::string m_dpadLayout3;
    gd::string m_dpadLayoutDual1;
    gd::string m_dpadLayoutDual2;
    gd::string m_dpadLayoutDual3;
    int m_leaderboardLevelID;
    int m_leaderboardLevelTime;
    int m_leaderboardLevelPoints;
    bool m_shouldResetShader;
    cocos2d::CCPoint m_practicePos;
    float m_practiceOpacity;
}

[[link(android)]]
class GameObject : CCSpritePlus {
    GameObject() = win 0x137820;
    ~GameObject() = win 0x18b6f0;

    static GameObject* createWithFrame(char const* name) = win 0x18dc60;
    static GameObject* createWithKey(int key) = win 0x18b810;
    static bool isBasicEnterEffect(int id) = win inline {
        return (id > 21 && id < 29) || (id > 54 || id < 60) || id == 1915;
    }
    static GameObject* objectFromVector(gd::vector<gd::string>& propValues, gd::vector<void*>& propIsPresent, GJBaseGameLayer* gameLayer, bool lowDetail) = win 0x19d220;
    static void resetMID() = win inline {
        *reinterpret_cast<int*>(geode::base::get() + 0x69c158) = 10;
    }

    virtual void update(float dt) = win inline {}
    virtual void setScaleX(float scaleX) = win 0x198290;
    virtual void setScaleY(float scaleY);
    virtual void setScale(float scale);
    virtual void setPosition(cocos2d::CCPoint const& position) = win 0x197ba0;
    virtual void setVisible(bool visible) = win 0x198c90;
    virtual void setRotation(float rotation) = win 0x197e40;
    virtual void setRotationX(float rotationX) = win 0x197f90;
    virtual void setRotationY(float rotationY) = win 0x1980e0;
    virtual void setOpacity(unsigned char opacity) = win 0x198840;
    virtual bool initWithTexture(cocos2d::CCTexture2D* texture) = win 0x18dcf0;
    virtual void setChildColor(cocos2d::ccColor3B const& color) = win 0x1a0e00;
    virtual void setFlipX(bool flipX) = win 0x198200;
    virtual void setFlipY(bool flipY) = win 0x198240;
    virtual void firstSetup() {}
    virtual void customSetup() = win 0x190e60;
    virtual void setupCustomSprites(gd::string frameName) = win 0x1aef40;
    virtual void addMainSpriteToParent(bool reorder) = win 0x19bd90;
    virtual void resetObject() = win 0x190710;
    virtual void triggerObject(GJBaseGameLayer* layer, int uniqueID, gd::vector<int> const* remapKeys) {}
    virtual void activateObject() = win 0x190b20;
    virtual void deactivateObject(bool deactivate) = win 0x190bd0;
    virtual void transferObjectRect(cocos2d::CCRect& rect) = win 0x197690;
    virtual cocos2d::CCRect const& getObjectRect() = win 0x1976e0;
    virtual cocos2d::CCRect getObjectRect(float width, float height) = win 0x197700;
    virtual cocos2d::CCRect const& getObjectRect2(float width, float height) = win 0x197890;
    virtual cocos2d::CCRect const& getObjectTextureRect() = win 0x197930;
    virtual cocos2d::CCPoint getRealPosition() = win 0x197b60;
    virtual void setStartPos(cocos2d::CCPoint position) = win 0x190590;
    virtual void updateStartValues() = win 0x190960;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) {}
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x19ed10;
    virtual void claimParticle() = win 0x198db0;
    virtual void unclaimParticle() = win 0x1992e0;
    virtual void particleWasActivated() = win inline {}
    virtual bool isFlipX();
    virtual bool isFlipY();
    virtual void setRScaleX(float scaleX) = win 0x198550;
    virtual void setRScaleY(float scaleY) = win 0x198590;
    virtual void setRScale(float scale) = win 0x1985d0;
    virtual float getRScaleX();
    virtual float getRScaleY();
    virtual void setRRotation(float rotation) = win 0x197db0;
    virtual void triggerActivated(float xPosition) {}
    virtual void setObjectColor(cocos2d::ccColor3B const& color) = win 0x1a0ac0;
    virtual void setGlowColor(cocos2d::ccColor3B const& color) = win 0x1a0db0;
    virtual void restoreObject();
    virtual void animationTriggered() {}
    virtual void selectObject(cocos2d::ccColor3B color) = win 0x1a0e80;
    virtual void activatedByPlayer(PlayerObject* player) {}
    virtual bool hasBeenActivatedByPlayer(PlayerObject* player) { return false; }
    virtual bool hasBeenActivated() { return false; }
    virtual OBB2D* getOrientedBox() = win 0x1a1550;
    virtual void updateOrientedBox() = win 0x1a15b0;
    virtual float getObjectRotation() = win 0x1a1530;
    virtual void updateMainColor(cocos2d::ccColor3B const& color);
    virtual void updateSecondaryColor(cocos2d::ccColor3B const& color);
    virtual int addToGroup(int id) = win 0x19c7d0;
    virtual void removeFromGroup(int id) = win 0x19c8f0;
    virtual void saveActiveColors() = win 0x1a0910;
    virtual float spawnXPosition() = win 0x137c60;
    virtual bool canAllowMultiActivate() { return false; }
    virtual void blendModeChanged() {}
    virtual void updateParticleColor(cocos2d::ccColor3B const& color) = win 0x1a0ca0;
    virtual void updateParticleOpacity(unsigned char opacity) = win 0x198ae0;
    virtual void updateMainParticleOpacity(unsigned char opacity) {}
    virtual void updateSecondaryParticleOpacity(unsigned char opacity) {}
    virtual bool canReverse() { return false; }
    virtual bool isSpecialSpawnObject() { return false; }
    virtual bool canBeOrdered() { return false; }
    virtual cocos2d::CCLabelBMFont* getObjectLabel() { return nullptr; }
    virtual void setObjectLabel(cocos2d::CCLabelBMFont* label) {}
    virtual bool shouldDrawEditorHitbox() = win inline { return true; }
    virtual bool getHasSyncedAnimation() { return false; }
    virtual bool getHasRotateAction() { return false; }
    virtual bool canMultiActivate(bool multiActivate) { return false; }
    virtual void updateTextKerning(int kerning) {}
    virtual int getTextKerning() { return false; }
    virtual bool getObjectRectDirty() const;
    virtual void setObjectRectDirty(bool dirty);
    virtual bool getOrientedRectDirty() const;
    virtual void setOrientedRectDirty(bool dirty);
    virtual GameObjectType getType() const;
    virtual void setType(GameObjectType type);
    virtual cocos2d::CCPoint getStartPos() const = win 0x137ce0;

    void addColorSprite(gd::string frame) = win 0x18e7f0;
    void addColorSpriteToParent(bool reorder) = win 0x19c000;
    void addColorSpriteToSelf() = win 0x19c200;
    cocos2d::CCSprite* addCustomBlackChild(gd::string frame, float opacity, bool color) = win inline, ios inline {
        if (color) {
            return this->addCustomColorChild(frame);
        }
        else {
            auto ret = this->addCustomChild(frame, { 0.f, 0.f }, -2);
            ret->setColor({ 0, 0, 0 });
            m_blackChildOpacity = opacity;
            ret->setOpacity(opacity * 255);
            m_blackChildOpacityLocked = true;
            return ret;
        }
    }
    cocos2d::CCSprite* addCustomChild(gd::string frame, cocos2d::CCPoint offset, int zOrder) = win 0x1972f0;
    cocos2d::CCSprite* addCustomColorChild(gd::string frame) = win 0x1973b0;
    void addEmptyGlow() = win 0x18e6a0;
    void addGlow(gd::string frame) = win 0x18df20;
    cocos2d::CCSprite* addInternalChild(cocos2d::CCSprite* parent, gd::string frame, cocos2d::CCPoint offset, int zOrder) = win inline, ios inline {
        auto spr = cocos2d::CCSprite::createWithSpriteFrameName(frame.c_str());
        spr->setPosition(parent->convertToNodeSpace({0.f, 0.f}) + offset);
        parent->addChild(spr, zOrder);
        return spr;
    }
    cocos2d::CCSprite* addInternalCustomColorChild(gd::string frame, cocos2d::CCPoint offset, int zOrder) = win 0x1974f0;
    cocos2d::CCSprite* addInternalGlowChild(gd::string frame, cocos2d::CCPoint offset) = win 0x1975c0;
    void addNewSlope01(bool dontDraw) = win inline {
        if (dontDraw) this->setDontDraw(true);
        auto sprite = this->addCustomChild("blockOutline_14new_001.png", { 0.f, 0.f }, 2);
        sprite->setRotation(-45.f);
    }
    void addNewSlope01Glow(bool dontDraw) = win inline {
        if (!m_glowSprite) return;
        if (dontDraw) m_glowSprite->setDontDraw(true);
        auto sprite = cocos2d::CCSprite::createWithSpriteFrameName(this->getGlowFrame("blockOutline_14new_001.png").c_str());
        sprite->setRotation(-45.f);
        m_glowSprite->addChild(sprite);
        sprite->setPosition(m_glowSprite->convertToNodeSpace({ 0.f, 0.f }));
    }
    void addNewSlope02(bool dontDraw) = win inline {
        if (dontDraw) this->setDontDraw(true);
        auto sprite = this->addCustomChild("blockOutline_15new_001.png", { 0.f, 0.f }, 2);
        sprite->setRotation(-26.5f);
    }
    void addNewSlope02Glow(bool dontDraw) = win inline {
        if (!m_glowSprite) return;
        if (dontDraw) m_glowSprite->setDontDraw(true);
        auto sprite = cocos2d::CCSprite::createWithSpriteFrameName(this->getGlowFrame("blockOutline_15new_001.png").c_str());
        sprite->setRotation(-26.5f);
        m_glowSprite->addChild(sprite);
        sprite->setPosition(m_glowSprite->convertToNodeSpace({ 0.f, 0.f }));
    }
    void addRotation(float rotation) = win 0x197d10;
    void addRotation(float rotationX, float rotationY) = win inline, ios inline {
        this->setRotationX(this->getRotationX() + rotationX);
        this->setRotationY(this->getRotationY() + rotationY);
    }
    void addToColorGroup(int group) = win 0x19ca10;
    void addToCustomScaleX(float scale) = win inline {
        m_isDirty = true;
        m_isObjectRectDirty = true;
        m_scaleXOffset += scale;
        m_scaleX += scale;
    }
    void addToCustomScaleY(float scale) = win inline {
        m_isDirty = true;
        m_isObjectRectDirty = true;
        m_scaleYOffset += scale;
        m_scaleY += scale;
    }
    void addToOpacityGroup(int group) = win inline {
        if (m_opacityGroupCount < 10 && group > 0 && group < 10000) {
            this->createOpacityGroupContainer(10);
            if (m_opacityGroupCount > 0) {
                for (int i = 0; i < m_opacityGroupCount; i++) {
                    if ((*m_opacityGroups)[i] == group) return;
                }
            }
            (*m_opacityGroups)[m_opacityGroupCount] = group;
            m_opacityGroupCount++;
        }
    }
    void addToTempOffset(double offsetX, double offsetY) = win inline {
        if (!m_tempOffsetXRelated) m_positionX += offsetX;
        m_positionY += offsetY;
    }
    void assignUniqueID() = win inline {
        auto uniqueID = reinterpret_cast<int*>(geode::base::get() + 0x69c158);
        m_uniqueID = *uniqueID;
        m_unknown5 = *uniqueID;
        (*uniqueID)++;
    }
    bool belongsToGroup(int group) = win inline {
        if (m_groupCount > 0) {
            for (int i = 0; i < m_groupCount; i++) {
                if ((*m_groups)[i] == group) return true;
            }
        }
        return false;
    }
    void calculateOrientedBox() = win inline {
        m_shouldUseOuterOb = true;
        this->updateOrientedBox();
        this->getObjectRect();
    }
    bool canChangeCustomColor() = win inline {
        return this->canChangeMainColor() || this->canChangeSecondaryColor();
    }
    bool canChangeMainColor() = win inline {
        return m_baseColor->m_defaultColorID != 0;
    }
    bool canChangeSecondaryColor() = win inline {
        return m_detailColor && m_detailColor->m_defaultColorID != 0;
    }
    bool canRotateFree() = win inline {
        auto type = m_objectType;
        return (
            type != GameObjectType::Solid
            && type != GameObjectType::Breakable
            && type != GameObjectType::Slope
        ) || m_isNoTouch;
    }
    const cocos2d::ccColor3B& colorForMode(int id, bool mainColor) = win 0x1a1fd0;
    void commonInteractiveSetup() = win 0x196dc0;
    void commonSetup();
    void copyGroups(GameObject* object) = win 0x19c980;
    cocos2d::CCParticleSystemQuad* createAndAddParticle(int objectType, char const* plistName, int tag, cocos2d::tCCPositionType positionType) = win 0x198b60;
    void createColorGroupContainer(int size) = win inline, ios inline {
        if (!m_colorGroups) {
            m_colorGroups = new std::array<short, 10>();
            for (int i = 0; i < size; i++) {
                (*m_colorGroups)[i] = 0;
            }
        }
    }
    void createGlow(gd::string frame) = win 0x18e710;
    void createGroupContainer(int size) = win 0x19c700, ios inline {
        if (!m_groups) {
            m_groups = new std::array<short, 10>();
            for (int i = 0; i < size; i++) {
                (*m_groups)[i] = 0;
            }
        }
    }
    void createOpacityGroupContainer(int size) = win inline, ios inline {
        if (!m_opacityGroups) {
            m_opacityGroups = new std::array<short, 10>();
            for (int i = 0; i < size; i++) {
                (*m_opacityGroups)[i] = 0;
            }
        }
    }
    void createSpriteColor(int type) = win inline {
        if (type == 2) {
            if (!m_detailColor) m_detailColor = new GJSpriteColor();
        }
        else {
            if (!m_baseColor) m_baseColor = new GJSpriteColor();
        }
    }
    void deselectObject() = win inline {
        m_isSelected = false;
        this->updateObjectEditorColor();
    }
    void destroyObject() = win inline {
        m_isDisabled = true;
        m_isDisabled2 = true;
        this->setOpacity(0);
    }
    void determineSlopeDirection() = win 0x19c300;
    bool didScaleXChange() = win inline, ios inline {
        return (int)(m_scaleX * 10000) != (int)(m_customScaleX * 10000);
    }
    bool didScaleYChange() = win inline, ios inline {
        return (int)(m_scaleY * 10000) != (int)(m_customScaleY * 10000);
    }
    void dirtifyObjectPos() = win inline {
        m_isObjectPosDirty = true;
        m_isUnmodifiedPosDirty = true;
    }
    void dirtifyObjectRect() = win inline {
        m_isObjectRectDirty = true;
        m_isOrientedBoxDirty = true;
    }
    void disableObject() = win inline {
        m_isDisabled = true;
        m_isDisabled2 = true;
        this->setOpacity(0);
        this->triggerActivated(0.f);
    }
    bool dontCountTowardsLimit() = win inline, ios inline {
        return m_objectID == 31;
    }
    void duplicateAttributes(GameObject* object) = win 0x1a1cc0;
    void duplicateColorMode(GameObject* object) = win 0x1a1be0;
    void duplicateValues(GameObject* object) = win 0x1a1e00;
    cocos2d::ccColor3B editorColorForCustomMode(int id) = win inline {
        auto index = (id < 5 ? id : id - 5) % 12;
        switch (index) {
            case 0: return { 210, 255, 167 };
            case 1: return { 167, 255, 167 };
            case 2: return { 165, 255, 209 };
            case 3: return { 167, 255, 255 };
            case 4: return { 166, 209, 255 };
            case 5: return { 167, 167, 255 };
            case 6: return { 209, 166, 255 };
            case 7: return { 255, 167, 255 };
            case 8: return { 255, 166, 209 };
            case 9: return { 255, 167, 167 };
            case 10: return { 255, 209, 166 };
            case 11: return { 255, 255, 167 };
            default: return { 255, 255, 255 };
        }
    }
    cocos2d::ccColor3B editorColorForMode(int id) = win 0x1a1060;
    void fastRotateObject(float rotation) = win inline {
        m_rotationXOffset += rotation;
        m_rotationYOffset += rotation;
        this->addRotation(rotation);
        if (m_objectType != GameObjectType::Decoration && !m_shouldUseOuterOb) {
            this->calculateOrientedBox();
        }
    }
    cocos2d::ccColor3B const& getActiveColorForMode(int id, bool mainColor) = win 0x1a2100;
    const char* getBallFrame(int index) = win inline {
        return cocos2d::CCString::createWithFormat("rod_ball_%02d_001.png", std::clamp(index, 0, 3))->getCString();
    }
    cocos2d::CCRect getBoundingRect() = win inline, ios inline {
        return cocos2d::CCRectApplyAffineTransform({ 0.f, 0.f, m_width, m_height }, this->nodeToParentTransform());
    }
    cocos2d::CCPoint const& getBoxOffset() = win 0x1a1810;
    gd::string getColorFrame(gd::string frame);
    int getColorIndex() = win inline {
        switch (m_objectID) {
            case 29: return 1000;
            case 30: return 1001;
            case 105: return 1004;
            case 744: return 1003;
            case 899: return m_targetColor;
            case 900: return 1009;
            case 915: return 1002;
            default: return 0;
        }
    }
    gd::string getColorKey(bool isMainColor, bool colorGroups) = win 0x19cd70;
    ZLayer getCustomZLayer() = win inline {
        return m_zLayer;
    }
    gd::string getGlowFrame(gd::string frame);
    bool getGroupDisabled() = win inline {
        return m_isGroupDisabled;
    }
    int getGroupID(int index) = win inline {
        if (index < 10 && m_groups) {
            return (*m_groups)[index];
        }
        return 0;
    }
    gd::string getGroupString() = win inline {
        fmt::memory_buffer buffer;
        auto first = true;
        for (int i = 0; i < 10; i++) {
            auto group = (*m_groups)[i];
            if (group > 0) {
                if (!first) fmt::format_to(std::back_inserter(buffer), ".");
                fmt::format_to(std::back_inserter(buffer), "{}", group);
                first = false;
            }
        }
        return fmt::to_string(buffer);
    }
    cocos2d::CCPoint const& getLastPosition() = win inline {
        return m_lastPosition;
    }
    GJSpriteColor* getMainColor() = win inline {
        return m_baseColor;
    }
    int getMainColorMode() = win inline {
        if (auto color = this->getMainColor()) return color->getColorMode();
        return 0;
    }
    int getObjectDirection() = win 0x19c560;
    float getObjectRadius() = win inline {
        return m_scaleX == 1.f && m_scaleY == 1.f ? m_objectRadius : m_objectRadius * std::max(m_scaleX, m_scaleY);
    }
    cocos2d::CCRect* getObjectRectPointer() = win inline {
        if (m_isObjectRectDirty) this->getObjectRect();
        return &m_objectRect;
    }
    ZLayer getObjectZLayer() = win inline {
        return m_zLayer != ZLayer::Default ? m_zLayer : m_defaultZLayer;
    }
    int getObjectZOrder() = win inline {
        return m_zOrder != 0 ? m_zOrder : m_defaultZOrder;
    }
    cocos2d::CCRect getOuterObjectRect() = win inline, ios inline {
        if (m_isOrientedBoxDirty) this->updateOrientedBox();
        return m_orientedBox->getBoundingRect();
    }
    int getParentMode() = win 0x19ab70;
    GJSpriteColor* getRelativeSpriteColor(int type) = win 0x1a1af0;
    cocos2d::CCPoint getScalePosDelta() = win 0x19c5e0;
    GJSpriteColor* getSecondaryColor() = win inline {
        return m_detailColor;
    }
    int getSecondaryColorMode() = win inline {
        if (auto color = this->getSecondaryColor()) return color->getColorMode();
        return 0;
    }
    float getSlopeAngle() = win inline {
        cocos2d::CCRect rect = getObjectRect();
        return atanf(rect.size.height / rect.size.width);
    }
    cocos2d::CCPoint getUnmodifiedPosition() = win inline {
        return { (float)(m_positionX - m_positionXOffset), (float)(m_positionY - m_positionYOffset) };
    }
    cocos2d::ccColor3B const& groupColor(cocos2d::ccColor3B const& color, bool mainColor) = win inline {
        m_groupColor = color;
        if (m_groupCount > 0) {
            for (int i = 0; i < m_groupCount; i++) {
                m_groupColor = m_goEffectManager->colorForGroupID((*m_groups)[i], color, mainColor);
            }
        }
        return m_groupColor;
    }
    float groupOpacityMod() = win 0x19ccf0;
    void groupWasDisabled() = win inline {
        m_enabledGroupsCounter--;
        m_isGroupDisabled = m_enabledGroupsCounter < 1;
    }
    void groupWasEnabled() = win inline {
        m_enabledGroupsCounter++;
        m_isGroupDisabled = m_enabledGroupsCounter < 1;
    }
    bool hasSecondaryColor() = win inline {
        return m_colorSprite;
    }
    bool ignoreEditorDuration() = win 0x1a3140;
    bool ignoreEnter() = win inline {
        return m_ignoreEnter;
    }
    bool ignoreFade() = win inline {
        return m_ignoreFade;
    }
    bool init(char const* frame) = win inline {
        if (!CCSpritePlus::initWithSpriteFrameName(frame)) return false;
        this->commonSetup();
        m_bUnkBool2 = true;
        return true;
    }
    bool isBasicTrigger() = win 0x1a3630;
    bool isColorObject() = win inline {
        if (m_customColorType == 0) {
            if (m_maybeNotColorable) return false;
        }
        else if (m_customColorType == 1) return false;
        if (this->hasSecondaryColor()) return false;
        auto defaultColorID = m_baseColor->m_defaultColorID;
        return defaultColorID != 1004 && defaultColorID != 0;
    }
    bool isColorTrigger() = win inline {
        return m_objectID == 29 || m_objectID == 30 || m_objectID == 105 || m_objectID == 744 || m_objectID == 899 || m_objectID == 900 || m_objectID == 915;
    }
    bool isConfigurablePortal() = win inline {
        auto id = m_objectID;
        return id == 12 || id == 13 || id == 47 || id == 111 || id == 286 || id == 287 || id == 660 || id == 745 || id == 1331 || id == 1933;
    }
    bool isEditorSpawnableTrigger() = win inline {
        auto id = m_objectID;
        return id == 29 || id == 30 || id == 105 || id == 744 || id == 899 || id == 900 || id == 901 || id == 915 || id == 1006 || id == 1007 || id == 1049 || id == 1268 || id == 1346 ||
            id == 1347 || id == 1585 || id == 1595 || id == 1611 || id == 1612 || id == 1613 || id == 1616 || id == 1811 || id == 1814 || id == 1815 || id == 1817 || id == 1912 ||
            id == 1913 || id == 1914 || id == 1916 || id == 1917 || id == 1932 || id == 1934 || id == 1935 || id == 2015 || id == 2062 || id == 2066 || id == 2067 || id == 2068 ||
            id == 2899 || id == 2900 || id == 2901 || id == 2903 || id == 2904 || id == 2905 || id == 2907 || id == 2909 || id == 2910 || id == 2911 || id == 2912 || id == 2913 ||
            id == 2914 || id == 2915 || id == 2916 || id == 2917 || id == 2919 || id == 2920 || id == 2921 || id == 2922 || id == 2923 || id == 2924 || id == 2925 || id == 2999 ||
            id == 3006 || id == 3007 || id == 3008 || id == 3009 || id == 3010 || id == 3011 || id == 3012 || id == 3013 || id == 3014 || id == 3015 || id == 3016 || id == 3022 ||
            id == 3024 || id == 3029 || id == 3030 || id == 3031 || id == 3033 || id == 3602 || id == 3603 || id == 3604 || id == 3605 || id == 3606 || id == 3607 || id == 3608 ||
            id == 3609 || id == 3612 || id == 3613 || id == 3614 || id == 3615 || id == 3617 || id == 3618 || id == 3619 || id == 3620 || id == 3640 || id == 3641 || id == 3655 ||
            id == 3660 || id == 3661 || id == 3662;
    }
    bool isFacingDown() = win 0x1a1950;
    bool isFacingLeft() = win 0x1a1a10;
    bool isSettingsObject() = win inline {
        return m_objectID == 3662 || m_objectID == 3613;
    }
    bool isSpawnableTrigger() = win 0x1a26f0;
    bool isSpecialObject() = win 0x1a2b00;
    bool isSpeedObject() = win inline {
        auto id = m_objectID;
        return id == 200 || id == 201 || id == 202 || id == 203 || id == 1334 || id == 1917 || id == 1934 || id == 1935 || id == 2900 || id == 2902 || id == 3022 || id == 3027;
    }
    bool isStoppableTrigger() = win inline {
        auto id = m_objectID;
        return id == 29 || id == 30 || id == 105 || id == 744 || id == 899 || id == 900 || id == 901 || id == 915 || id == 1006 || id == 1007 || id == 1268 || id == 1346 || id == 1347 ||
            id == 1595 || id == 1611 || id == 1615 || id == 1812 || id == 1814 || id == 1815 || id == 1913 || id == 1916 || id == 2015 || id == 2067 || id == 2903 || id == 2999 ||
            id == 3006 || id == 3007 || id == 3008 || id == 3009 || id == 3010 || id == 3016 || id == 3033 || id == 3602 || id == 3604 || id == 3614 || id == 3615;
    }
    bool isTrigger() = win 0x1a2280;
    void loadGroupsFromString(gd::string groupList) = win 0x19cb10;
    void makeInvisible() = win inline {
        m_isDisabled2 = true;
        m_isInvisible = true;
        this->setOpacity(0);
    }
    void makeVisible() = win inline {
        m_isDisabled2 = false;
        m_isInvisible = false;
        this->setOpacity(255);
    }
    float opacityModForMode(int id, bool mainColor) = win inline {
        auto ret = 1.f;
        if (id > 0) {
            auto actionSprite = mainColor ? m_mainActionSprite : m_detailActionSprite;
            uint8_t opacity = actionSprite->m_opacity;
            if (opacity < 250) ret = opacity / 255.f;
        }
        if (m_opacityGroupCount > 0) ret *= this->groupOpacityMod();
        return ret;
    }
    cocos2d::CCNode* parentForZLayer(int zLayer, bool blending, int parentMode) = win 0x19bf20;
    gd::string perspectiveColorFrame(char const* prefix, int index) = win 0x1aef10;
    gd::string perspectiveFrame(char const* prefix, int index) = win 0x1aedd0;
    void playDestroyObjectAnim(GJBaseGameLayer* layer) = win 0x1aa4e0;
    void playPickupAnimation(cocos2d::CCSprite* target, float offset, float duration, float randomValue1, float randomValue2) = win 0x1a9f10, ios inline {
        this->playPickupAnimation(target, offset * 50.f, offset * 60.f, offset * 90.f, offset * 180.f, offset * 20.f, duration * .75f, duration * .5f, duration * .25f, false, randomValue1, randomValue2);
    }
    void playPickupAnimation(cocos2d::CCSprite* target, float xOffset, float yOffset, float controlYOffset1, float controlYOffset2, float endYOffset, float duration, float fadeDelay, float fadeDuration, bool rotate, float randomValue1, float randomValue2) = win 0x1aa000;
    void playShineEffect() = win 0x1993f0;
    void quickUpdatePosition() = win inline {
        auto pos = ccp(m_positionX, m_positionY);
        cocos2d::CCSprite::setPosition(pos);
        if (m_colorSprite && !m_colorSpriteLocked) m_colorSprite->setPosition(pos);
    }
    void quickUpdatePosition2() = win inline, ios inline {
        m_obPosition.x = m_positionX;
        m_obPosition.y = m_positionY;
    }
    void removeColorSprite() = win inline, ios inline {
        if (m_colorSprite) {
            m_colorSprite->release();
            m_colorSprite = nullptr;
        }
    }
    void removeGlow() = win inline {
        if (m_glowSprite) {
            m_glowSprite->removeMeAndCleanup();
            m_glowSprite = nullptr;
        }
    }
    void reorderColorSprite() = win inline, ios inline {}
    void resetColorGroups() = win inline {
        if (m_colorGroupCount > 0) {
            for (int i = 0; i < m_colorGroupCount; i++) {
                (*m_colorGroups)[i] = 0;
            }
        }
        m_colorGroupCount = 0;
    }
    void resetGroupDisabled() = win inline {
        m_enabledGroupsCounter = 0;
        m_isGroupDisabled = false;
    }
    void resetGroups() = win inline {
        m_groupCount = 0;
    }
    void resetMainColorMode() = win inline, ios inline {
        if (auto color = this->getMainColor()) {
            color->m_defaultColorID = std::clamp(color->m_defaultColorID, 0, 1101);
            color->m_colorID = 0;
        }
    }
    void resetMoveOffset() = win inline {
        m_positionX = m_startPosition.x;
        m_positionY = m_startPosition.y;
    }
    void resetRScaleForced() = win inline, ios inline {
        m_fScaleX = 0.f;
        m_fScaleY = 0.f;
        this->setRScaleX(1.f);
        this->setRScaleY(1.f);
    }
    void resetSecondaryColorMode() = win inline, ios inline {
        if (auto color = this->getSecondaryColor()) {
            color->m_defaultColorID = std::clamp(color->m_defaultColorID, 0, 1101);
            color->m_colorID = 0;
        }
    }
    void setAreaOpacity(float step, float value, int index) = win 0x1987b0;
    void setCustomZLayer(int zLayer) = win inline {
        if (m_zFixedZLayer) return;
        m_zLayer = static_cast<ZLayer>(zLayer);
    }
    void setDefaultMainColorMode(int id) = win inline {
        if (auto color = this->getMainColor()) {
            color->m_defaultColorID = std::clamp(id, 0, 1101);
            color->m_colorID = 0;
        }
    }
    void setDefaultSecondaryColorMode(int id) = win inline {
        if (auto color = this->getSecondaryColor()) {
            color->m_defaultColorID = std::clamp(id, 0, 1101);
            color->m_colorID = 0;
        }
    }
    void setGlowOpacity(unsigned char opacity) = win inline {
        if (m_glowSprite) {
            auto glowOpacity = opacity * m_opacityMod;
            m_glowSprite->setOpacity(glowOpacity);
            m_glowSprite->setChildOpacity(glowOpacity);
        }
    }
    void setLastPosition(cocos2d::CCPoint const& position) = win inline {
        m_lastPosition = position;
    }
    void setMainColorMode(int id) = win inline {
        if (auto color = this->getMainColor()) {
            color->m_colorID = std::clamp(id, 0, 1101);
        }
    }
    void setSecondaryColorMode(int id) = win inline, ios inline {
        if (auto color = this->getSecondaryColor()) {
            color->m_colorID = std::clamp(id, 0, 1101);
        }
    }
    void setupColorSprite(int id, bool mainColor) = win inline, ios inline {
        if (mainColor) m_mainActionSprite = m_goEffectManager->getColorSprite(id);
        else m_detailActionSprite = m_goEffectManager->getColorSprite(id);
    }
    void setupPixelScale() = win 0x1c3340;
    void setupSpriteSize() = win 0x1a36e0;
    bool shouldBlendColor(GJSpriteColor* color, bool mainColor) = win 0x190cc0;
    bool shouldLockX() = win 0x196e80;
    bool shouldNotHideAnimFreeze() = win inline, ios inline {
        return m_objectID == 1855;
    }
    bool shouldShowPickupEffects() = win inline {
        if (!m_hasNoEffects && !m_isInvisible) {
            if (this->getOpacity() != 0) return true;
            if (m_colorSprite && m_colorSprite->getOpacity() != 0) return true;
        }
        return false;
    }
    bool slopeFloorTop() = win inline {
        return m_slopeDirection == 1 || m_slopeDirection == 3 || m_slopeDirection == 5 || m_slopeDirection == 6;
    }
    bool slopeWallLeft() = win inline {
        return m_slopeDirection == 2 || m_slopeDirection == 3 || m_slopeDirection == 4 || m_slopeDirection == 6;
    }
    double slopeYPos(GameObject* object) = win inline, ios inline {
        return this->slopeYPos(object->getObjectRect());
    }
    double slopeYPos(cocos2d::CCRect rect) = win inline {
        auto floorTop = this->slopeFloorTop();
        if (m_slopeUphill) {
            return this->slopeYPos(floorTop ? rect.getMaxX() : rect.getMinX());
        }
        else {
            return this->slopeYPos(floorTop ? rect.getMinX() : rect.getMaxX());
        }
    }
    double slopeYPos(float x) = win 0x1a13f0;
    void spawnDefaultPickupParticle(GJBaseGameLayer* layer) = win 0x1aa2a0;
    void updateBlendMode() = win inline {
        auto shouldBlend = this->shouldBlendColor(m_baseColor, true);
        m_shouldBlendBase = shouldBlend;
        if (!m_colorSprite) {
            m_shouldBlendDetail = false;
            return;
        }
        m_shouldBlendDetail = m_detailColor->getColorMode() != 1012 ? this->shouldBlendColor(m_detailColor, false) : shouldBlend;
    }
    void updateCustomColorType(short type) = win inline, ios inline {
        m_customColorType = type;
        m_customSpriteColor = this->getRelativeSpriteColor(1) == nullptr;
    }
    void updateCustomScaleX(float scaleX);
    void updateCustomScaleY(float scaleY);
    void updateHSVState() = win inline {
        if (auto color = m_baseColor) {
            color->m_usesHSV = color->m_hsv.h != 0.f || color->m_hsv.s != 1.f || color->m_hsv.v != 1.f || color->m_hsv.absoluteSaturation || color->m_hsv.absoluteBrightness;
        }
        if (auto color = m_detailColor) {
            color->m_usesHSV = color->m_hsv.h != 0.f || color->m_hsv.s != 1.f || color->m_hsv.v != 1.f || color->m_hsv.absoluteSaturation || color->m_hsv.absoluteBrightness;
        }
    }
    void updateIsOriented() = win 0x1a1770;
    void updateMainColor() = win inline {
        this->updateMainColor(this->colorForMode(m_activeMainColorID, true));
        this->updateMainOpacity();
    }
    void updateMainColorOnly() = win inline, ios inline {
        if (m_activeMainColorID != 0 && m_colorGroupCount != 0 && m_opacityGroupCount != 0) {
            this->updateMainColor(this->colorForMode(m_activeMainColorID, true));
        }
    }
    void updateMainOpacity() = win inline, ios inline {
        m_baseColor->m_opacity = this->opacityModForMode(m_activeMainColorID, true);
    }
    void updateObjectEditorColor() = win 0x1a1330;
    void updateSecondaryColor() = win inline {
        if (this->hasSecondaryColor() && m_activeDetailColorID != 0 && m_groupCount != 0) {
            this->updateSecondaryColor(this->colorForMode(m_activeDetailColorID, false));
            this->updateSecondaryOpacity();
        }
    }
    void updateSecondaryColorOnly() = win inline, ios inline {
        if (this->hasSecondaryColor() && m_activeDetailColorID != 0 && m_groupCount != 0) {
            this->updateSecondaryColor(this->colorForMode(m_activeDetailColorID, false));
        }
    }
    void updateSecondaryOpacity() = win inline, ios inline {
        m_detailColor->m_opacity = this->opacityModForMode(m_activeDetailColorID, false);
    }
    void updateStartPos() = win 0x190630;
    void updateUnmodifiedPositions() = win inline, ios inline {
        if (m_isDisabled) {
            m_isDisabled = false;
            m_unmodifiedPositionX = m_positionX - m_positionXOffset;
            m_unmodifiedPositionY = m_positionY - m_positionYOffset;
        }
    }
    bool usesFreezeAnimation() = win inline {
        auto id = m_objectID;
        return id == 921 || id == 1519 || id == 1618 || id == 1851 || id == 1852 || id == 1854 || id == 1855 || id == 1856 || id == 1860 || id == 2020 || id == 2021 || id == 2022 ||
            id == 2024 || id == 2025 || id == 2026 || id == 2027 || id == 2028 || id == 2029 || id == 2030 || id == 2031 || id == 2033 || id == 2035 || id == 2036 || id == 2037 ||
            id == 2038 || id == 2039 || id == 2040 || id == 2043 || id == 2044 || id == 2045 || id == 2046 || id == 2047 || id == 2048 || id == 2049 || id == 2050 || id == 2051 ||
            id == 2052 || id == 2053 || id == 2054 || id == 2055 || id == 2867 || id == 2868 || id == 2869 || id == 2870 || id == 2871 || id == 2872 || id == 2875 || id == 2876 ||
            id == 2877 || id == 2878 || id == 2880 || id == 2882 || id == 2883 || id == 2885 || id == 2886 || id == 2887;
    }
    bool usesSpecialAnimation() = win inline {
        auto id = m_objectID;
        return id == 1591 || id == 1593 || id == 1839 || id == 1840 || id == 1841 || id == 1842 || id == 2892 || id == 2893;
    }

    int m_someOtherIndex;
    int m_innerSectionIndex;
    int m_outerSectionIndex;
    int m_middleSectionIndex;
    // property 511
    bool m_hasExtendedCollision;
    cocos2d::ccColor3B m_groupColor;
    bool m_isColorSpriteBlack;
    bool m_isObjectBlack;
    float m_blackChildOpacity;
    bool m_blackChildOpacityLocked;
    bool m_editorEnabled;
    bool m_isGroupDisabled;
    bool m_unk28B;
    bool m_unk28c;
    // somehow related to property 155 and 156 if anyone wants to reverse engineer
    int m_activeMainColorID;
    int m_activeDetailColorID;
    bool m_baseUsesHSV;
    bool m_detailUsesHSV;
    float m_positionXOffset;
    float m_positionYOffset;
    float m_rotationXOffset;
    float m_unk2A8;
    float m_rotationYOffset;
    float m_unk2B0;
    float m_scaleXOffset;
    float m_scaleYOffset;
    float m_unk2BC;
    float m_unk2C0;
    bool m_tempOffsetXRelated;
    bool m_isFlipX;
    bool m_isFlipY;
    cocos2d::CCPoint m_customBoxOffset;
    bool m_boxOffsetCalculated;
    cocos2d::CCPoint m_boxOffset;
    OBB2D* m_orientedBox;
    bool m_shouldUseOuterOb;
    cocos2d::CCSprite* m_glowSprite;
    bool m_isRingPoweredOn;
    float m_width;
    float m_height;
    bool m_addToNodeContainer;
    bool m_isActivated;
    bool m_isDisabled2;
    cocos2d::CCParticleSystemQuad* m_particle;
    gd::string m_particleString;
    bool m_hasParticles;
    // property 146
    bool m_particleUseObjectColor;
    bool m_hasColorSprite;
    cocos2d::CCPoint m_particleOffset;
    bool m_isParticleSpriteLocked;
    cocos2d::CCRect m_textureRect;
    bool m_isDirty;
    bool m_isObjectPosDirty;
    bool m_isUnmodifiedPosDirty;
    float m_fadeMargin;
    cocos2d::CCRect m_objectRect;
    bool m_isObjectRectDirty;
    bool m_isOrientedBoxDirty;
    bool m_colorSpriteLocked;
    bool m_unk353;
    bool m_canRotateFree;
    bool m_isMirroredByScale;
    // property 108
    int m_linkedGroup;
    int m_unk35C;
    short m_colorType;
    short m_childColorType;
    bool m_shouldBlendBase;
    bool m_shouldBlendDetail;
    bool m_hasCustomChild;
    bool m_unk367;
    cocos2d::CCSprite* m_colorSprite;
    bool m_unk370;
    float m_objectRadius;
    bool m_isRotationAligned;
    float m_spriteWidthScale;
    float m_spriteHeightScale;
    int m_uniqueID;
    GameObjectType m_objectType;
    // used in PlayerObject::gameEventTriggered
    GameObjectType m_savedObjectType;
    int m_unk390;
    float m_unmodifiedPositionX;
    float m_unmodifiedPositionY;
    double m_positionX;
    double m_positionY;
    cocos2d::CCPoint m_startPosition;
    bool m_usesAudioScale;
    // property 372
    bool m_hasNoAudioScale;
    bool m_isDisabled;
    float m_startRotationX;
    float m_startRotationY;
    float m_startScaleX;
    float m_startScaleY;
    float m_customScaleX;
    float m_customScaleY;
    bool m_startFlipX;
    bool m_startFlipY;
    bool m_unk3ee;
    bool m_isInvisible;
    int m_unk3D8;
    short m_varianceIndex;
    bool m_unk3DE;
    short m_enterType;
    short m_exitType;
    // property 343
    short m_enterChannel;
    // property 446
    short m_objectMaterial;
    bool m_unk3E8;
    short m_parentMode;
    // property 96
    bool m_hasNoGlow;
    // property 23
    int m_targetColor;
    // property 1
    int m_objectID;
    bool m_unk3F8;
    bool m_intrinsicDontFade;
    bool m_ignoreEnter;
    bool m_ignoreFade;
    // true for object IDs 207-213 and 693-694
    bool m_isSolidColorBlock;
    bool m_unk3FD;
    bool m_customSpriteColor;
    // property 497
    short m_customColorType;
    // property 67
    bool m_isDontEnter;
    // property 64
    bool m_isDontFade;
    // property 116
    bool m_hasNoEffects;
    // property 507
    bool m_hasNoParticles;
    int m_defaultZOrder;
    bool m_unk40C;
    bool m_colorZLayerRelated;
    bool m_customAudioScale;
    float m_minAudioScale;
    float m_maxAudioScale;
    bool m_particleLocked;
    // property 53
    int m_property53;
    bool m_isInvisibleBlock;
    bool m_glowColorIsLBG;
    bool m_customGlowColor;
    bool m_cantColorGlow;
    float m_opacityMod;
    bool m_slopeUphill;
    int m_slopeDirection;
    bool m_slopeIsHazard;
    float m_opacityMod2;
    // property 21, also used with 41 and 43
    GJSpriteColor* m_baseColor;
    // property 22, also used with 42 and 44
    GJSpriteColor* m_detailColor;
    bool m_baseOrDetailBlending;
    ZLayer m_defaultZLayer;
    bool m_zFixedZLayer;
    // property 24
    ZLayer m_zLayer;
    // property 25
    int m_zOrder;
    bool m_wasSelected;
    bool m_isSelected;
    float m_unk460;
    cocos2d::CCPoint m_unk464;
    bool m_updateParents;
    bool m_updateEditorColor;
    // property 34
    bool m_hasGroupParent;
    // property 279
    bool m_hasAreaParent;
    // property 128
    float m_scaleX;
    // property 129
    float m_scaleY;
    // property 57, short array of size either 10 or m_groupCount
    std::array<short, 10>* m_groups;
    // used with property 57
    short m_groupCount;
    // used with property 274
    bool m_hasGroupParentsString;
    std::array<short, 10>* m_colorGroups;
    short m_colorGroupCount;
    std::array<short, 10>* m_opacityGroups;
    short m_opacityGroupCount;
    // property 20
    short m_editorLayer;
    // property 61
    short m_editorLayer2;
    int m_enabledGroupsCounter;
    bool m_updateCustomContentSize;
    bool m_hasContentSize;
    // property 121
    bool m_isNoTouch;
    cocos2d::CCSize m_lastSize;
    cocos2d::CCPoint m_lastPosition;
    int m_unk4C0;
    int m_unk4C4;
    int m_unk4C8;
    int m_unk4CC;
    GameObjectClassType m_classType;
    bool m_isTrigger;
    bool m_isSpawnOrderTrigger;
    bool m_isColorTrigger;
    bool m_dontIgnoreDuration;
    bool m_canBeControlled;
    bool m_activateTriggerInEditor;
    bool m_isStartPos;
    // property 103
    bool m_isHighDetail;
    ColorActionSprite* m_mainActionSprite;
    ColorActionSprite* m_detailActionSprite;
    GJEffectManager* m_goEffectManager;
    bool m_unk4F8;
    bool m_isDecoration;
    bool m_isDecoration2;
    bool m_unk4fb;
    bool m_maybeNotColorable;
    // property 134
    bool m_isPassable;
    // property 135
    bool m_isHide;
    // property 136
    bool m_isNonStickX;
    // property 289
    bool m_isNonStickY;
    // property 137
    bool m_isIceBlock;
    // property 193
    bool m_isGripSlope;
    // property 356
    bool m_isScaleStick;
    // property 495
    bool m_isExtraSticky;
    // property 496
    bool m_isDontBoostY;
    // property 509
    bool m_isDontBoostX;
    bool m_unk507;
    bool m_unk508;
    float m_unk50C;
    float m_pixelScaleX;
    float m_pixelScaleY;
    // property 155
    int m_mainColorKeyIndex;
    // property 156
    int m_detailColorKeyIndex;
    uint8_t m_areaOpacityRelated;
    float m_areaOpacityValue;
    int m_areaOpacityIndex;
    int m_unk52C;
    bool m_unk530;
    bool m_isUIObject;
    bool m_greenDebugDraw;
}

[[link(android)]]
class GameObjectCopy : cocos2d::CCObject {
    // virtual ~GameObjectCopy();

    static GameObjectCopy* create(GameObject* object) = win 0x2e87a0;

    bool init(GameObject* object) = win inline {
        m_object = object;
        object->retain();
        m_position = m_object->getPosition();
        m_rotationX = m_object->getRotationX();
        m_rotationY = m_object->getRotationY();
        m_isFlipX = m_object->isFlipX();
        m_isFlipY = m_object->isFlipY();
        m_customScaleX = m_object->m_scaleX;
        m_customScaleY = m_object->m_scaleY;
        return true;
    }
    void resetObject() = win 0x2e88a0;

    GameObject* m_object;
    cocos2d::CCPoint m_position;
    float m_rotationX;
    float m_rotationY;
    bool m_isFlipX;
    bool m_isFlipY;
    float m_customScaleX;
    float m_customScaleY;
}

[[link(android)]]
class GameObjectEditorState {
    void loadValues(GameObject* obj) = win inline {
        m_position = obj->getPosition();
        m_scaleX = obj->m_scaleX / obj->m_pixelScaleX;
        m_scaleY = obj->m_scaleY / obj->m_pixelScaleY;
        m_rotationX = obj->getRotationX();
        m_rotationY = obj->getRotationY();
    }

    cocos2d::CCPoint m_position;
    float m_scaleX;
    float m_scaleY;
    float m_rotationX;
    float m_rotationY;
}

[[link(android)]]
class GameOptionsLayer : GJOptionsLayer {
    // virtual ~GameOptionsLayer();
    GameOptionsLayer() {
        m_practiceDialogIndex = 0;
    }

    static GameOptionsLayer* create(GJBaseGameLayer* baseGameLayer) = win inline {
        auto ret = new GameOptionsLayer();
        if (ret->init(baseGameLayer)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void setupOptions() = win 0x29eda0;
    virtual void didToggle(int tag) = win 0x2a03c0;

    bool init(GJBaseGameLayer* baseGameLayer) = win inline {
        m_baseGameLayer = baseGameLayer;
        m_gap = 40.f;
        m_maxLabelScale = .4f;
        if (!GJOptionsLayer::init(2)) return false;
        this->preSetup();
        this->postSetup();
        return true;
    }
    void onPracticeMusicSync(cocos2d::CCObject* sender) = win 0x2a00d0;
    void onUIOptions(cocos2d::CCObject* sender);
    void onUIPOptions(cocos2d::CCObject* sender) = win 0x2a0270;
    void showPracticeMusicSyncUnlockInfo() = win 0x29f870;

    GJBaseGameLayer* m_baseGameLayer;
    int m_practiceDialogIndex;
}

[[link(android)]]
class GameOptionsTrigger : EffectGameObject {
    // virtual ~GameOptionsTrigger();
    GameOptionsTrigger() {
        m_streakAdditive = GameOptionsSetting::Disabled;
        m_unlinkDualGravity = GameOptionsSetting::Disabled;
        m_hideGround = GameOptionsSetting::Disabled;
        m_hideP1 = GameOptionsSetting::Disabled;
        m_hideP2 = GameOptionsSetting::Disabled;
        m_disableP1Controls = GameOptionsSetting::Disabled;
        m_disableP2Controls = GameOptionsSetting::Disabled;
        m_hideMG = GameOptionsSetting::Disabled;
        m_hideAttempts = GameOptionsSetting::Disabled;
        m_editRespawnTime = GameOptionsSetting::Disabled;
        m_respawnTime = 0.f;
        m_audioOnDeath = GameOptionsSetting::Disabled;
        m_noDeathSFX = GameOptionsSetting::Disabled;
        m_boostSlide = GameOptionsSetting::Disabled;
    }

    static GameOptionsTrigger* create(char const* frame) = win inline {
        auto ret = new GameOptionsTrigger();
        if (ret->init(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x49f0e0;
    virtual gd::string getSaveString(GJBaseGameLayer* layer);

    bool init(char const* frame) = win inline, ios inline {
        return EffectGameObject::init(frame);
    }

    // property 159
    GameOptionsSetting m_streakAdditive;
    // property 160
    GameOptionsSetting m_unlinkDualGravity;
    // property 161
    GameOptionsSetting m_hideGround;
    // property 162
    GameOptionsSetting m_hideP1;
    // property 163
    GameOptionsSetting m_hideP2;
    // property 165
    GameOptionsSetting m_disableP1Controls;
    // property 199
    GameOptionsSetting m_disableP2Controls;
    // property 195
    GameOptionsSetting m_hideMG;
    // property 532
    GameOptionsSetting m_hideAttempts;
    // property 573
    GameOptionsSetting m_editRespawnTime;
    // property 574
    float m_respawnTime;
    // property 575
    GameOptionsSetting m_audioOnDeath;
    // property 576
    GameOptionsSetting m_noDeathSFX;
    // property 593
    GameOptionsSetting m_boostSlide;
}

[[link(android)]]
class GameRateDelegate {
    virtual void updateRate() {}
}

[[link(android)]]
class GameStatsManager : cocos2d::CCNode {
    static GameStatsManager* get() {
        return GameStatsManager::sharedState();
    }
    // virtual ~GameStatsManager();
    // GameStatsManager();
    static GameStatsManager* sharedState();

    virtual bool init() = win 0x1d1150;

    int accountIDForIcon(int id, UnlockType type) = win inline {
        if (auto it = m_accountIDForIcon.find({ id, type }); it != m_accountIDForIcon.end()) {
            return it->second;
        }
        return 0;
    }
    void addSimpleSpecialChestReward(gd::string key, UnlockType type, int id, bool unused) = win 0x1ea0e0;
    void addSpecialRewardDescription(gd::string key, gd::string description) = win 0x1ea2f0, ios inline {
        m_specialRewardDescriptions[key] = description;
    }
    void addStoreItem(int index, int id, int unlockType, int price, ShopType shopType) = win 0x1d4010;
    bool areChallengesLoaded() = win inline {
        return m_challengeTime > 0;
    }
    bool areRewardsLoaded() = win inline {
        return m_rewardItems->objectForKey(1) != nullptr;
    }
    void awardCurrencyForLevel(GJGameLevel* level) = win 0x1e09a0;
    void awardDiamondsForLevel(GJGameLevel* level) = win 0x1e1180;
    bool awardSecretKey() = win 0x1f1a30;
    bool canItemBeUnlocked(int id, UnlockType type) = win inline, ios inline { return true; }
    void checkAchievement(char const* statKey) = win 0x1d5480;
    void checkCoinAchievement(GJGameLevel* level) = win 0x1dd840;
    void checkCoinsForLevel(GJGameLevel* level) = win inline {
        if (level->m_coins > 0 && level->m_coinsVerified.value() == 1) {
            for (int i = 1; i < 4; i++) {
                auto coinKey = level->getCoinKey(i);
                if (this->hasPendingUserCoin(coinKey)) {
                    if (!this->hasUserCoin(coinKey)) {
                        this->storeUserCoin(coinKey);
                        this->incrementStat("12");
                    }
                    m_pendingUserCoins->removeObjectForKey(coinKey);
                }
            }
        }
    }
    bool claimListReward(GJLevelList* list) = win inline {
        if (list->m_diamonds > 0 && list->m_levelsToClaim > 0 && list->completedLevels() >= list->m_levelsToClaim && !this->hasClaimedListReward(list)) {
            m_completedLists->setObject(cocos2d::CCString::createWithFormat("%i", list->m_diamonds), this->getListRewardKey(list));
            return true;
        }
        return false;
    }
    void collectReward(GJRewardType type, GJRewardItem* item) = win inline {
        if (!item || this->hasRewardBeenCollected(type, item->m_chestID)) return;
        this->registerRewardsFromItem(item);
        m_dailyChests->setObject(item, this->getRewardKey(type, item->m_chestID));
    }
    void collectVideoReward(int orbs);
    void completedChallenge(GJChallengeItem* item) = win inline {
        if (item->m_canClaim && !this->hasCompletedChallenge(item)) {
            auto reward = item->m_reward.value();
            m_challengeDiamonds->setObject(cocos2d::CCString::createWithFormat("%i", reward), this->getChallengeKey(item));
            this->incrementStat("13", reward);
        }
    }
    GJRewardItem* completedDailyLevel(GJGameLevel* level) = win 0x1e2e20;
    void completedDemonLevel(GJGameLevel* level) = win 0x1de540;
    void completedLevel(GJGameLevel* level) = win 0x1de3f0;
    void completedMapPack(GJMapPack* pack) = win 0x1dee40;
    void completedStarLevel(GJGameLevel* level) = win 0x1de7b0;
    int countSecretChests(GJRewardType rewardType) = win inline {
        if (!m_allTreasureRoomChests) {
            return 0;
        }

        if (rewardType == GJRewardType::Unknown) {
            return m_allTreasureRoomChests->count();
        }

        int count = 0;
        cocos2d::CCDictElement* obj;
        cocos2d::CCDictElement* temp;
        HASH_ITER(hh, m_allTreasureRoomChests->m_pElements, obj, temp) {
            auto chest = static_cast<GJRewardItem*>(obj->getObject());
            if (chest->m_rewardType == rewardType) count++;
        }
        return count;
    }
    int countUnlockedSecretChests(GJRewardType rewardType) = win inline {
        if (!m_treasureRoomChests) {
            return 0;
        }

        if (rewardType == GJRewardType::Unknown) {
            return m_treasureRoomChests->count();
        }

        int count = 0;
        cocos2d::CCDictElement* obj;
        cocos2d::CCDictElement* temp;
        HASH_ITER(hh, m_treasureRoomChests->m_pElements, obj, temp) {
            auto chest = static_cast<GJRewardItem*>(obj->getObject());
            if (chest->m_rewardType == rewardType) count++;
        }
        return count;
    }
    GJRewardItem* createReward(GJRewardType type, int id, gd::string str) = win 0x1e1630;
    void createSecretChestItems() = win inline {
        if (m_allTreasureRoomChestItems) return;
        m_allTreasureRoomChestItems = cocos2d::CCDictionary::create();
        m_allTreasureRoomChestItems->retain();
        m_allTreasureRoomChests = cocos2d::CCDictionary::create();
        m_allTreasureRoomChests->retain();
        this->createSecretChestRewards();
        cocos2d::CCDictElement* element;
        cocos2d::CCDictElement* temp;
        HASH_ITER(hh, m_allTreasureRoomChests->m_pElements, element, temp) {
            if (auto rewardItem = static_cast<GJRewardItem*>(element->getObject())) {
                auto rewardObjects = rewardItem->m_rewardObjects;
                for (int i = 0; i < rewardObjects->count(); i++) {
                    auto rewardObject = static_cast<GJRewardObject*>(rewardObjects->objectAtIndex(i));
                    auto rewardKey = this->getItemKey(rewardObject->m_itemID, (int)rewardObject->m_unlockType);
                    m_allTreasureRoomChestItems->setObject(cocos2d::CCString::createWithFormat("%i", rewardItem->m_chestID), rewardKey);
                }
            }
        }
    }
    void createSecretChestRewards() = win 0x1eab30;
    void createSpecialChestItems() = win 0x1e5ca0;
    void createStoreItems() = win 0x1d1840;
    void dataLoaded(DS_Dictionary* dict) = win 0x1f24e0;
    void encodeDataTo(DS_Dictionary* dict);
    void firstSetup() = win 0x1f1af0;
    void generateItemUnlockableData() = win 0x1d1350;
    int getAwardedCurrencyForLevel(GJGameLevel* level) = win 0x1e0760;
    int getAwardedDiamondsForLevel(GJGameLevel* level) = win 0x1e0f50;
    int getBaseCurrency(int stars, bool mainLevel, int levelID) = win inline {
        if (mainLevel) {
            return levelID == 14 || levelID == 18 || levelID == 20 ? 400 : (stars + 1) * 20;
        }
        else {
            switch (stars) {
                case 2: return 40;
                case 3: return 60;
                case 4: return 100;
                case 5: return 140;
                case 6: return 180;
                case 7: return 220;
                case 8: return 280;
                case 9: return 340;
                case 10: return 400;
                default: return 0;
            }
        }
    }
    int getBaseCurrencyForLevel(GJGameLevel* level) = win 0x1e04c0;
    int getBaseDiamonds(int stars) = win inline {
        return stars > 2 && stars < 11 ? stars + 2 : 0;
    }
    int getBonusDiamonds(int stars) = win inline {
        return stars > 2 && stars < 11 ? stars == 10 ? 20 : this->getBaseDiamonds(stars) / 2.f : 0;
    }
    GJChallengeItem* getChallenge(int id);
    gd::string getChallengeKey(GJChallengeItem* chal) = win inline {
        return cocos2d::CCString::createWithFormat("c%i%i", chal->m_position, chal->m_timeLeft)->getCString();
    }
    int getCollectedCoinsForLevel(GJGameLevel* level) = win 0x1ddbe0;
    cocos2d::CCArray* getCompletedMapPacks() = win 0x1df190;
    gd::string getCurrencyKey(GJGameLevel* level) = win inline {
        auto dailyID = level->m_dailyID.value();
        return cocos2d::CCString::createWithFormat("%i", dailyID > 0 ? dailyID : level->m_levelID.value())->getCString();
    }
    gd::string getDailyLevelKey(int dailyID) = win inline {
        return cocos2d::CCString::createWithFormat("d%i", dailyID)->getCString();
    }
    const char* getDemonLevelKey(GJGameLevel* level) = win inline {
        auto dailyID = level->m_dailyID.value();
        if (dailyID > 0) return cocos2d::CCString::createWithFormat("ddemon_%i", dailyID)->getCString();
        auto levelID = level->m_levelID.value();
        if (level->m_gauntletLevel) return cocos2d::CCString::createWithFormat("gdemon_%i", levelID)->getCString();
        return cocos2d::CCString::createWithFormat("demon_%i", levelID)->getCString();
    }
    gd::string getEventRewardKey(int id) = win inline, ios inline {
        return fmt::format("o_event_{}", id);
    }
    gd::string getGauntletRewardKey(int id);
    gd::string getItemKey(int id, int type) = win 0x1e19c0;
    int getItemUnlockState(int itemID, UnlockType unlockType) = win 0x1e5b40;
    int getItemUnlockStateLite(int id, UnlockType type);
    gd::string getLevelKey(GJGameLevel* level) = win inline {
        return getLevelKey(level->m_levelID, level->m_levelType != GJLevelType::Main, level->m_dailyID > 0, level->m_gauntletLevel, level->m_dailyID > 200000);
    }
    gd::string getLevelKey(int levelID, bool isOnline, bool isDaily, bool isGauntlet, bool isEvent) = win 0x1ddd60;
    gd::string getListRewardKey(GJLevelList* list) = win inline {
        return cocos2d::CCString::createWithFormat("lr_%i", list->m_listID)->getCString();
    }
    const char* getMapPackKey(int id) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("pack_%i", id)->getCString();
    }
    int getNextGoldChestID() = win inline {
        for (int i = 6001; i < 6021; i++) {
            if (!this->isSecretChestUnlocked(i)) return i;
        }
        return 0;
    }
    gd::string getNextVideoAdReward();
    gd::string getPathRewardKey(int id);
    GJChallengeItem* getQueuedChallenge(int id);
    GJRewardItem* getRewardForSecretChest(int id) = win inline, ios inline {
        return static_cast<GJRewardItem*>(m_allTreasureRoomChests->objectForKey(id));
    }
    GJRewardItem* getRewardForSpecialChest(gd::string key) = win inline {
        return static_cast<GJRewardItem*>(m_allSpecialChests->objectForKey(key));
    }
    GJRewardItem* getRewardItem(GJRewardType type) = win inline {
        return static_cast<GJRewardItem*>(m_rewardItems->objectForKey((int)type));
    }
    gd::string getRewardKey(GJRewardType type, int id) = win 0x1e19c0;
    GJChallengeItem* getSecondaryQueuedChallenge(int id) = win 0x1e2020;
    int getSecretChestForItem(int id, UnlockType type) = win inline {
        return m_allTreasureRoomChestItems->valueForKey(this->getItemKey(id, (int)type))->intValue();
    }
    const char* getSecretCoinKey(char const* key) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("unique_%s", key)->getCString();
    }
    gd::string getSecretOnlineRewardKey(int id) = win inline {
        return fmt::format("o_secret_{}", id);
    }
    cocos2d::CCString* getSpecialChestKeyForItem(int id, UnlockType type) = win inline {
        return static_cast<cocos2d::CCString*>(m_allSpecialChestItems->objectForKey(this->getItemKey(id, (int)type)));
    }
    gd::string getSpecialRewardDescription(gd::string key, bool unused) = win inline {
        if (auto it = m_specialRewardDescriptions.find(key); it != m_specialRewardDescriptions.end()) {
            return it->second;
        }
        return "";
    }
    gd::string getSpecialUnlockDescription(int id, UnlockType type, bool unused) = win 0x1ea380;
    char const* getStarLevelKey(GJGameLevel* level) = win inline {
        int dailyID = level->m_dailyID.value();
        if (dailyID > 0) return cocos2d::CCString::createWithFormat("dstar_%i",dailyID)->getCString();
        int levelID = level->m_levelID.value();
        if (level->m_gauntletLevel) return cocos2d::CCString::createWithFormat("gstar_%i",levelID)->getCString();
        return cocos2d::CCString::createWithFormat("star_%i",levelID)->getCString();
    }
    int getStat(char const* key) = win 0x1d51f0;
    int getStatFromKey(StatKey key) = win inline {
        return this->getStat(GameToolbox::intToString((int)key).c_str());
    }
    GJStoreItem* getStoreItem(int index) = win inline {
        return static_cast<GJStoreItem*>(m_storeItems->objectForKey(index));
    }
    GJStoreItem* getStoreItem(int id, int type) = win inline {
        return static_cast<GJStoreItem*>(m_allStoreItems->objectForKey(this->getItemKey(id, type)));
    }
    int getTotalCollectedCurrency() = win 0x1e38c0;
    int getTotalCollectedDiamonds() = win 0x1e4190;
    bool hasClaimedListReward(GJLevelList* list) = win 0x1e2c40;
    bool hasCompletedChallenge(GJChallengeItem* item) = win 0x1e2880;
    bool hasCompletedDailyLevel(int dailyID) = win 0x1e2d20;
    bool hasCompletedDemonLevel(GJGameLevel* level) = win inline {
        return m_completedLevels->objectForKey(this->getDemonLevelKey(level)) != nullptr;
    }
    bool hasCompletedGauntletLevel(int id);
    bool hasCompletedLevel(GJGameLevel* level) = win 0x1ddfc0;
    bool hasCompletedMainLevel(int levelID);
    bool hasCompletedMapPack(int id);
    bool hasCompletedOnlineLevel(int id);
    bool hasCompletedStarLevel(GJGameLevel* level) = win 0x1de2e0;
    bool hasPendingUserCoin(char const* key);
    bool hasRewardBeenCollected(GJRewardType type, int id) = win 0x1e1ab0;
    bool hasSecretCoin(char const* key);
    bool hasUserCoin(char const* key);
    void incrementActivePath(int amount) = win inline {
        this->trySelectActivePath();
        if (m_activePath < 30 || m_activePath > 39) return;
        this->incrementStat(GameToolbox::intToString(m_activePath).c_str(), amount);
    }
    void incrementChallenge(GJChallengeType type, int amount) = win 0x1e2100;
    void incrementStat(char const* key) = win inline {
        this->incrementStat(key, 1);
    }
    void incrementStat(char const* key, int amount) = win 0x1d4510;
    bool isGauntletChestUnlocked(int id) = win inline {
        return this->isSpecialChestUnlocked(this->getGauntletRewardKey(id));
    }
    bool isItemEnabled(UnlockType type, int id) = win inline {
        return this->isItemUnlocked(type, id) && m_enabledItems->valueForKey(this->getItemKey(id, (int)type))->boolValue();
    }
    bool isItemUnlocked(UnlockType type, int id) = win 0x1e5860;
    bool isPathChestUnlocked(int path) = win inline {
        return this->isSpecialChestUnlocked(this->getPathRewardKey(path));
    }
    bool isPathUnlocked(StatKey key) = win inline, ios inline {
        return this->isItemUnlocked(UnlockType::GJItem, (int)key - 24);
    }
    bool isSecretChestUnlocked(int id);
    bool isSecretCoin(gd::string key) = win inline, ios inline {
        return key.starts_with("unique_");
    }
    bool isSecretCoinValid(gd::string key) = win 0x1e0100;
    bool isSpecialChestLiteUnlockable(gd::string key) = win inline, ios inline {
        return m_specialChestsLite && m_specialChestsLite->objectForKey(key) != nullptr;
    }
    bool isSpecialChestUnlocked(gd::string key) = win 0x1ea530;
    bool isStoreItemUnlocked(int index);
    int keyCostForSecretChest(int id) = win inline {
        if (id < 1001) return 1;
        if (id < 2001) return 5;
        if (id < 3001) return 10;
        if (id < 4001) return 25;
        if (id < 5001) return 50;
        if (id < 6001) return 100;
        return 1;
    }
    void linkSpecialChestUnlocks(GJRewardItem* item, gd::string key) = win 0x1e9fd0;
    void logCoins();
    void markLevelAsCompletedAndClaimed(GJGameLevel* level) = win 0x1de950;
    void postLoadGameStats();
    void preProcessReward(GJRewardItem* item) = win 0x1e1b10;
    void preSaveGameStats();
    void processChallengeQueue(int position) = win 0x1e2960;
    void processOnlineChests() = win 0x1f3630;
    bool purchaseItem(int index) = win 0x1d42f0;
    void recountSpecialStats() = win 0x1e4490;
    void recountUserCoins(bool force) = win 0x1df400;
    void registerRewardsFromItem(GJRewardItem* item) = win 0x1f1540;
    void removeChallenge(int position) = win inline {
        m_activeChallenges->removeObjectForKey(cocos2d::CCString::createWithFormat("%i", position)->getCString());
    }
    void removeErrorFromSpecialChests() = win 0x1f3820;
    void removeQueuedChallenge(int position) = win inline {
        m_upcomingChallenges->removeObjectForKey(cocos2d::CCString::createWithFormat("%i", position)->getCString());
    }
    void removeQueuedSecondaryChallenge(int position) = win inline {
        m_upcomingChallenges->removeObjectForKey(cocos2d::CCString::createWithFormat("%i", position + 100)->getCString());
    }
    void resetChallengeTimer() = win inline {
        m_challengeTime = 0;
    }
    void resetPreSync() = win inline, ios inline {}
    void resetSpecialChest(gd::string key) = win inline, ios inline {
        m_miscChests->removeObjectForKey(key);
    }
    void resetSpecialStatAchievements() = win 0x1e52f0;
    void resetUserCoins() = win inline, ios inline {
        this->setStat("12", 0);
        m_verifiedUserCoins->removeAllObjects();
        m_pendingUserCoins->removeAllObjects();
    }
    void restorePostSync() = win inline, ios inline {}
    void setAwardedBonusKeys(int keys) {
        m_bonusKey = keys;
    }
    void setStarsForMapPack(int id, int stars) = win 0x1df0a0;
    void setStat(char const* key, int value) = win 0x1d5310;
    void setStatIfHigher(char const* key, int value) = win inline, ios inline {
        if (value > this->getStat(key)) this->setStat(key, value);
    }
    void setupIconCredits() = win 0x1c4150;
    ShopType shopTypeForItemID(int index) = win inline, ios inline {
        if (auto item = this->getStoreItem(index)) {
            return item->m_shopType;
        }
        return ShopType::Normal;
    }
    bool shouldAwardSecretKey() = win inline, ios inline {
        return m_bonusKey.value() < this->getStat("22") / 500.f;
    }
    int starsForMapPack(int id) = win inline {
        return m_completedMappacks->valueForKey(this->getMapPackKey(id))->intValue();
    }
    void storeChallenge(int position, GJChallengeItem* challenge) = win inline {
        m_activeChallenges->setObject(challenge, cocos2d::CCString::createWithFormat("%i", position)->getCString());
    }
    void storeChallengeTime(int remaining) = win inline {
        __timeb64 current;
        _ftime64_s(&current);
        m_challengeTime = ((current.time & 0xfffff) * 1000 + current.millitm) / 1000.0;
    }
    void storeEventChest(int eventID, GJRewardItem* item) = win inline {
        if (item) m_eventChest->setObject(item, this->getDailyLevelKey(eventID));
    }
    void storeOnlineChest(gd::string key, GJRewardItem* item) = win inline {
        if (item) m_allSpecialChests->setObject(item, key);
    }
    void storePendingUserCoin(char const* key) = win inline {
        m_pendingUserCoins->setObject(m_trueString, key);
    }
    void storeQueuedChallenge(int position, GJChallengeItem* challenge) = win 0x1e1da0;
    void storeRewardState(GJRewardType type, int id, int remaining, gd::string str) = win 0x1e1920;
    void storeSecondaryQueuedChallenge(int position, GJChallengeItem* challenge) = win inline {
        m_upcomingChallenges->setObject(challenge, cocos2d::CCString::createWithFormat("%i", position + 100)->getCString());
    }
    void storeSecretCoin(char const* key);
    void storeUserCoin(char const* key);
    void tempClear() = win inline, ios inline {}
    void toggleEnableItem(UnlockType type, int id, bool enabled) = win 0x1e5c10;
    void tryFixPathBug() = win 0x1d4820;
    void trySelectActivePath() = win 0x1d46a0;
    void uncompleteLevel(GJGameLevel* level) = win 0x1debd0;
    GJRewardItem* unlockGauntletChest(int id) = win inline {
        if (auto reward = this->unlockSpecialChest(this->getGauntletRewardKey(id))) {
            this->incrementStat("40");
            return reward;
        }
        return nullptr;
    }
    GJRewardItem* unlockGoldChest(int id) = win inline {
        if (!this->isSecretChestUnlocked(id)) {
            if (auto reward = this->getRewardForSecretChest(id)) {
                auto keys = this->getStat("43");
                if (keys > 0) {
                    this->setStat("43", keys - 1);
                    this->preProcessReward(reward);
                    this->registerRewardsFromItem(reward);
                    m_treasureRoomChests->setObject(reward, cocos2d::CCString::createWithFormat("%i", id)->getCString());
                    return reward;
                }
            }
        }
        return nullptr;
    }
    GJRewardItem* unlockOnlineChest(gd::string key) = win 0x1ea7e0;
    GJRewardItem* unlockPathChest(int id) = win inline {
        return this->unlockSpecialChest(this->getPathRewardKey(id));
    }
    GJRewardItem* unlockSecretChest(int id) = win 0x1ea970;
    GJRewardItem* unlockSpecialChest(gd::string key) = win 0x1ea620;
    void updateActivePath(StatKey key) = win inline {
        m_activePath = key >= StatKey::FirePath && key <= StatKey::SoulPath ? (int)key : 0;
    }
    gd::string usernameForAccountID(int id) = win inline {
        if (auto it = m_usernameForAccountID.find(id); it != m_usernameForAccountID.end()) {
            return it->second;
        }
        return "";
    }
    void verifyPathAchievements() = win 0x1d4f90;
    void verifyUserCoins() = win 0x1dfc40;

    bool m_usePlayerStatsCCDictionary;
    cocos2d::CCString* m_trueString;
    cocos2d::CCDictionary* m_allStoreItems;
    cocos2d::CCDictionary* m_storeItems;
    cocos2d::CCDictionary* m_allTreasureRoomChests;
    cocos2d::CCDictionary* m_allTreasureRoomChestItems;
    cocos2d::CCDictionary* m_allSpecialChests;
    cocos2d::CCDictionary* m_allSpecialChestItems;
    gd::unordered_map<gd::string, gd::string> m_specialRewardDescriptions;
    gd::unordered_map<gd::string, gd::string> m_createSpecialChestItemsMap;
    cocos2d::CCDictionary* m_specialChestsLite;
    cocos2d::CCArray* m_storeItemArray;
    cocos2d::CCDictionary* m_rewardItems;
    cocos2d::CCDictionary* m_dailyChests;
    cocos2d::CCDictionary* m_worldAdvertChests;
    cocos2d::CCDictionary* m_activeChallenges;
    cocos2d::CCDictionary* m_upcomingChallenges;
    double m_challengeTime;
    cocos2d::CCDictionary* m_playerStats;
    gd::unordered_map<int, int> m_playerStatsRandMap;
    gd::unordered_map<int, int> m_playerStatsSeedMap;
    cocos2d::CCDictionary* m_completedLevels;
    cocos2d::CCDictionary* m_verifiedUserCoins;
    cocos2d::CCDictionary* m_pendingUserCoins;
    cocos2d::CCDictionary* m_purchasedItems;
    cocos2d::CCDictionary* m_onlineCurrencyScores;
    cocos2d::CCDictionary* m_mainCurrencyScores;
    cocos2d::CCDictionary* m_gauntletCurrencyScores;
    cocos2d::CCDictionary* m_timelyCurrencyScores;
    cocos2d::CCDictionary* m_onlineStars;
    cocos2d::CCDictionary* m_timelyStars;
    cocos2d::CCDictionary* m_gauntletDiamondScores;
    cocos2d::CCDictionary* m_timelyDiamondScores;
    cocos2d::CCDictionary* m_unusedCurrencyAwardDict;
    cocos2d::CCDictionary* m_challengeDiamonds;
    cocos2d::CCDictionary* m_completedMappacks;
    cocos2d::CCDictionary* m_completedLists;
    cocos2d::CCDictionary* m_weeklyChest;
    cocos2d::CCDictionary* m_eventChest;
    cocos2d::CCDictionary* m_treasureRoomChests;
    geode::SeedValueRSV m_bonusKey;
    cocos2d::CCDictionary* m_miscChests;
    cocos2d::CCDictionary* m_enabledItems;
    cocos2d::CCDictionary* m_wraithChests;
    bool m_skipIncrementChallenge;
    cocos2d::CCDictionary* m_unkDict;
    cocos2d::CCDictionary* m_unlockedItems;
    gd::map<std::pair<int, UnlockType>, int> m_accountIDForIcon;
    gd::map<int, gd::string> m_usernameForAccountID;
    gd::set<std::pair<UnlockType, int>> m_wraithIcons;
    bool m_pathBugFixed;
    bool m_tryFixPathBug;
    int m_activePath;
}

[[link(android)]]
class GameToolbox {
    static void addBackButton(cocos2d::CCLayer* parent, cocos2d::CCMenuItem* menuItem) = win 0x65060;
    static void addRThumbScrollButton(cocos2d::CCLayer* parent) = win 0x65140;
    static void alignItemsHorisontally(cocos2d::CCArray* items, float gap, cocos2d::CCPoint position, bool skipSize) = win 0x64160;
    static void alignItemsVertically(cocos2d::CCArray* items, float gap, cocos2d::CCPoint position) = win inline {
        using cocos2d::CCObject;

        CCObject* obj;
        auto y = -gap;
        CCARRAY_FOREACH(items, obj) {
            auto node = static_cast<cocos2d::CCNode*>(obj);
            y += node->getScaleY() * node->getContentSize().height + gap;
        }

        y = -y / 2.f;
        CCARRAY_FOREACH(items, obj) {
            auto node = static_cast<cocos2d::CCNode*>(obj);
            auto size = node->getContentSize();
            auto scale = node->getScaleY();
            node->setPosition({ 0.f, scale * size.height / 2.f + y });
            node->setPosition(node->getPosition() + position);
            y += scale * size.height + gap;
        }
    }
    static float bounceTime(float time) = win 0x68ae0;
    static cocos2d::ccColor3B colorToSepia(cocos2d::ccColor3B color, float factor) = win inline, ios inline {
        cocos2d::ccColor3B sepia;
        sepia.r = std::min<uint8_t>(255, color.r * 0.393 + color.g * 0.769 + color.b * 0.189);
        sepia.g = std::min<uint8_t>(255, color.r * 0.349 + color.g * 0.686 + color.b * 0.168);
        sepia.b = std::min<uint8_t>(255, color.r * 0.272 + color.g * 0.534 + color.b * 0.131);
        return factor < 1.f ? GameToolbox::multipliedColorValue(color, sepia, factor) : sepia;
    }
    static void contentScaleClipRect(cocos2d::CCRect& rect) = win inline, ios inline {}
    static gd::string createHashString(gd::string const& str, int length) = win inline, ios inline {
        std::string ret;
        if (length > 0) {
            auto strSize = str.size();
            if (length > strSize) ret = str;
            else {
                int increment = (float)strSize / (float)length;
                for (int i = 0; i < length; i += increment) {
                    ret += str[i];
                }
            }
        }
        return ret;
    }
    static CCMenuItemToggler* createToggleButton(gd::string label, cocos2d::SEL_MenuHandler selector, bool state, cocos2d::CCMenu* menu, cocos2d::CCPoint position, cocos2d::CCNode* parent, cocos2d::CCNode* labelParent, cocos2d::CCArray* container) = win inline {
        return GameToolbox::createToggleButton(label, selector, state, menu, position, parent, labelParent, .7f, .5f, 80.f, { 8.f, 0.f }, "bigFont.fnt", false, 0, container);
    }
    static CCMenuItemToggler* createToggleButton(gd::string label, cocos2d::SEL_MenuHandler selector, bool state, cocos2d::CCMenu* menu, cocos2d::CCPoint position, cocos2d::CCNode* parent, cocos2d::CCNode* labelParent, float buttonScale, float maxLabelScale, float maxLabelWidth, cocos2d::CCPoint labelOffset, char const* font, bool labelTop, int labelTag, cocos2d::CCArray* container) = win 0x646c0;
    static bool doWeHaveInternet() = win inline {
        return true;
    }
    static gd::string easeToText(int easingType) = win 0x685c0;
    static uint64_t fast_rand() = win inline, ios inline {
        auto value = GameToolbox::getfast_srand() * 214013 + 2531011;
        GameToolbox::fast_srand(value);
        return value >> 16 & 32767;
    }
    static float fast_rand_0_1() = win inline {
        return GameToolbox::fast_rand() / 32767.f;
    }
    static float fast_rand_minus1_1() = win inline {
        return GameToolbox::fast_rand_0_1() * 2.f - 1.f;
    }
    static void fast_srand(uint64_t seed) = win inline {
        *reinterpret_cast<uint64_t*>(geode::base::get() + 0x6a4e20) = seed;
    }
    static gd::string gen_random(int length) = win 0x66090;
    static cocos2d::CCSequence* getDropActionWDelay(float delay, float duration, float scale, cocos2d::CCNode* target, cocos2d::SEL_CallFunc selector) = win inline, ios inline {
        auto scaleAndFade = cocos2d::CCSpawn::create(
            cocos2d::CCEaseExponentialIn::create(cocos2d::CCScaleTo::create(duration, scale)),
            cocos2d::CCEaseExponentialIn::create(cocos2d::CCFadeIn::create(duration)),
            nullptr
        );
        auto delayTime = cocos2d::CCDelayTime::create(delay);
        if (target) {
            return cocos2d::CCSequence::create(delayTime, scaleAndFade, cocos2d::CCCallFunc::create(target, selector), nullptr);
        }
        else {
            return cocos2d::CCSequence::create(delayTime, scaleAndFade, nullptr);
        }
    }
    static cocos2d::CCSequence* getDropActionWEnd(float delay, float duration, float scale, cocos2d::CCAction* action, float actionDelay) = win inline, ios inline {
        return cocos2d::CCSequence::create(
            GameToolbox::getDropActionWDelay(delay, duration, scale, nullptr, nullptr),
            cocos2d::CCDelayTime::create(actionDelay),
            action,
            nullptr
        );
    }
    static cocos2d::CCActionInterval* getEasedAction(cocos2d::CCActionInterval* action, int easingType, float easingRate) = win inline, ios inline {
        if (easingType == 0) return action;
        if (easingRate <= 0.f) easingRate = 2.f;
        switch (easingType) {
            case 1: return cocos2d::CCEaseInOut::create(action, easingRate);
            case 2: return cocos2d::CCEaseIn::create(action, easingRate);
            case 3: return cocos2d::CCEaseOut::create(action, easingRate);
            case 4: return cocos2d::CCEaseElasticInOut::create(action, easingRate);
            case 5: return cocos2d::CCEaseElasticIn::create(action, easingRate);
            case 6: return cocos2d::CCEaseElasticOut::create(action, easingRate);
            case 7: return cocos2d::CCEaseBounceInOut::create(action);
            case 8: return cocos2d::CCEaseBounceIn::create(action);
            case 9: return cocos2d::CCEaseBounceOut::create(action);
            case 10: return cocos2d::CCEaseExponentialInOut::create(action);
            case 11: return cocos2d::CCEaseExponentialIn::create(action);
            case 12: return cocos2d::CCEaseExponentialOut::create(action);
            case 13: return cocos2d::CCEaseSineInOut::create(action);
            case 14: return cocos2d::CCEaseSineIn::create(action);
            case 15: return cocos2d::CCEaseSineOut::create(action);
            case 16: return cocos2d::CCEaseBackInOut::create(action);
            case 17: return cocos2d::CCEaseBackIn::create(action);
            case 18: return cocos2d::CCEaseBackOut::create(action);
            default: return action;
        }
    }
    static float getEasedValue(float value, int easingType, float easingRate) = win 0x68b90;
    static uint64_t getfast_srand() = win inline, ios inline {
        return *reinterpret_cast<uint64_t*>(geode::base::get() + GEODE_WINDOWS(0x6a4e20) GEODE_IOS(0x85d890));
    }
    static int getInvertedEasing(int easingType) = win inline, ios inline {
        switch (easingType) {
            case 2: return 3;
            case 3: return 2;
            case 5: return 6;
            case 6: return 5;
            case 8: return 9;
            case 9: return 8;
            case 11: return 12;
            case 12: return 11;
            case 14: return 15;
            case 15: return 14;
            case 17: return 18;
            case 18: return 17;
            default: return easingType;
        }
    }
    static cocos2d::CCDictionary* getLargestMergedIntDicts(cocos2d::CCDictionary* dict1, cocos2d::CCDictionary* dict2) = win inline, ios inline {
        if (dict2->count() > dict1->count()) {
            GameToolbox::mergeDictsSaveLargestInt(dict2, dict1);
            return dict2;
        }
        else {
            GameToolbox::mergeDictsSaveLargestInt(dict1, dict2);
            return dict1;
        }
    }
    static cocos2d::ccHSVValue getMultipliedHSV(cocos2d::ccHSVValue const& value, float factor) = win inline {
        cocos2d::ccHSVValue ret;
        ret.h = value.h * factor;
        ret.s = value.absoluteSaturation ? value.s * factor : value.s * factor + (1.f - factor);
        ret.v = value.absoluteBrightness ? value.v * factor : value.v * factor + (1.f - factor);
        ret.absoluteSaturation = value.absoluteSaturation;
        ret.absoluteBrightness = value.absoluteBrightness;
        return ret;
    }
    static cocos2d::CCPoint getRelativeOffset(GameObject* object, cocos2d::CCPoint offset) = win 0x649c0;
    static gd::string getResponse(cocos2d::extension::CCHttpResponse* response) = win 0x64360;
    static gd::string getTimeString(int seconds, bool noSeconds) = win 0x65e70;
    static cocos2d::ccHSVValue hsvFromString(gd::string const& str, char const* delim) = win 0x65530; // on windows, 2nd param is ignored and assumed to be "a"
    static gd::string intToShortString(int value) = win 0x69170;
    static gd::string intToString(int value) = win 0x690b0;
    static bool isIOS() = win inline, ios inline {
        #ifdef GEODE_IS_IOS
        return true;
        #else
        return false;
        #endif
    }
    static bool isRateEasing(int easingType) = win inline {
        return easingType > 0 && easingType < 7;
    }
    static void mergeDictsSaveLargestInt(cocos2d::CCDictionary* toDict, cocos2d::CCDictionary* fromDict) = win 0x64bc0;
    static void mergeDictsSkipConflict(cocos2d::CCDictionary* toDict, cocos2d::CCDictionary* fromDict) = win 0x64e20;
    static gd::string msToTimeString(int milliseconds, int formattingMode) = win 0x69680;
    static cocos2d::ccColor3B multipliedColorValue(cocos2d::ccColor3B minColor, cocos2d::ccColor3B maxColor, float factor) = win inline {
        if (factor < 1.f) {
            if (factor > 0.f) {
                cocos2d::ccColor3B ret;
                ret.r = (maxColor.r - minColor.r) * factor + minColor.r;
                ret.g = (maxColor.g - minColor.g) * factor + minColor.g;
                ret.b = (maxColor.b - minColor.b) * factor + minColor.b;
                return ret;
            }
            else return minColor;
        }
        else return maxColor;
    }
    static void openAppPage() = win inline {
        cocos2d::CCApplication::sharedApplication()->openURL("https://store.steampowered.com/recommended/recommendgame/322170");
    }
    static void openRateURL(gd::string str1, gd::string str2);
    static cocos2d::CCParticleSystemQuad* particleFromString(gd::string const& str, cocos2d::CCParticleSystemQuad* system, bool dontUpdate) = win inline {
        cocos2d::ParticleStruct ret;
        GameToolbox::particleStringToStruct(str, ret);
        return GameToolbox::particleFromStruct(ret, system, dontUpdate);
    }
    static cocos2d::CCParticleSystemQuad* particleFromStruct(cocos2d::ParticleStruct const& particleStruct, cocos2d::CCParticleSystemQuad* system, bool dontUpdate) = win 0x68050;
    static void particleStringToStruct(gd::string const& str, cocos2d::ParticleStruct& particleStruct) = win 0x67590;
    static gd::string pointsToString(int points) = win 0x697b0;
    static void postClipVisit() = win inline {
        glDisable(GL_SCISSOR_TEST);
    }
    static void preVisitWithClippingRect(cocos2d::CCNode* node, cocos2d::CCRect rect) = win 0x64610;
    static void preVisitWithClipRect(cocos2d::CCRect rect) = win inline {
        glEnable(GL_SCISSOR_TEST);
        GameToolbox::contentScaleClipRect(rect);
        cocos2d::CCDirector::sharedDirector()->getOpenGLView()->setScissorInPoints(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);
    }
    static gd::string saveParticleToString(cocos2d::CCParticleSystemQuad* system) = win 0x66320;
    static bool saveStringToFile(gd::string const& path, gd::string const& content) = win inline, ios inline {
        #ifdef GEODE_IS_WINDOWS
        FILE* file = nullptr;
        fopen_s(&file, (cocos2d::CCFileUtils::sharedFileUtils()->getWritablePath() + path).c_str(), "w");
        #else
        auto file = fopen((cocos2d::CCFileUtils::sharedFileUtils()->getWritablePath() + path).c_str(), "w");
        #endif
        if (!file) return false;
        auto result = fwrite(content.c_str(), 1, content.size(), file);
        fclose(file);
        return result == content.size();
    }
    static gd::string stringFromHSV(cocos2d::ccHSVValue value, char const* separator) = win 0x65740;
    static cocos2d::CCDictionary* stringSetupToDict(gd::string const& str, char const* separator) = win 0x65c80;
    static void stringSetupToMap(gd::string const& str, char const* separator, gd::map<gd::string, gd::string>& setup) = win 0x658e0;
    static cocos2d::ccColor3B strongColor(cocos2d::ccColor3B color) = win inline {
        if (color.r != 255 && color.b != 255 && color.g != 255) {
            auto factor = std::min(1.5f, 255.f / std::max({ color.r, color.g, color.b }));
            color.r *= factor;
            color.g *= factor;
            color.b *= factor;
        }
        return color;
    }
    static gd::string timestampToHumanReadable(time_t timestamp) = win 0x69310;
    static cocos2d::ccColor3B transformColor(cocos2d::ccColor3B const& color, cocos2d::ccHSVValue hsv) = win 0x652e0;
    static cocos2d::ccColor3B transformColor(cocos2d::ccColor3B const& color, float h, float s, float v) = win inline {
        return GameToolbox::transformColor(color, { h, s, v, true, true });
    }
}

[[link(android)]]
class GauntletLayer : cocos2d::CCLayer, LevelManagerDelegate {
    GauntletLayer() {
        m_levels = nullptr;
        m_loadingCircle = nullptr;
        m_backgroundSprite = nullptr;
        m_unkPtr = nullptr;
        m_activeItemButton = nullptr;
        m_activeObjects = nullptr;
        m_tryAgainText = nullptr;
    }
    ~GauntletLayer() = win inline {
        auto glm = GameLevelManager::sharedState();
        if (glm->m_levelManagerDelegate == this) glm->m_levelManagerDelegate = nullptr;
        CC_SAFE_RELEASE(m_activeObjects);
    }

    static GauntletLayer* create(GauntletType type) = win inline {
        auto ret = new GauntletLayer();
        if (ret->init(type)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static cocos2d::CCScene* scene(GauntletType type) = win 0x1f5e30;

    virtual void keyBackClicked();
    virtual void loadLevelsFinished(cocos2d::CCArray* levels, char const* key, int type) = win 0x1f6970;
    virtual void loadLevelsFailed(char const* key, int type) = win 0x1f6b80;

    bool init(GauntletType type) = win 0x1f6180;
    void onBack(cocos2d::CCObject* sender);
    void onLevel(cocos2d::CCObject* sender) = win 0x1f7dd0;
    void setupGauntlet(cocos2d::CCArray* levels);
    void unlockActiveItem() = win 0x1f7e40;

    cocos2d::CCArray* m_levels;
    LoadingCircle* m_loadingCircle;
    GauntletType m_gauntletType;
    cocos2d::CCSprite* m_backgroundSprite;
    void* m_unkPtr;
    CCMenuItemSpriteExtra* m_activeItemButton;
    cocos2d::CCArray* m_activeObjects;
    TextArea* m_tryAgainText;
}

[[link(android)]]
class GauntletNode : cocos2d::CCNode {
    // virtual ~GauntletNode();
    GauntletNode() {
        m_gauntletInfoNode = nullptr;
        m_rewardNode = nullptr;
    }

    static GauntletNode* create(GJMapPack* gauntlet) = win inline {
        auto ret = new GauntletNode();
        if (ret->init(gauntlet)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static gd::string frameForType(GauntletType type);
    static gd::string nameForType(GauntletType type);

    bool init(GJMapPack* gauntlet);
    void onClaimReward() = win 0x1fde00;

    cocos2d::CCNode* m_gauntletInfoNode;
    cocos2d::CCNode* m_rewardNode;
}

[[link(android)]]
class GauntletSelectLayer : cocos2d::CCLayer, BoomScrollLayerDelegate, LevelManagerDelegate {
    GauntletSelectLayer() {
        m_backgroundSprite = nullptr;
        m_scrollLayer = nullptr;
        m_refreshButton = nullptr;
        m_exiting = false;
        m_playing = false;
        m_tryAgainText = nullptr;
        m_loadingCircle = nullptr;
        m_gauntlets = nullptr;
        m_playBlocked = false;
    }
    ~GauntletSelectLayer() = win inline {
        auto glm = GameLevelManager::sharedState();
        if (glm->m_levelManagerDelegate == this) glm->m_levelManagerDelegate = nullptr;
        CC_SAFE_RELEASE(m_gauntlets);
    }

    static GauntletSelectLayer* create(int unused) = win inline {
        auto ret = new GauntletSelectLayer();
        if (ret->init(unused)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static cocos2d::CCScene* scene(int unused);

    virtual void onExit() = win 0x1fb070;
    virtual void keyBackClicked();
    virtual void scrollLayerWillScrollToPage(BoomScrollLayer* layer, int page) = win 0x1fa6a0;
    virtual void scrollLayerScrolledToPage(BoomScrollLayer* layer, int page) = win 0x1fa6a0;
    virtual void loadLevelsFinished(cocos2d::CCArray* gauntlets, char const* key, int type) = win 0x1f9a30;
    virtual void loadLevelsFailed(char const* key, int type) = win 0x1f9bf0;

    void goToPage(int page, bool instant) = win 0x1fa530;
    bool init(int unused) = win 0x1f8c70;
    void onBack(cocos2d::CCObject* sender);
    void onInfo(cocos2d::CCObject* sender) = win 0x1f97d0;
    void onNext(cocos2d::CCObject* sender) = win 0x1fa4f0;
    void onPlay(cocos2d::CCObject* sender) = win 0x1fa7b0;
    void onPrev(cocos2d::CCObject* sender) = win 0x1fa510;
    void onRefresh(cocos2d::CCObject* sender) = win 0x1f9910;
    void setupGauntlets() = win 0x1f9d70;
    void unblockPlay();
    void updateArrows() = win inline, ios inline {
        m_leftButton->setVisible(m_scrollLayer != nullptr);
        m_rightButton->setVisible(m_scrollLayer != nullptr);
    }

    cocos2d::CCSprite* m_backgroundSprite;
    BoomScrollLayer* m_scrollLayer;
    CCMenuItemSpriteExtra* m_leftButton;
    CCMenuItemSpriteExtra* m_rightButton;
    CCMenuItemSpriteExtra* m_refreshButton;
    bool m_exiting;
    bool m_playing;
    TextArea* m_tryAgainText;
    LoadingCircle* m_loadingCircle;
    cocos2d::CCDictionary* m_gauntlets;
    bool m_playBlocked;
}

[[link(android)]]
class GauntletSprite : cocos2d::CCNode {
    // virtual ~GauntletSprite();
    GauntletSprite() {}

    static GauntletSprite* create(GauntletType type, bool locked) = win inline {
        auto ret = new GauntletSprite();
        if (ret->init(type, locked)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    void addLockedSprite() = win 0xc9650;
    void addNormalSprite() = win inline {
        auto normalSprite = cocos2d::CCSprite::createWithSpriteFrameName(GauntletNode::frameForType(m_gauntletType).c_str());
        this->addChild(normalSprite);
        normalSprite->setPosition(this->getContentSize() / 2);
    }
    cocos2d::ccColor3B colorForType(GauntletType type) = win inline, ios inline {
        switch (type) {
            case GauntletType::Fire: return { 255, 200, 200 };
            case GauntletType::Lava: return { 200, 200, 200 };
            case GauntletType::Bonus: return { 225, 225, 100 };
            case GauntletType::Monster: return { 200, 200, 200 };
            case GauntletType::Doom: return { 200, 200, 200 };
            default: return { 225, 225, 225 };
        }
    }
    bool init(GauntletType type, bool locked) = win inline {
        if (!CCNode::init()) return false;

        m_gauntletType = type;
        this->setContentSize({ 60.0f, 60.0f });
        this->toggleLockedSprite(locked);

        return true;
    }
    float luminanceForType(GauntletType type) = win inline {
        switch (type) {
            case GauntletType::Fire: return 1.1f;
            case GauntletType::Ice: return 0.9f;
            case GauntletType::Shadow: return 1.6f;
            case GauntletType::Lava: return 1.3f;
            case GauntletType::Bonus: return 0.9f;
            case GauntletType::Chaos: return 1.5f;
            case GauntletType::Spike: return 0.8f;
            default: return 1.0f;
        }
    }
    void toggleLockedSprite(bool locked) = win 0x1f8830;

    GauntletType m_gauntletType;
}

[[link(android)]]
class GhostTrailEffect : cocos2d::CCNode {
    // virtual ~GhostTrailEffect();
    //GhostTrailEffect() = ios 0x305d20;

    static GhostTrailEffect* create() = win 0x6a020;

    virtual bool init() = win 0x6a100;
    virtual void draw() = win inline {}

    void doBlendAdditive() = win inline {
        m_blendFunc.src = GL_SRC_ALPHA;
        m_blendFunc.dst = GL_ONE;
    }
    void runWithTarget(cocos2d::CCSprite* sprite, float snapshotInterval, float fadeInterval, float duration, float ghostScale, bool scaleTwice) = win inline {
        m_iconSprite = sprite;
        m_snapshotInterval = snapshotInterval;
        m_fadeInterval = fadeInterval;
        if (ghostScale <= .1f) ghostScale = .1f;
        m_scaleTwice = scaleTwice;
        m_ghostScale = ghostScale;
        this->schedule(schedule_selector(GhostTrailEffect::trailSnapshot), snapshotInterval);
        if (duration > 0.f) this->runAction(cocos2d::CCSequence::create(
            cocos2d::CCDelayTime::create(duration),
            cocos2d::CCCallFunc::create(this, callfunc_selector(GhostTrailEffect::stopTrail)),
            nullptr
        ));
    }
    void stopTrail() = win inline {
        this->unscheduleAllSelectors();
        this->stopAllActions();
        this->removeMeAndCleanup();
    }
    void trailSnapshot(float dt) = win 0x6a160;

    float m_snapshotInterval;
    float m_fadeInterval;
    float m_ghostScale;
    bool m_scaleTwice;
    float m_playerScale;
    cocos2d::ccBlendFunc m_blendFunc;
    cocos2d::CCSprite* m_iconSprite;
    PlayerObject* m_playerObject;
    cocos2d::CCLayer* m_objectLayer;
    float m_opacity;
    void* m_delegate;
    cocos2d::ccColor3B m_color;
    cocos2d::CCPoint m_position;
    bool m_unk194;
}

[[link(android)]]
class GJAccountBackupDelegate {
    virtual void backupAccountFinished() {}
    virtual void backupAccountFailed(BackupAccountError errorType, int response) {}
}

[[link(android)]]
class GJAccountDelegate {
    virtual void accountStatusChanged() {}
}

[[link(android)]]
class GJAccountLoginDelegate {
    virtual void loginAccountFinished(int accountID, int userID) {}
    virtual void loginAccountFailed(AccountError errorType) {}
}

[[link(android)]]
class GJAccountManager : cocos2d::CCNode {
    // virtual ~GJAccountManager();
    // GJAccountManager();

    static GJAccountManager* get() {
        return GJAccountManager::sharedState();
    }
    static GJAccountManager* sharedState() = win 0x200010;

    virtual bool init() = win 0x2005d0;

    void addDLToActive(char const* tag) = win inline, ios inline {
        this->addDLToActive(tag, cocos2d::CCNode::create());
    }
    void addDLToActive(char const* tag, cocos2d::CCObject* object) = win inline {
        m_activeDownloads->setObject(object, tag);
    }
    bool backupAccount(gd::string url) = win 0x2019b0;
    void dataLoaded(DS_Dictionary* dict) = win inline {
        m_username = dict->getStringForKey("GJA_001");
        m_accountID = dict->getIntegerForKey("GJA_003");
        m_password = dict->getStringForKey("GJA_002");
        m_GJP2 = dict->getStringForKey("GJA_005");
        if (!m_password.empty() && m_GJP2.empty()) {
            m_GJP2 = this->getShaPassword(m_password);
        }
    }
    void encodeDataTo(DS_Dictionary* dict) = win inline {
        dict->setStringForKey("GJA_001", m_username);
        dict->setIntegerForKey("GJA_003", m_accountID);
        dict->setStringForKey("GJA_005", m_GJP2);
    }
    void firstSetup() = win inline {}
    bool getAccountBackupURL() = win 0x201390;
    bool getAccountSyncURL() = win 0x2022f0;
    cocos2d::CCObject* getDLObject(char const* tag) = win inline {
        return m_activeDownloads->objectForKey(tag);
    }
    gd::string getShaPassword(gd::string password) = win 0x2040a0;
    void handleIt(bool success, gd::string response, gd::string tag, GJHttpType type) = win 0x200380;
    void handleItDelayed(bool success, gd::string response, gd::string tag, GJHttpType type) = win inline, ios inline {
        auto result = GJHttpResult::create(true, response, tag, type);
        result->retain();
        m_pActionManager->addAction(cocos2d::CCSequence::create(
            cocos2d::CCDelayTime::create(.1f),
            cocos2d::CCCallFuncND::create(this, callfuncND_selector(GJMultiplayerManager::handleItND), result),
            nullptr
        ), this, false);
    }
    void handleItND(cocos2d::CCNode* node, void* data) = win inline, ios inline {
        auto result = static_cast<GJHttpResult*>(data);
        this->handleIt(result->m_success, result->m_response, result->m_requestTag, result->m_httpType);
        result->release();
    }
    bool isDLActive(char const* tag) = win inline, ios inline {
        return this->getDLObject(tag) != nullptr;
    }
    void linkToAccount(gd::string username, gd::string gjp2, int accountID, int userID) = win 0x2038e0;
    void loginAccount(gd::string username, gd::string gjp2) = win 0x200b40;
    void onBackupAccountCompleted(gd::string response, gd::string tag) = win 0x201ee0;
    void onGetAccountBackupURLCompleted(gd::string response, gd::string tag);
    void onGetAccountSyncURLCompleted(gd::string response, gd::string tag);
    void onLoginAccountCompleted(gd::string response, gd::string tag) = win 0x200fa0;
    void onProcessHttpRequestCompleted(cocos2d::extension::CCHttpClient* client, cocos2d::extension::CCHttpResponse* response);
    void onRegisterAccountCompleted(gd::string response, gd::string tag) = win 0x2009b0;
    void onSyncAccountCompleted(gd::string response, gd::string tag) = win 0x202b70;
    void onUpdateAccountSettingsCompleted(gd::string response, gd::string tag) = win 0x203f40;
    void ProcessHttpRequest(gd::string url, gd::string params, gd::string tag, GJHttpType type) = win 0x200130;
    void registerAccount(gd::string response, gd::string tag, gd::string data) = win 0x2006e0;
    void removeDLFromActive(char const* tag) = win inline {
        m_activeDownloads->removeObjectForKey(tag);
    }
    bool syncAccount(gd::string url) = win 0x202900;
    void unlinkFromAccount() = win inline {
        m_GJP2 = "";
        m_password = "";
        m_username = "";
        m_accountID = 0;
        auto gameManager = GameManager::sharedState();
        gameManager->m_shouldLoadUnlockValueKeeper = true;
        gameManager->firstLoad();
        gameManager->m_shouldLoadUnlockValueKeeper = false;
        LocalLevelManager::sharedState()->firstLoad();
        if (m_accountDelegate) m_accountDelegate->accountStatusChanged();
        gameManager->accountStatusChanged();
    }
    void updateAccountSettings(int messageStatus, int friendRequestStatus, int commentStatus, gd::string youtube, gd::string twitter, gd::string twitch);

    cocos2d::CCDictionary* m_activeDownloads;
    gd::string m_username;
    int m_accountID;
    int m_unkInt1; // likely VRS for account ID but unimplemented
    int m_unkInt2; // likely VRS for account ID but unimplemented
    gd::string m_GJP2;
    GJAccountRegisterDelegate* m_accountRegisterDelegate;
    GJAccountLoginDelegate* m_accountLoginDelegate;
    GJAccountDelegate* m_accountDelegate;
    GJAccountBackupDelegate* m_backupDelegate;
    GJAccountSyncDelegate* m_syncDelegate;
    GJAccountSettingsDelegate* m_accountSettingsDelegate;
    int m_gameManagerSize;
    int m_localLevelsSize;
    gd::string m_password;
}

[[link(android)]]
class GJAccountRegisterDelegate {
    virtual void registerAccountFinished() {}
    virtual void registerAccountFailed(AccountError errorType) {}
}

[[link(android)]]
class GJAccountSettingsDelegate {
    virtual void updateSettingsFinished() {}
    virtual void updateSettingsFailed() {}
}

[[link(android)]]
class GJAccountSettingsLayer : FLAlertLayer, TextInputDelegate {
    GJAccountSettingsLayer() {
        m_accountID = 0;
        m_messageStatus = 0;
        m_friendStatus = 0;
        m_commentHistoryStatus = 0;
        m_youtubeInput = nullptr;
        m_twitterInput = nullptr;
        m_twitchInput = nullptr;
        m_messageSettings = nullptr;
        m_friendRequestSettings = nullptr;
        m_commentSettings = nullptr;
    }
    ~GJAccountSettingsLayer() = win inline {
        CC_SAFE_RELEASE(m_messageSettings);
        CC_SAFE_RELEASE(m_friendRequestSettings);
        CC_SAFE_RELEASE(m_commentSettings);
    }

    static GJAccountSettingsLayer* create(int accountID) = win inline {
        auto ret = new GJAccountSettingsLayer();
        if (ret->init(accountID)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyBackClicked();
    virtual void textInputShouldOffset(CCTextInputNode* node, float yOffset) = win 0x7b620;
    virtual void textInputReturn(CCTextInputNode* node) = win 0x7b680;

    CCMenuItemToggler* createToggleButton(gd::string label, cocos2d::SEL_MenuHandler selector, bool toggled, cocos2d::CCMenu* menu, cocos2d::CCPoint position, float width, float scale);
    bool init(int accountID) = win 0x2946c0;
    void onClose(cocos2d::CCObject* sender);
    void onCommentSetting(cocos2d::CCObject* sender);
    void onFriendRequests(cocos2d::CCObject* sender);
    void onMessageSetting(cocos2d::CCObject* sender);
    void onUpdate(cocos2d::CCObject* sender);
    void updateScoreValues() = win inline {
        if (auto score = GameLevelManager::sharedState()->userInfoForAccountID(m_accountID)) {
            score->m_messageState = m_messageStatus;
            score->m_friendStatus = m_friendStatus;
            score->m_commentHistoryStatus = m_commentHistoryStatus;
            score->m_youtubeURL = m_youtubeURL;
            score->m_twitterURL = m_twitterURL;
            score->m_twitchURL = m_twitchURL;
        }
    }

    int m_accountID;
    int m_messageStatus;
    int m_friendStatus;
    int m_commentHistoryStatus;
    gd::string m_youtubeURL;
    gd::string m_twitterURL;
    gd::string m_twitchURL;
    CCTextInputNode* m_youtubeInput;
    CCTextInputNode* m_twitterInput;
    CCTextInputNode* m_twitchInput;
    cocos2d::CCArray* m_messageSettings;
    cocos2d::CCArray* m_friendRequestSettings;
    cocos2d::CCArray* m_commentSettings;
}

[[link(android)]]
class GJAccountSyncDelegate {
    virtual void syncAccountFinished() {}
    virtual void syncAccountFailed(BackupAccountError errorType, int response) {}
}

[[link(android)]]
class GJActionManager : cocos2d::CCNode {
    GJActionManager() {
        m_internalActions = nullptr;
    }
    ~GJActionManager() = win inline {
        CC_SAFE_RELEASE(m_internalActions);
    }

    static GJActionManager* create() = win inline {
        auto ret = new GJActionManager();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x2005d0;

    cocos2d::CCAction* getInternalAction(int id) = win inline, ios inline {
        return static_cast<cocos2d::CCAction*>(m_internalActions->objectForKey(id));
    }
    void runInternalAction(cocos2d::CCAction* action, cocos2d::CCNode* target) = win inline {
        m_internalActions->setObject(action, action->getTag());
        action->startWithTarget(target);
    }
    void stopAllInternalActions() = win inline {
        this->updateInternalActions(0.f, true);
    }
    void stopInternalAction(int id) = win inline {
        if (auto action = static_cast<cocos2d::CCAction*>(m_internalActions->objectForKey(id))) {
            action->stop();
            m_internalActions->removeObjectForKey(id);
        }
    }
    void updateInternalActions(float dt, bool remove) = win inline {
        auto keys = m_internalActions->allKeys();
        CCObject* obj;
        CCARRAY_FOREACH(keys, obj) {
            auto key = static_cast<cocos2d::CCInteger*>(obj)->getValue();
            auto action = static_cast<cocos2d::CCAction*>(m_internalActions->objectForKey(key));
            if (action->isDone() || remove) {
                action->stop();
                m_internalActions->removeObjectForKey(key);
            }
            else {
                action->step(dt);
            }
        }
    }

    cocos2d::CCDictionary* m_internalActions;
}

[[link(android)]]
class GJAssetDownloadAction {
    int m_id;
    GJAssetType m_assetType;
    int m_status;
}

[[link(android), depends(GJGameState), depends(PlayerButtonCommand)]]
class GJBaseGameLayer : cocos2d::CCLayer, TriggerEffectDelegate {
    GJBaseGameLayer() = win 0x2cfd50;
    ~GJBaseGameLayer() = win 0x2057e0;

    static float convertToClosestDirection(float angle, float bound) = win 0x22e8e0;
    static gd::string gameEventToString(GJGameEvent event) = win 0x232560;
    // GJBaseGameLayer() = ios 0x1256b4;
    static GJBaseGameLayer* get() {
        return GameManager::get()->m_gameLayer;
    }

    virtual void update(float dt);
    virtual bool init() = win 0x206f70;
    virtual void visit() = win 0x246cf0;
    virtual void postUpdate(float dt) {}
    virtual void checkForEnd() {}
    virtual void testTime() {}
    virtual void updateVerifyDamage() {}
    virtual void updateAttemptTime(float attemptTime) {}
    virtual void updateVisibility(float dt) {}
    virtual void playerTookDamage(PlayerObject* player) {}
    virtual float opacityForObject(GameObject* object) = win 0x237270;
    virtual void addToSpeedObjects(EffectGameObject* object) {}
    virtual void objectsCollided(int blockAID, int blockBID) = win 0x2191a0;
    virtual void updateColor(cocos2d::ccColor3B& color, float fadeTime, int colorID, bool blending, float opacity, cocos2d::ccHSVValue& copyHSV, int colorIDToCopy, bool copyOpacity, EffectGameObject* callerObject, int unk1, int unk2) = win 0x2239a0;
    virtual void toggleGroupTriggered(int group, bool activate, gd::vector<int> const& remapKeys, int triggerID, int controlID) = win 0x223b80;
    virtual void spawnGroup(int group, bool ordered, double delay, gd::vector<int> const& remapKeys, int triggerID, int controlID) = win 0x21abb0;
    virtual void spawnObject(GameObject* object, double delay, gd::vector<int> const& remapKeys) = win 0x21b060;
    virtual void activateEndTrigger(int targetID, bool reverse, bool lockPlayerY) {}
    virtual void activatePlatformerEndTrigger(EndTriggerGameObject* object, gd::vector<int> const& remapKeys) {}
    virtual void toggleGlitter(bool visible) {}
    virtual void destroyPlayer(PlayerObject* player, GameObject* object) {}
    virtual void updateDebugDraw() = win 0x210840;
    virtual void addToSection(GameObject* object) = win 0x226530;
    virtual void addToGroup(GameObject* object, int groupID, bool triggerGroup) = win 0x224000;
    virtual void removeFromGroup(GameObject* object, int groupID) = win 0x224180;
    virtual void updateObjectSection(GameObject* object) = win 0x227f80;
    virtual void updateDisabledObjectsLastPos(cocos2d::CCArray* objects) {}
    virtual void toggleGroundVisibility(bool visible) = win inline {}
    virtual void toggleMGVisibility(bool visible) = win inline {}
    virtual void toggleHideAttempts(bool hide) = win inline {}
    virtual float timeForPos(cocos2d::CCPoint position, int order, int channel, bool songTriggers, int id) { return 0.f; }
    virtual cocos2d::CCPoint posForTime(float time) { return { 0.f, 0.f }; }
    virtual void resetSPTriggered() {}
    virtual void updateScreenRotation(float rotation, bool add, bool convert, float duration, int easingType, float easingRate, int uniqueID, int controlID) = win 0x235cc0;
    virtual void reverseDirection(EffectGameObject* object) = win 0x218190;
    virtual void rotateGameplay(RotateGameplayGameObject* object) = win 0x2181f0;
    virtual void didRotateGameplay() {}
    virtual void updateTimeWarp(float timeWarp) = win 0x235f90;
    virtual void updateTimeWarp(GameObject* object, float timeWarp);
    virtual void applyTimeWarp(float timeWarp) = win 0x235fe0;
    virtual void playGravityEffect(bool flip) {}
    virtual void manualUpdateObjectColors(GameObject* object) {}
    virtual cocos2d::CCParticleSystemQuad* createCustomParticle(gd::string const& key, cocos2d::ParticleStruct const& particleStruct, int minimum, bool dontAdd) = win 0x240b90;
    virtual cocos2d::CCParticleSystemQuad* claimCustomParticle(gd::string const& key, cocos2d::ParticleStruct const& particleStruct, int zLayer, int zOrder, int uiObject, bool dontAdd) = win 0x240e90;
    virtual void unclaimCustomParticle(gd::string const& key, cocos2d::CCParticleSystemQuad* particle) = win 0x241090;
    virtual void activatedAudioTrigger(SFXTriggerGameObject* object) = win 0x242c40;
    virtual void checkpointActivated(CheckpointGameObject* object) = win 0x2468d0;
    virtual void flipArt(bool flip) = win inline {}
    virtual void addKeyframe(KeyframeGameObject* object) = win 0x2339c0;
    virtual void updateTimeLabel(int seconds, int centiseconds, bool decimals) {}
    virtual void checkSnapshot() {}
    virtual void toggleProgressbar() {}
    virtual void toggleInfoLabel() {}
    virtual void removeAllCheckpoints() {}
    virtual void toggleMusicInPractice() {}

    void activateCustomRing(RingObject* object) = win inline {
        if (object->m_isSpawnOnly) this->spawnGroup(object->m_targetGroupID, false, 0.0, {}, object->m_uniqueID, object->m_controlID);
        else this->toggleGroupTriggered(object->m_targetGroupID, object->m_activateGroup, {}, object->m_uniqueID, object->m_controlID);
    }
    void activatedAudioTrigger(SFXTriggerGameObject* object, float levelTime) = win 0x242c60;
    void activateEventTrigger(EventLinkTrigger* object, gd::vector<int> const& remapKeys) = win 0x231f50;
    void activateItemCompareTrigger(ItemTriggerGameObject* object, gd::vector<int> const& remapKeys) = win 0x234470;
    void activateItemEditTrigger(ItemTriggerGameObject* object) = win 0x234090;
    void activateObjectControlTrigger(ObjectControlGameObject* object) = win inline {}
    void activatePersistentItemTrigger(ItemTriggerGameObject* object) = win 0x234880;
    void activatePlayerControlTrigger(PlayerControlGameObject* object) = win 0x217510;
    void activateResetTrigger(EffectGameObject* object) = win inline {
        auto group = this->getGroup(object->m_targetGroupID);
        if (group && group->count() != 0) {
            cocos2d::CCObject* obj;
            CCARRAY_FOREACH(group, obj) {
                auto gameObject = static_cast<GameObject*>(obj);
                if (gameObject->m_objectID == 2063) {
                    m_effectManager->removeTriggeredID(gameObject->m_uniqueID, m_player1->m_uniqueID);
                    m_effectManager->removeTriggeredID(gameObject->m_uniqueID, m_player2->m_uniqueID);
                    gameObject->restoreObject();
                }
                else if (gameObject->getType() == GameObjectType::Collectible || gameObject->getType() == GameObjectType::Breakable) {
                    m_effectManager->removeTriggeredID(gameObject->m_uniqueID, 0);
                    gameObject->restoreObject();
                }
            }
        }
    }
    void activateSFXEditTrigger(SFXTriggerGameObject* object) = win 0x241c60;
    void activateSFXTrigger(SFXTriggerGameObject* object) = win 0x241a60;
    void activateSongEditTrigger(SongTriggerGameObject* object) = win 0x241750;
    void activateSongTrigger(SongTriggerGameObject* object) = win 0x2413d0;
    void activateTimerTrigger(TimerTriggerGameObject* object, gd::vector<int> const& remapKeys) = win 0x234ca0;
    void addAreaEffect(EnterEffectObject* object, gd::vector<EnterEffectInstance>* instances, GJAreaActionType type) = win 0x2274b0;
    void addCustomEnterEffect(EnterEffectObject* object, bool enter) = win 0x20e440;
    bool addGuideArt(GameObject* object) = win 0x245ce0;
    void addObjectCounter(LabelGameObject* object) = win inline {
        auto id = object->m_itemID;
        if (object->m_shownSpecial < 0) id = object->m_shownSpecial;
        auto& objects = object->m_isTimeCounter ? m_timeLabelObjects[id] : m_labelObjects[id];
        objects.push_back(object);
    }
    void addPickupTrigger(CountTriggerGameObject* object) = win inline {
        auto itemID = object->m_itemID;
        if (object->m_pickupTriggerMode == 1) {
            m_effectManager->updateCountForItem(itemID, m_effectManager->countForItem(itemID) * object->m_pickupTriggerMultiplier);
        }
        else if (object->m_pickupTriggerMode == 2) {
            if (object->m_pickupTriggerMultiplier != 0.f) {
                m_effectManager->updateCountForItem(itemID, m_effectManager->countForItem(itemID) / object->m_pickupTriggerMultiplier);
            }
        }
        else if (object->m_isOverride) {
            m_effectManager->updateCountForItem(itemID, object->m_pickupCount);
        }
        else {
            m_effectManager->addCountToItem(itemID, object->m_pickupCount);
        }
        this->updateCounters(itemID, m_effectManager->countForItem(itemID));
    }
    void addPoints(int points) = win inline {
        m_gameState.m_unkBool32 = true;
        m_gameState.m_points += points;
    }
    void addProximityVolumeEffect(int channelID, int targetType, SFXTriggerGameObject* object) = win 0x242240;
    void addRemapTargets(gd::set<int>& targets) = win 0x20dc10;
    void addToGroupParents(GameObject* object) = win inline {
        if (object->m_hasGroupParentsString) {
            if (auto groupIDs = static_cast<cocos2d::CCArray*>(m_removedParentGroupIDs->objectForKey(object->m_uniqueID))) {
                object->m_hasGroupParentsString = false;
                for (int i = 0; i < groupIDs->count(); i++) {
                    auto groupID = static_cast<cocos2d::CCInteger*>(groupIDs->objectAtIndex(i))->getValue();
                    if (m_parentGroupsDict->objectForKey(groupID)) {
                        this->setGroupParent(object, groupID);
                    }
                }
                m_removedParentGroupIDs->removeObjectForKey(object->m_uniqueID);
            }
        }
    }
    void addToGroups(GameObject* object, bool duplicateTrigger) = win 0x223f70;
    void addToObjectsToShow(GameObject* object) {
        if (m_activeObjectsCount < m_activeObjectsIndex) {
            m_activeObjects[m_activeObjectsIndex] = object;
        }
        else {
            m_activeObjects.push_back(object);
            m_activeObjectsIndex++;
        }
        m_activeObjectsCount++;
    }
    void addUIObject(GameObject* object) = win 0x225f80;
    void animateInDualGroundNew(GameObject* object, float height, bool instant, float duration) = win 0x2133b0;
    void animateInGroundNew(bool unk1, float unk2, bool unk3) = win inline, ios inline {}
    void animateOutGroundNew(bool instant) = win inline {
        m_gameState.m_unkBool7 = false;
        if (m_gameState.m_unkBool1) {
            this->resetStaticCamera(false, true);
        }
        m_gameState.tweenValue(m_gameState.m_unkFloat9, 0.f, 25, m_gameState.m_isDualMode ? .32f : .4f, 1, 1.5f, -1, -1);
    }
    void animatePortalY(float fromY, float toY, float duration, float easingRate) = win inline, ios inline {
        m_gameState.m_portalY = fromY;
        if (fromY != toY) {
            m_gameState.tweenValue(fromY, toY, 9, duration, 1, easingRate, -1, -1);
            if (m_gameState.m_cameraZoom != m_gameState.m_targetCameraZoom) {
                m_gameState.m_unkBool6 = true;
            }
        }
    }
    void applyLevelSettings(GameObject* object) = win inline {
        object->m_canRotateFree = m_allowStaticRotate || object->canRotateFree();
        if (m_fixNegativeScale != object->m_isMirroredByScale) object->m_isObjectRectDirty = true;
        object->m_isMirroredByScale = m_fixNegativeScale;
    }
    void applyRemap(EffectGameObject* object, gd::vector<int> const& remapKeys, gd::unordered_map<int, int>& remap) = win 0x21b1f0;
    void applySFXEditTrigger(int channelID, int targetType, SFXTriggerGameObject* object) = win 0x241f40;
    void applyShake(cocos2d::CCPoint& point) = win inline {
        if (m_gameState.m_unkUint64_1 < 0.0 || m_gameState.m_unkUint16 <= 0.f && m_gameState.m_unkUint16 < m_gameState.m_totalTime - m_gameState.m_unkUint64_1) {
            m_gameState.m_unkUint64_1 = m_gameState.m_totalTime;
            auto xFactor = 0.f;
            auto yFactor = 0.f;
            if (m_staticCameraShake) {
                xFactor = ((float)rand() / (float)RAND_MAX) > .5f ? 1.f : -1.f;
                yFactor = ((float)rand() / (float)RAND_MAX) > .5f ? 1.f : -1.f;
            }
            else {
                xFactor = ((float)rand() / (float)RAND_MAX) * 2.f - 1.f;
                yFactor = ((float)rand() / (float)RAND_MAX) * 2.f - 1.f;
            }
            m_gameState.m_unkPoint34.x = xFactor * m_gameState.m_unkUint15;
            m_gameState.m_unkPoint34.y = yFactor * m_gameState.m_unkUint15;
        }

        point.x += m_gameState.m_unkPoint34.x;
        point.y += m_gameState.m_unkPoint34.y;
    }
    void assignNewStickyGroups(cocos2d::CCArray* objects) = win 0x224d70;
    void asyncBGLoaded(int background) = win inline {
        this->createBackground(background);
        this->updateLevelColors();
    }
    void asyncGLoaded(int ground) = win inline {
        this->createGroundLayer(ground, 0);
        this->updateLevelColors();
    }
    void asyncMGLoaded(int middleground) = win inline {
        this->createMiddleground(middleground);
        this->updateLevelColors();
    }
    int atlasValue(int atlas) = win inline, ios inline {
        if (atlas < 30) return 0;
        return (int)std::min(atlas * 1.1f, 9999.f);
    }
    void bumpPlayer(PlayerObject* player, EffectGameObject* object) = win 0x217a00;
    int buttonIDToButton(int id) = win inline, ios inline {
        switch (id) {
            case 2: case 7: return 2;
            case 3: case 8: return 3;
            case 4: case 9: return 4;
            case 5: case 10: return 5;
            default: return 1;
        }
    }
    void calculateColorGroups();
    void cameraMoveX(float value, float duration, float rate, bool unused) = win inline, ios inline {
        float x = m_gameState.m_cameraPosition.x;
        m_gameState.m_unkBool4 = true;
        m_gameState.tweenValue(x, value, 1, duration, 1, rate, -1, -1);
    }
    void cameraMoveY(float value, float duration, float rate, bool force) = win inline, ios inline {
        if (!m_gameState.m_unkBool5 || m_gameState.m_unkInt13 != value || force) {
            float y = m_gameState.m_cameraPosition.y;
            m_gameState.m_unkBool5 = true;
            m_gameState.m_unkInt13 = value;
            m_gameState.tweenValue(y, value, 2, duration, 1, rate, -1, -1);
        }
    }
    bool canBeActivatedByPlayer(PlayerObject* player, EffectGameObject* object) = win 0x2178f0;
    bool canProcessSFX(SFXTriggerState& state, gd::unordered_map<int, int>& stateIndices, gd::unordered_map<int, float>& times, gd::vector<SFXTriggerState>& states) = win 0x242fb0;
    bool canTouchObject(GameObject* object) = win inline, ios inline {
        if (m_gameState.m_currentChannel == 0 || object->m_classType != GameObjectClassType::Effect) return true;
        auto effectObject = static_cast<EffectGameObject*>(object);
        return effectObject->m_channelValue == 0 || effectObject->m_channelValue == m_gameState.m_currentChannel;
    }
    void checkCameraLimitAfterTeleport(PlayerObject* player, float yOffset) = win 0x2399e0;
    bool checkCollision(int blockAID, int blockBID) = win 0x2190c0;
    void checkCollisionBlocks(EffectGameObject* object, gd::vector<EffectGameObject*>* blocks, int blockCount) = win 0x218ef0;
    int checkCollisions(PlayerObject* object, float dt, bool ignoreDamage) = win 0x213830;
    void checkRepellPlayer() = win 0x239710;
    void checkSpawnObjects() = win 0x21a920;
    cocos2d::CCPoint claimMoveAction(int groupID, bool ignoreStaticGroups) = win 0x22dc10;
    cocos2d::CCParticleSystemQuad* claimParticle(gd::string key, int zLayer) = win 0x2407e0;
    void claimRotationAction(int targetID, int centerID, float& rotation, float& offset, bool ignoreStaticGroups, bool unused) = win 0x22d9d0;
    void clearActivatedAudioTriggers() = win inline {
        m_gameState.m_songChannelStates.clear();
        m_gameState.m_songTriggerStateVectors.clear();
    }
    void clearPickedUpItems() = win inline, ios inline {
        m_collectedItems->removeAllObjects();
    }
    void collectedObject(EffectGameObject* object) = win inline {
        m_effectManager->addCountToItem(object->m_itemID, object->m_subtractCount ? -1 : 1);
        this->updateCounters(object->m_itemID, m_effectManager->countForItem(object->m_itemID));
    }
    void collisionCheckObjects(PlayerObject* object, gd::vector<GameObject*>* objects, int objectCount, float dt) = win 0x214990;
    void controlAdvancedFollowCommand(AdvancedFollowTriggerObject* object, int controlID, GJActionCommand command) = win inline {
        for (auto& inst : m_gameState.m_advanceFollowInstances) {
            if ((controlID == -1 && inst.m_gameObject == object) || inst.m_controlId == controlID) {
                switch (command) {
                    case GJActionCommand::Stop:
                        inst.m_started = true;
                        inst.m_finished = false;
                        inst.m_doStart = false;
                        break;
                    case GJActionCommand::Pause:
                        inst.m_finished = true;
                        inst.m_doStart = true;
                        break;
                    case GJActionCommand::Resume:
                        inst.m_finished = false;
                        inst.m_doStart = false;
                        break;
                }
            }
        }
    }
    void controlAreaEffect(EnterEffectObject* object, gd::vector<EnterEffectInstance>* instances, GJActionCommand command) = win 0x227a20;
    void controlAreaEffectWithID(int uniqueID, int controlID, GJActionCommand command) = win 0x227820;
    void controlDynamicCommand(EffectGameObject* object, int controlID, gd::vector<DynamicObjectAction>& actions, GJActionCommand command) = win inline {
        for (auto& action : actions) {
            if ((controlID == -1 && action.m_gameObject1 == object) || action.m_controlID == controlID) {
                switch (command) {
                    case GJActionCommand::Stop:
                        action.m_unkBool2 = true;
                        break;
                    case GJActionCommand::Pause:
                        action.m_unkBool3 = true;
                        action.m_unkBool4 = true;
                        break;
                    case GJActionCommand::Resume:
                        action.m_unkBool3 = false;
                        action.m_unkBool4 = false;
                        break;
                }
            }
        }
    }
    void controlDynamicMoveCommand(EffectGameObject* object, int controlID, GJActionCommand command) = win inline, ios inline {
        this->controlDynamicCommand(object, controlID, m_gameState.m_dynamicMoveActions, command);
    }
    void controlDynamicRotateCommand(EffectGameObject* object, int controlID, GJActionCommand command) = win inline, ios inline {
        this->controlDynamicCommand(object, controlID, m_gameState.m_dynamicRotateActions, command);
    }
    void controlEventLink(int uniqueID, int controlID, GJActionCommand command) = win 0x2321c0;
    void controlGradientTrigger(GradientTriggerObject* object, GJActionCommand command) = win inline {
        if (command == GJActionCommand::Resume) {
            this->triggerGradientCommand(object);
        }
        else {
            if (auto gradientLayer = static_cast<GJGradientLayer*>(m_gradientLayers->objectForKey(std::min(object->m_gradientID, 999)))) {
                gradientLayer->removeFromParentAndCleanup(false);
                gradientLayer->m_triggerObject = nullptr;
            }
        }
    }
    void controlTriggersInGroup(int group, GJActionCommand command) = win 0x21e1c0;
    void controlTriggersWithControlID(int controlID, GJActionCommand command) = win 0x21e750;
    void createBackground(int background) = win 0x20b860;
    void createGroundLayer(int ground, int line) = win 0x20bca0;
    void createMiddleground(int middleground) = win 0x20bb20;
    cocos2d::CCArray* createNewKeyframeAnim() = win inline {
        auto group = cocos2d::CCArray::create();
        group->setTag(m_keyframeGroup);
        m_keyframeGroups->setObject(group, m_keyframeGroup++);
        return group;
    }
    cocos2d::CCParticleSystemQuad* createParticle(int objectType, char const* plistName, int tag, cocos2d::tCCPositionType positionType) = win 0x240400;
    void createPlayer();
    void createPlayerCollisionBlock() = win 0x2183a0;
    void createTextLayers() = win 0x20ecd0;
    cocos2d::CCArray* damagingObjectsInRect(cocos2d::CCRect rect, bool enabledGroups) = win 0x211660;
    void destroyObject(GameObject* object) = win 0x2160c0;
    void enterDualMode(GameObject* object, bool unused) = win inline {
        if (!object) return;
        m_player1->m_lastPortalPos = object->getPosition();
        m_player1->m_lastActivatedPortal = object;
        m_gameState.m_lastActivatedPortal1 = object;
    }
    void exitStaticCamera(bool exitX, bool exitY, float time, int easingType, float easingRate, bool smoothVelocity, float smoothVelocityMod, bool exitInstant) = win 0x23f480;
    void flipFinished() = win inline {
        m_player1->levelFlipFinished();
        if (m_gameState.m_isDualMode) m_player2->levelFlipFinished();
        m_gameState.m_unkBool11 = false;
        m_gameState.m_unkBool12 = false;
    }
    void flipGravity(PlayerObject* object, bool flip, bool noEffects) = win 0x212b40;
    void flipObjects() = win 0x246810;
    void gameEventTriggered(GJGameEvent event, int material, int playerID) = win 0x231e30;
    int generateEnterEasingBuffer(int easingType, float easingRate) = win 0x20ea80;
    void generateEnterEasingBuffers(EnterEffectObject* object) = win inline {
        object->m_easingInBuffer = this->generateEnterEasingBuffer((int)object->m_easingInType, object->m_easingInRate);
        object->m_easingOutBuffer = this->generateEnterEasingBuffer((int)object->m_easingOutType, object->m_easingOutRate);
    }
    void generatePickupAnimRandVal(GameObject* object, float& randomValue1, float& randomValue2) = win inline {
        std::pair<int, int> key = { (int)object->getPosition().x, (int)object->getPosition().y };
        if (m_destroyObjectValues.count(key) != 0) {
            m_destroyObjectValues[key] = { ((float)rand() / (float)RAND_MAX) * 2.f - 1.f, (float)rand() / (float)RAND_MAX };
        }
        randomValue1 = m_destroyObjectValues[key].first;;
        randomValue2 = m_destroyObjectValues[key].second;
    }
    void generateSpawnRemap() = win 0x21dfe0;
    void generateTargetGroups();
    void generateVisibilityGroups() = win 0x2315c0;
    cocos2d::CCArray* getActiveOrderSpawnObjects() = win inline {
        if (auto objects = static_cast<cocos2d::CCArray*>(m_spawnObjects->objectForKey(m_gameState.m_currentChannel))) return objects;
        return cocos2d::CCArray::create();
    }
    float getAreaObjectValue(EnterEffectInstance* instance, GameObject* object, cocos2d::CCPoint& position, bool& show) = win 0x2280a0 {
        auto realPosition = object->getRealPosition();
        float value;
        switch (instance->m_gameObject->m_directionType) {
            case 1: {
                value = realPosition.x - position.x + (instance->m_offsetVariance != 0.f ? instance->m_offsetVariance * m_varianceValues[object->m_varianceIndex + 1] : 0.f);
                value *= value > 0.f ? instance->m_modFront : instance->m_modBack;
                show = instance->m_reversed ? position.x >= realPosition.x : position.x <= realPosition.x;
                break;
            }
            case 2: {
                value = realPosition.y - position.y + (instance->m_offsetVariance != 0.f ? instance->m_offsetVariance * m_varianceValues[object->m_varianceIndex + 1] : 0.f);
                value *= value > 0.f ? instance->m_modFront : instance->m_modBack;
                show = instance->m_reversed ? position.y >= realPosition.y : position.y <= realPosition.y;
                break;
            }
            default: {
                value = cocos2d::ccpDistance(realPosition, position + cocos2d::CCPoint {
                    instance->m_offsetVariance != 0.f ? instance->m_offsetVariance * m_varianceValues[object->m_varianceIndex + 1] : 0.f,
                    instance->m_offsetYVariance != 0.f ? instance->m_offsetYVariance * m_varianceValues[object->m_varianceIndex + 2] : 0.f
                });
                show = instance->m_reversed ? position.x >= realPosition.x : position.x <= realPosition.y;
                break;
            }
        }
        auto deadzone = instance->m_deadzone;
        auto result = value / (instance->m_length + (instance->m_lengthVariance != 0.f ? instance->m_lengthVariance * m_varianceValues[object->m_varianceIndex] : 0.f));
        result = std::clamp(deadzone != 0.f ? (result - deadzone) / (1.f - deadzone) : result, 0.f, 1.f);
        return instance->m_gameObject->m_inbound ? 1.f - result : result;
    }
    float getBumpMod(PlayerObject* player, int type) = win inline {
        if (static_cast<GameObjectType>(type) == GameObjectType::PinkJumpPad) {
            if (player->m_isShip) return .35f;
            if (player->m_isBird) return .4f;
            if (player->m_isBall || player->m_isSpider) return .7f;
            return .65f;
        }
        if (static_cast<GameObjectType>(type) == GameObjectType::RedJumpPad) {
            if (player->m_isShip) return (player->m_vehicleSize < 1.f) ? .95f : .63f;
            if (player->m_isBird) return (player->m_vehicleSize < 1.f) ? .98f : .6f;
            return 1.25f;
        }
        return 1.f;
    }
    float getCameraEdgeValue(int type) = win inline {
        switch (type - 1) {
            case 0: {
                if (auto mainObject = this->tryGetMainObject(m_gameState.m_cameraEdgeValue0)) {
                    return mainObject->getRealPosition().x;
                }
                return 0.f;
            }
            case 1: {
                if (auto mainObject = this->tryGetMainObject(m_gameState.m_cameraEdgeValue1)) {
                    return mainObject->getRealPosition().x;
                }
                return 0.f;
            }
            case 2: {
                if (auto mainObject = this->tryGetMainObject(m_gameState.m_cameraEdgeValue2)) {
                    return mainObject->getRealPosition().y;
                }
                return 0.f;
            }
            case 3: {
                if (auto mainObject = this->tryGetMainObject(m_gameState.m_cameraEdgeValue3)) {
                    return mainObject->getRealPosition().y;
                }
                return 0.f;
            }
            default: {
                return 0.f;
            }
        }
    }
    gd::string getCapacityString() = win inline {
        fmt::memory_buffer buffer;
        auto first = true;
        auto index = 0;
        CCObject* obj;
        CCARRAY_FOREACH(m_batchNodes, obj) {
            auto capacity = static_cast<cocos2d::CCSpriteBatchNode*>(obj)->getUsedAtlasCapacity();
            if (capacity > 200) {
                if (!first) fmt::format_to(std::back_inserter(buffer), ",");
                fmt::format_to(std::back_inserter(buffer), "{},{}", capacity, index++);
                first = false;
            }
        }
        return fmt::to_string(buffer);
    }
    GameObject* getCenterGroupObject(int groupID, int defaultID) = win inline, ios inline {
        if (groupID < 1) groupID = defaultID;
        auto group = this->getGroup(groupID);
        if (group && group->count() == 1) return static_cast<GameObject*>(group->objectAtIndex(0));
        else return this->getGroupParent(groupID);
    }
    gd::vector<EnterEffectInstance>* getCustomEnterEffects(int id, bool enter) = win inline {
        if (id > 100) return nullptr;
        return enter ? &m_gameState.m_enterEffectInstanceVectors[id] : &m_gameState.m_exitEffectInstanceVectors[id];
    }
    float getEasedAreaValue(GameObject* object, EnterEffectInstance* instance, float value, bool show, int index) = win 0x228290, ios inline {
        auto enterObject = instance->m_gameObject;
        if (enterObject->m_easeOutEnabled) {
            if (value > .01f && value < .99f) {
                auto index = instance->m_easeIndex;
                auto& indices = instance->m_easeIndices;
                if (indices[index] == index - 2) {
                    indices[index] = index;
                    show = false;
                }
                else if (indices[index] == index - 1) {
                    indices[index] = index + 1;
                    show = true;
                }
            }
            if (!show) return this->getEnterEasingValue(value, (int)enterObject->m_easingOutType, enterObject->m_easingOutRate, enterObject->m_easingOutBuffer);
        }
        return this->getEnterEasingValue(value, (int)enterObject->m_easingInType, enterObject->m_easingInRate, enterObject->m_easingInBuffer);
    }
    int getEnterEasingKey(int easingType, float easingRate) = win inline, ios inline {
        switch (easingType) {
            case 0: return -1;
            case 3: case 7: case 8: case 9: return -2;
            default: return easingType * 10000 + easingRate * 100.f;
        }
    }
    float getEnterEasingValue(float value, int easingType, float easingRate, int easingBuffer) = win inline {
        if (easingBuffer == -1) return value;
        if (easingBuffer == -2) return GameToolbox::getEasedValue(value, easingType, easingRate);
        auto easeIndex = (int)(value * 100.f) + easingBuffer;
        return (value - (int)(value * 100.f) / 100.f) * (m_enterEasingValues[easeIndex + 1] - m_enterEasingValues[easeIndex]) * 100.f + m_enterEasingValues[easeIndex];
    }
    cocos2d::CCPoint getFollowSpeedVal(GameObject* object, int startSpeedRef, int startDirRef, float startDir, float startSpeed) = win 0x22e980;
    float getGroundHeight(PlayerObject* player, int type) = win inline {
        if (m_gameState.m_isDualMode) {
            auto height1 = this->getGroundHeightForMode(type);
            if (height1 == 240.f) height1 = 270.f;
            auto otherPlayer = this->getOtherPlayer(player);
            auto height2 = this->getGroundHeightForMode(otherPlayer->isFlying() ? 5 : otherPlayer->m_isBall ? 16 : 6);
            return std::max(height1, height2);
        }
        return this->getGroundHeightForMode(type);
    }
    float getGroundHeightForMode(int type) = win 0x211d90, ios inline {
        while (true) {
            switch (type) {
                case 5: case 19: case 26: case 41: {
                    return 300.f;
                }
                case 16: {
                    return 240.f;
                }
                case 23: case 24: {
                    type = m_gameState.m_dualRelated;
                    if (type == 23 || type == 24) {
                        return 270.f;
                    }
                    break;
                }
            }
        }
        return 270.f;
    }
    cocos2d::CCArray* getGroup(int id) = win 0x2242b0;
    GameObject* getGroupParent(int groupId) = win inline {
        return static_cast<GameObject*>(m_parentGroupsDict->objectForKey(groupId));
    }
    gd::string getGroupParentsString(GameObject* object) = win inline {
        auto groupParents = static_cast<cocos2d::CCArray*>(m_parentGroupIDs->objectForKey(object->m_uniqueID));
        if (!groupParents || groupParents->count() == 0) return "";
        fmt::memory_buffer buffer;
        auto first = true;
        for (auto i = 0; i < groupParents->count(); i++) {
            auto groupID = static_cast<cocos2d::CCInteger*>(groupParents->objectAtIndex(i))->getValue();
            if (!first) fmt::format_to(std::back_inserter(buffer), ".");
            fmt::format_to(std::back_inserter(buffer), "{}", groupID);
            first = false;
        }
        return fmt::to_string(buffer);
    }
    double getItemValue(int type, int id) = win 0x234000;
    float getMaxPortalY() = win 0x2137b0;
    float getMinDistance(cocos2d::CCPoint position, cocos2d::CCArray* objects, float minNear, int mode) = win 0x2427d0;
    float getMinPortalY() = win 0x2136d0;
    float getModifiedDelta(float dt) = win 0x2375f0;
    cocos2d::CCPoint getMoveTargetDelta(EffectGameObject* object, bool mainObject) = win inline {
        auto targetID = object->m_targetModCenterID;
        if (targetID < 1) targetID = object->m_targetGroupID;
        auto object1 = mainObject ? this->tryGetMainObject(targetID) : this->tryGetObject(targetID);
        GameObject* object2;
        if (!object->m_targetPlayer1) {
            if (!object->m_targetPlayer2) object2 = mainObject ? this->tryGetMainObject(object->m_centerGroupID) : this->tryGetObject(object->m_centerGroupID);
            else if (m_gameState.m_isDualMode) object2 = m_player2;
            else object2 = m_player1;
        }
        else object2 = m_player1;
        if (object1 && object2 && object1->m_uniqueID != object2->m_uniqueID) {
            return object2->getRealPosition() - object1->getRealPosition();
        }
        else return { 0.f, 0.f };
    }
    cocos2d::CCArray* getOptimizedGroup(int groupID) = win inline {
        groupID = std::clamp(groupID, 0, 9999);
        auto group = m_optimizedGroups[groupID];
        if (group) return group;
        group = cocos2d::CCArray::create();
        m_optimizedGroupDict->setObject(group, groupID);
        m_optimizedGroups[groupID] = group;
        return group;
    }
    PlayerObject* getOtherPlayer(PlayerObject* player) = win inline {
        return player->m_uniqueID != m_player1->m_uniqueID ? m_player1 : m_player2;
    }
    gd::string getParticleKey(int objectType, char const* plistName, int tag, cocos2d::tCCPositionType positionType) = win 0x2401d0;
    gd::string getParticleKey2(gd::string key) = win 0x240350;
    int getPlayerButtonID(int button, bool player2) = win inline, ios inline {
        if (button < 2 || button > 5) return player2 ? 6 : 1;
        return player2 ? button + 5 : button;
    }
    int getPlayTimerFullSeconds() = win inline, ios inline {
        return m_timePlayed;
    }
    int getPlayTimerMilli() = win inline {
        return m_timePlayed * 1000.0;
    }
    TeleportPortalObject* getPortalTarget(TeleportPortalObject* object) = win inline {
        auto target = object->m_orangePortal;
        if (target) return target;
        if (object->m_targetGroupID > 0) {
            auto group = this->getGroup(object->m_targetGroupID);
            auto count = group->count();
            if (count > 0) {
                if (count == 1) return static_cast<TeleportPortalObject*>(group->objectAtIndex(0));
                else {
                    auto seed = reinterpret_cast<uint64_t*>(geode::base::get() + 0x6a4e88);
                    *seed = *seed * 214013 + 2531011;
                    auto num = ((*seed >> 16) & 32767) / 32767.f;
                    if (num == 1.f) num = 0.f;
                    return static_cast<TeleportPortalObject*>(group->objectAtIndex(num * count));
                }
            }
        }
        return nullptr;
    }
    cocos2d::CCPoint getPortalTargetPos(TeleportPortalObject* object, GameObject* target, PlayerObject* player) = win inline {
        if (target && object->m_objectID != 747) return target->getRealPosition();
        else return { player->getPosition().x, object->getRealPosition().y + object->m_teleportYOffset };
    }
    gd::string getRecordString();
    void getRotateCommandTargets(EnhancedTriggerObject* object, GameObject*& centerObject, GameObject*& targetObject, GameObject*& rotateObject) = win inline {
        auto centerID = object->m_centerGroupID;
        if (centerID == 0) centerID = object->m_targetGroupID;
        centerObject = this->tryGetObject(centerID);
        targetObject = this->tryGetObject(object->m_targetGroupID);
        if (!object->m_targetPlayer1) {
            if (!object->m_targetPlayer2) rotateObject = this->tryGetObject(object->m_rotationTargetID);
            else if (m_gameState.m_isDualMode) rotateObject = m_player2;
            else rotateObject = m_player1;
        }
        else rotateObject = m_player1;
    }
    cocos2d::CCPoint getSavedPosition(int groupID, float delay) = win 0x2192d0;
    float getScaledGroundHeight(float height) = win inline, ios inline {
        if (m_gameState.m_targetCameraZoom != 1.f) return floorf((height / m_gameState.m_targetCameraZoom) / 30.f) * 30.f;
        return height;
    }
    GameObject* getSingleGroupObject(int groupID) = win inline {
        if (groupID < 1) return nullptr;
        auto group = this->getGroup(groupID);
        if (group && group->count() == 1) return static_cast<GameObject*>(group->objectAtIndex(0));
        return nullptr;
    }
    int getSpecialKey(int groupID, bool ignoreGroupParent, bool ignoreLinkedObjects) = win inline, ios inline {
        return groupID + (int)ignoreGroupParent * 1000000 + (int)ignoreLinkedObjects * 10000000 + 10000000;
    }
    cocos2d::CCArray* getStaticGroup(int groupID) = win inline {
        groupID = std::clamp(groupID, 0, 9999);
        auto group = m_staticGroups[groupID];
        if (group) return group;
        group = cocos2d::CCArray::create();
        m_staticGroupDict->setObject(group, groupID);
        m_staticGroups[groupID] = group;
        return group;
    }
    cocos2d::CCArray* getStickyGroup(int group) = win inline {
        return static_cast<cocos2d::CCArray*>(m_linkedGroupDict->objectForKey(group));
    }
    float getTargetFlyCameraY(GameObject* object) = win inline {
        if (m_gameState.m_isDualMode) {
            if (m_gameState.m_lastActivatedPortal2) return m_gameState.m_lastActivatedPortal2->getStartPos().y;
            if (m_startPosObject) return m_startPosObject->getStartPos().y;
            if (object) return object->getStartPos().y;
        }
        else {
            if (object) return object->getStartPos().y;
            if (m_startPosObject) return m_startPosObject->getStartPos().y;
        }
        return 0.f;
    }
    cocos2d::CCArray* getTargetGroup(int index, int uniqueID) = win inline, ios inline {
        return static_cast<cocos2d::CCArray*>(static_cast<cocos2d::CCDictionary*>(m_targetGroupsArray->objectAtIndex(index + 1))->objectForKey(uniqueID));
    }
    cocos2d::CCArray* getTargetGroupOrigin(int index, int uniqueID) = win inline, ios inline {
        return static_cast<cocos2d::CCArray*>(static_cast<cocos2d::CCDictionary*>(m_targetGroupsArray->objectAtIndex(index + 2))->objectForKey(uniqueID));
    }
    void gravBumpPlayer(PlayerObject* player, EffectGameObject* object) = win inline {
        auto flip = player->m_isSideways ? !object->isFacingLeft() : !object->isFacingDown();
        if (player->m_isUpsideDown != flip && this->canBeActivatedByPlayer(player, object)) {
            if (object->m_isReverse) player->reversePlayer(object);
            if (!object->m_hasNoEffects) this->playGravityEffect(flip);
            player->m_lastPortalPos = object->getPosition() - cocos2d::CCPoint { 0.f, 10.f };
            object->activatedByPlayer(player);
            player->m_lastActivatedPortal = object;
            player->propellPlayer(.8f, object->m_hasNoEffects, 10);
            this->flipGravity(player, flip, true);
            player->m_padRingRelated = true;
            this->gameEventTriggered(GJGameEvent::GravityPad, 0, 0);
        }
    }
    void groupStickyObjects(cocos2d::CCArray* objects) = win 0x224b90;
    void handleButton(bool down, int button, bool isPlayer1) = win 0x233720;
    bool hasItem(int id) = win inline {
        return m_collectedItems->objectForKey(cocos2d::CCString::createWithFormat("%i", id)->getCString()) != nullptr;
    }
    bool hasUniqueCoin(EffectGameObject* object) = win 0x216730;
    void increaseBatchNodeCapacity() = win 0x20cc60;
    bool isFlipping() = win inline {
        return m_gameState.m_levelFlipping != 0.f && m_gameState.m_levelFlipping != 1.f;
    }
    bool isPlayer2Button(int button) = win inline, ios inline {
        return button > 5;
    }
    void lightningFlash(cocos2d::CCPoint to, cocos2d::ccColor3B color) = win inline {
        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        auto x = ((float)rand() / (float)RAND_MAX) * 150.f + (to.x - 50.f);
        auto y = m_gameState.m_cameraPosition.y + (winSize.height + 50.f) / m_objectLayer->getScale();
        this->lightningFlash({ x, y }, to, color, 5.f, .5f, 0, true, 1.f);
    }
    void lightningFlash(cocos2d::CCPoint from, cocos2d::CCPoint to, cocos2d::ccColor3B color, float lineWidth, float duration, int displacement, bool flash, float opacity) = win 0x246b10;
    void loadGroupParentsFromString(GameObject* object, gd::string groupList) = win 0x224890;
    void loadLevelSettings() = win 0x23ab40;
    void loadStartPosObject() = win 0x2355a0;
    void loadUpToPosition(float position, int order, int channel) = win 0x235740;
    int maxZOrderForShaderZ(int zLayer) = win 0x2237e0;
    int minZOrderForShaderZ(int zLayer) = win 0x223730;
    void modifyGroupPhysics(AdvancedFollowEditObject* object, cocos2d::CCArray* group) = win 0x22ee30;
    void modifyObjectPhysics(AdvancedFollowEditObject* object, GameObjectPhysics& physics) = win inline {
        physics.m_unkPoint1.x = GameToolbox::fast_rand_0_1() * object->m_modXVariance + object->m_modX;
        physics.m_unkPoint1.y = GameToolbox::fast_rand_0_1() * object->m_modYVariance + object->m_modY;
        auto speed = GameToolbox::fast_rand_0_1() * object->m_startSpeedVariance + object->m_startSpeed;
        if (speed != 0.f) {
            auto speedVal = this->getFollowSpeedVal(physics.m_gameObject, object->m_startSpeedReference, object->m_startDirectionReference,
                GameToolbox::fast_rand_0_1() * object->m_startDirectionVariance + object->m_startDirection, speed);
            if (!object->m_xOnly) physics.m_unkPoint1.y += speedVal.y;
            if (!object->m_yOnly) physics.m_unkPoint1.x += speedVal.x;
        }
    }
    void moveAreaObject(GameObject* object, float dx, float dy) = win 0x22aae0 {
        auto result = this->resetAreaObjectValues(object, true);
        if (dx == 0.f && dy == 0.f && !result) return;
        if (dy != 0.f) {
            object->m_positionY += dy;
            object->m_positionYOffset += dy;
            object->dirtifyObjectPos();
            object->dirtifyObjectRect();
        }
        if (dx != 0.f && !object->m_tempOffsetXRelated) {
            object->m_positionX += dx;
            object->m_positionXOffset += dx;
            object->dirtifyObjectPos();
            object->dirtifyObjectRect();
        }
        this->updateObjectSection(object);
    }
    void moveCameraToPos(cocos2d::CCPoint pos) = win inline, ios inline {
        this->cameraMoveX(pos.x, 1.2f, 1.8f, false);
        this->cameraMoveY(pos.y, 1.2f, 1.8f, false);
    }
    void moveObject(GameObject* object, double dx, double dy, bool lockPlayerY) = win inline {
        m_objectsToMove->addObject(object);
        this->moveObjects(m_objectsToMove, dx, dy, lockPlayerY);
        m_objectsToMove->removeObjectAtIndex(0);
    }
    void moveObjects(cocos2d::CCArray* objects, double dx, double dy, bool lockPlayerY) = win 0x22dd80;
    void moveObjectsSilent(int groupId, double dx, double dy) = win inline {
        auto group = this->getGroup(groupId);
        CCObject* object;
        CCARRAY_FOREACH(group, object) {
            auto obj = static_cast<GameObject*>(object);

            if (!obj->m_tempOffsetXRelated) {
                obj->m_positionX += dx;
            }
            obj->m_positionY += dy;
            obj->dirtifyObjectRect();
            obj->dirtifyObjectPos();
            this->updateObjectSection(obj);
            obj->m_lastPosition.x = obj->m_positionX;
            obj->m_lastPosition.y = obj->m_positionY;
        }

        m_effectManager->saveCompletedMove(groupId, dx, dy);
    }
    void moveObjectToStaticGroup(GameObject* object) = win 0x231440;
    bool objectIntersectsCircle(GameObject* object, GameObject* circle) = win inline {
        auto objectRect = object->getObjectRect();
        auto circleRadius = circle->getObjectRadius();
        auto circlePosition = circle->getRealPosition();
        auto minX = objectRect.getMinX();
        auto maxX = objectRect.getMaxX();
        auto minY = objectRect.getMinY();
        auto maxY = objectRect.getMaxY();
        if (objectRect.containsPoint(circlePosition)) return true;
        if (circleRadius > std::abs(cocos2d::ccpDistance({ maxX, maxY }, circlePosition))) return true;
        if (circleRadius > std::abs(cocos2d::ccpDistance({ maxX, minY }, circlePosition))) return true;
        if (circleRadius > std::abs(cocos2d::ccpDistance({ minX, minY }, circlePosition))) return true;
        if (circleRadius > std::abs(cocos2d::ccpDistance({ minX, maxY }, circlePosition))) return true;
        return false;
    }
    GJGameEvent objectTypeToGameEvent(int type) = win 0x2323a0;
    void optimizeMoveGroups();
    void orderSpawnObjects() = win 0x245b80;
    cocos2d::CCNode* parentForZLayer(int zLayer, bool blending, int parentMode, int uiObject) = win 0x20f1a0;
    void pauseAudio() = win 0x2372f0;
    double performMathOperation(double operand1, double operand2, int operation) = win inline, ios inline {
        switch (operation) {
            case 0:
                return operand1 + operand2;
            case 1:
                return operand1 - operand2;
            case 2:
                return operand1 * operand2;
            case 3:
                return operand2 != 0.0 ? operand1 / operand2 : 0.0;
            default:
                return 0.0;
        }
    }
    double performMathRounding(double value, int type) = win inline, ios inline {
        switch (type) {
            case 1: return round(value);
            case 2: return floor(value);
            case 3: return ceil(value);
            default: return value;
        }
    }
    void pickupItem(EffectGameObject* object);
    void playAnimationCommand(int id, int groupID) = win inline {
        if (groupID <= 0) return;
        auto group = this->getGroup(groupID);
        for (int i = 0; i < group->count(); i++) {
            auto object = static_cast<AnimatedGameObject*>(group->objectAtIndex(i));
            if (object->m_classType == GameObjectClassType::Animated) object->playAnimation(id);
            else object->animationTriggered();
        }
    }
    bool playerCircleCollision(PlayerObject* player, GameObject* object) = win 0x211e30;
    bool playerIntersectsCircle(PlayerObject* player, GameObject* object) = win inline {
        return cocos2d::ccpDistance(object->getPosition(), player->getRealPosition()) <= player->getObjectRect().size.width * .5f + object->getObjectRadius();
    }
    void playerTouchedObject(PlayerObject* player, GameObject* object) = win inline, ios inline {
        m_gameState.m_unkMapPairIntIntInt[{ object->m_uniqueID, player->m_uniqueID }] = m_gameState.m_unkUint2;
    }
    void playerTouchedRing(PlayerObject* player, RingObject* object) = win 0x217e70;
    void playerTouchedTrigger(PlayerObject* player, EffectGameObject* object) = win 0x217f80;
    bool playerWasTouchingObject(PlayerObject* player, GameObject* object) = win inline, ios inline {
        return m_gameState.m_unkMapPairIntIntInt.find({ object->m_uniqueID, player->m_uniqueID }) != m_gameState.m_unkMapPairIntIntInt.end();
    }
    void playerWillSwitchMode(PlayerObject* player, GameObject* object) = win 0x212f30;
    void playExitDualEffect(PlayerObject* player) = win 0x216eb0;
    void playFlashEffect(float duration, int flashes, float unknown) = win inline, ios inline {
        m_unk31f8 = unknown;
        m_flashNode->setVisible(true);
        auto action = flashes > 1 ? cocos2d::CCSequence::create(
            cocos2d::CCBlink::create(duration, flashes - 1), cocos2d::CCHide::create(), nullptr
        ) : cocos2d::CCSequence::create(
            cocos2d::CCDelayTime::create(duration), cocos2d::CCHide::create(), nullptr
        );
        action->setTag(15);
        m_flashNode->runAction(action);
    }
    void playKeyframeAnimation(KeyframeAnimTriggerObject* object, gd::vector<int> const& remapKeys) = win 0x217bf0;
    void playSpeedParticle(float timeMod) = win inline {
        if (GameManager::sharedState()->m_performanceMode || m_skipArtReload) return;
        const char* particleFile;
        if (timeMod == .7f) particleFile = "speedEffect_slow.plist";
        else if (timeMod == 1.1f) particleFile = "speedEffect_fast.plist";
        else if (timeMod == 1.3f) particleFile = "speedEffect_vfast.plist";
        else if (timeMod == 1.6f) particleFile = "speedEffect_vvfast.plist";
        else particleFile = "speedEffect_normal.plist";
        auto director = cocos2d::CCDirector::sharedDirector();
        auto winSize = director->getWinSize();
        auto particle = cocos2d::CCParticleSystemQuad::create(particleFile, false);
        particle->setPositionType(cocos2d::tCCPositionType::kCCPositionTypeGrouped);
        particle->setAutoRemoveOnFinish(true);
        this->addChild(particle, 100);
        particle->setPosition({ director->getScreenRight() + 10.f, winSize.height / 2.f });
        particle->setPosVar({ 10.f, director->getScreenScaleFactorH() * 160.f });
        particle->resetSystem();
    }
    cocos2d::CCPoint positionForShaderTarget(int groupID) = win 0x223580;
    void positionUIObjects() = win 0x2260a0;
    void prepareSavePositionObjects() = win 0x2197e0;
    void prepareTransformParent(bool rotateNode) = win inline {
        m_areaTransformNode2->retain();
        m_areaTransformNode2->removeFromParentAndCleanup(false);

        auto node = rotateNode ? m_areaRotateNode : m_areaTransformNode;
        node->addChild(m_areaTransformNode2);
        m_areaTransformNode2->release();
    }
    void preResumeGame() = win inline {
        m_resumeTimer = 2;
    }
    void preUpdateVisibility(float dt) = win 0x236040;
    void processActivatedAudioTriggers(float levelTime) = win 0x243780;
    void processAdvancedFollowAction(AdvancedFollowInstance& instance, bool started, float dt) = win 0x22f330;
    void processAdvancedFollowActions(float dt) = win 0x22f110;
    void processAreaActions(float dt, bool visibleFrame) = win 0x228ff0;
    void processAreaEffects(gd::vector<EnterEffectInstance>* effects, GJAreaActionType type, float dt, bool visibleFrame) = win 0x228410;
    void processAreaFadeGroupAction(cocos2d::CCArray* objects, EnterEffectInstance* instance, cocos2d::CCPoint position, bool targetGroups) = win inline {
        auto fromOpacity = instance->m_fromOpacity;;
        auto toOpacity = instance->m_toOpacity;
        m_areaColorCount += objects->count();
        auto colorCount = 0;
        auto totalCount = 0;
        CCObject* obj;
        CCARRAY_FOREACH(objects, obj) {
            auto object = static_cast<GameObject*>(obj);
            if (!object->m_isActivated) continue;
            totalCount++;
            auto show = false;
            auto rawOpacity = this->getAreaObjectValue(instance, object, position, show);
            auto opacity = rawOpacity * (toOpacity - fromOpacity) + fromOpacity;
            if (targetGroups) {
                auto targetGroup = this->getTargetGroup(instance->m_targetGroupIndex, object->m_uniqueID);
                colorCount += targetGroup->count() - 1;
                CCObject* targetObj;
                CCARRAY_FOREACH(targetGroup, targetObj) {
                    static_cast<GameObject*>(targetObj)->setAreaOpacity(opacity, rawOpacity, m_gameState.m_unkUint2);
                }
            }
            else {
                object->setAreaOpacity(opacity, rawOpacity, m_gameState.m_unkUint2);
            }
        }
        m_areaColorCount += colorCount;
        m_areaColorCountTotal += colorCount + totalCount;
    }
    void processAreaMoveGroupAction(cocos2d::CCArray* objects, EnterEffectInstance* instance, cocos2d::CCPoint position, int outerMin, int outerMax, int middleMin, int middleMax, int startIndex, bool targetGroups, bool reset) = win 0x22a500;
    void processAreaRotateGroupAction(cocos2d::CCArray* objects, EnterEffectInstance* instance, cocos2d::CCPoint position, int outerMin, int outerMax, int middleMin, int middleMax, int startIndex, bool targetGroups, bool reset) = win 0x229dc0;
    void processAreaTintGroupAction(cocos2d::CCArray* objects, EnterEffectInstance* instance, cocos2d::CCPoint position, bool targetGroups) = win 0x22abd0;
    void processAreaTransformGroupAction(cocos2d::CCArray* objects, EnterEffectInstance* instance, cocos2d::CCPoint position, int outerMin, int outerMax, int middleMin, int middleMax, int startIndex, bool targetGroups, bool reset) = win 0x229250;
    void processAreaVisualActions(float dt) = win inline {
        this->processAreaEffects(&m_gameState.m_fadeEffectInstances, GJAreaActionType::Fade, dt, true);
        this->processAreaEffects(&m_gameState.m_tintEffectInstances, GJAreaActionType::Tint, dt, true);
    }
    GameObject* processCameraObject(GameObject* object, PlayerObject* player) = win inline {
        if (object) {
            player->m_lastPortalPos = object->getPosition();
            player->m_lastActivatedPortal = object;
        }
        auto ret = object;
        if (m_gameState.m_isDualMode && m_gameState.m_lastActivatedPortal2) ret = m_gameState.m_lastActivatedPortal2;
        if (object) m_gameState.m_lastActivatedPortal1 = object;
        return ret;
    }
    void processCommands(float dt);
    void processDynamicObjectActions(int type, float dt) = win 0x22e2b0;
    void processFollowActions() = win 0x2305b0;
    void processItems() = win 0x2162c0;
    void processMoveActions() = win 0x22d5e0;
    void processMoveActionsStep(float dt, bool visibleFrame) = win 0x22b600;
    void processOptionsTrigger(GameOptionsTrigger* object) = win 0x223d80;
    void processPlayerFollowActions(float dt) = win 0x22df00;
    void processQueuedAudioTriggers() = win 0x23b8f0;
    void processQueuedButtons();
    void processRotationActions() = win 0x22b820;
    void processSFXObjects() = win 0x241820;
    void processSFXState(SFXTriggerState* state1, SFXTriggerState* state2, int type, float levelTime) = win 0x244c20;
    bool processSongState(int musicID, float spawnDelay, float levelTime, int songOffset, float volume, float speed, gd::vector<SongTriggerState>* states, SongTriggerGameObject* object) = win 0x245160;
    void processStateObjects() = win inline {
        for (auto it = m_gameState.m_stateObjects.begin(); it != m_gameState.m_stateObjects.end();) {
            auto obj = it->second;
            obj->updateState(m_gameState.m_unkUint2);
            if (obj->m_isRingPoweredOn) ++it;
            else {
                obj->stateSensitiveOff(this);
                it = m_gameState.m_stateObjects.erase(it);
            }
        }
    }
    void processTransformActions(bool visibleFrame) = win 0x22c6b0;
    void queueButton(int button, bool push, bool isPlayer2) = win inline {
        if (button <= 0 || button > 3) {
            return;
        }
        PlayerButtonCommand command = {};
        command.m_button = (PlayerButton) button;
        command.m_isPush = push;
        command.m_isPlayer2 = isPlayer2;
        m_queuedButtons.push_back(command);
    }
    void reAddToStickyGroup(GameObject* object) = win inline {
        auto uniqueID = object->m_uniqueID;
        if (m_stickyGroups.count(uniqueID) != 0 && object->m_linkedGroup == 0) {
            auto groupID = m_stickyGroups[uniqueID];
            if (auto stickyGroup = this->getStickyGroup(groupID)) {
                stickyGroup->addObject(object);
                object->m_linkedGroup = groupID;
                m_stickyGroups.erase(uniqueID);
            }
        }
    }
    void recordAction(int button, bool down, bool player2) = win inline {
        if (m_recordInputs && !m_useReplay) {
            PlayerButtonCommand command;
            command.m_button = (PlayerButton)button;
            command.m_isPush = down;
            command.m_isPlayer2 = player2;
            command.m_step = 0;
            m_queuedRecordedButtons.push_back(command);
        }
    }
    bool rectIntersectsCircle(cocos2d::CCRect rect, cocos2d::CCPoint center, float radius) = win inline {
        auto minX = rect.getMinX();
        auto maxX = rect.getMaxX();
        auto minY = rect.getMinY();
        auto maxY = rect.getMaxY();
        if (rect.containsPoint(center)) return true;
        if (radius > std::abs(cocos2d::ccpDistance({ maxX, maxY }, center))) return true;
        if (radius > std::abs(cocos2d::ccpDistance({ maxX, minY }, center))) return true;
        if (radius > std::abs(cocos2d::ccpDistance({ minX, minY }, center))) return true;
        if (radius > std::abs(cocos2d::ccpDistance({ minX, maxY }, center))) return true;
        if (radius >= cocos2d::ccpDistance({ std::clamp(center.x, minX, maxX), std::clamp(center.y, minY, maxY) }, center)) return true;
        return false;
    }
    void refreshCounterLabels() = win 0x2353f0;
    void refreshKeyframeAnims() = win 0x233b20;
    void regenerateEnterEasingBuffers() = win inline {
        m_enterEasingValues.clear();
        m_enterEasingIndices.clear();
        m_enterEasingValuesIndex = 0;
        CCObject* obj;
        CCARRAY_FOREACH(m_objects, obj) {
            auto object = static_cast<EnterEffectObject*>(obj);
            if (object->m_objectID >= 3006 && object->m_objectID <= 3021 && object->m_objectID != 3016) {
                this->generateEnterEasingBuffers(object);
            }
        }
    }
    int registerSpawnRemap(gd::vector<ChanceObject>& spawnRemap) = win inline {
        std::unordered_map<int, int> remap;
        m_spawnRemapTriggers.push_back(remap);
        for (auto& obj : spawnRemap) {
            m_spawnRemapTriggers.back()[obj.m_groupID] = obj.m_chance;
        }
        return m_spawnRemapTriggers.size() - 1;
    }
    void registerStateObject(EffectGameObject* object) = win inline {
        m_gameState.m_stateObjects[object->m_uniqueID] = object;
    }
    void removeBackground() = win inline {
        if (m_background) {
            m_background->removeFromParent();
            m_background = nullptr;
        }
    }
    void removeCustomEnterEffects(int id, bool enter) = win inline, ios inline {
        if (id > 100) return;
        if (enter) m_gameState.m_enterEffectInstanceVectors.erase(id);
        else m_gameState.m_exitEffectInstanceVectors.erase(id);
    }
    void removeFromGroupParents(GameObject* object) = win inline {
        if (object->m_hasGroupParentsString) {
            if (auto groupIDs = static_cast<cocos2d::CCArray*>(m_removedParentGroupIDs->objectForKey(object->m_uniqueID))) {
                for (int i = 0; i < groupIDs->count(); i++) {
                    m_parentGroupsDict->removeObjectForKey(static_cast<cocos2d::CCInteger*>(groupIDs->objectAtIndex(i))->getValue());
                }
                m_removedParentGroupIDs->removeObjectForKey(object->m_uniqueID);
                m_parentGroupIDs->removeObjectForKey(object->m_uniqueID);
            }
        }
    }
    void removeFromGroups(GameObject* object) = win 0x2240f0;
    void removeFromStickyGroup(GameObject* object) = win inline {
        if (object->m_linkedGroup != 0) {
            if (auto stickyGroup = this->getStickyGroup(object->m_linkedGroup)) stickyGroup->removeObject(object);
            m_stickyGroups[object->m_uniqueID] = object->m_linkedGroup;
            object->m_linkedGroup = 0;
        }
    }
    void removeGroundLayer() = win inline {
        if (m_groundLayer) {
            m_groundLayer->removeFromParent();
            m_groundLayer = nullptr;
            m_groundLayer2->removeFromParent();
            m_groundLayer2 = nullptr;
        }
    }
    void removeGroupParent(int groupID) = win 0x2247c0;
    void removeKeyframe(KeyframeGameObject* object) = win inline {
        if (auto keyframeGroup = static_cast<cocos2d::CCArray*>(m_keyframeGroups->objectForKey(object->m_keyframeGroup))) {
            keyframeGroup->removeObject(object);
            this->updateKeyframeOrder(object->m_keyframeGroup);
        }
    }
    void removeMiddleground() = win inline {
        if (m_middleground) {
            m_middleground->removeFromParent();
            m_middleground = nullptr;
        }
    }
    void removeObjectFromSection(GameObject* object) = win 0x226d90;
    void removePlayer2() = win inline {
        m_player2->removeFromParentAndCleanup(true);
        m_player2->setOpacity(0);
        m_player2->releaseAllButtons();
        m_player2->removeAllParticles();
        m_player2->deactivateStreak(true);
    }
    void removeTemporaryParticles() = win inline {
        for (int i = 0; i < m_temporaryParticles->count();) {
            auto particle = static_cast<cocos2d::CCParticleSystem*>(m_temporaryParticles->objectAtIndex(i));
            if (particle->isAutoRemoveOnFinish()) {
                particle->removeMeAndCleanup();
                m_customParticlesUIDs.erase(particle->m_uID);
                m_temporaryParticles->fastRemoveObjectAtIndex(i);
            }
            else i++;
        }
    }
    void reorderObjectSection(GameObject* object) = win inline {
        this->removeObjectFromSection(object);
        this->addToSection(object);
    }
    void reparentObject(cocos2d::CCNode* node, cocos2d::CCNode* parent) = win inline {
        if (parent == node->getParent() || node->getTag() == -9999) return;
        node->retain();
        node->removeFromParentAndCleanup(false);
        parent->addChild(node, node->getZOrder());
        node->release();
    }
    void resetActiveEnterEffects() = win 0x20e3d0;
    bool resetAreaObjectValues(GameObject* object, bool update) = win 0x227c60 {
        if (m_gameState.m_unkUint2 <= object->m_unk4C8) return false;
        if (update) this->updateAreaObjectLastValues(object);
        auto result = false;
        if (object->m_positionXOffset != 0.f) {
            object->m_positionX -= object->m_positionXOffset;
            object->m_positionXOffset = 0.f;
            object->m_isUnmodifiedPosDirty = true;
            result = true;
        }
        if (object->m_positionYOffset != 0.f) {
            object->m_positionY -= object->m_positionYOffset;
            object->m_positionYOffset = 0.f;
            object->m_isUnmodifiedPosDirty = true;
            result = true;
        }
        if (object->m_unk2BC != 0.f || object->m_unk2C0 != 0.f) {
            object->m_scaleXOffset -= object->m_unk2BC;
            object->m_scaleX -= object->m_unk2BC;
            object->m_scaleYOffset -= object->m_unk2C0;
            object->m_scaleY -= object->m_unk2C0;
            object->m_unk2BC = 0.f;
            object->m_unk2C0 = 0.f;
            if (!update) object->setRScale(1.f);
        }
        if (object->m_unk2A8 != 0.f || object->m_unk2B0 != 0.f) {
            object->m_rotationXOffset -= object->m_unk2A8;
            object->m_rotationYOffset -= object->m_unk2B0;
            object->m_unk2A8 = 0.f;
            object->m_unk2B0 = 0.f;
            if (!update) object->setRRotation(0.f);
        }
        object->m_unk4C8 = m_gameState.m_unkUint2;
        if (update) {
            if (m_areaObjectsCount < m_areaObjectsIndex) {
                m_areaObjects[m_areaObjectsCount++] = object;
            }
            else {
                m_areaObjects.push_back(object);
                m_areaObjectsIndex++;
                m_areaObjectsCount++;
            }
        }
        else this->updateAreaObjectLastValues(object);
        return result;
    }
    void resetAudio() = win 0x237550;
    void resetCamera() = win 0x23f910;
    void resetGradientLayers() = win 0x220fd0;
    void resetGroupCounters(bool reset) = win inline {
        for (auto& pair : m_labelObjects) {
            for (auto label : pair.second) {
                if (reset) label->updateLabel("0");
                else label->updatePreviewLabel();
            }
        }

        for (auto& pair : m_timeLabelObjects) {
            for (auto label : pair.second) {
                if (reset) label->updateLabel(label->m_showSecondsOnly ? "0" : "0.00");
                else label->updatePreviewLabel();
            }
        }
    }
    void resetLevelVariables() = win 0x23ae80;
    void resetMoveOptimizedValue() = win inline {
        CCObject* obj;
        CCARRAY_FOREACH(m_objects, obj) {
            auto object = static_cast<GameObject*>(obj);
            object->m_isDecoration2 = object->m_isDecoration;
        }
    }
    void resetPlayer() = win 0x2120f0;
    void resetSongTriggerValues() = win inline, ios inline {
        m_gameState.m_proximityVolumeRelated.clear();
        m_gameState.m_levelTime = 0.0;
    }
    void resetSpawnChannelIndex() = win 0x245c30;
    void resetStaticCamera(bool resetX, bool resetY) = win 0x23fbf0;
    void resetStoppedAreaObjects() = win inline {
        if (m_areaObjectsCount > 0) {
            for (size_t i = 0; i < m_areaObjectsCount; i++) {
                auto object = m_areaObjects[i];
                object->m_isDirty = true;
                object->m_isObjectRectDirty = true;
                object->m_isOrientedBoxDirty = true;
                if (this->resetAreaObjectValues(object, false)) {
                    this->updateObjectSection(object);
                }
                object->setRRotation(0.f);
                object->setRScale(1.f);
            }
        }
    }
    void restoreAllUIObjects() = win inline {
        CCObject* obj;
        CCARRAY_FOREACH(m_uiObjects, obj) {
            auto object = static_cast<GameObject*>(obj);
            object->setStartPos(m_uiObjectPositions[object->m_uniqueID]);
            object->deactivateObject(true);
            object->m_outerSectionIndex = 0;
            object->m_isUIObject = false;
            this->addToSection(object);
            m_objectsToDeactivate->setObject(object, object->m_uniqueID);
            object->m_unk3ee = true;
        }
        m_uiObjects->removeAllObjects();
        m_uiObjectPositions.clear();
        m_calcCollisionBlockObjects2.clear();
        m_calcCollisionBlockObjects2Size = 0;
    }
    void restoreDefaultGameplayOffsetX() = win inline, ios inline {
        this->updateGameplayOffsetX(75, false);
    }
    void restoreDefaultGameplayOffsetY() = win inline, ios inline {
        this->updateGameplayOffsetY(75, false);
    }
    void restoreRemap(EffectGameObject* object, gd::unordered_map<int, int>& remap) = win 0x21cfd0;
    void resumeAudio() = win 0x237440;
    void rotateAreaObjects(GameObject* object, cocos2d::CCArray* objects, float rotation, bool reset) = win 0x22a130;
    void rotateObject(GameObject* object, float rotation) = win 0x22c130;
    void rotateObjects(cocos2d::CCArray* objects, float rotation, cocos2d::CCPoint position, cocos2d::CCPoint offset, bool finished, bool unused) = win 0x22c1d0;
    void setGroupParent(GameObject* object, int groupID) = win 0x2246b0;
    void setStartPosObject(StartPosObject* startPos) = win inline {
        if (startPos != m_startPosObject) {
            if (startPos) {
                startPos->retain();
            }
            if (m_startPosObject) {
                m_startPosObject->release();
            }
            m_startPosObject = startPos;
        }
    }
    void setupLayers() = win 0x208ae0;
    void setupLevelStart(LevelSettingsObject* settings) = win 0x212260;
    void setupReplay(gd::string inputs);
    void shakeCamera(float duration, float strength, float interval) = win 0x23ba60;
    bool shouldExitHackedLevel() = win 0x20b090;
    void sortAllGroupsX() = win inline {
        for (int i = 0; i < 10000; i++) {
            if (auto group = m_groups[i]) {
                qsort(group->data->arr, group->data->num, sizeof(GameObject*), [](const void* a, const void* b) {
                    auto objA = *static_cast<GameObject* const*>(a);
                    auto objB = *static_cast<GameObject* const*>(b);
                    return (int)objA->getPosition().x - (int)objB->getPosition().x;
                });
            }
        }
    }
    void sortGroups() = win 0x224320;
    void sortSectionVector() = win 0x226fd0;
    void sortStickyGroups() = win 0x224a30;
    void spawnGroupTriggered(int targetID, float delay, bool spawnOrdered, gd::vector<int> const& remapKeys, int uniqueID, int controlID) = win inline {
        if (delay > 0.f) m_effectManager->spawnGroup(targetID, delay, spawnOrdered, remapKeys, uniqueID, controlID);
        else this->spawnGroup(targetID, spawnOrdered, -delay, remapKeys, uniqueID, controlID);
    }
    void spawnObjectsInOrder(cocos2d::CCArray* objects, double delay, gd::vector<int> const& remapKeys, int uniqueID, int controlID) = win 0x21ae30;
    cocos2d::CCParticleSystemQuad* spawnParticle(char const* plist, int zOrder, cocos2d::tCCPositionType positionType, cocos2d::CCPoint position) = win 0x2400f0;
    void spawnParticleTrigger(SpawnParticleGameObject* object) = win inline {
        auto rotation = object->m_rotation + (((float)rand() / (float)RAND_MAX) * 2.f - 1.f) * object->m_rotationVariance;
        auto scale = object->m_scale + (((float)rand() / (float)RAND_MAX) * 2.f - 1.f) * object->m_scaleVariance;
        auto position = this->getPosition();
        auto centerID = object->m_centerGroupID;
        if (centerID > 0) {
            if (auto groupObject = this->tryGetObject(centerID)) {
                position = groupObject->getPosition();
                if (object->m_matchRotation) rotation += groupObject->getRotation();
            }
        }
        position.x += object->m_offset.x + (((float)rand() / (float)RAND_MAX) * 2.f - 1.f) * object->m_offsetVariance.x;
        position.y += object->m_offset.y + (((float)rand() / (float)RAND_MAX) * 2.f - 1.f) * object->m_offsetVariance.y;
        this->spawnParticleTrigger(object->m_targetGroupID, position, rotation, scale);
    }
    void spawnParticleTrigger(int particleID, cocos2d::CCPoint position, float rotation, float scale) = win 0x23fcc0;
    void spawnPlayer2() = win inline {
        auto parent = m_player2->getParent();
        if (!parent) {
            m_player1->getParent()->addChild(m_player2, 59);
            if (!m_isEditor) m_player2->addAllParticles();
        }
        m_player2->spawnFromPlayer(m_player1, m_gameState.m_unkBool31);
    }
    cocos2d::CCPoint speedForShaderTarget(int groupID) = win 0x223630;
    cocos2d::CCArray* staticObjectsInRect(cocos2d::CCRect rect, bool enabledGroups) = win 0x2112a0;
    void stopAllGroundActions() = win inline, ios inline {
        m_groundLayer->deactivateGround();
        m_groundLayer2->deactivateGround();
    }
    void stopCameraShake() = win inline {
        m_gameState.m_cameraShakeEnabled = false;
        m_gameState.m_cameraShakeFactor = 0.f;
    }
    void stopCustomEnterEffect(EnterEffectObject* object) = win inline {
        auto enterType = object->m_enterType;
        if (enterType == 0 || enterType == 1) this->stopCustomEnterEffect(object, true);
        if (enterType == 0 || enterType == 2) this->stopCustomEnterEffect(object, false);
    }
    void stopCustomEnterEffect(EnterEffectObject* object, bool enter) = win 0x20e7a0;
    void stopSFXTrigger(SFXTriggerGameObject* object) = win inline {
        if (object->m_objectID != 3602) return;
        auto engine = FMODAudioEngine::sharedEngine();
        for (auto& channel : m_gameState.m_unkUMap8[object->m_uniqueID]) {
            engine->stopChannel(channel);
            m_gameState.m_proximityVolumeRelated.erase({ channel, 0 });
        }
        m_gameState.m_unkUMap8[object->m_uniqueID].clear();
    }
    void swapBackground(int background) = win inline {
        m_gameState.m_background = background;
        if (m_skipArtReload) return;
        auto gameManager = GameManager::sharedState();
        if (background != gameManager->m_loadedBgID) gameManager->loadBackgroundAsync(background);
        else this->asyncBGLoaded(background);
    }
    void swapGround(int ground) = win inline {
        m_gameState.m_ground = ground;
        if (m_skipArtReload) return;
        auto gameManager = GameManager::sharedState();
        if (ground != gameManager->m_loadedGroundID) gameManager->loadGroundAsync(ground);
    }
    void swapMiddleground(int middleground) = win inline {
        m_gameState.m_middleground = middleground;
        if (m_skipArtReload) return;
        auto gameManager = GameManager::sharedState();
        if (middleground == gameManager->m_loadedMG && (middleground < 1 || !m_middleground)) return;
        if (middleground == 0) this->createMiddleground(0);
        else {
            if (middleground != gameManager->m_loadedMG) gameManager->loadMiddlegroundAsync(middleground);
            else this->asyncMGLoaded(middleground);
        }
    }
    void switchToFlyMode(PlayerObject* player, GameObject* object, bool noPortal, int type) = win inline {
        player->switchedToMode((GameObjectType)type);
        auto cameraObject = this->processCameraObject(object, player);
        auto noEffects = cameraObject && cameraObject->m_hasNoEffects;
        switch (type) {
            case 5:
                player->toggleFlyMode(true, noEffects);
                break;
            case 19:
                player->toggleBirdMode(true, noEffects);
                break;
            case 26:
                player->toggleDartMode(true, noEffects);
                break;
            case 41:
                player->toggleSwingMode(true, noEffects);
                break;
        }
        this->toggleGlitter(true);
    }
    void switchToRobotMode(PlayerObject* player, GameObject* object, bool noPortal);
    void switchToRollMode(PlayerObject* player, GameObject* object, bool noPortal);
    void switchToSpiderMode(PlayerObject* player, GameObject* object, bool noPortal);
    void syncBGTextures() = win 0x23ade0;
    void teleportPlayer(TeleportPortalObject* object, PlayerObject* player) = win 0x20fdf0;
    void testInstantCountTrigger(int itemID, int compareCount, int groupID, bool activateGroup, int triggerMode, gd::vector<int> const& remapKeys, int uniqueID, int controlID) = win inline {
        auto itemCount = m_effectManager->countForItem(itemID);
        switch (triggerMode) {
            case 0:
                if (itemCount != compareCount) return;
                break;
            case 1:
                if (itemCount <= compareCount) return;
                break;
            case 2:
                if (itemCount >= compareCount) return;
                break;
        }
        this->toggleGroupTriggered(groupID, activateGroup, remapKeys, uniqueID, controlID);
    }
    void toggleAudioVisualizer(bool visible) = win 0x2488f0;
    void toggleDualMode(GameObject* object, bool dual, PlayerObject* player, bool noEffects) = win 0x216900;
    void toggleFlipped(bool flip, bool noEffects) = win 0x2465e0;
    void toggleGroup(int id, bool activate) = win 0x223bf0;
    void toggleLockPlayer(bool disable, bool player2) = win inline, ios inline {
        auto player = player2 ? m_player2 : m_player1;
        if (disable) player->disablePlayerControls();
        else player->enablePlayerControls();
    }
    void togglePlayerStreakBlend(bool blend) = win inline {
        if (blend != m_gameState.m_playerStreakBlend) {
            m_gameState.m_playerStreakBlend = blend;
            m_player1->updateStreakBlend(blend);
            m_player2->updateStreakBlend(blend);
        }
    }
    void togglePlayerVisibility(bool visible) = win inline {
        this->togglePlayerVisibility(visible, true);
        this->togglePlayerVisibility(visible, false);
    }
    void togglePlayerVisibility(bool visible, bool player1) = win inline, ios inline {
        if (player1)
            this->m_player1->toggleVisibility(visible);
        else
            this->m_player2->toggleVisibility(visible);
    }
    void transformAreaObjects(GameObject* object, cocos2d::CCArray* objects, float scaleX, float scaleY, bool reset) = win 0x229750;
    void triggerAdvancedFollowCommand(AdvancedFollowTriggerObject* object) = win inline {
        auto targetID = object->m_centerGroupID;
        if (object->m_targetPlayer1) targetID = -1;
        else if (object->m_targetPlayer2) targetID = -2;
        else if (object->m_followCPP) targetID = -3;
        auto exists = false;
        for (auto& inst : m_gameState.m_advanceFollowInstances) {
            if (inst.m_gameObject != object || inst.m_group != object->m_targetGroupID || inst.m_objectKey != targetID || inst.m_controlId != object->m_controlID) continue;
            inst.m_finished = false;
            inst.m_doStart = false;
            inst.m_relatedToGJGameStateUnkUint7 = ++m_gameState.m_unkUint7;
            exists = true;
        }
        if (!exists) {
            m_gameState.m_advanceFollowInstances.emplace_back(object, object->m_targetGroupID, targetID, 0, ++m_gameState.m_unkUint7, object->m_controlID);
        }
    }
    void triggerAdvancedFollowEditCommand(AdvancedFollowEditObject* object) = win 0x22eaf0;
    void triggerAreaEffect(EnterEffectObject* object) = win 0x2271f0;
    void triggerAreaEffectAnimation(EnterEffectObject* object) = win inline {
        auto targetID = object->m_targetGroupID;
        if (object->m_useEffectID) {
            for (int i = 0; i < 5; i++) {
                std::vector<EnterEffectInstance>* instances;
                switch (i) {
                    case 0: instances = &m_gameState.m_moveEffectInstances; break;
                    case 1: instances = &m_gameState.m_rotateEffectInstances; break;
                    case 2: instances = &m_gameState.m_scaleEffectInstances; break;
                    case 3: instances = &m_gameState.m_fadeEffectInstances; break;
                    case 4: instances = &m_gameState.m_tintEffectInstances; break;
                    default: continue;
                }
                for (auto& inst : *instances) {
                    if (inst.m_gameObject->m_effectID == targetID) {
                        inst.loadTransitions(object, m_gameState.m_totalTime);
                        if (targetID > 0) break;
                    }
                    else break;
                }
            }
        }
        else {
            auto group = this->getGroup(targetID);
            CCObject* obj;
            CCARRAY_FOREACH(group, obj) {
                auto groupObject = static_cast<GameObject*>(obj);
                if (groupObject->m_unk390 != 45) continue;
                std::vector<EnterEffectInstance>* instances;
                switch (groupObject->m_objectID) {
                    case 3006: instances = &m_gameState.m_moveEffectInstances; break;
                    case 3007: instances = &m_gameState.m_rotateEffectInstances; break;
                    case 3008: instances = &m_gameState.m_scaleEffectInstances; break;
                    case 3009: instances = &m_gameState.m_fadeEffectInstances; break;
                    case 3010: instances = &m_gameState.m_tintEffectInstances; break;
                    default: continue;
                }
                for (auto& inst : *instances) {
                    if (inst.m_gameObject == groupObject) {
                        inst.loadTransitions(object, m_gameState.m_totalTime);
                    }
                }
            }
        }
    }
    void triggerDynamicMoveCommand(EffectGameObject* object) = win inline {
        auto targetID = object->m_targetModCenterID;
        if (targetID < 1) targetID = object->m_targetGroupID;
        auto object1 = this->tryGetObject(targetID);
        GameObject* object2;
        if (!object->m_targetPlayer1) {
            if (!object->m_targetPlayer2) object2 = this->tryGetObject(object->m_centerGroupID);
            else if (m_gameState.m_isDualMode) object2 = m_player2;
            else object2 = m_player1;
        }
        else object2 = m_player1;
        if (object1 && object2) {
            m_gameState.m_dynamicMoveActions.emplace_back(object, object1, object2);
        }
    }
    void triggerDynamicRotateCommand(EnhancedTriggerObject* object) = win 0x21f2d0;
    void triggerGradientCommand(GradientTriggerObject* object) = win 0x21f780;
    void triggerGravityChange(EffectGameObject* object, int playerID) = win inline {
        if (object->m_followCPP) {
            if (playerID == 1) m_player1->m_gravityMod = object->m_gravityValue;
            else if (playerID == 2) m_player2->m_gravityMod = object->m_gravityValue;
        }
        else {
            if (object->m_targetPlayer1) m_player1->m_gravityMod = object->m_gravityValue;
            else if (object->m_targetPlayer2) m_player2->m_gravityMod = object->m_gravityValue;
        }
    }
    void triggerMoveCommand(EffectGameObject* object) = win 0x21ea70;
    void triggerRotateCommand(EnhancedTriggerObject* object) = win inline {
        if (object->m_isDynamicMode && object->m_duration != 0.f) {
            if (object->m_useMoveTarget || object->m_isDirectionFollowSnap360) {
                this->triggerDynamicRotateCommand(object);
            }
        }
        else {
            auto rotation = object->m_times360 * 360.f + object->m_rotationDegrees;
            if (object->m_useMoveTarget || object->m_isDirectionFollowSnap360) {
                GameObject* centerObject;
                GameObject* targetObject;
                GameObject* rotateObject;
                this->getRotateCommandTargets(object, centerObject, targetObject, rotateObject);
                if (centerObject && targetObject && rotateObject) {
                    auto minXObject = this->tryGetObject(object->m_minXID);
                    auto minYObject = this->tryGetObject(object->m_minYID);
                    auto maxXObject = this->tryGetObject(object->m_maxXID);
                    auto maxYObject = this->tryGetObject(object->m_maxYID);
                    auto centerPosition = centerObject->getRealPosition();
                    auto targetPosition = targetObject->getRealPosition();
                    auto rotatePosition = rotateObject->getRealPosition();
                    if (centerObject == targetObject) {
                        rotation = centerObject->getRotation();
                    }
                    else {
                        auto difference = targetPosition - centerPosition;
                        if (sqrtf(difference.x * difference.x + difference.y * difference.y) < .01f) {
                            rotation = centerObject->getRotation();
                        }
                        else {
                            rotation = 90.f - atan2f(difference.y, difference.x) * (180.f / M_PI);
                        }
                    }
                    auto distance = 0.f;
                    if (centerObject != targetObject) {
                        if (object->m_useMoveTarget) {
                            if (minXObject) {
                                auto minX = minXObject->getRealPosition().x;
                                if (rotatePosition.x < minX) rotatePosition.x = minX;
                            }
                            if (maxXObject) {
                                auto maxX = maxXObject->getRealPosition().x;
                                if (rotatePosition.x > maxX) rotatePosition.x = maxX;
                            }
                            if (minYObject) {
                                auto minY = minYObject->getRealPosition().y;
                                if (rotatePosition.y < minY) rotatePosition.y = minY;
                            }
                            if (maxYObject) {
                                auto maxY = maxYObject->getRealPosition().y;
                                if (rotatePosition.y > maxY) rotatePosition.y = maxY;
                            }
                            auto difference = rotatePosition - centerPosition;
                            if (sqrtf(difference.x * difference.x + difference.y * difference.y) >= .01f) {
                                distance = 90.f - atan2f(difference.y, difference.x) * (180.f / M_PI);
                            }
                        }
                        else {
                            distance = rotateObject->getRotation();
                        }
                    }
                    rotation = convertToClosestDirection(distance - rotation + object->m_rotationOffset, 180.f);
                }
                m_effectManager->createRotateCommand(rotation, object->m_duration, object->m_targetGroupID, object->m_centerGroupID,
                    (int)object->m_easingType, object->m_easingRate, object->m_lockObjectRotation, false, false, object->m_uniqueID, object->m_controlID);
            }
        }
    }
    void triggerShaderCommand(ShaderGameObject* object) = win 0x221060;
    void triggerTransformCommand(TransformTriggerGameObject* object) = win 0x21f4f0;
    GameObject* tryGetGroupParent(int groupID) = win inline, ios inline {
        if (auto groupParent = static_cast<GameObject*>(m_parentGroupsDict->objectForKey(groupID))) return groupParent;
        auto group = this->getGroup(groupID);
        CCObject* obj;
        CCARRAY_FOREACH(group, obj) {
            auto object = static_cast<GameObject*>(obj);
            if (object->m_hasGroupParent) return object;
        }
        return nullptr;
    }
    GameObject* tryGetMainObject(int groupID) = win 0x224550;
    GameObject* tryGetObject(int groupID) = win 0x2245c0;
    void tryResumeAudio() = win inline {
        if (m_resumeTimer < 1 && m_audioPaused) {
            this->resumeAudio();
            m_audioPaused = false;
        }
    }
    void unclaimParticle(char const* key, cocos2d::CCParticleSystemQuad* particle) = win 0x2409f0;
    void ungroupStickyObjects(cocos2d::CCArray* objects) = win 0x224cb0;
    void unlinkAllEvents() = win inline, ios inline {
        m_gameState.m_unkMapPairGJGameEventIntVectorEventTriggerInstance.clear();
    }
    void updateActiveEnterEffect(EnterEffectObject* object) = win inline {
        auto id = -2;
        switch (object->m_objectID) {
            case 23: id = -6; break;
            case 24: id = -5; break;
            case 25: id = -7; break;
            case 26: id = -8; break;
            case 27: id = -3; break;
            case 28: id = -4; break;
            case 55: id = -11; break;
            case 56: id = -10; break;
            case 57: id = -9; break;
            case 58: id = -12; break;
            case 59: id = -13; break;
            case 1915: id = -14; break;
            case 3017: case 3018: case 3019: case 3020: case 3021: id = -15; break;
        }
        auto enterType = object->m_enterType;
        if (enterType == 0 || enterType == 1) {
            m_gameState.m_enterChannelMap[object->m_enterChannel] = id;
            if (id == -15) this->addCustomEnterEffect(object, true);
            else this->removeCustomEnterEffects(id, true);
        }
        if (enterType == 0 || enterType == 2) {
            m_gameState.m_exitChannelMap[object->m_enterChannel] = id;
            if (id == -15) this->addCustomEnterEffect(object, false);
            else this->removeCustomEnterEffects(id, false);
        }
    }
    void updateAllObjectSection() = win inline {
        CCObject* obj;
        CCARRAY_FOREACH(m_objects, obj) {
            this->updateObjectSection(static_cast<GameObject*>(obj));
        }
    }
    void updateAreaObjectLastValues(GameObject* object) = win 0x227ee0 {
        if (object->m_isDecoration2) return;
        if (object->m_unk4C4 != m_gameState.m_unkUint2) {
            object->m_lastPosition.x = object->m_positionX;
            object->m_lastPosition.y = object->m_positionY;
            object->m_unk4C4 = m_gameState.m_unkUint2;
            object->dirtifyObjectRect();
        }
        if (object->m_unk4CC != m_gameState.m_unkUint2) {
            object->m_customScaleX = object->m_scaleX;
            object->m_customScaleY = object->m_scaleY;
            object->m_unk4CC = m_gameState.m_unkUint2;
            object->dirtifyObjectRect();
        }
    }
    void updateAudioVisualizer() = win 0x248690;
    void updateBGArtSpeed(float modX, float modY) = win inline {
        m_gameState.m_unkFloat5 = modX;
        m_gameState.m_unkFloat6 = modY;
    }
    void updateCamera(float dt) = win 0x23bb00;
    void updateCameraBGArt(cocos2d::CCPoint position, float zoom) = win 0x23e260;
    void updateCameraEdge(int direction, int value) = win inline {
        switch (direction) {
            case 1:
                m_gameState.m_cameraEdgeValue0 = value;
                break;
            case 2:
                m_gameState.m_cameraEdgeValue1 = value;
                break;
            case 3:
                m_gameState.m_cameraEdgeValue2 = value;
                break;
            case 4:
                m_gameState.m_cameraEdgeValue3 = value;
                break;
        }
    }
    void updateCameraMode(EffectGameObject* obj, bool updateDual) = win inline {
        auto cameraFree = obj->m_cameraIsFreeMode;
        auto freeMode = m_gameState.m_unkBool8;
        m_gameState.m_unkBool8 = cameraFree;
        m_gameState.m_unkBool9 = obj->m_cameraDisableGridSnap;
        if (obj->m_cameraEditCameraSettings) {
            m_gameState.m_unkFloat3 = std::clamp(obj->m_cameraEasingValue, 1.f, 40.f);
            m_gameState.m_unkFloat2 = std::clamp(obj->m_cameraPaddingValue, 0.f, 1.f);
        }
        if (cameraFree != freeMode && updateDual) this->updateDualGround(m_player1, m_gameState.m_dualRelated, false, 0.f);
    }
    void updateCameraOffsetX(float offsetX, float duration, int easingType, float easingRate, int uniqueID, int controlID) = win 0x235db0;
    void updateCameraOffsetY(float offsetY, float duration, int easingType, float easingRate, int uniqueID, int controlID) = win 0x235e50;
    void updateCollisionBlocks() = win 0x218800;
    void updateCounters(int itemId, int value) = win 0x233d00;
    void updateDualGround(PlayerObject* object, int mode, bool instant, float duration) = win 0x2131c0;
    void updateEnterEffects(float dt) = win 0x20e9a0;
    void updateExtendedCollision(GameObject* object, bool extendedCollision) = win inline {
        if (object->m_hasExtendedCollision != extendedCollision) {
            this->removeObjectFromSection(object);
            object->m_hasExtendedCollision = extendedCollision;
            this->addToSection(object);
        }
    }
    void updateExtraGameLayers() = win 0x223880;
    void updateGameplayOffsetX(int offsetX, bool staticOffset) = win inline {
        m_gameState.m_unkInt1 = offsetX;
        m_gameState.m_unkBool2 = staticOffset;
    }
    void updateGameplayOffsetY(int offsetY, bool staticOffset) = win inline {
        m_gameState.m_unkInt2 = offsetY;
        m_gameState.m_unkBool3 = staticOffset;
    }
    void updateGradientLayers() = win 0x21fc10;
    void updateGroundShadows() = win 0x20bda0;
    void updateGuideArt() = win 0x2464d0;
    void updateInternalCamOffsetX(float offsetX, float duration, float easingRate) = win inline, ios inline {
        m_gameState.m_unkPoint27.x = offsetX;
        if (duration > 0.f) {
            m_gameState.tweenValue(m_gameState.m_unkPoint26.x, offsetX, 18, duration, 1, easingRate, -1, -1);
        }
        else {
            m_gameState.stopTweenAction(18);
            m_gameState.m_unkPoint26.x = m_gameState.m_unkPoint27.x;
        }
    }
    void updateInternalCamOffsetY(float offsetY, float duration, float easingRate) = win inline, ios inline {
        m_gameState.m_unkPoint27.y = offsetY;
        if (duration > 0.f) {
            m_gameState.tweenValue(m_gameState.m_unkPoint26.y, offsetY, 19, duration, 1, easingRate, -1, -1);
        }
        else {
            m_gameState.stopTweenAction(10);
            m_gameState.m_unkPoint26.y = m_gameState.m_unkPoint27.y;
        }
    }
    void updateKeyframeOrder(int keyframeGroup) = win 0x233a50;
    void updateLayerCapacity(gd::string capacityString) = win 0x20cd40;
    void updateLegacyLayerCapacity(int front, int frontBlend, int back, int backBlend) = win inline {
        if (front < 100) front = 100;
        if (frontBlend < 100) frontBlend = 100;
        if (back < 100) back = 100;
        if (backBlend < 100) backBlend = 100;
        m_gameLayerT1->increaseAtlasCapacity(front);
        m_gameBlendingLayerT1->increaseAtlasCapacity(frontBlend);
        m_game2LayerT1->increaseAtlasCapacity(20);
        m_game2BlendingLayerT1->increaseAtlasCapacity(20);
        m_game2LayerB1->increaseAtlasCapacity(20);
        m_gameLayerB1->increaseAtlasCapacity(back);
        m_gameBlendingLayerB1->increaseAtlasCapacity(backBlend);
        m_gameLayerB2->increaseAtlasCapacity(back);
        m_gameBlendingLayerB2->increaseAtlasCapacity(backBlend);
        m_glowLayerT1->increaseAtlasCapacity(frontBlend / 2);
        m_glowLayerB1->increaseAtlasCapacity(backBlend / 2);
        m_glowLayerB2->increaseAtlasCapacity(backBlend / 2);
    }
    void updateLevelColors() = win 0x20c4d0;
    void updateMaxGameplayY() = win 0x23ad00;
    void updateMGArtSpeed(float modX, float modY) = win inline {
        m_gameState.m_unkFloat7 = modX;
        m_gameState.m_unkFloat8 = modY;
    }
    void updateMGOffsetY(float offsetY, float duration, int easingType, float easingRate, int uniqueID, int controlID) = win 0x235ef0;
    void updateOBB2(cocos2d::CCRect rect) = win inline {
        m_obb2->calculateWithCenter(rect.size * .5f, rect.size.width, rect.size.height, 0.f);
    }
    void updateParticles(float dt) = win 0x241150;
    void updatePlatformerTime() = win 0x239500;
    void updatePlayerCollisionBlocks() = win 0x2185d0;
    void updateProximityVolumeEffects() = win 0x242130;
    void updateQueuedLabels() = win inline {
        for (auto& pair : m_labelObjects) {
            for (auto label : pair.second) {
                if (label->m_isActivated) label->updateLabelIfDirty();
            }
        }
        for (auto& pair : m_timeLabelObjects) {
            for (auto label : pair.second) {
                if (label->m_isActivated) label->updateLabelIfDirty();
            }
        }
    }
    void updateReplay() = win inline {
        if (!m_useReplay) return;
        for (auto it = m_queuedReplayButtons.begin(); it != m_queuedReplayButtons.end() && it->m_step <= m_gameState.m_unkUint2;) {
            this->handleButton(it->m_isPush, (int)it->m_button, it->m_isPlayer2);
            it = m_queuedReplayButtons.erase(it);
        }
    }
    void updateSavePositionObjects() = win inline {
        if (m_gameState.m_unkUint4 != 0 && m_gameState.m_unkUint4 + 1000 > m_gameState.m_unkUint5) return;
        m_gameState.m_unkUint4 = m_gameState.m_unkUint5;
        m_gameState.m_unkUint11++;
        for (auto& pair : m_savePositionValues) {
            cocos2d::CCPoint position;
            auto type = pair.first;
            auto value = pair.second;
            auto offset = 0;
            if (type < 1) {
                switch (type) {
                    case -1:
                        offset = m_player1->m_unk52C;
                        position = m_player1->m_lastPosition;
                        break;
                    case -2:
                        offset = m_player2->m_unk52C;
                        position = m_player2->m_lastPosition;
                        break;
                    case -3:
                        offset = m_gameState.m_unkUint12;
                        position = m_gameState.m_cameraPosition2;
                        break;
                }
            }
            else {
                auto object = m_savePositionObjects[type];
                offset = object->m_unk52C;
                position = object->m_lastPosition;
            }
            auto index = (m_gameState.m_unkUint11 % value + offset) * 2;
            m_gameState.m_unkVecFloat1[index] = position.x;
            m_gameState.m_unkVecFloat1[index + 1] = position.y;
        }
    }
    void updateShaderLayer(float dt) = win 0x2222e0;
    void updateSpecialGroupData();
    void updateSpecialLabels() = win 0x239220;
    void updateStaticCameraPos(cocos2d::CCPoint pos, bool staticX, bool staticY, bool followOrSmoothEase, float time, int easingType, float easingRate) = win 0x23f040;
    void updateStaticCameraPosToGroup(int centerID, bool updateX, bool updateY, bool followObject, float followEase, float duration, int easingType, float easingRate, bool smoothVelocity, float velocityMod) = win 0x23ec50;
    void updateTimeMod(float speed, bool players, bool noEffects) = win inline {
        if (players) {
            m_gameState.m_timeModRelated = 0;
            m_gameState.m_timeModRelated2 = false;
            m_player1->updateTimeMod(speed, noEffects);
            if (m_gameState.m_isDualMode) m_player2->updateTimeMod(speed, noEffects);
        }
        else {
            m_gameState.m_timeModRelated = speed;
            m_gameState.m_timeModRelated2 = noEffects;
        }
    }
    void updateTimerLabels() = win 0x235080;
    void updateZoom(float zoom, float duration, int easing, float rate, int uniqueID, int controlID) = win 0x235b30;
    void visitWithColorFlash() = win 0x2480d0;
    float volumeForProximityEffect(SFXTriggerInstance& instance) = win 0x242400;

    PAD = win 0x8, android32 0x8, android64 0x8, imac 0x8, m1 0x8, ios 0x8;
    GJGameState m_gameState;
    GJGameLevel* m_level;
    PlaybackMode m_playbackMode;
    bool m_lowDetailMode;
    bool m_extraLDM;
    bool m_ignoreDamage;
    bool m_enable22Changes;
    bool m_allowStaticRotate;
    bool m_fixNegativeScale;
    bool m_startingFromBeginning;
    gd::vector<SFXTriggerGameObject*> m_activeSfxTriggers;
    gd::vector<void*> m_unk8a0;
    cocos2d::CCNode* m_hoverNode;
    cocos2d::CCNode* m_areaTransformNode;
    cocos2d::CCNode* m_areaSkewNode;
    cocos2d::CCNode* m_areaScaleNode;
    cocos2d::CCNode* m_areaRotateNode;
    cocos2d::CCNode* m_areaTransformNode2;
    OBB2D* m_obb2;
    gd::vector<gd::unordered_map<int,int>> m_spawnRemapTriggers;
    gd::unordered_map<int, cocos2d::CCPoint> m_uiObjectPositions;
    GJEffectManager* m_effectManager;
    cocos2d::CCSpriteBatchNode* m_gameBlendingLayerT5;
    cocos2d::CCSpriteBatchNode* m_fireBlendingLayerT5;
    cocos2d::CCSpriteBatchNode* m_pixelBlendingLayerT5;
    cocos2d::CCSpriteBatchNode* m_particleBlendingLayerT5;
    cocos2d::CCSpriteBatchNode* m_game2BlendingLayerT5;
    cocos2d::CCSpriteBatchNode* m_gameLayerT4;
    cocos2d::CCSpriteBatchNode* m_gameBlendingLayerT4;
    cocos2d::CCSpriteBatchNode* m_glowLayerT4;
    CCNodeContainer* m_specialLayerT4;
    cocos2d::CCSpriteBatchNode* m_textLayerT4;
    cocos2d::CCSpriteBatchNode* m_textBlendingLayerT4;
    cocos2d::CCSpriteBatchNode* m_fireLayerT4;
    cocos2d::CCSpriteBatchNode* m_fireBlendingLayerT4;
    cocos2d::CCSpriteBatchNode* m_pixelLayerT4;
    cocos2d::CCSpriteBatchNode* m_pixelBlendingLayerT4;
    cocos2d::CCSpriteBatchNode* m_particleLayerT4;
    cocos2d::CCSpriteBatchNode* m_particleBlendingLayerT4;
    cocos2d::CCSpriteBatchNode* m_game2LayerT4;
    cocos2d::CCSpriteBatchNode* m_game2BlendingLayerT4;
    cocos2d::CCSpriteBatchNode* m_gameLayerT3;
    cocos2d::CCSpriteBatchNode* m_gameBlendingLayerT3;
    cocos2d::CCSpriteBatchNode* m_glowLayerT3;
    CCNodeContainer* m_specialLayerT3;
    cocos2d::CCSpriteBatchNode* m_textLayerT3;
    cocos2d::CCSpriteBatchNode* m_textBlendingLayerT3;
    cocos2d::CCSpriteBatchNode* m_fireLayerT3;
    cocos2d::CCSpriteBatchNode* m_fireBlendingLayerT3;
    cocos2d::CCSpriteBatchNode* m_pixelLayerT3;
    cocos2d::CCSpriteBatchNode* m_pixelBlendingLayerT3;
    cocos2d::CCSpriteBatchNode* m_particleLayerT3;
    cocos2d::CCSpriteBatchNode* m_particleBlendingLayerT3;
    cocos2d::CCSpriteBatchNode* m_game2LayerT3;
    cocos2d::CCSpriteBatchNode* m_game2BlendingLayerT3;
    cocos2d::CCSpriteBatchNode* m_gameLayerT2;
    cocos2d::CCSpriteBatchNode* m_gameBlendingLayerT2;
    cocos2d::CCSpriteBatchNode* m_glowLayerT2;
    CCNodeContainer* m_specialLayerT2;
    cocos2d::CCSpriteBatchNode* m_textLayerT2;
    cocos2d::CCSpriteBatchNode* m_textBlendingLayerT2;
    cocos2d::CCSpriteBatchNode* m_fireLayerT2;
    cocos2d::CCSpriteBatchNode* m_fireBlendingLayerT2;
    cocos2d::CCSpriteBatchNode* m_pixelLayerT2;
    cocos2d::CCSpriteBatchNode* m_pixelBlendingLayerT2;
    cocos2d::CCSpriteBatchNode* m_particleLayerT2;
    cocos2d::CCSpriteBatchNode* m_particleBlendingLayerT2;
    cocos2d::CCSpriteBatchNode* m_game2LayerT2;
    cocos2d::CCSpriteBatchNode* m_game2BlendingLayerT2;
    cocos2d::CCSpriteBatchNode* m_gameLayerT1;
    cocos2d::CCSpriteBatchNode* m_gameBlendingLayerT1;
    cocos2d::CCSpriteBatchNode* m_glowLayerT1;
    CCNodeContainer* m_specialLayerT1;
    cocos2d::CCSpriteBatchNode* m_textLayerT1;
    cocos2d::CCSpriteBatchNode* m_textBlendingLayerT1;
    cocos2d::CCSpriteBatchNode* m_fireLayerT1;
    cocos2d::CCSpriteBatchNode* m_fireBlendingLayerT1;
    cocos2d::CCSpriteBatchNode* m_pixelLayerT1;
    cocos2d::CCSpriteBatchNode* m_pixelBlendingLayerT1;
    cocos2d::CCSpriteBatchNode* m_particleLayerT1;
    cocos2d::CCSpriteBatchNode* m_particleBlendingLayerT1;
    cocos2d::CCSpriteBatchNode* m_game2LayerT1;
    cocos2d::CCSpriteBatchNode* m_game2BlendingLayerT1;
    cocos2d::CCSpriteBatchNode* m_game2LayerB0;
    cocos2d::CCSpriteBatchNode* m_gameBlendingLayerB0;
    cocos2d::CCSpriteBatchNode* m_fireBlendingLayerB0;
    cocos2d::CCSpriteBatchNode* m_pixelBlendingLayerB0;
    cocos2d::CCSpriteBatchNode* m_particleBlendingLayerB0;
    cocos2d::CCSpriteBatchNode* m_game2BlendingLayerB0;
    cocos2d::CCSpriteBatchNode* m_gameLayerB1;
    cocos2d::CCSpriteBatchNode* m_gameBlendingLayerB1;
    cocos2d::CCSpriteBatchNode* m_glowLayerB1;
    CCNodeContainer* m_specialLayerB1;
    cocos2d::CCSpriteBatchNode* m_textLayerB1;
    cocos2d::CCSpriteBatchNode* m_textBlendingLayerB1;
    cocos2d::CCSpriteBatchNode* m_fireLayerB1;
    cocos2d::CCSpriteBatchNode* m_fireBlendingLayerB1;
    cocos2d::CCSpriteBatchNode* m_pixelLayerB1;
    cocos2d::CCSpriteBatchNode* m_pixelBlendingLayerB1;
    cocos2d::CCSpriteBatchNode* m_particleLayerB1;
    cocos2d::CCSpriteBatchNode* m_particleBlendingLayerB1;
    cocos2d::CCSpriteBatchNode* m_game2LayerB1;
    cocos2d::CCSpriteBatchNode* m_game2BlendingLayerB1;
    cocos2d::CCSpriteBatchNode* m_gameLayerB2;
    cocos2d::CCSpriteBatchNode* m_gameBlendingLayerB2;
    cocos2d::CCSpriteBatchNode* m_glowLayerB2;
    CCNodeContainer* m_specialLayerB2;
    cocos2d::CCSpriteBatchNode* m_textLayerB2;
    cocos2d::CCSpriteBatchNode* m_textBlendingLayerB2;
    cocos2d::CCSpriteBatchNode* m_fireLayerB2;
    cocos2d::CCSpriteBatchNode* m_fireBlendingLayerB2;
    cocos2d::CCSpriteBatchNode* m_pixelLayerB2;
    cocos2d::CCSpriteBatchNode* m_pixelBlendingLayerB2;
    cocos2d::CCSpriteBatchNode* m_particleLayerB2;
    cocos2d::CCSpriteBatchNode* m_particleBlendingLayerB2;
    cocos2d::CCSpriteBatchNode* m_game2LayerB2;
    cocos2d::CCSpriteBatchNode* m_game2BlendingLayerB2;
    cocos2d::CCSpriteBatchNode* m_gameLayerB3;
    cocos2d::CCSpriteBatchNode* m_gameBlendingLayerB3;
    cocos2d::CCSpriteBatchNode* m_glowLayerB3;
    CCNodeContainer* m_specialLayerB3;
    cocos2d::CCSpriteBatchNode* m_textLayerB3;
    cocos2d::CCSpriteBatchNode* m_textBlendingLayerB3;
    cocos2d::CCSpriteBatchNode* m_fireLayerB3;
    cocos2d::CCSpriteBatchNode* m_fireBlendingLayerB3;
    cocos2d::CCSpriteBatchNode* m_pixelLayerB3;
    cocos2d::CCSpriteBatchNode* m_pixelBlendingLayerB3;
    cocos2d::CCSpriteBatchNode* m_particleLayerB3;
    cocos2d::CCSpriteBatchNode* m_particleBlendingLayerB3;
    cocos2d::CCSpriteBatchNode* m_game2LayerB3;
    cocos2d::CCSpriteBatchNode* m_game2BlendingLayerB3;
    cocos2d::CCSpriteBatchNode* m_gameLayerB4;
    cocos2d::CCSpriteBatchNode* m_gameBlendingLayerB4;
    cocos2d::CCSpriteBatchNode* m_glowLayerB4;
    CCNodeContainer* m_specialLayerB4;
    cocos2d::CCSpriteBatchNode* m_textLayerB4;
    cocos2d::CCSpriteBatchNode* m_textBlendingLayerB4;
    cocos2d::CCSpriteBatchNode* m_fireLayerB4;
    cocos2d::CCSpriteBatchNode* m_fireBlendingLayerB4;
    cocos2d::CCSpriteBatchNode* m_pixelLayerB4;
    cocos2d::CCSpriteBatchNode* m_pixelBlendingLayerB4;
    cocos2d::CCSpriteBatchNode* m_particleLayerB4;
    cocos2d::CCSpriteBatchNode* m_particleBlendingLayerB4;
    cocos2d::CCSpriteBatchNode* m_game2LayerB4;
    cocos2d::CCSpriteBatchNode* m_game2BlendingLayerB4;
    cocos2d::CCSpriteBatchNode* m_gameLayerB5;
    cocos2d::CCSpriteBatchNode* m_gameBlendingLayerB5;
    cocos2d::CCSpriteBatchNode* m_glowLayerB5;
    CCNodeContainer* m_specialLayerB5;
    cocos2d::CCSpriteBatchNode* m_textLayerB5;
    cocos2d::CCSpriteBatchNode* m_textBlendingLayerB5;
    cocos2d::CCSpriteBatchNode* m_fireLayerB5;
    cocos2d::CCSpriteBatchNode* m_fireBlendingLayerB5;
    cocos2d::CCSpriteBatchNode* m_pixelLayerB5;
    cocos2d::CCSpriteBatchNode* m_pixelBlendingLayerB5;
    cocos2d::CCSpriteBatchNode* m_particleLayerB5;
    cocos2d::CCSpriteBatchNode* m_particleBlendingLayerB5;
    cocos2d::CCSpriteBatchNode* m_game2LayerB5;
    cocos2d::CCSpriteBatchNode* m_game2BlendingLayerB5;
    PlayerObject* m_player1;
    PlayerObject* m_player2;
    LevelSettingsObject* m_levelSettings;
    cocos2d::CCArray* m_objects;
    cocos2d::CCArray* m_collisionBlocks;
    cocos2d::CCArray* m_spawnObjectsArray;
    cocos2d::CCDictionary* m_spawnObjects;
    cocos2d::CCNode* m_unkdd0;
    gd::vector<GameObject*> m_unkdd8;
    gd::vector<GameObject*> m_disabledObjects;
    gd::vector<GameObject*> m_unke08;
    gd::vector<GameObject*> m_areaObjects;
    gd::vector<GameObject*> m_processedAreaObjects;
    gd::unordered_map<int, gd::vector<GameObject*>> m_visibilityGroups;
    gd::vector<GameObject*> m_visibleObjects;
    int m_visibleObjectsCount;
    int m_visibleObjectsIndex;
    gd::vector<GameObject*> m_visibleObjects2;
    int m_visibleObjects2Count;
    int m_visibleObjects2Index;
    int m_unked0;
    int m_disabledObjectsCount;
    int m_unked8;
    int m_areaObjectsCount;
    int m_processedAreaObjectsCount;
    int m_unkee4;
    int m_disabledObjectsIndex;
    int m_unkeec;
    int m_areaObjectsIndex;
    int m_processedAreaObjectsIndex;
    cocos2d::CCDictionary* m_groupDict;
    cocos2d::CCDictionary* m_staticGroupDict;
    cocos2d::CCDictionary* m_optimizedGroupDict;
    gd::vector<cocos2d::CCArray*> m_groups;
    gd::vector<cocos2d::CCArray*> m_staticGroups;
    gd::vector<cocos2d::CCArray*> m_optimizedGroups;
    cocos2d::CCDictionary* m_parentGroupsDict;
    cocos2d::CCDictionary* m_parentGroupIDs;
    cocos2d::CCDictionary* m_removedParentGroupIDs;
    cocos2d::CCArray* m_targetGroupsArray;
    gd::unordered_map<int, std::pair<int, int>> m_targetGroups;
    cocos2d::CCDictionary* m_linkedGroupDict;
    int m_lastUsedLinkedID;
    cocos2d::CCNode* m_objectParent;
    cocos2d::CCNode* m_inShaderParent;
    cocos2d::CCNode* m_aboveShaderParent;
    cocos2d::CCLayer* m_objectLayer;
    cocos2d::CCLayer* m_inShaderObjectLayer;
    cocos2d::CCLayer* m_aboveShaderObjectLayer;
    cocos2d::CCSprite* m_background;
    void* m_unk1000;
    GJGroundLayer* m_groundLayer;
    GJGroundLayer* m_groundLayer2;
    GJMGLayer* m_middleground;
    cocos2d::CCArray* m_batchNodes;
    cocos2d::CCDictionary* m_objectsToDeactivate;
    gd::unordered_map<int, gd::vector<LabelGameObject*>> m_labelObjects;
    gd::unordered_map<int, gd::vector<LabelGameObject*>> m_timeLabelObjects;
    gd::set<std::tuple<int, int, int>> m_spawnTuples;
    bool m_increasedLayerCapacity;
    std::array<float, 2000> m_varianceValues;
    gd::map<std::pair<int, int>, std::pair<float, float>> m_destroyObjectValues;
    gd::vector<float> m_enterEasingValues;
    gd::unordered_map<int, int> m_enterEasingIndices;
    int m_enterEasingValuesIndex;
    bool m_dualTouchTrigger;
    int m_clicks;
    int m_attempts;
    bool m_jumping;
    int m_leftSectionIndex;
    int m_rightSectionIndex;
    int m_bottomSectionIndex;
    int m_topSectionIndex;
    bool m_isEditor;
    bool m_blending;
    bool m_isPlatformer;
    GameObject* m_player1CollisionBlock;
    GameObject* m_player2CollisionBlock;
    int m_particleCount;
    int m_customParticleCount;
    int m_particleSystemLimit;
    cocos2d::CCDictionary* m_particlesDict;
    cocos2d::CCDictionary* m_customParticles;
    cocos2d::CCArray* m_unclaimedParticles;
    gd::unordered_map<int, gd::string> m_particleCountToParticleString;
    cocos2d::CCDictionary* m_claimedParticles;
    cocos2d::CCArray* m_temporaryParticles;
    gd::unordered_set<int> m_customParticlesUIDs;
    cocos2d::CCDictionary* m_gradientLayers;
    int m_activeGradients;
    ShaderLayer* m_shaderLayer;
    bool m_objectsDeactivated;
    bool m_areaObjectsUpdated;
    StartPosObject* m_startPosObject;
    bool m_useReplay;
    bool m_unk3189;
    int m_solidCollisionObjectsCount;
    int m_solidCollisionObjectsIndex;
    gd::vector<GameObject*> m_solidCollisionObjects;
    int m_hazardCollisionObjectsCount;
    int m_hazardCollisionObjectsIndex;
    gd::vector<GameObject*> m_hazardCollisionObjects;
    gd::vector<SequenceTriggerGameObject*> m_sequenceTriggers;
    bool m_isPracticeMode;
    bool m_practiceMusicSync;
    float m_loadingProgress;
    cocos2d::CCNode* m_flashNode;
    float m_unk31f8;
    float m_cameraFlip;
    float m_cameraWidthOffset;
    float m_cameraHeightOffset;
    bool m_updateGroundShadows;
    cocos2d::CCDictionary* m_collectedItems;
    float m_levelLength;
    bool m_resetActiveObjects;
    bool m_skipArtReload;
    EndPortalObject* m_endPortal;
    bool m_isTestMode;
    bool m_freezeStartCamera;
    bool m_unk322a;
    float m_cameraUnzoomedHeightOffset;
    float m_targetCameraHeightOffset;
    bool m_calculateTargetHeightOffset;
    cocos2d::CCParticleSystemQuad* m_glitterParticles;
    bool m_staticCameraShake;
    bool m_skipCameraShake;
    bool m_playerDied;
    double m_extraDelta;
    bool m_started;
    bool m_unk3251;
    float m_cameraWidth;
    float m_cameraHeight;
    float m_cameraUnzoomedX;
    float m_halfCameraWidth;
    AudioEffectsLayer* m_audioEffectsLayer;
    OBB2D* m_cameraObb2;
    gd::vector<GameObject*> m_activeObjects;
    int m_activeObjectsCount;
    int m_activeObjectsIndex;
    cocos2d::ccColor3B m_lightBGColor;
    int m_resumeTimer;
    bool m_recordInputs;
    bool m_unk32a1;
    bool m_unk32a2;
    bool m_unk32a3;
    bool m_unk32a4;
    gd::string m_recordString;
    cocos2d::CCObject* m_unk32c8;
    int m_unk32d0;
    bool m_unk32d4;
    double m_queueInterval;
    uint64_t m_coinsCollected;
    int m_replayRandSeed;
    int m_unk32ec;
    int m_currentStep;
    gd::vector<PlayerButtonCommand> m_queuedButtons;
    gd::vector<PlayerButtonCommand> m_queuedRecordedButtons;
    gd::vector<PlayerButtonCommand> m_queuedReplayButtons;
    gd::vector<void*> m_unk3340;
    gd::vector<void*> m_unk3358;
    int m_queuedRecordedButtonsSize;
    bool m_portalIndicators;
    bool m_orbIndicators;
    cocos2d::CCArray* m_indicatorSprites;
    float m_unk3380;
    gd::vector<int> m_unk3388;
    gd::vector<int> m_unk33a0;
    bool m_hideGround;
    cocos2d::CCArray* m_unk33c0;
    cocos2d::CCArray* m_objectsToMove;
    gd::unordered_map<int, GameObject*> m_savePositionObjects;
    gd::unordered_map<int, int> m_savePositionValues;
    bool m_keepGroupParents;
    cocos2d::CCDictionary* m_keyframeGroups;
    int m_keyframeGroup;
    UILayer* m_uiLayer;
    cocos2d::CCArray* m_uiObjects;
    cocos2d::CCDictionary* m_uiObjectLayers;
    cocos2d::CCNode* m_uiTriggerUI;
    double m_timePlayed;
    bool m_levelEndAnimationStarted;
    int m_points;
    gd::string m_pointsString;
    gd::vector<gd::vector<gd::vector<GameObject*>*>*> m_sections;
    gd::vector<gd::vector<gd::vector<GameObject*>*>*> m_nonEffectObjects;
    gd::vector<gd::vector<GameObject*>*> m_collisionBlockSections;
    gd::vector<GameObject*> m_calcNonEffectObjects;
    int m_calcNonEffectObjectsSize;
    gd::vector<GameObject*> m_calcCollisionBlockObjects;
    int m_calcCollisionBlockObjectsSize;
    gd::vector<GameObject*> m_calcCollisionBlockObjects2;
    int m_calcCollisionBlockObjects2Size;
    gd::vector<gd::vector<int>*> m_sectionSizes;
    gd::vector<gd::vector<int>*> m_nonEffectObjectsSizes;
    gd::vector<gd::vector<int>*> m_collisionBlockSectionSizes;
    gd::vector<gd::vector<bool>*> m_nonEffectObjectsFlags;
    float m_sectionXFactor;
    float m_sectionYFactor;
    float m_maxGameplayY;
    float m_songTriggerInterval;
    gd::unordered_map<int, int> m_stickyGroups;
    FMODLevelVisualizer* m_audioVisualizerBG;
    FMODLevelVisualizer* m_audioVisualizerSFX;
    bool m_showAudioVisualizer;
    int m_areaMovedCount;
    int m_areaScaledCount;
    int m_areaRotatedCount;
    int m_areaColorCount;
    int m_areaMovedCountTotal;
    int m_areaScaledCountTotal;
    int m_areaRotatedCountTotal;
    int m_areaColorCountTotal;
    int m_movedCount;
    int m_scaledCount;
    int m_rotatedCount;
    int m_followedCount;
    int m_areaMovedCountDisplay;
    int m_areaScaledCountDisplay;
    int m_areaRotatedCountDisplay;
    int m_areaColorCountDisplay;
    int m_areaMovedCountTotalDisplay;
    int m_areaScaledCountTotalDisplay;
    int m_areaRotatedCountTotalDisplay;
    int m_areaColorCountTotalDisplay;
    int m_movedCountDisplay;
    int m_scaledCountDisplay;
    int m_rotatedCountDisplay;
    int m_followedCountDisplay;
    bool m_loadingStartPosition;
    bool m_processingAudioTriggers;
    bool m_audioPaused;
    bool m_startOptimization;
    GJGameLoadingLayer* m_loadingLayer;
    cocos2d::CCDrawNode* m_debugDrawNode;
    std::array<cocos2d::CCPoint, 400>* m_debugDrawPoints;
    bool m_isDebugDrawEnabled;
    bool m_disablePlayerHitbox;
    GameObject* m_anticheatSpike;
}

[[link(android)]]
class GJBigSprite : cocos2d::CCNode {
    // virtual ~GJBigSprite();

    static GJBigSprite* create();

    virtual bool init();

    void finishedLoadingSpriteAsync(cocos2d::CCObject* obj);
    void loadSpriteAsync(gd::string filename, int index);
    void unloadAll();
    void unloadSprite(gd::string filename, int index);
    void updateSpriteVisibility();

    gd::vector<bool> m_spritesLoaded;
    cocos2d::CCArray* m_spriteNodes;
    float m_scaleX;
    float m_scaleY;
    bool m_loadSprites;
    bool m_unloadingAll;
}

[[link(android)]]
class GJBigSpriteNode : cocos2d::CCNode {
    // virtual ~GJBigSpriteNode();

    static GJBigSpriteNode* create();

    virtual bool init();

    gd::string m_spriteName;
    cocos2d::CCSprite* m_sprite;
    cocos2d::CCRect m_spriteRect;
    bool m_spriteVisible;
}

[[link(android)]]
class GJChallengeDelegate {
    virtual void challengeStatusFinished() {}
    virtual void challengeStatusFailed() {}
}

[[link(android)]]
class GJChallengeItem : cocos2d::CCObject {
    // virtual ~GJChallengeItem();

    static GJChallengeItem* create() = win inline {
        return create(GJChallengeType::Unknown, 0, 0, 0, "");
    }
    static GJChallengeItem* create(GJChallengeType challengeType, int goal, int reward, int timeLeft, gd::string questName) = win 0x1f4a30;
    static GJChallengeItem* createFromString(gd::string string) = win 0x1f47d0;
    static GJChallengeItem* createWithCoder(DS_Dictionary* dsdict) = win inline {
        auto ret = GJChallengeItem::create();
        ret->dataLoaded(dsdict);
        return ret;
    }

    virtual void encodeWithCoder(DS_Dictionary* dsdict) = win 0x1f4bb0;
    virtual bool canEncode() = win inline { return true; }

    void dataLoaded(DS_Dictionary* dsdict) = win inline {
        m_challengeType = (GJChallengeType)dsdict->getIntegerForKey("1");
        m_timeLeft = dsdict->getIntegerForKey("5");
        m_canClaim = dsdict->getBoolForKey("6");
        m_name = dsdict->getStringForKey("7");
        m_count = dsdict->getIntegerForKey("2");
        m_goal = dsdict->getIntegerForKey("3");
        m_reward = dsdict->getIntegerForKey("4");
        m_position = dsdict->getIntegerForKey("8");
    }
    void incrementCount(int add) = win inline {
        if (m_canClaim) return;
        auto newCount = m_count.value() + add;
        if (m_goal.value() <= newCount) {
            m_canClaim = true;
            m_count = m_goal.value();
        }
        else {
            m_count = newCount;
        }
    }
    bool init(GJChallengeType challengeType, int goal, int reward, int timeLeft, gd::string questName) = win inline {
        m_challengeType = challengeType;
        m_goal = goal;
        m_reward = reward;
        m_timeLeft = timeLeft;
        m_name = questName;
        return true;
    }
    void setCount(int value) {
        m_count = value;
    }

    GJChallengeType m_challengeType;
    geode::SeedValueRSV m_count;
    geode::SeedValueRSV m_reward;
    geode::SeedValueRSV m_goal;
    int m_timeLeft;
    bool m_canClaim;
    int m_position;
    gd::string m_name;
}

[[link(android)]]
class GJChestSprite : cocos2d::CCSprite {
    // virtual ~GJChestSprite();

    static GJChestSprite* create(int chestType) = win 0x3d1270;

    virtual void setOpacity(unsigned char opacity) = win 0x3d1400;
    virtual void setColor(cocos2d::ccColor3B const& color) = win 0x3d1340;

    bool init(int chestType) = win inline {
        if (!cocos2d::CCSprite::init()) return false;
        m_chestType = chestType;
        this->setContentSize({ 0, 0 });
        this->switchToState(ChestSpriteState::Closed, false);
        return true;
    }
    void switchToState(ChestSpriteState state, bool noGlow) = win 0x3d1470;

    int m_chestType;
    ChestSpriteState m_spriteState;
    bool m_dark;
}

[[link(android)]]
class GJColorSetupLayer : FLAlertLayer, ColorSelectDelegate, FLAlertLayerProtocol {
    // virtual ~GJColorSetupLayer();

    static GJColorSetupLayer* create(LevelSettingsObject* object) = win 0x255d60;

    virtual void keyBackClicked() = win 0x256b80;
    virtual void colorSelectClosed(cocos2d::CCNode* popup) = win 0x256ab0;

    bool init(LevelSettingsObject* object) = win 0x255ea0;
    void onClose(cocos2d::CCObject* sender) = win 0x256b30;
    void onColor(cocos2d::CCObject* sender) = win 0x2569e0;
    void onPage(cocos2d::CCObject* sender) = win 0x256990;
    void showPage(int page) = win 0x256ac0;
    void updateSpriteColor(ColorChannelSprite* sprite, cocos2d::CCLabelBMFont* label, int id) = win 0x256820;
    void updateSpriteColors() = win 0x256700;

    LevelSettingsObject* m_settingsObject;
    cocos2d::CCDictionary* m_unk290;
    cocos2d::CCDictionary* m_unk298;
    cocos2d::CCArray* m_colorLabels;
    cocos2d::CCArray* m_colorSprites;
    int m_page;
    int m_colorsPerPage;
    int m_totalPages;
    CCMenuItemSpriteExtra* m_prevButton;
    CCMenuItemSpriteExtra* m_nextButton;
    bool m_closeOnSelect;
    ColorSetupDelegate* m_delegate;
    int m_colorID;
}

[[link(android)]]
class GJComment : cocos2d::CCNode {
    GJComment() {
        m_commentID = 0;
        m_userID = 0;
        m_likeCount = 0;
        m_levelID = 0;
        m_isSpam = false;
        m_accountID = 0;
        m_commentDeleted = false;
        m_percentage = 0;
        m_modBadge = 0;
        m_color.r = 255;
        m_color.g = 255;
        m_color.b = 255;
        m_hasLevelID = false;
        m_unkMultiplayerBool = false;
        m_canDelete = false;
        m_userScore = nullptr;
    }
    ~GJComment() = win inline {
        CC_SAFE_RELEASE(m_userScore);
    }

    static GJComment* create() = win inline {
        auto ret = new GJComment();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static GJComment* create(cocos2d::CCDictionary* dict) = win 0x1752e0;

    virtual bool init();

    gd::string m_commentString;
    gd::string m_userName;
    int m_commentID;
    int m_userID;
    int m_likeCount;
    int m_levelID;
    bool m_isSpam;
    int m_accountID;
    gd::string m_uploadDate;
    bool m_commentDeleted;
    int m_percentage;
    int m_modBadge;
    cocos2d::ccColor3B m_color;
    bool m_hasLevelID;
    bool m_unkMultiplayerBool;
    bool m_canDelete;
    GJUserScore* m_userScore;
}

[[link(android)]]
class GJCommentListLayer : cocos2d::CCLayerColor {
    // virtual ~GJCommentListLayer();

    static GJCommentListLayer* create(BoomListView* listView, char const* title, cocos2d::ccColor4B color, float width, float height, bool blueBorder) = win 0x291b10;

    bool init(BoomListView* listView, char const* title, cocos2d::ccColor4B color, float width, float height, bool blueBorder) = win 0x291c30;

    BoomListView* m_list;
}

[[link(android)]]
class GJDailyLevelDelegate {
    virtual void dailyStatusFinished(GJTimedLevelType type) {}
    virtual void dailyStatusFailed(GJTimedLevelType type, GJErrorCode errorType) {}
}

[[link(android)]]
class GJDifficultySprite : cocos2d::CCSprite {
    // virtual ~GJDifficultySprite();

    static GJDifficultySprite* create(int difficulty, GJDifficultyName name) = win 0x2a4df0;
    static gd::string getDifficultyFrame(int difficulty, GJDifficultyName name) = win 0x2a4ed0;

    bool init(int difficulty, GJDifficultyName name) = win inline {
        return cocos2d::CCSprite::initWithSpriteFrameName(GJDifficultySprite::getDifficultyFrame(difficulty, name).c_str());
    }
    void updateDifficultyFrame(int difficulty, GJDifficultyName name) = win 0x2a4fb0;
    void updateFeatureState(GJFeatureState state) = win 0x2a50d0;
    void updateFeatureStateFromLevel(GJGameLevel* level) = win inline {
        if (!level) return;

        GJFeatureState featureState;

        if (level->m_isEpic >= 3) {
            featureState = GJFeatureState::Mythic;
        } else if (level->m_isEpic == 2) {
            featureState = GJFeatureState::Legendary;
        } else if (level->m_isEpic == 1) {
            featureState = GJFeatureState::Epic;
        } else if (level->m_featured >= 1) {
            featureState = GJFeatureState::Featured;
        } else {
            featureState = GJFeatureState::None;
        }

        this->updateFeatureState(featureState);
    }

    GJFeatureState m_featureState;
}

[[link(android)]]
class GJDropDownLayer : cocos2d::CCLayerColor {
    GJDropDownLayer() = win 0x7d250 {
        m_buttonMenu = nullptr;
        m_listLayer = nullptr;
        m_mainLayer = nullptr;
        m_closeOnHide = false;
        m_delegate = nullptr;
        m_fastMenu = false;
    }
    ~GJDropDownLayer() = win 0x256be0;

    static GJDropDownLayer* create(const char* title) = win inline, ios inline {
        return create(title, 220.0f, false);
    }
    static GJDropDownLayer* create(const char* title, float height, bool noBack) = win inline, ios inline {
        auto ret = new GJDropDownLayer();
        if (ret->init(title, height, noBack)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void draw() = win 0x42780;
    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline { return true; }
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline {}
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline {}
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline {}
    virtual void registerWithTouchDispatcher() = win 0x42660;
    virtual void keyBackClicked();
    virtual void customSetup() = win inline {}
    virtual void enterLayer() = win 0x42630;
    virtual void exitLayer(cocos2d::CCObject* sender) = win 0x257130;
    virtual void showLayer(bool instant) = win 0x257170;
    virtual void hideLayer(bool instant) = win 0x2572c0;
    virtual void layerVisible();
    virtual void layerHidden();
    virtual void enterAnimFinished() = win inline {}
    virtual void disableUI() = win 0x2570d0;
    virtual void enableUI() = win 0x2570f0;

    bool init(char const* title) = win inline {
        return init(title, 220.0f, false);
    }
    bool init(char const* title, float height, bool noBack) = win 0x256c90;

    cocos2d::CCPoint m_endPosition;
    cocos2d::CCPoint m_startPosition;
    cocos2d::CCMenu* m_buttonMenu;
    GJListLayer* m_listLayer;
    cocos2d::CCLayer* m_mainLayer;
    bool m_closeOnHide;
    GJDropDownLayerDelegate* m_delegate;
    bool m_fastMenu;
}

[[link(android)]]
class GJDropDownLayerDelegate {
    virtual void dropDownLayerWillClose(GJDropDownLayer* layer) {}
}

[[link(android), depends(DynamicMoveCalculation), depends(PulseEffectAction), depends(TouchToggleAction), depends(CollisionTriggerAction), depends(ToggleTriggerAction), depends(SpawnTriggerAction), depends(GroupCommandObject2), depends(OpacityEffectAction), depends(CountTriggerAction), depends(TimerItem), depends(TimerTriggerAction)]]
class GJEffectManager : cocos2d::CCNode {
    // virtual ~GJEffectManager();
    // GJEffectManager();

    static GJEffectManager* create();
    static cocos2d::ccColor3B getMixedColor(cocos2d::ccColor3B color1, cocos2d::ccColor3B color2, float ratio) = win inline {
        auto r = color1.r * ratio + color2.r * (1.f - ratio);
        auto g = color1.g * ratio + color2.g * (1.f - ratio);
        auto b = color1.b * ratio + color2.b * (1.f - ratio);
        return { std::clamp<uint8_t>(r, 0, 255), std::clamp<uint8_t>(g, 0, 255), std::clamp<uint8_t>(b, 0, 255) };
    }

    virtual bool init() = win 0x25aaf0;

    cocos2d::ccColor3B activeColorForIndex(int index) = win inline {
        if (index == 1010) return { 0, 0, 0 };
        else if (index == 0 || index == 1011) return { 255, 255, 255 };
        else {
            if (auto sprite = this->getColorSprite(index)) return sprite->m_color;
            else return { 255, 255, 255 };
        }
    }
    float activeOpacityForIndex(int index) = win inline {
        if (auto sprite = this->getColorSprite(index)) return sprite->m_opacity;
        else return 1.f;
    }
    void addAllInheritedColorActions(cocos2d::CCArray* actions) = win inline, ios inline {
        cocos2d::CCDictElement* element;
        cocos2d::CCDictElement* temp;
        HASH_ITER(hh, m_unkObject148->m_pElements, element, temp) {
            auto action = static_cast<ColorAction*>(element->getObject());
            if (action->m_copyID > 0) {
                if (!actions) actions = cocos2d::CCArray::create();
                actions->addObject(action);
            }
        }
    }
    void addCountToItem(int itemId, int value) = win inline {
        itemId = std::clamp(itemId, 0, 9999);
        this->updateCountForItem(itemId, value + m_itemCountMap[itemId]);
    }
    void addMoveCalculation(CCMoveCNode* node, cocos2d::CCPoint offset, GameObject* object) = win inline {
        node->m_unk0d1 = true;
        m_unkVector708.push_back({
            .m_moveNode = node,
            .m_offset = offset,
            .m_gameObject = object
        });
    }
    void calculateBaseActiveColors() = win 0x25b270;
    void calculateInheritedColor(int id, ColorAction* action) = win 0x25b650;
    void calculateLightBGColor(cocos2d::ccColor3B color) = win 0x263800;
    bool checkCollision(int const& blockAID, int const& blockBID) = win inline {
        auto key = std::min(blockAID, blockBID) * 10000 + std::max(blockAID, blockBID) + 10000000;
        return m_unkMap288.count(key) != 0;
    }
    void colorActionChanged(ColorAction* action) = win inline {
        if (action->m_copyID > 0) m_colorActionDict->setObject(action, action->m_colorID);
        else m_colorActionDict->removeObjectForKey(action->m_colorID);
    }
    bool colorExists(int col) = win inline {
        return m_colorActionVector[std::clamp(col, 0, 1101)] != nullptr;
    }
    cocos2d::ccColor3B colorForEffect(cocos2d::ccColor3B color, cocos2d::ccHSVValue hsv) = win inline {
        return GameToolbox::transformColor(color, hsv);
    }
    cocos2d::ccColor3B colorForGroupID(int id, cocos2d::ccColor3B const& color, bool mainColor) = win 0x261920;
    cocos2d::ccColor3B colorForIndex(int index) = win inline, ios inline {
        if (auto colorAction = this->getColorAction(index)) return colorAction->m_toColor;
        else return { 255, 255, 255 };
    }
    cocos2d::ccColor3B colorForPulseEffect(cocos2d::ccColor3B const& color, PulseEffectAction* action) = win 0x261570;
    void controlActionsForControlID(int id, GJActionCommand command) = win 0x25d860;
    void controlActionsForTrigger(EffectGameObject* object, GJActionCommand command) = win 0x25e1c0;
    int countForItem(int id) = win 0x262200;
    void createFollowCommand(float xMod, float yMod, float duration, int targetID, int centerID, int uniqueID, int controlID) = win 0x25c8f0;
    GroupCommandObject2* createKeyframeCommand(int targetID, cocos2d::CCArray* group, GameObject* object, int uniqueID, int controlID, bool temporary, float posXMod, float posYMod, float rotMod, float scaleXMod, float scaleYMod, float timeMod, gd::vector<int> const& remapKeys) = win 0x25cb20;
    void createMoveCommand(cocos2d::CCPoint pt, int groupID, float duration, int easingType, float easingRate, bool lockPlayerX, bool lockPlayerY, bool lockCameraX, bool lockCameraY, float moveModX, float moveModY, int uniqueID, int controlID) = win 0x25c510;
    void createPlayerFollowCommand(float delay, float speed, int offset, float maxSpeed, float duration, int targetID, int uniqueID, int controlID);
    void createRotateCommand(float offset, float duration, int targetID, int centerID, int easingType, float easingRate, bool lockRotation, bool player1, bool player2, int uniqueID, int controlID);
    void createTransformCommand(double scaleX, double scaleY, double property450, double property451, bool onlyMove, float duration, int targetID, int centerID, int easingType, float easingRate, bool, bool relativeRotation, int uniqueID, int controlID) = win inline {
        auto& command = m_unkVector560.emplace_back();
        command.m_targetScaleX = scaleX;
        command.m_targetScaleY = scaleY;
        command.m_transformTriggerProperty450 = property450;
        command.m_transformTriggerProperty451 = property451;
        command.m_onlyMove = onlyMove;
        command.m_targetGroupID = targetID;
        command.m_centerGroupID = centerID;
        command.m_transformRelatedFalse = p10;
        command.m_relativeRotation = relativeRotation;
        command.m_triggerUniqueID = uniqueID;
        command.m_controlID = controlID;
        command.runTransformCommand(duration, easingType, easingRate);
    }
    cocos2d::CCArray* getAllColorActions() = win 0x25b0e0;
    cocos2d::CCArray* getAllColorSprites() = win inline, ios inline {
        auto arr = cocos2d::CCArray::create();
        cocos2d::CCDictElement* element;
        cocos2d::CCDictElement* temp;
        HASH_ITER(hh, m_unkDict150->m_pElements, element, temp) {
            arr->addObject(element->getObject());
        }
        return arr;
    }
    ColorAction* getColorAction(int index) = win 0x25ba10;
    ColorActionSprite* getColorSprite(int index) = win 0x25bad0;
    void getLoadedMoveOffset(gd::unordered_map<int, std::pair<double, double>>& offsets) = win 0x260760;
    CCMoveCNode* getMoveCommandNode(GroupCommandObject2* command) = win 0x25ede0;
    CCMoveCNode* getMoveCommandObject() = win 0x25ece0;
    OpacityEffectAction* getOpacityActionForGroup(int id) = win inline {
        if (auto it = m_opacityEffectMap.find(id); it != m_opacityEffectMap.end()) {
            return &it->second;
        }
        return nullptr;
    }
    gd::string getSaveString() = win inline {
        cocos2d::CCDictElement* element;
        cocos2d::CCDictElement* temp;
        fmt::memory_buffer out;
        HASH_ITER(hh, m_unkDict150->m_pElements, element, temp) {
            auto action = static_cast<ColorAction*>(element->getObject());
            if (
                action->m_colorID < 1000 && action->m_fromColor.r == 255 && action->m_fromColor.g == 255 && action->m_fromColor.b == 255 &&
                !action->m_blending && action->m_fromOpacity == 1.f && action->m_copyID == 0 && action->m_playerColor < 1
            ) {
                continue;
            }

            fmt::format_to(std::back_inserter(out), "1_{}_2_{}_3_{}_", action->m_fromColor.r, action->m_fromColor.g, action->m_fromColor.b);
            if (action->m_paused) {
                fmt::format_to(std::back_inserter(out), "19_1_");
            }
            if (action->m_toColor.r != 0 || action->m_toColor.g != 0 || action->m_toColor.b != 0) {
                fmt::format_to(std::back_inserter(out), "11_{}_12_{}_13_{}_", action->m_toColor.r, action->m_toColor.g, action->m_toColor.b);
            }
            if (action->m_playerColor != 0) {
                fmt::format_to(std::back_inserter(out), "4_{}_", action->m_playerColor);
            }
            if (action->m_duration != 0.f) {
                fmt::format_to(std::back_inserter(out), "16_{}_", action->m_duration);
            }
            fmt::format_to(std::back_inserter(out), "6_{}_", action->m_colorID);
            if (action->m_blending) {
                fmt::format_to(std::back_inserter(out), "5_1_");
            }
            fmt::format_to(std::back_inserter(out), "7_{}_15_{}_", action->m_fromOpacity, action->m_toOpacity);
            if (action->m_copyOpacity) {
                fmt::format_to(std::back_inserter(out), "17_1_");
            }
            if (action->m_copyID != 0) {
                fmt::format_to(std::back_inserter(out), "9_{}_", action->m_copyID);
            }
            if (
                action->m_copyHSV.h != 0.f || action->m_copyHSV.s != 1.f || action->m_copyHSV.v != 1.f ||
                action->m_copyHSV.absoluteSaturation || action->m_copyHSV.absoluteBrightness
            ) {
                fmt::format_to(std::back_inserter(out), "10_{}_", GameToolbox::stringFromHSV(action->m_copyHSV, "a"));
            }
            if (action->m_deltaTime > 0.f) {
                fmt::format_to(std::back_inserter(out), "14_{}_", action->m_deltaTime);
            }
            fmt::format_to(std::back_inserter(out), "18_{}_8_1|", action->m_uniqueID);
        }
        return fmt::to_string(out);
    }
    GroupCommandObject2* getTempGroupCommand() = win 0x25f080;
    void handleObjectCollision(bool triggerOnExit, int blockAID, int blockBID) = win 0x25c350;
    bool hasActiveDualTouch() = win inline {
        for (auto& action : m_unkVector1e0) {
            if (action.m_dualMode && !action.m_disabled) return true;
        }
        return false;
    }
    bool hasBeenTriggered(int objectUniqueID, int playerUniqueID) = win inline {
        auto bound = m_unkMap498.lower_bound(std::make_pair(objectUniqueID, playerUniqueID));
        return bound != m_unkMap498.end() && *bound <= std::make_pair(objectUniqueID, playerUniqueID);
    }
    bool hasPulseEffectForGroupID(int id) = win inline, ios inline {
        if (auto it = m_pulseEffectMap.find(id); it != m_pulseEffectMap.end()) return !it->second.empty();
        return false;
    }
    bool isGroupEnabled(int id) = win inline {
        return m_unkVector438[std::clamp(id, 0, 9999)];
    }
    const char* keyForGroupIDColor(int id, cocos2d::ccColor3B const& color, bool mainColor) = win inline, ios inline {
        fmt::memory_buffer out;
        fmt::format_to(std::back_inserter(out), "{}_{}{}{}_{}", id, color.r, color.g, color.b, (int)mainColor);
        return out.data();
    }
    void loadFromState(EffectManagerState& state) = win 0x2642b0;
    void objectsCollided(int blockAID, int blockBID) = win inline {
        auto key = std::min(blockAID, blockBID) * 10000 + std::max(blockAID, blockBID) + 10000000;
        if (auto it = m_unkMap288.find(key); it != m_unkMap288.end()) {
            it->second = true;
        }
        else {
            this->handleObjectCollision(true, blockAID, blockBID);
            m_unkMap288[key] = true;
        }
    }
    float opacityForIndex(int index) = win inline, ios inline {
        if (auto colorAction = this->getColorAction(index)) return colorAction->m_toOpacity;
        else return 1.f;
    }
    float opacityModForGroup(int id) = win 0x260990;
    void pauseTimer(int id) = win inline {
        if (m_timerItemMap.count(id) != 0) m_timerItemMap[id].m_active = false;
    }
    void playerButton(bool down, bool player1) = win 0x261fa0;
    void playerDied() = win inline {
        if (m_triggerEffectDelegate) {
            for (int i = 0; i < m_unkVector248.size(); i++) {
                auto& action = m_unkVector248[i];
                if (action.m_disabled) continue;
                m_triggerEffectDelegate->toggleGroupTriggered(action.m_targetGroupID, action.m_activateGroup, action.m_remapKeys, action.m_triggerUniqueID, action.m_controlID);
            }
        }
    }
    void postCollisionCheck() = win 0x25c0f0;
    void postMoveActions() = win 0x260610;
    void preCollisionCheck() = win inline {
        for (auto& pair : m_unkMap288) {
            pair.second = false;
        }
    }
    void prepareMoveActions(float dt, bool intermediate) = win 0x25f200;
    void processColors() = win 0x25b150;
    void processCopyColorPulseActions() = win 0x261320;
    void processInheritedColors() = win 0x25b330;
    void processMoveCalculations() = win inline {
        for (auto& calc : m_unkVector708) {
            auto angle = -calc.m_gameObject->m_rotationXOffset * M_PI / 180.f;
            cocos2d::CCPoint position;
            position.x = calc.m_offset.x * cosf(angle) - calc.m_offset.y * sinf(angle);
            position.y = calc.m_offset.x * sinf(angle) + calc.m_offset.y * cosf(angle);
            auto diff = position - calc.m_offset;
            calc.m_moveNode->m_unk038 += diff.x;
            calc.m_moveNode->m_unk040 += diff.y;
            calc.m_moveNode->m_unk090 += diff.x;
            calc.m_moveNode->m_unk098 += diff.y;
            calc.m_moveNode->m_unk0d1 = false;
        }
        m_unkVector708.clear();
    }
    void processPulseActions() = win inline {
        for (int i = 0; i < m_pulseEffectVector.size(); i++) {
            auto& action = m_pulseEffectVector[i];
            auto colorAction = this->getColorAction(action.m_targetGroupID);
            if (action.m_colorIndex == 0 && (!colorAction || colorAction->m_copyID == 0)) {
                colorAction->m_colorSprite->m_copyColor = this->colorForPulseEffect(colorAction->m_colorSprite->m_copyColor, &action);
            }
        }
    }
    void registerCollisionTrigger(int targetID, int blockAID, int blockBID, bool triggerOnExit, bool activateGroup, gd::vector<int> const& remapKeys, int uniqueID, int controlID) = win 0x25c240;
    void registerRotationCommand(GroupCommandObject2* object, bool clear) = win 0x25ef80;
    void removeAllPulseActions() = win inline {
        m_pulseEffectVector.clear();
        m_unkVector2f0.clear();
    }
    void removeColorAction(int id) = win inline {
        id = std::clamp(id, 0, 1101);
        m_unkObject148->removeObjectForKey(id);
        m_colorActionVector[id] = nullptr;
        m_colorActionDict->removeObjectForKey(id);
    }
    void removePersistentFromAllItems() = win inline {
        m_persistentItemCountMap.clear();
    }
    void removePersistentFromAllTimers() = win inline {
        m_persistentTimerItemSet.clear();
    }
    void removeTriggeredID(int objectUniqueID, int playerUniqueID) = win 0x261ef0;
    void reset() = win 0x25aeb0;
    void resetEffects() = win 0x25be30;
    void resetMoveActions() = win inline {
        m_unkVector560.clear();
        m_unkMap578.clear();
        m_unkMap618.clear();
        m_unkVector6c0.clear();
    }
    void resetTempGroupCommands(bool noRemove) = win 0x25f110;
    void resetToggledGroups() = win inline {
        m_unkVector438.assign(m_unkVector438.size(), true);
        m_unkMap460.clear();
    }
    void resetTriggeredIDs() = win inline, ios inline {
        m_unkMap498.clear();
    }
    void resumeTimer(int id) = win inline {
        if (m_timerItemMap.count(id) != 0) m_timerItemMap[id].m_active = true;
    }
    void runCountTrigger(int id, int targetCount, bool multiActivate, int targetID, bool activateGroup, gd::vector<int> const& remapKeys, int uniqueID, int controlID) = win inline {
        m_countTriggerActions[id].emplace_back(targetID, targetCount, activateGroup, multiActivate, id, this->countForItem(id), remapKeys, uniqueID, controlID);
    }
    void runDeathTrigger(int targetID, bool activateGroup, gd::vector<int> const& remapKeys, int uniqueID, int controlID) = win inline {
        m_unkVector248.emplace_back(targetID, activateGroup, remapKeys, uniqueID, controlID);
    }
    OpacityEffectAction* runOpacityActionOnGroup(int targetID, float duration, float opacity, int uniqueID, int controlID) = win 0x260880;
    PulseEffectAction* runPulseEffect(int targetID, bool targetGroup, float fadeInDuration, float holdDuration, float fadeOutDuration, PulseEffectType effectType, cocos2d::ccColor3B targetColor, cocos2d::ccHSVValue targetHSV, int copyID, bool mainOnly, bool detailOnly, bool exclusive, bool legacyHSV, int uniqueID, int controlID) = win 0x260a50;
    void runTimerTrigger(int id, double targetTime, bool multiActivate, int targetID, gd::vector<int> const& remapKeys, int uniqueID, int controlID) = win inline {
        m_unkMap3f8[id].emplace_back(targetID, targetTime, multiActivate, id, remapKeys, uniqueID, controlID);
    }
    void runTouchTriggerCommand(int targetID, bool holdMode, TouchTriggerType touchType, TouchTriggerControl touchControl, bool dualMode, gd::vector<int> const& remapKeys, int uniqueID, int controlID) = win inline {
        m_unkVector1e0.emplace_back(targetID, holdMode, touchType, touchControl, dualMode, remapKeys, uniqueID, controlID);
    }
    void saveCompletedMove(int groupId, double dx, double dy) = win inline {
        auto& entry = m_unkMap578[groupId];
        entry.first += dx;
        entry.second += dy;
    }
    void saveToState(EffectManagerState& state) = win 0x263c90;
    void setColorAction(ColorAction* action, int id) = win 0x25bc30;
    void setFollowing(int targetID, int targetPosID, bool following) = win inline {
        auto key = targetID * 2000 + targetPosID;
        if (following) m_unkMap4c8.insert(key);
        else m_unkMap4c8.erase(key);
    }
    void setupFromString(gd::string str) = win 0x263a00;
    bool shouldBlend(int id) = win inline {
        auto action = m_colorActionVector[std::clamp(id, 0, 1101)];
        return action && action->m_blending;
    }
    void spawnGroup(int targetID, float delay, bool spawnOrdered, gd::vector<int> const& remapKeys, int uniqueID, int controlID) = win 0x261ac0;
    void spawnObject(GameObject* object, float delay, gd::vector<int> const& remapKeys, int uniqueID, int controlID) = win inline {
        m_spawnTriggerActions.emplace_back(object, delay, remapKeys, uniqueID, controlID);
    }
    void startTimer(int id, double startTime, double targetTime, bool stopTime, bool active, bool dontOverride, float timeMod, bool ignoreTimewarp, int targetID, gd::vector<int> const& remapKeys, int uniqueID, int controlID) = win 0x262d60;
    void storeTriggeredID(int objectUniqueID, int playerUniqueID) = win 0x261e00;
    double timeForItem(int id) = win 0x263740;
    bool timerExists(int id) = win 0x262f20;
    void toggleGroup(int id, bool activate) = win inline {
        id = std::clamp(id, 0, 9999);
        if (activate) {
            m_unkVector438[id] = true;
            m_unkMap460.erase(id);
        }
        else {
            m_unkVector438[id] = false;
            m_unkMap460.insert(id);
        }
    }
    void toggleItemPersistent(int id, bool persistent) = win inline {
        if (persistent) m_persistentItemCountMap[id] = m_itemCountMap.count(id) != 0 ? m_itemCountMap[id] : 0;
        else m_persistentItemCountMap.erase(id);
    }
    void toggleTimerPersistent(int id, bool persistent) = win inline {
        if (persistent) m_persistentTimerItemSet.insert(id);
        else m_persistentTimerItemSet.erase(id);
    }
    void transferPersistentItems() = win 0x262ce0;
    void traverseInheritanceChain(InheritanceNode* node) = win inline {
        while (node) {
            m_unkArray430->addObject(node);
            node = node->m_inheritanceNode;
        }
        CCObject* obj;
        CCARRAY_FOREACH(m_unkArray430, obj) {
            auto currentNode = static_cast<InheritanceNode*>(obj);
            this->calculateInheritedColor(currentNode->m_colorID, currentNode->m_colorAction);
        }
        m_unkArray430->removeAllObjects();
    }
    CCMoveCNode* tryGetMoveCommandNode(int id) = win inline {
        auto it = m_unkMap618.find(id);
        return it != m_unkMap618.end() ? it->second : nullptr;
    }
    void updateActiveOpacityEffects() = win inline, ios inline {
        for (auto it = m_opacityEffectMap.begin(); it != m_opacityEffectMap.end();) {
            auto& action = it->second;
            if (action.m_finished && action.m_currentValue >= 1.f) it = m_opacityEffectMap.erase(it);
            else ++it;
        }
    }
    void updateColorAction(ColorAction* action) = win inline {
        if (action->m_copyID == 0) {
            action->m_colorSprite->m_color = action->m_color;
            action->m_colorSprite->m_opacity = action->m_currentOpacity * 255.f;
        }
    }
    void updateColorEffects(float dt) = win inline {
        cocos2d::CCDictElement* element;
        cocos2d::CCDictElement* temp;
        HASH_ITER(hh, m_unkObject148->m_pElements, element, temp) {
            auto action = static_cast<ColorAction*>(element->getObject());
            action->step(dt);
            if (action->m_copyID == 0) {
                action->m_colorSprite->m_color = action->m_color;
                action->m_colorSprite->m_opacity = action->m_currentOpacity * 255.f;
            }
        }
    }
    void updateColors(cocos2d::ccColor3B color1, cocos2d::ccColor3B color2) = win inline {
        cocos2d::CCDictElement* element;
        cocos2d::CCDictElement* temp;
        HASH_ITER(hh, m_unkObject148->m_pElements, element, temp) {
            auto action = static_cast<ColorAction*>(element->getObject());
            if (action->m_playerColor == 1) action->m_fromColor = color1;
            else if (action->m_playerColor == 2) action->m_fromColor = color2;
        }
    }
    void updateCountForItem(int id, int count) = win 0x2622c0;
    void updateEffects(float dt) = win 0x25bcb0;
    void updateOpacityAction(OpacityEffectAction* action) = win inline {
        if (action->m_finished && action->m_currentValue >= 1.f) m_opacityEffectMap.erase(action->m_targetGroupID);
    }
    void updateOpacityEffects(float dt) = win inline {
        for (auto it = m_opacityEffectMap.begin(); it != m_opacityEffectMap.end();) {
            auto& action = it->second;
            action.step(dt);
            if (action.m_finished && action.m_currentValue >= 1.f) it = m_opacityEffectMap.erase(it);
            else ++it;
        }
    }
    void updatePulseEffects(float dt) = win 0x260fd0;
    void updateSpawnTriggers(float dt) = win 0x261bb0;
    void updateTimer(int id, double time) = win 0x262fc0;
    void updateTimers(float dt, float timeWarp) = win 0x263150;
    bool wasFollowing(int targetID, int targetPosID) = win inline {
        return m_unkMap4c8.count(targetID * 2000 + targetPosID) != 0;
    }
    bool wouldCreateLoop(InheritanceNode* node, int id) = win 0x25b9f0, ios inline {
        while (node) {
            if (node->m_colorID == id) return true;
            node = node->m_inheritanceNode;
        }
        return false;
    }

    TriggerEffectDelegate* m_triggerEffectDelegate;
    cocos2d::CCDictionary* m_unkObject148;
    cocos2d::CCDictionary* m_unkDict150;
    gd::vector<PulseEffectAction> m_pulseEffectVector;
    gd::unordered_map<int, gd::vector<PulseEffectAction>> m_pulseEffectMap;
    gd::unordered_map<int, OpacityEffectAction> m_opacityEffectMap;
    gd::vector<TouchToggleAction> m_unkVector1e0;
    gd::unordered_map<int, gd::vector<CountTriggerAction>> m_countTriggerActions;
    gd::vector<CollisionTriggerAction> m_unkVector230;
    gd::vector<ToggleTriggerAction> m_unkVector248;
    cocos2d::CCDictionary* m_colorActionDict;
    cocos2d::CCDictionary* m_unkDict268;
    gd::vector<InheritanceNode*> m_unkVector270;
    gd::unordered_map<int, bool> m_unkMap288;
    gd::vector<ColorAction*> m_colorActionVector;
    gd::vector<ColorActionSprite*> m_colorActionSpriteVector;
    gd::vector<bool> m_unkVector2f0;
    gd::unordered_map<int, int> m_itemCountMap;
    gd::unordered_map<int, int> m_persistentItemCountMap;
    gd::unordered_set<int> m_persistentTimerItemSet;
    gd::unordered_map<int, TimerItem> m_timerItemMap;
    gd::unordered_map<int, gd::vector<TimerTriggerAction>> m_unkMap3f8;
    cocos2d::CCArray* m_unkArray430;
    gd::vector<bool> m_unkVector438;
    gd::unordered_set<int> m_unkMap460;
    gd::set<std::pair<int, int>> m_unkMap498;
    gd::unordered_set<int> m_unkMap4c8;
    gd::vector<SpawnTriggerAction> m_spawnTriggerActions;
    gd::vector<GroupCommandObject2*> m_unkVector518;
    gd::vector<GroupCommandObject2*> m_unkVector530;
    gd::vector<cocos2d::CCObject*> m_unkVector548;
    gd::vector<GroupCommandObject2> m_unkVector560;
    gd::unordered_map<int, std::pair<double, double>> m_unkMap578;
    gd::vector<GroupCommandObject2*> m_unkVector5b0;
    gd::unordered_map<int, gd::vector<GroupCommandObject2*>> m_unkMap5c8;
    gd::vector<GroupCommandObject2*> m_unkVector600;
    gd::unordered_map<int, CCMoveCNode*> m_unkMap618;
    gd::unordered_map<int, CCMoveCNode*> m_unkMap650;
    gd::unordered_map<int, CCMoveCNode*> m_unkMap688;
    gd::vector<CCMoveCNode*> m_unkVector6c0;
    gd::vector<CCMoveCNode*> m_unkVector6d8;
    gd::vector<CCMoveCNode*> m_unkVector6f0;
    gd::vector<DynamicMoveCalculation> m_unkVector708;
    gd::map<std::pair<int, int>, gd::vector<GroupCommandObject2*>> m_unkMap770;
    float m_unk780;
    float m_unk784;
    float m_unk788;
    float m_unk78C;
    float m_unk790;
    float m_unk794;
    bool m_unk798;
}

[[link(android)]]
class GJFlyGroundLayer : GJGroundLayer {
    // virtual ~GJFlyGroundLayer();

    static GJFlyGroundLayer* create();

    virtual bool init();
}

[[link(android)]]
class GJFollowCommandLayer : SetupTriggerPopup {
    // virtual ~GJFollowCommandLayer();

    static GJFollowCommandLayer* create(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x2703f0;

    virtual void determineStartValues() = win 0x271820;
    virtual void onClose(cocos2d::CCObject* sender) = win 0x272890;
    virtual void textChanged(CCTextInputNode* node) = win 0x271f40;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects);
    void onUpdateGroupID(cocos2d::CCObject* sender) = win 0x271e80;
    void onUpdateGroupID2(cocos2d::CCObject* sender) = win 0x271ee0;
    void sliderChanged(cocos2d::CCObject* sender) = win 0x271b30;
    void sliderXModChanged(cocos2d::CCObject* sender);
    void sliderYModChanged(cocos2d::CCObject* sender);
    void updateDuration();
    void updateDurLabel(bool decimals);
    void updateTargetGroupID();
    void updateTargetGroupID2();
    void updateTextInputLabel();
    void updateTextInputLabel2();
    void updateXMod();
    void updateXModLabel();
    void updateYMod();
    void updateYModLabel();

    CCTextInputNode* m_moveTimeInput;
    Slider* m_moveTimeSlider;
    float m_moveTime;
    CCTextInputNode* m_xModInput;
    CCTextInputNode* m_yModInput;
    Slider* m_xModSlider;
    Slider* m_yModSlider;
    float m_xMod;
    float m_yMod;
    CCTextInputNode* m_targetIDInput;
    int m_targetGroupID;
    CCTextInputNode* m_followIDInput;
    int m_followGroupID;
}

[[link(android)]]
class GJFriendRequest : cocos2d::CCNode {
    // virtual ~GJFriendRequest();
    GJFriendRequest() {
        m_requestID = 0;
        m_accountID = 0;
        m_unusedToAccountID = 0;
        m_isRead = false;
    }

    static GJFriendRequest* create() = win inline {
        auto ret = new GJFriendRequest();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static GJFriendRequest* create(cocos2d::CCDictionary* dict) = win 0x172cc0;

    virtual bool init();

    int m_requestID;
    int m_accountID;
    int m_unusedToAccountID;
    gd::string m_message;
    gd::string m_uploadDate;
    bool m_isRead;
}

[[link(android)]]
class GJGameLevel : cocos2d::CCNode {
    GJGameLevel() = win 0x1415d0 {
        m_lastBuildSave = nullptr;
        m_levelID = { 0, 0 };
        m_userID = { 0, 0 };
        m_accountID = { 0, 0 };
        m_difficulty = GJDifficulty::Auto;
        m_audioTrack = 0;
        m_songID = 0;
        m_levelRev = 0;
        m_unlisted = false;
        m_friendsOnly = false;
        m_objectCount = { 0, 0 };
        m_levelIndex = 0;
        m_ratings = 0;
        m_ratingsSum = 0;
        m_downloads = 0;
        m_isEditable = false;
        m_gauntletLevel = false;
        m_gauntletLevel2 = false;
        m_workingTime = 0;
        m_workingTime2 = 0;
        m_lowDetailMode = false;
        m_lowDetailModeToggled = false;
        m_disableShakeToggled = false;
        m_selected = false;
        m_localOrSaved = false;
        m_isVerified = { 0, 0 };
        m_isVerifiedRaw = false;
        m_isUploaded = false;
        m_hasBeenModified = false;
        m_levelVersion = 0;
        m_gameVersion = 0;
        m_attempts = { 0, 0 };
        m_jumps = { 0, 0 };
        m_clicks = { 0, 0 };
        m_attemptTime = { 0, 0 };
        m_isChkValid = false;
        m_isCompletionLegitimate = false;
        m_normalPercent = { 0, 0 };
        m_orbCompletion = { 0, 0 };
        m_newNormalPercent2 = { 0, 0 };
        m_practicePercent = 0;
        m_likes = 0;
        m_dislikes = 0;
        m_levelLength = 0;
        m_featured = 0;
        m_isEpic = 0;
        m_levelFavorited = false;
        m_levelFolder = 0;
        m_dailyID = { 0, 0 };
        m_demon = { 0, 0 };
        m_demonDifficulty = 4;
        m_stars = { 0, 0 };
        m_autoLevel = false;
        m_coins = 0;
        m_coinsVerified = { 0, 0 };
        m_password = { 0, 0 };
        m_originalLevel = { 0, 0 };
        m_twoPlayerMode = false;
        m_failedPasswordAttempts = 0;
        m_firstCoinVerified = { 0, 0 };
        m_secondCoinVerified = { 0, 0 };
        m_thirdCoinVerified = { 0, 0 };
        m_starsRequested = 0;
        m_showedSongWarning = false;
        m_starRatings = 0;
        m_starRatingsSum = 0;
        m_maxStarRatings = 0;
        m_minStarRatings = 0;
        m_demonVotes = 0;
        m_rateStars = 0;
        m_rateFeature = false;
        m_dontSave = false;
        m_levelNotDownloaded = false;
        m_requiredCoins = 0;
        m_isUnlocked = false;
        m_lastEditorZoom = 0.f;
        m_lastBuildTab = 0;
        m_lastBuildPage = 0;
        m_lastBuildGroupID = 0;
        m_levelType = GJLevelType::Default;
        m_M_ID = 0;
        m_highObjectsEnabled = false;
        m_unlimitedObjectsEnabled = false;
        m_timestamp = 0;
        m_listPosition = 0;
        m_54 = 0;
        m_bestTime = 0;
        m_bestPoints = 0;
    }
    ~GJGameLevel() = win inline {
        CC_SAFE_RELEASE(m_lastBuildSave);
    }

    static GJGameLevel* create();
    static GJGameLevel* create(cocos2d::CCDictionary* dict, bool download);
    static GJGameLevel* createWithCoder(DS_Dictionary* dict) = win inline {
        auto level = GJGameLevel::create();
        level->dataLoaded(dict);
        return level;
    }
    static int demonIconForDifficulty(DemonDifficultyType type) = win inline {
        switch (type) {
            case DemonDifficultyType::EasyDemon: return 7;
            case DemonDifficultyType::MediumDemon: return 8;
            case DemonDifficultyType::InsaneDemon: return 9;
            case DemonDifficultyType::ExtremeDemon: return 10;
            default: return 6;
        }
    }
    static int getLengthKey(int length, bool platformer) = win inline {
        if (platformer) return 5;
        if (length < 10) return 0;
        if (length < 30) return 1;
        if (length < 60) return 2;
        if (length < 120) return 3;
        return 4;
    }
    static gd::string lengthKeyToString(int key) = win 0x16cc10;

    virtual void encodeWithCoder(DS_Dictionary* dict) = win 0x16ef40;
    virtual bool canEncode() = win inline { return true; }
    virtual bool init() = win 0x16c6e0;

    bool areCoinsVerified() = win 0x16ff80;
    void copyLevelInfo(GJGameLevel* level) = win 0x16d850;
    void dataLoaded(DS_Dictionary* dict) = win 0x16df00;
    gd::string generateSettingsString() = win inline, ios inline { return ""; }
    gd::string getAudioFileName() = win 0x16cf30;
    int getAverageDifficulty() = win 0x16cd70;
    char const* getCoinKey(int coinNumber) = win 0x16cde0;
    int getLastBuildPageForTab(int tab);
    GJGameLevel* getListSnapshot() = win 0x16db70;
    int getNormalPercent() = win inline {
        return m_normalPercent.value();
    }
    gd::string getSongName() = win 0x16cff0;
    gd::string getUnpackedLevelDescription();
    void handleStatsConflict(GJGameLevel* level);
    bool isPlatformer() = win inline {
        return m_levelLength == 5;
    }
    void levelWasAltered() = win inline {
        m_hasBeenModified = true;
        m_isVerifiedRaw = false;
        m_isVerified = false;
        this->unverifyCoins();
        m_capacityString = "";
        if (m_isUploaded) {
            m_isUploaded = false;
            m_levelVersion++;
        }
    }
    void levelWasSubmitted() = win inline, ios inline {
        m_isUploaded = true;
    }
    void parseSettingsString(gd::string str) = win inline, ios inline {}
    void saveNewScore(int value, int type) = win inline {
        if (type == 0) {
            if (value > 0 && (m_bestTime > value || m_bestTime == 0)) m_bestTime = value;
        }
        else {
            if (m_bestPoints < value || m_bestPoints == 0) m_bestPoints = value;
        }
        uint32_t seed = (((m_bestTime + 7890) % 34567) * 601 + ((abs(m_bestPoints) + 3456) % 78901) * 967 + 94819) % 94433;
        m_platformerSeed = (int)(((int)seed >> 16 ^ seed) * 829) % 77849;
        storeNewLocalScore(value, type);
    }
    void savePercentage(int percent, bool isPracticeMode, int clicks, int attempts, bool isChkValid) = win 0x16c8f0;
    void scoreStringToVector(gd::string& str, gd::vector<int>& vec) = win 0x16d6c0;
    gd::string scoreVectorToString(gd::vector<int>& vec, int type) = win inline {
        if (type == 1) std::sort(vec.begin(), vec.end(), std::greater<int>());
        else std::sort(vec.begin(), vec.end(), std::less<int>());
        fmt::memory_buffer out;
        for (int i = 0; i < vec.size(); i++) {
            if (i > 0) fmt::format_to(std::back_inserter(out), ",");
            fmt::format_to(std::back_inserter(out), "{}", vec[i]);
        }
        return fmt::to_string(out);
    }
    void setAccountID(int id) {
        m_accountID = id;
    }
    void setAttempts(int attempts) {
        m_attempts = attempts;
    }
    void setAttemptTime(int time) {
        m_attemptTime = time;
    }
    void setClicks(int clicks) {
        m_clicks = clicks;
    }
    void setCoinsVerified(int coinsVerified) {
        m_coinsVerified = coinsVerified;
    }
    void setDailyID(int id) {
        m_dailyID = id;
    }
    void setDemon(int demon) {
        m_demon = demon;
    }
    void setJumps(int jumps) {
        m_jumps = jumps;
    }
    void setLastBuildPageForTab(int tab, int page) = win inline {
        m_lastBuildSave->setObject(cocos2d::CCString::createWithFormat("%i", page), cocos2d::CCString::createWithFormat("%i", tab)->getCString());
    }
    void setLevelID(int levelID) {
        m_levelID = levelID;
    }
    void setNewNormalPercent(int percent) {
        m_orbCompletion = percent;
    }
    void setNewNormalPercent2(int percent) {
        m_newNormalPercent2 = percent;
    }
    void setNormalPercent(int percent) = win inline, ios inline {
        m_normalPercent = percent;
    }
    void setObjectCount(int count) {
        m_objectCount = count;
    }
    void setOriginalLevel(int id) {
        m_originalLevel = id;
    }
    void setPassword(int password) {
        m_password = password;
    }
    void setStars(int stars) {
        m_stars = stars;
    }
    bool shouldCheatReset() = win inline, ios inline {
        return m_stars.value() > 7 && m_jumps.value() < 50 && m_clicks.value() < 50;
    }
    void storeNewLocalScore(int value, int type) = win 0x16d440;
    void unverifyCoins() = win 0x16ffe0;

    cocos2d::CCDictionary* m_lastBuildSave;
    geode::SeedValueRSV m_levelID;
    gd::string m_levelName;
    gd::string m_levelDesc;
    gd::string m_levelString;
    gd::string m_creatorName;
    gd::string m_recordString;
    gd::string m_uploadDate;
    gd::string m_updateDate;
    gd::string m_lockedEditorLayers;
    gd::string m_savedCameraPositions;
    cocos2d::CCPoint m_previewLock;
    geode::SeedValueRSV m_userID;
    geode::SeedValueRSV m_accountID;
    GJDifficulty m_difficulty;
    int m_audioTrack;
    int m_songID;
    int m_levelRev;
    bool m_unlisted;
    bool m_friendsOnly;
    geode::SeedValueRSV m_objectCount;
    int m_levelIndex;
    int m_ratings;
    int m_ratingsSum;
    int m_downloads;
    bool m_isEditable;
    bool m_gauntletLevel;
    bool m_gauntletLevel2;
    int m_workingTime;
    int m_workingTime2;
    bool m_lowDetailMode;
    bool m_lowDetailModeToggled;
    bool m_disableShakeToggled;
    bool m_selected;
    bool m_localOrSaved;
    bool m_disableShake;
    geode::SeedValueRS m_isVerified;
    bool m_isVerifiedRaw;
    bool m_isUploaded;
    bool m_hasBeenModified;
    int m_levelVersion;
    int m_gameVersion;
    geode::SeedValueRSV m_attempts;
    geode::SeedValueRSV m_jumps;
    geode::SeedValueRSV m_clicks;
    geode::SeedValueRSV m_attemptTime;
    int m_chk;
    bool m_isChkValid;
    bool m_isCompletionLegitimate;
    geode::SeedValueVSR m_normalPercent;
    geode::SeedValueRSV m_orbCompletion;
    geode::SeedValueRSV m_newNormalPercent2;
    int m_practicePercent;
    int m_likes;
    int m_dislikes;
    int m_levelLength;
    int m_featured;
    int m_isEpic;
    bool m_levelFavorited;
    int m_levelFolder;
    geode::SeedValueRSV m_dailyID;
    geode::SeedValueRSV m_demon;
    int m_demonDifficulty;
    geode::SeedValueRSV m_stars;
    bool m_autoLevel;
    int m_coins;
    geode::SeedValueRSV m_coinsVerified;
    geode::SeedValueRS m_password;
    geode::SeedValueRSV m_originalLevel;
    bool m_twoPlayerMode;
    int m_failedPasswordAttempts;
    geode::SeedValueRSV m_firstCoinVerified;
    geode::SeedValueRSV m_secondCoinVerified;
    geode::SeedValueRSV m_thirdCoinVerified;
    int m_starsRequested;
    bool m_showedSongWarning;
    int m_starRatings;
    int m_starRatingsSum;
    int m_maxStarRatings;
    int m_minStarRatings;
    int m_demonVotes;
    int m_rateStars;
    bool m_rateFeature;
    gd::string m_rateUser;
    bool m_dontSave;
    bool m_levelNotDownloaded;
    int m_requiredCoins;
    bool m_isUnlocked;
    cocos2d::CCPoint m_lastCameraPos;
    float m_lastEditorZoom;
    int m_lastBuildTab;
    int m_lastBuildPage;
    int m_lastBuildGroupID;
    GJLevelType m_levelType;
    int m_M_ID;
    gd::string m_tempName;
    gd::string m_capacityString;
    bool m_highObjectsEnabled;
    bool m_unlimitedObjectsEnabled;
    gd::string m_personalBests;
    int m_timestamp;
    int m_listPosition;
    gd::string m_songIDs;
    gd::string m_sfxIDs;
    int m_54; //aka k106
    int m_bestTime;
    int m_bestPoints;
    int m_platformerSeed;
    gd::string m_localBestTimes;
    gd::string m_localBestPoints;
}

[[link(android)]]
class GJGameLoadingLayer : cocos2d::CCLayer {
    // virtual ~GJGameLoadingLayer();
    GJGameLoadingLayer() {
        m_level = nullptr;
        m_editor = false;
    }

    static GJGameLoadingLayer* create(GJGameLevel* level, bool editor) = win inline {
        auto ret = new GJGameLoadingLayer();
        if (ret->init(level, editor)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static GJGameLoadingLayer* transitionToLoadingLayer(GJGameLevel* level, bool editor) = win 0x248c30;

    virtual void onEnter();
    virtual void onEnterTransitionDidFinish();

    void gameLayerDidUnload() = win inline {
        this->runAction(cocos2d::CCSequence::create(
            cocos2d::CCDelayTime::create(.01f),
            cocos2d::CCCallFunc::create(this, callfunc_selector(GJGameLoadingLayer::loadLevel)),
            nullptr
        ));
    }
    bool init(GJGameLevel* level, bool editor) = win inline {
        if (!cocos2d::CCLayer::init()) return false;

        if (level) {
            m_level = level;
            level->retain();
        }
        m_editor = editor;

        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        auto loadingLabel = cocos2d::CCLabelBMFont::create("Loading...", "bigFont.fnt");
        loadingLabel->setScale(.7f);
        this->addChild(loadingLabel, 1);
        loadingLabel->setAnchorPoint({ 1.f, 0.f });
        loadingLabel->setPosition({ winSize.width - 20.f, 20.f });

        return true;
    }
    void loadLevel() = win 0x248e20;

    GJGameLevel* m_level;
    bool m_editor;
}

[[link(android), depends(EventTriggerInstance), depends(SongChannelState), depends(DynamicObjectAction), depends(AdvancedFollowInstance), depends(EnterEffectInstance), depends(GameObjectPhysics), depends(GJValueTween), depends(SFXTriggerInstance), depends(SFXTriggerState), depends(SongTriggerState), depends(EnterEffectAnimValue)]]
class GJGameState {
    // ~GJGameState();
    // GJGameState();

    void controlTweenAction(int uniqueID, int controlID, GJActionCommand command) = win 0x2054a0;
    GameObjectPhysics& getGameObjectPhysics(GameObject* object) = win 0x2056a0;
    void processStateTriggers() = win 0x205530;
    void stopTweenAction(int action) = win inline, ios inline {
        m_tweenActions.erase(action);
    }
    void tweenValue(float from, float to, int action, float duration, int easing, float rate, int uniqueID, int controlID) = win 0x2053e0;
    void updateTweenAction(float value, int action) = win inline {
        switch (action) {
            case 1: m_cameraPosition.x = value; break;
            case 2: m_cameraPosition.y = value; break;
            case 7: m_levelFlipping = value; break;
            case 9: m_portalY = value; break;
            case 10: m_unkPoint6.x = value; break;
            case 11: m_unkPoint6.y = value; break;
            case 12: m_unkPoint8.x = value; break;
            case 13: m_unkPoint8.y = value; break;
            case 14: m_cameraZoom = value; break;
            case 15: m_cameraOffset.x = value; break;
            case 16: m_cameraOffset.y = value; break;
            case 17: m_cameraAngle = value; break;
            case 18: m_unkPoint26.x = value; break;
            case 19: m_unkPoint26.y = value; break;
            case 20: m_middleGroundOffsetY = value; break;
            case 21: m_unkPoint12.x = value; break;
            case 22: m_unkPoint12.y = value; break;
            case 25: m_unkFloat9 = value; break;
        }
    }
    void updateTweenActions(float tweenValue) = win inline {
        for (auto it = m_tweenActions.begin(); it != m_tweenActions.end();) {
            it->second.step(tweenValue);
            this->updateTweenAction(it->second.m_currentValue, it->first);
            if (it->second.m_finished) it = m_tweenActions.erase(it);
            else ++it;
        }
    }

    float m_cameraZoom;
    float m_targetCameraZoom;
    cocos2d::CCPoint m_cameraOffset;
    cocos2d::CCPoint m_unkPoint1;
    cocos2d::CCPoint m_unkPoint2;
    cocos2d::CCPoint m_unkPoint3;
    cocos2d::CCPoint m_unkPoint4;
    cocos2d::CCPoint m_unkPoint5;
    cocos2d::CCPoint m_unkPoint6;
    cocos2d::CCPoint m_unkPoint7;
    cocos2d::CCPoint m_unkPoint8;
    cocos2d::CCPoint m_unkPoint9;
    cocos2d::CCPoint m_unkPoint10;
    cocos2d::CCPoint m_unkPoint11;
    cocos2d::CCPoint m_unkPoint12;
    cocos2d::CCPoint m_unkPoint13;
    cocos2d::CCPoint m_unkPoint14;
    cocos2d::CCPoint m_unkPoint15;
    cocos2d::CCPoint m_unkPoint16;
    cocos2d::CCPoint m_unkPoint17;
    cocos2d::CCPoint m_unkPoint18;
    cocos2d::CCPoint m_unkPoint19;
    cocos2d::CCPoint m_unkPoint20;
    cocos2d::CCPoint m_unkPoint21;
    cocos2d::CCPoint m_unkPoint22;
    cocos2d::CCPoint m_unkPoint23;
    cocos2d::CCPoint m_unkPoint24;
    cocos2d::CCPoint m_unkPoint25;
    cocos2d::CCPoint m_unkPoint26;
    cocos2d::CCPoint m_unkPoint27;
    cocos2d::CCPoint m_unkPoint28;
    cocos2d::CCPoint m_unkPoint29;
    bool m_unkBool1;
    int m_unkInt1;
    bool m_unkBool2;
    int m_unkInt2;
    bool m_unkBool3;
    cocos2d::CCPoint m_unkPoint30;
    float m_middleGroundOffsetY;
    int m_unkInt3;
    int m_unkInt4;
    bool m_unkBool4;
    bool m_unkBool5;
    float m_unkFloat2;
    float m_unkFloat3;
    int m_unkInt5;
    int m_unkInt6;
    int m_unkInt7;
    int m_unkInt8;
    int m_unkInt9;
    int m_unkInt10;
    int m_unkInt11;
    float m_unkFloat4;
    float m_unkUint1;
    float m_portalY;
    bool m_unkBool6;
    bool m_gravityRelated;
    int m_unkInt12;
    float m_unkInt13;
    int m_unkInt14;
    int m_unkInt15;
    bool m_unkBool7;
    bool m_unkBool8;
    bool m_unkBool9;
    float m_unkFloat5;
    float m_unkFloat6;
    float m_unkFloat7;
    float m_unkFloat8;
    float m_cameraAngle;
    float m_targetCameraAngle;
    bool m_playerStreakBlend;
    float m_timeWarp;
    float m_timeWarpRelated;
    int m_currentChannel;
    int m_rotateChannel;
    gd::unordered_map<int, int> m_spawnChannelRelated0;
    gd::unordered_map<int, bool> m_spawnChannelRelated1;
    double m_totalTime;
    double m_levelTime;
    double m_unkDouble3;
    int m_unkUint2;
    float m_unkUint3;
    int m_currentProgress;
    int m_unkUint4;
    int m_unkUint5;
    int m_unkUint6;
    int m_unkUint7;
    GameObject* m_lastActivatedPortal1;
    GameObject* m_lastActivatedPortal2;
    cocos2d::CCPoint m_cameraPosition;
    bool m_unkBool10;
    float m_levelFlipping;
    bool m_unkBool11;
    bool m_unkBool12;
    bool m_isDualMode;
    float m_unkFloat9;
    gd::unordered_map<int, GJValueTween> m_tweenActions;
    int m_cameraEdgeValue0;
    int m_cameraEdgeValue1;
    int m_cameraEdgeValue2;
    int m_cameraEdgeValue3;
    gd::unordered_map<int, GameObjectPhysics> m_gameObjectPhysics;
    gd::vector<float> m_unkVecFloat1;
    float m_unkUint10;
    int m_unkUint11;
    int m_unkUint12;
    cocos2d::CCPoint m_cameraStepDiff;
    float m_unkFloat10;
    unsigned int m_timeModRelated;
    bool m_timeModRelated2;
    gd::map<std::pair<int, int>, int> m_unkMapPairIntIntInt;
    float m_unkUint13;
    cocos2d::CCPoint m_unkPoint32;
    // same as m_cameraPosition but still updates in the editor when not playtesting?
    cocos2d::CCPoint m_cameraPosition2;
    bool m_unkBool20;
    bool m_unkBool21;
    bool m_unkBool22;
    float m_unkUint14;
    bool m_unkBool26;
    bool m_cameraShakeEnabled;
    float m_cameraShakeFactor;
    float m_unkUint15;
    float m_unkUint16;
    double m_unkUint64_1;
    cocos2d::CCPoint m_unkPoint34;
    unsigned int m_dualRelated;
    gd::unordered_map<int, EnhancedGameObject*> m_stateObjects;
    gd::map<std::pair<GJGameEvent, int>, gd::vector<EventTriggerInstance>> m_unkMapPairGJGameEventIntVectorEventTriggerInstance;
    gd::map<std::pair<GJGameEvent, int>, int> m_unkMapPairGJGameEventIntInt;
    gd::unordered_map<int, gd::vector<EnterEffectInstance>> m_enterEffectInstanceVectors;
    gd::unordered_map<int, gd::vector<EnterEffectInstance>> m_exitEffectInstanceVectors;
    gd::vector<int> m_enterChannelMap;
    gd::vector<int> m_exitChannelMap;
    gd::vector<EnterEffectInstance> m_moveEffectInstances;
    gd::vector<EnterEffectInstance> m_rotateEffectInstances;
    gd::vector<EnterEffectInstance> m_scaleEffectInstances;
    gd::vector<EnterEffectInstance> m_fadeEffectInstances;
    gd::vector<EnterEffectInstance> m_tintEffectInstances;
    gd::unordered_set<int> m_unsortedAreaEffects;
    bool m_unkBool27;
    gd::vector<AdvancedFollowInstance> m_advanceFollowInstances;
    gd::vector<DynamicObjectAction> m_dynamicMoveActions;
    gd::vector<DynamicObjectAction> m_dynamicRotateActions;
    bool m_unkBool28;
    bool m_unkBool29;
    float m_unkUint17;
    gd::unordered_map<int, gd::vector<int>> m_unkUMap8;
    gd::map<std::pair<int,int>, SFXTriggerInstance> m_proximityVolumeRelated;
    gd::unordered_map<int, SongChannelState> m_songChannelStates;
    gd::unordered_map<int, gd::vector<SongTriggerState>> m_songTriggerStateVectors;
    gd::vector<SFXTriggerState> m_sfxTriggerStates;
    bool m_unkBool30;
    int m_background;
    int m_ground;
    int m_middleground;
    bool m_unkBool31;
    int m_points;
    bool m_unkBool32;
    unsigned int m_pauseCounter;
    unsigned int m_pauseBufferTimer;
}

[[link(android)]]
class GJGarageLayer : cocos2d::CCLayer, TextInputDelegate, FLAlertLayerProtocol, GameRateDelegate, ListButtonBarDelegate, DialogDelegate, CharacterColorDelegate, RewardedVideoDelegate {
    GJGarageLayer() {
        m_playerObject = nullptr;
        m_unknown = nullptr;
        m_supporter = nullptr;
        m_hasClosed = false;
        m_cursor2 = nullptr;
        m_currentIcon = nullptr;
        m_iconSelection = nullptr;
        m_iconID = 0;
        m_selectedIconType = IconType::Cube;
        m_videoPlaying = false;
    }
    ~GJGarageLayer() = win inline {
        auto gm = GameManager::sharedState();
        gm->m_gameRateDelegate1 = nullptr;
        CC_SAFE_RELEASE(m_tabButtons);
        CC_SAFE_RELEASE(m_pageButtons);
        if (gm->m_rewardedVideoDelegate == this) gm->m_rewardedVideoDelegate = nullptr;
    }

    static gd::string achievementForUnlock(int id, UnlockType type) = win inline, ios inline {
        auto achievementManager = AchievementManager::sharedState();
        auto achievement = achievementManager->achievementForUnlock(id, type);
        return achievementManager->isAchievementAvailable(achievement) ? achievement : "";
    }
    static gd::string descriptionForUnlock(int id, UnlockType type) = win 0x278120;
    static GJGarageLayer* node() = win inline {
        auto ret = new GJGarageLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static cocos2d::CCScene* scene() = win 0x272ca0;
    static gd::string titleForUnlock(int id, UnlockType type) = win inline {
        auto achievementManager = AchievementManager::sharedState();
        return achievementManager->getAchievementsWithID(achievementManager->achievementForUnlock(id, type).c_str())->valueForKey("title")->getCString();
    }

    virtual bool init() = win 0x272e60, ios 0x1234567, imac 0x1234567, m1 0x1234567;
    virtual void keyBackClicked() = win 0x278fe0;
    virtual void textInputOpened(CCTextInputNode* node) = win 0x274a80;
    virtual void textInputClosed(CCTextInputNode* node) = win 0x274c70;
    virtual void textChanged(CCTextInputNode* node) = win 0xc3da0;
    virtual void listButtonBarSwitchedPage(ListButtonBar* bar, int page) = win 0xc3e50;
    virtual void showUnlockPopup(int id, UnlockType type) = win 0x277a10;
    virtual void updateRate() = win 0x2786e0;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x2782b0;
    virtual void dialogClosed(DialogLayer* layer) = win 0x278510;
    virtual void playerColorChanged() = win 0x277860;
    virtual void rewardedVideoFinished();

    cocos2d::CCArray* getItems(IconType type) = win 0x276540;
    cocos2d::CCArray* getItems(int count, int page, IconType type, int current) = win 0x276600;
    gd::string getLockFrame(int id, UnlockType type) = win inline, ios inline {
        return "GJ_lock_001";
    }
    void onArrow(cocos2d::CCObject* sender) = win 0x275c80;
    void onBack(cocos2d::CCObject* sender) = win 0x278e40;
    void onInfo(cocos2d::CCObject* sender) = win 0x274880;
    void onNavigate(cocos2d::CCObject* sender) = win 0x275d80;
    void onPaint(cocos2d::CCObject* sender) = win 0x278c60;
    void onRewardedVideo(cocos2d::CCObject* sender);
    void onSelect(cocos2d::CCObject* sender) = win 0x276f80;
    void onSelectTab(cocos2d::CCObject* sender);
    void onShards(cocos2d::CCObject* sender) = win 0x278b10;
    void onShop(cocos2d::CCObject* sender);
    void onSpecial(cocos2d::CCObject* sender);
    void onToggleItem(cocos2d::CCObject* sender) = win 0x277620;
    void playRainbowEffect() = win 0x278920;
    void playShadowEffect() = win inline, ios inline {
        auto circleWave = CCCircleWave::create(20.f, 60.f, .3f, false);
        circleWave->m_color.r = 0;
        circleWave->m_color.g = 0;
        circleWave->m_color.b = 0;
        circleWave->m_opacityMod = .5f;
        circleWave->m_blendAdditive = false;
        circleWave->setPosition(m_playerObject->getPosition());
        this->addChild(circleWave, -1);
    }
    void selectTab(IconType type) = win 0x275de0;
    void setupIconSelect() = win 0x275020;
    void setupPage(int page, IconType type) = win 0x275ea0;
    void setupSpecialPage() = win 0x2768d0;
    void showUnlockPopupNew(int id, UnlockType type) = win inline, ios inline {
        ItemInfoPopup::create(id, type)->show();
    }
    void toggleGlow() = win inline, ios inline {
        auto gameManager = GameManager::sharedState();
        gameManager->m_playerGlow = !gameManager->m_playerGlow;
        m_playerObject->m_hasGlowOutline = gameManager->m_playerGlow;
        m_playerObject->updateColors();
        if (gameManager->m_playerGlow) this->playRainbowEffect();
    }
    void updatePlayerColors() = win 0x277890;
    void updatePlayerName(char const* name) = win inline, ios inline {}

    CCTextInputNode* m_usernameInput;
    SimplePlayer* m_playerObject;
    cocos2d::CCArray* m_tabButtons;
    cocos2d::CCArray* m_pageButtons;
    cocos2d::CCNode* m_unknown;
    cocos2d::CCSprite* m_supporter;
    bool m_hasClosed;
    IconType m_iconType;
    gd::map<IconType, int> m_iconPages;
    cocos2d::CCSprite* m_cursor1;
    cocos2d::CCSprite* m_cursor2;
    CCMenuItemSpriteExtra* m_currentIcon;
    ListButtonBar* m_iconSelection;
    CCMenuItemSpriteExtra* m_leftArrow;
    CCMenuItemSpriteExtra* m_rightArrow;
    cocos2d::CCMenu* m_navDotMenu;
    int m_iconID;
    IconType m_selectedIconType;
    bool m_videoPlaying;
}

[[link(android)]]
class GJGradientLayer : cocos2d::CCLayerGradient {
    // virtual ~GJGradientLayer();
    GJGradientLayer() {
        m_baseColor = 0;
        m_detailColor = 0;
        m_triggerObject = nullptr;
        m_noScale = false;
        m_blendingMode = 0;
        m_blendingLayer = 0;
        m_gradientID = 0;
    }

    static GJGradientLayer* create() = win inline {
        auto ret = new GJGradientLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x248bb0;

    int m_baseColor;
    int m_detailColor;
    cocos2d::CCPoint m_gradientPosition;
    GradientTriggerObject* m_triggerObject;
    bool m_noScale;
    int m_blendingMode;
    int m_blendingLayer;
    int m_gradientID;
}

[[link(android)]]
class GJGroundLayer : cocos2d::CCLayer {
    // virtual ~GJGroundLayer();

    static GJGroundLayer* create(int groundID, int lineType) = win 0x27e000;

    virtual void draw() = win inline {}
    virtual void showGround();
    virtual void fadeInGround(float duration) = win 0x27ec60;
    virtual void fadeOutGround(float duration);

    void createLine(int lineType) = win 0x27e8b0;
    void deactivateGround() = win inline, ios inline {
        this->stopAllActions();
        m_showGround = false;
    }
    void fadeInFinished();
    float getGroundY() = win inline, ios inline {
        return 0.f;
    }
    void hideShadows() = win inline, ios inline {
        if (auto leftShadow = this->getChildByTag(0)) leftShadow->setVisible(false);
        if (auto rightShadow = this->getChildByTag(1)) rightShadow->setVisible(false);
    }
    bool init(int groundID, int lineType) = win 0x27e080;
    void loadGroundSprites(int count, bool ground1) = win 0x27e5f0;
    void positionGround(float y) = win inline {
        this->setPosition(0.f, y);
    }
    float scaleGround(float scale) = win 0xcd280;
    void toggleVisible01(bool visible) = win inline {
        if (m_showGround1 == visible) return;
        m_showGround1 = visible;
        this->setVisible(visible && m_showGround2);
    }
    void toggleVisible02(bool visible) = win inline {
        if (m_showGround2 == visible) return;
        m_showGround2 = visible;
        this->setVisible(visible && m_showGround1);
    }
    void updateGround01Color(cocos2d::ccColor3B color) = win inline {
        if (auto children = m_ground1Sprite->getChildren()) {
            for (int i = 0; i < children->count(); i++) {
                static_cast<cocos2d::CCSprite*>(children->objectAtIndex(i))->setColor(color);
            }
        }
    }
    void updateGround02Color(cocos2d::ccColor3B color) = win inline {
        if (!m_ground2Sprite) return;
        if (auto children = m_ground2Sprite->getChildren()) {
            for (int i = 0; i < children->count(); i++) {
                static_cast<cocos2d::CCSprite*>(children->objectAtIndex(i))->setColor(color);
            }
        }
    }
    void updateGroundPos(cocos2d::CCPoint pos) = win inline {
        m_ground1Sprite->setPosition(pos);
        if (m_ground2Sprite) m_ground2Sprite->setPosition(pos);
    }
    void updateGroundWidth(bool useThis) = win inline {
        auto parent = this->getParent();
        if (!parent) return;
        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        auto scale = useThis ? this->getScaleX() : parent->getScale();
        m_groundWidth = winSize.width / scale + 10.f;
        int count = ceilf(m_groundWidth / m_textureWidth) + 1.f;
        if (m_cameraRotated) count++;
        this->loadGroundSprites(count, true);
        this->loadGroundSprites(count, false);
        m_lineSprite->setScaleX(m_lineType > 1 ? (((winSize.width + 10.f) / scale) / m_lineSprite->getTextureRect().size.width) : (1.f / scale));
        m_lineSprite->setPosition({ m_groundWidth * .5f - 5.f, m_lineSprite->getPosition().y } );
    }
    void updateLineBlend(bool blend) = win inline {
        if (m_blendLine == blend) return;
        m_blendLine = blend;
        if (blend) m_lineSprite->setBlendFunc({ GL_SRC_ALPHA, GL_ONE });
        else m_lineSprite->setBlendFunc({ GL_ONE, GL_ONE_MINUS_SRC_ALPHA });
    }
    void updateShadows() = win 0x27ece0;
    void updateShadowXPos(float leftX, float rightX) = win 0x27ed80;

    cocos2d::CCSprite* m_ground1Sprite;
    cocos2d::CCSprite* m_ground2Sprite;
    float m_textureWidth;
    cocos2d::CCSprite* m_lineSprite;
    bool m_showGround;
    bool m_blendLine;
    float m_ground1Offset;
    int m_lineType;
    float m_groundWidth;
    bool m_showGround1;
    bool m_showGround2;
    float m_unk1cc;
    bool m_cameraRotated;
}

[[link(android)]]
class GJHttpResult : cocos2d::CCNode {
    // virtual ~GJHttpResult();
    GJHttpResult() {
        m_success = false;
        m_httpType = (GJHttpType)0;
    }

    static GJHttpResult* create(bool success, gd::string response, gd::string tag, GJHttpType type) = win inline, ios inline {
        auto ret = new GJHttpResult();
        if (ret->init(success, response, tag, type)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init(bool success, gd::string response, gd::string tag, GJHttpType type) = win inline, ios inline {
        if (!cocos2d::CCNode::init()) return false;
        m_success = success;
        m_response = response;
        m_requestTag = tag;
        m_httpType = type;
        return true;
    }

    bool m_success;
    gd::string m_response;
    gd::string m_requestTag;
    GJHttpType m_httpType;
}

[[link(android)]]
class GJItemIcon : cocos2d::CCSprite {
    GJItemIcon() {
        m_player = nullptr;
        m_iconRequestID = 0;
        m_isIcon = false;
        m_unlockID = 0;
        m_unlockType = (UnlockType)0;
    }
    ~GJItemIcon() = win inline {
        GameManager::sharedState()->unloadIcons(m_iconRequestID);
    }

    static GJItemIcon* create(UnlockType type, int id, cocos2d::ccColor3B color1, cocos2d::ccColor3B color2, bool dark, bool unused, bool noLabel, cocos2d::ccColor3B unlockColor) = win inline {
        auto ret = new GJItemIcon();
        if (ret->init(type, id, color1, color2, dark, unused, noLabel, unlockColor)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static GJItemIcon* createBrowserItem(UnlockType unlockType, int itemID) = win 0x27a800, ios inline {
        return create(unlockType, itemID, { 175, 175, 175 }, { 255, 255, 255 }, false, true, true, { 255, 255, 255 });
    }
    static GJItemIcon* createStoreItem(UnlockType type, int id, bool dark, cocos2d::ccColor3B unlockColor) = win 0x27a6d0;
    static float scaleForType(UnlockType type) = win 0x27b520;
    static cocos2d::ccColor3B unlockedColorForType(int type) = win inline {
        switch (type) {
            case 1: return { 10, 30, 20 };
            case 2: return { 33, 22, 66 };
            case 3: return { 20, 20, 40 };
            case 4: return { 20, 30, 50 };
            case 5: return { 50, 50, 50 };
            default: return { 60, 30, 20 };
        }
    }

    virtual void setOpacity(unsigned char opacity) = win 0x27b030;

    void changeToLockedState(float scale) = win 0x27b440;
    void darkenStoreItem(ShopType type) = win 0x27b0d0;
    void darkenStoreItem(cocos2d::ccColor3B color) = win 0x27b150;
    bool init(UnlockType type, int id, cocos2d::ccColor3B color1, cocos2d::ccColor3B color2, bool dark, bool unused, bool noLabel, cocos2d::ccColor3B unlockColor) = win 0x27a920;
    void toggleEnabledState(bool enabled) = win 0x27b380;

    cocos2d::CCSprite* m_player;
    int m_iconRequestID;
    cocos2d::CCSize m_playerSize;
    bool m_isIcon;
    int m_unlockID;
    UnlockType m_unlockType;
}

[[link(android)]]
class GJLevelList : cocos2d::CCNode {
    // virtual ~GJLevelList();
    GJLevelList() {
        m_listID = 0;
        m_listVersion = 0;
        m_downloads = 0;
        m_likes = 0;
        m_difficulty = -1;
        m_accountID = 0;
        m_folder = 0;
        m_listRevision = 0;
        m_listOrder = 0;
        m_original = 0;
        m_diamonds = 0;
        m_levelsToClaim = 0;
        m_isEditable = false;
        m_unlisted = false;
        m_friendsOnly = false;
        m_uploaded = false;
        m_favorite = false;
        m_featured = false;
        m_onlineLevelsLoaded = false;
        m_modified = false;
        m_levelsDict = nullptr;
        m_listType = GJLevelType::Default;
        m_M_ID = 0;
    }

    static GJLevelList* create() = win 0x1767b0;
    static GJLevelList* create(cocos2d::CCDictionary* dict) = win 0x175ec0;
    static GJLevelList* createWithCoder(DS_Dictionary* dict) = win inline {
        auto ret = GJLevelList::create();
        ret->dataLoaded(dict);
        return ret;
    }
    static gd::string frameForListDifficulty(int diff, DifficultyIconType type) = win inline {
        if (diff == 0) return type == DifficultyIconType::NoText ? "diffIcon_auto_btn_001.png" : "difficulty_auto_btn_001.png";

        if (diff > 10) diff = 0;
        switch (diff) {
            case 6: diff = 7; break;
            case 7: diff = 8; break;
            case 8: diff = 6; break;
        }

        if (type == DifficultyIconType::NoText) {
            return cocos2d::CCString::createWithFormat("diffIcon_%02d_btn_001.png", diff)->getCString();
        }
        else if (type == DifficultyIconType::DefaultText && diff > 5) {
            return cocos2d::CCString::createWithFormat("difficulty_%02d_btn2_001.png", diff)->getCString();
        }
        else {
            return cocos2d::CCString::createWithFormat("difficulty_%02d_btn_001.png", diff)->getCString();
        }
    }

    virtual void encodeWithCoder(DS_Dictionary* dict) = win 0x178040;
    virtual bool canEncode() = win inline { return true; }
    virtual bool init() = win 0x176940;

    void addLevelToList(GJGameLevel* level) = win 0x176f30;
    int completedLevels() = win 0x1778b0;
    void dataLoaded(DS_Dictionary* dict) = win 0x177d20;
    void duplicateListLevels(GJLevelList* list) = win inline {
        auto levels = list->getListLevelsArray(nullptr);
        for (int i = 0; i < levels->count(); i++) {
            this->addLevelToList(static_cast<GJGameLevel*>(levels->objectAtIndex(i)));
        }
    }
    cocos2d::CCArray* getListLevelsArray(cocos2d::CCArray* levels) = win 0x1771b0;
    gd::string getUnpackedDescription();
    void handleStatsConflict(GJLevelList* list) = win inline {
        m_listOrder = std::max(m_listOrder, list->m_listOrder);
    }
    bool hasMatchingLevels(GJLevelList* list) = win 0x1769c0;
    int orderForLevel(int id) = win inline {
        auto index = 0;
        for (auto levelID : m_levels) {
            if (levelID == id) return index;
            index++;
        }
        return index;
    }
    void parseListLevels(gd::string str) = win 0x176c90;
    void removeLevelFromList(int id) = win inline {
        for (auto it = m_levels.begin(); it != m_levels.end(); ++it) {
            if (*it == id) {
                m_levels.erase(it);
                this->updateLevelsString();
                break;
            }
        }
        m_levelsDict->removeObjectForKey(GameToolbox::intToString(id));
        m_modified = true;
    }
    void reorderLevel(int levelID, int newPosition) = win 0x1770c0;
    void reorderLevelStep(int id, bool up) = win inline {
        this->reorderLevel(id, this->orderForLevel(id) + (up ? -1 : 1));
    }
    void showListInfo() = win 0x177950;
    int totalLevels() = win inline {
        return m_levels.size();
    }
    void updateLevelsString() = win 0x1777a0;

    gd::vector<int> m_levels;
    int m_listID;
    int m_listVersion;
    int m_downloads;
    int m_likes;
    int m_difficulty;
    int m_accountID;
    int m_folder;
    int m_listRevision;
    int m_listOrder;
    int m_original;
    int m_diamonds;
    int m_levelsToClaim;
    bool m_isEditable;
    bool m_unlisted;
    bool m_friendsOnly;
    bool m_uploaded;
    bool m_favorite;
    bool m_featured;
    bool m_onlineLevelsLoaded;
    bool m_modified;
    gd::string m_creatorName;
    gd::string m_listName;
    gd::string m_unkString;
    gd::string m_levelsString;
    gd::string m_listDesc;
    int m_uploadDate;
    int m_updateDate;
    cocos2d::CCDictionary* m_levelsDict;
    GJLevelType m_listType;
    int m_M_ID;
}

[[link(android)]]
class GJLevelScoreCell : TableViewCell {
    // virtual ~GJLevelScoreCell();
    GJLevelScoreCell(char const* identifier, float width, float height) = win inline, ios inline : TableViewCell(identifier, width, height) {
        this->init();
    }

    virtual bool init();
    virtual void draw() = win 0xade40;

    void loadFromScore(GJUserScore* score) = win 0xba0c0;
    void onViewProfile(cocos2d::CCObject* sender);
    void updateBGColor(int index) = win inline {
        m_backgroundLayer->setColor(index % 2 == 0 ? cocos2d::ccColor3B { 161, 88, 44 } : cocos2d::ccColor3B { 194, 114, 62 });
        m_backgroundLayer->setOpacity(255);
    }

    GJUserScore* m_userScore;
}

[[link(android)]]
class GJListLayer : cocos2d::CCLayerColor {
    // virtual ~GJListLayer();

    static GJListLayer* create(BoomListView* listView, char const* title, cocos2d::ccColor4B color, float width, float height, int type) = win 0x27f600;

    bool init(BoomListView* listView, char const* title, cocos2d::ccColor4B color, float width, float height, int type) = win 0x27f730;

    BoomListView* m_listView;
}

[[link(android)]]
class GJLocalLevelScoreCell : TableViewCell {
    // virtual ~GJLocalLevelScoreCell();
    GJLocalLevelScoreCell(char const* identifier, float width, float height) = win inline, ios inline : TableViewCell(identifier, width, height) {
        this->init();
    }

    virtual bool init();
    virtual void draw() = win 0xade40;

    void loadFromScore(GJLocalScore* score) = win 0xb9cc0;
    void updateBGColor(int index) = win inline {
        m_backgroundLayer->setColor(index % 2 == 0 ? cocos2d::ccColor3B { 161, 88, 44 } : cocos2d::ccColor3B { 194, 114, 62 });
        m_backgroundLayer->setOpacity(255);
    }

    GJLocalScore* m_localScore;
}

[[link(android)]]
class GJLocalScore : cocos2d::CCObject {
    // virtual ~GJLocalScore();
    GJLocalScore() {
        m_points = 0;
        m_type = LevelLeaderboardType::Friends;
        m_currentScore = false;
    }

    static GJLocalScore* create(int points, int type) = win inline {
        auto ret = new GJLocalScore();
        if (ret->init(points, type)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init(int points, int type) = win inline, ios inline {
        m_points = points;
        m_type = (LevelLeaderboardType)type;
        return true;
    }

    int m_points;
    LevelLeaderboardType m_type;
    bool m_currentScore;
}

[[link(android)]]
class GJMapObject : cocos2d::CCNode {
    // virtual ~GJMapObject();

    static GJMapObject* create(cocos2d::CCNode* parent);
    static GJMapObject* createMonster(int objectID);

    bool init(cocos2d::CCNode* parent);
    void monsterIdle();
    void monsterJump();
    void moveFinished();
    void moveMonster();
    void moveMonster(cocos2d::CCPoint position, float offset);
    void playerJump();
    void setObjectOrigin(cocos2d::CCPoint position, float offset);
    void startMonsterJumpLoop();
    void startPlayerJumpLoop();
    void touchMonster();
    void updateShadow(float scaleX, float scaleY, cocos2d::CCPoint position);

    float m_jumpStopTime;
    cocos2d::CCNode* m_mainNode;
    cocos2d::CCSprite* m_shadowSprite;
    cocos2d::CCPoint m_objectOrigin;
    float m_objectOffset;
    bool m_monsterIdle;
    bool m_monsterMoving;
    float m_moveStopTime;
    int m_monstersTouched;
}

[[link(android)]]
class GJMapPack : cocos2d::CCNode {
    GJMapPack() {
        m_levels = nullptr;
        m_packID = 0;
        m_difficulty = GJDifficulty::Auto;
        m_stars = 0;
        m_coins = 0;
        m_MId = 0;
        m_isGauntlet = false;
    }
    ~GJMapPack() = win inline {
        CC_SAFE_RELEASE(m_levels);
    }

    static GJMapPack* create() = win inline {
        auto ret = new GJMapPack();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static GJMapPack* create(cocos2d::CCDictionary* dict) = win 0x170160;

    virtual bool init() = win 0x170cc0;

    int completedMaps() = win 0x170fd0;
    bool hasCompletedMapPack() = win inline {
        auto total = this->totalMaps();
        if (total > 0) return this->completedMaps() >= total;
        else return 0;
    }
    void parsePackColors(gd::string textColorStr, gd::string barColorStr) = win 0x170d20;
    void parsePackLevels(gd::string levelsStr) = win inline {
        CC_SAFE_RELEASE(m_levels);
        auto levels = cocos2d::CCArray::create();
        auto start = 0;
        auto index = levelsStr.find_first_of(",");
        auto size = levelsStr.size();
        while (index != std::string::npos) {
            auto str = levelsStr.substr(start, index - start);
            if (!str.empty() || start != size) {
                levels->addObject(cocos2d::CCString::create(str));
            }
            start = index + 1;
            index = levelsStr.find_first_of(",", start);
        }
        m_levels = levels;
        levels->retain();
    }
    int totalMaps() = win inline {
        if (this->m_levels) {
            return this->m_levels->count();
        }

        return 0;
    }

    cocos2d::CCArray* m_levels;
    int m_packID;
    GJDifficulty m_difficulty;
    int m_stars;
    int m_coins;
    gd::string m_packName;
    gd::string m_levelStrings;
    cocos2d::ccColor3B m_textColour;
    cocos2d::ccColor3B m_barColour;
    int m_MId;
    bool m_isGauntlet;
}

[[link(android)]]
class GJMessageCell : TableViewCell, FLAlertLayerProtocol, UploadPopupDelegate, UploadActionDelegate {
    GJMessageCell(char const* identifier, float width, float height) = win inline, ios inline : TableViewCell(identifier, width, height) {
        this->init();
    }
    ~GJMessageCell() = win inline {
        auto glm = GameLevelManager::sharedState();
        if (glm->m_uploadActionDelegate == this) glm->m_uploadActionDelegate = nullptr;
        if (m_popup) m_popup->m_delegate = nullptr;
        CC_SAFE_RELEASE(m_message);
    }

    virtual bool init() = win 0xbc340;
    virtual void draw() = win 0xade40;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0xbe180;
    virtual void uploadActionFinished(int id, int response) = win 0xbe320;
    virtual void uploadActionFailed(int id, int response);
    virtual void onClosePopup(UploadActionPopup* popup);

    void loadFromMessage(GJUserMessage* message) = win 0xbd520;
    void markAsRead() = win 0xbdeb0;
    void onDeleteMessage(cocos2d::CCObject* sender) = win 0xbdfc0;
    void onToggle(cocos2d::CCObject* sender);
    void onViewMessage(cocos2d::CCObject* sender) = win 0xbde10;
    void onViewProfile(cocos2d::CCObject* sender);
    void updateBGColor(int index) = win inline {
        m_backgroundLayer->setColor(index % 2 == 0 ? cocos2d::ccColor3B { 161, 88, 44 } : cocos2d::ccColor3B { 194, 114, 62 });
        m_backgroundLayer->setOpacity(255);
    }
    void updateToggle() = win inline, ios inline {
       if (m_message && m_toggler) m_toggler->toggle(m_message->m_toggled);
    }

    GJUserMessage* m_message;
    UploadActionPopup* m_popup;
    CCMenuItemToggler* m_toggler;
}

[[link(android)]]
class GJMessagePopup : FLAlertLayer, UploadActionDelegate, UploadPopupDelegate, FLAlertLayerProtocol, DownloadMessageDelegate {
    // virtual ~GJMessagePopup();

    static GJMessagePopup* create(GJUserMessage* message) = win 0x2971d0;

    virtual void keyBackClicked() = win 0x846c0;
    virtual void downloadMessageFinished(GJUserMessage* message) = win 0x298970;
    virtual void downloadMessageFailed(int id) = win 0x2989c0;
    virtual void uploadActionFinished(int id, int response) = win 0x298a00;
    virtual void uploadActionFailed(int id, int response) = win 0x298b90;
    virtual void onClosePopup(UploadActionPopup* popup) = win 0x298c60;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x298ce0;

    void blockUser() = win inline {
        if (GameLevelManager::sharedState()->blockUser(m_message->m_accountID)) {
            m_uploadPopup = UploadActionPopup::create(this, "Blocking user...");
            m_uploadPopup->show();
        }
    }
    bool init(GJUserMessage* message) = win 0x297310;
    void loadFromGJMessage(GJUserMessage* message) = win 0x297c20;
    void onBlock(cocos2d::CCObject* sender) = win 0x298740;
    void onClose(cocos2d::CCObject* sender) = win 0x84690;
    void onRemove(cocos2d::CCObject* sender);
    void onReply(cocos2d::CCObject* sender) = win 0x298270;

    bool m_actionSuccess;
    cocos2d::CCLabelBMFont* m_errorLabel;
    GJUserMessage* m_message;
    LoadingCircle* m_loadingCircle;
    CCMenuItemSpriteExtra* m_closeButton;
    UploadActionPopup* m_uploadPopup;
}

[[link(android)]]
class GJMGLayer : cocos2d::CCLayer {
    // virtual ~GJMGLayer();
    GJMGLayer() {
        m_ground1Sprite = nullptr;
        m_ground2Sprite = nullptr;
        m_textureWidth = 0.f;
        m_unk1b0 = nullptr;
        m_showGround = false;
        m_groundWidth = 0.f;
        m_showGround1 = true;
        m_showGround2 = true;
        m_unk1c4 = 0.f;
        m_cameraRotated = false;
        m_blendMG1 = false;
        m_blendMG2 = false;
        m_mg1BatchNode = nullptr;
        m_mg2BatchNode = nullptr;
        m_groundScale = 0.f;
        m_ground2Offset = 0.f;
    }

    static GJMGLayer* create(int index) = win inline {
        auto ret = new GJMGLayer();
        if (ret->init(index)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static float defaultYOffsetForBG2(int index) = win inline, ios inline {
        switch (index) {
            case 1: return 25.f;
            case 2: case 3: return 30.f;
            default: return 0.f;
        }
    }

    virtual void draw() = win inline {}
    virtual void showGround();

    void deactivateGround() = win inline, ios inline {
        this->stopAllActions();
        m_showGround = false;
    }
    bool init(int index) = win 0x27ee60;
    void loadGroundSprites(int count, bool ground1) = win 0x27f360;
    float scaleGround(float scale) = win inline {
        m_groundScale = scale;
        this->setScaleX(scale);
        if (this->getScaleY() < 0.f) this->setScaleY(-scale);
        else this->setScaleY(scale);
        auto groundWidth = m_groundWidth;
        this->updateGroundWidth(true);
        return m_groundWidth - groundWidth;
    }
    void toggleVisible01(bool visible) = win inline, ios inline {
        if (m_showGround1 == visible) return;
        m_showGround1 = visible;
        this->setVisible(visible && m_showGround2);
    }
    void toggleVisible02(bool visible) = win inline {
        if (m_showGround2 == visible) return;
        m_showGround2 = visible;
        this->setVisible(visible && m_showGround1);
    }
    void updateGroundColor(cocos2d::ccColor3B color, bool ground1) = win inline {
        auto groundSprite = ground1 ? m_ground1Sprite : m_ground2Sprite;
        if (!groundSprite) return;
        if (auto children = groundSprite->getChildren()) {
            for (int i = 0; i < children->count(); i++) {
                static_cast<cocos2d::CCSprite*>(children->objectAtIndex(i))->setColor(color);
            }
        }
    }
    void updateGroundOpacity(unsigned char opacity, bool ground1) = win inline {
        auto groundSprite = ground1 ? m_ground1Sprite : m_ground2Sprite;
        if (!groundSprite) return;
        if (auto children = groundSprite->getChildren()) {
            for (int i = 0; i < children->count(); i++) {
                static_cast<cocos2d::CCSprite*>(children->objectAtIndex(i))->setOpacity(opacity);
            }
        }
    }
    void updateGroundPos(cocos2d::CCPoint pos) = win inline {
        m_ground1Sprite->setPosition(pos);
        if (m_ground2Sprite) m_ground2Sprite->setPosition(pos);
    }
    void updateGroundWidth(bool useThis) = win inline {
        auto parent = this->getParent();
        if (!parent) return;
        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        auto scale = useThis ? this->getScaleX() : parent->getScale();
        m_groundWidth = winSize.width / scale + 10.f;
        int count = ceilf(m_groundWidth / m_textureWidth) + 1.f;
        if (m_cameraRotated) count++;
        this->loadGroundSprites(count, true);
        this->loadGroundSprites(count, false);
    }
    void updateMG01Blend(bool blend) = win inline {
        if (m_blendMG1 == blend) return;
        m_blendMG1 = blend;
        if (blend) m_mg1BatchNode->setBlendFunc({ GL_SRC_ALPHA, GL_ONE });
        else m_mg1BatchNode->setBlendFunc({ GL_ONE, GL_ONE_MINUS_SRC_ALPHA });
    }
    void updateMG02Blend(bool blend) = win inline {
        if (m_blendMG2 == blend) return;
        m_blendMG2 = blend;
        if (blend) m_mg2BatchNode->setBlendFunc({ GL_SRC_ALPHA, GL_ONE });
        else m_mg2BatchNode->setBlendFunc({ GL_ONE, GL_ONE_MINUS_SRC_ALPHA });
    }

    cocos2d::CCSprite* m_ground1Sprite;
    cocos2d::CCSprite* m_ground2Sprite;
    float m_textureWidth;
    void* m_unk1b0;
    bool m_showGround;
    float m_groundWidth;
    bool m_showGround1;
    bool m_showGround2;
    float m_unk1c4;
    bool m_cameraRotated;
    bool m_blendMG1;
    bool m_blendMG2;
    cocos2d::CCSpriteBatchNode* m_mg1BatchNode;
    cocos2d::CCSpriteBatchNode* m_mg2BatchNode;
    float m_groundScale;
    float m_ground2Offset;
}

[[link(android)]]
class GJMoreGamesLayer : GJDropDownLayer {
    // virtual ~GJMoreGamesLayer();
    // GJMoreGamesLayer();

    static GJMoreGamesLayer* create() = win 0x27fda0;

    virtual void customSetup() = win 0x280480;

    cocos2d::CCArray* getMoreGamesList() = win 0x2800e0;

    cocos2d::CCArray* m_moreGamesList;
}

[[link(android)]]
class GJMPDelegate {
    virtual void joinLobbyFinished(int id) {}
    virtual void joinLobbyFailed(int id, GJMPErrorCode errorType) {}
    virtual void didUploadMPComment(int id) {}
    virtual void updateComments() {}
}

[[link(android)]]
class GJMultiplayerManager : cocos2d::CCNode {
    // virtual ~GJMultiplayerManager();

    static GJMultiplayerManager* sharedState() = win 0x282450;

    virtual bool init() = win 0x282ba0;

    void addComment(gd::string str, int lobbyID) = win 0x283b70;
    void addDLToActive(char const* tag) = win inline, ios inline {
        this->addDLToActive(tag, cocos2d::CCNode::create());
    }
    void addDLToActive(char const* tag, cocos2d::CCObject* obj) = win inline, ios inline {
        m_activeDownloads->setObject(obj, tag);
    }
    void createAndAddComment(gd::string text, int lobbyID) = win 0x283990;
    void dataLoaded(DS_Dictionary* dict) = win inline {}
    void encodeDataTo(DS_Dictionary* dict) = win inline {}
    bool exitLobby(int id);
    void firstSetup() = win inline {}
    gd::string getBasePostString() = win 0x283d30;
    cocos2d::CCObject* getDLObject(char const* tag) = win inline, ios inline {
        return m_activeDownloads->objectForKey(tag);
    }
    int getLastCommentIDForGame(int id) = win inline, ios inline {
        auto comments = static_cast<cocos2d::CCArray*>(m_lobbyComments->objectForKey(id));
        if (comments && comments->count() > 0) {
            auto commentID = 0;
            for (int i = 0; i < comments->count(); i++) {
                auto comment = static_cast<GJComment*>(comments->objectAtIndex(i));
                if (comment->m_commentID > commentID) commentID = comment->m_commentID;
            }
            return commentID;
        }
        return 0;
    }
    void handleIt(bool success, gd::string response, gd::string tag, GJHttpType type) = win 0x282910;
    void handleItDelayed(bool success, gd::string response, gd::string tag, GJHttpType type) = win inline, ios inline {
        auto result = GJHttpResult::create(true, response, tag, type);
        result->retain();
        m_pActionManager->addAction(cocos2d::CCSequence::create(
            cocos2d::CCDelayTime::create(.1f),
            cocos2d::CCCallFuncND::create(this, callfuncND_selector(GJMultiplayerManager::handleItND), result),
            nullptr
        ), this, false);
    }
    void handleItND(cocos2d::CCNode* node, void* data) = win inline, ios inline {
        auto result = static_cast<GJHttpResult*>(data);
        this->handleIt(result->m_success, result->m_response, result->m_requestTag, result->m_httpType);
        result->release();
    }
    bool isDLActive(char const* tag) = win inline, ios inline {
        return this->getDLObject(tag) != nullptr;
    }
    bool joinLobby(int id);
    void onExitLobbyCompleted(gd::string response, gd::string tag) = win inline {
        this->removeDLFromActive(tag.c_str());
        auto id = atoi(tag.c_str());
        if (response == "-1") {
            if (m_uploadDelegate) m_uploadDelegate->uploadActionFailed(id, 58);
        }
        else {
            if (m_uploadDelegate) m_uploadDelegate->uploadActionFinished(id, 58);
        }
    }
    void onJoinLobbyCompleted(gd::string response, gd::string tag) = win 0x282cd0;
    void onProcessHttpRequestCompleted(cocos2d::extension::CCHttpClient* client, cocos2d::extension::CCHttpResponse* response);
    void onUploadCommentCompleted(gd::string response, gd::string tag) = win inline {
        this->removeDLFromActive(tag.c_str());
        if (response != "-1") {
            if (m_mpDelegate) m_mpDelegate->didUploadMPComment(atoi(tag.c_str()));
        }
    }
    void ProcessHttpRequest(gd::string url, gd::string params, gd::string tag, GJHttpType type) = win 0x282500;
    void removeDLFromActive(char const* tag);
    bool uploadComment(gd::string text, int lobbyID) = win 0x283430;

    cocos2d::CCDictionary* m_activeDownloads;
    cocos2d::CCDictionary* m_lobbyScores;
    cocos2d::CCDictionary* m_scoreArrays;
    cocos2d::CCDictionary* m_lobbyComments;
    GJMPDelegate* m_mpDelegate;
    UploadActionDelegate* m_uploadDelegate;
}

[[link(android)]]
class GJObjectDecoder : cocos2d::CCNode, ObjectDecoderDelegate {
    // virtual ~GJObjectDecoder();

    static GJObjectDecoder* sharedDecoder() = win 0x283e20;

    virtual bool init();
    virtual cocos2d::CCObject* getDecodedObject(int type, DS_Dictionary* dict) = win 0x283ec0;
}

[[link(android)]]
class GJOnlineRewardDelegate {
    virtual void onlineRewardStatusFinished(gd::string key) {}
    virtual void onlineRewardStatusFailed() {}
}

[[link(android)]]
class GJOptionsLayer : SetupTriggerPopup {
    GJOptionsLayer() {
        m_gap = 48.f;
        m_page = 0;
        m_togglesPerPage = 10;
        m_toggleCount = 0;
        m_maxPage = 0;
        m_maxLabelScale = .5f;
        m_maxLabelWidth = 130.f;
        m_offset = 0.f;
    }
    ~GJOptionsLayer();

    static GJOptionsLayer* create(int background) = win inline, ios inline {
        auto ret = new GJOptionsLayer();
        if (ret->init(background)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void setupOptions() = win inline {}
    virtual void didToggleGV(gd::string variable) {}
    virtual void didToggle(int toggle) {}

    void addGVToggle(char const* title, char const* variable, char const* description) = win 0x28fc00;
    void addToggle(char const* title, int id, bool initial, char const* description) = win inline {
        addToggleInternal(title, id, initial, description);
    }
    void addToggleInternal(char const* title, int id, bool initial, char const* description);
    int countForPage(int page);
    void goToPage(int page);
    void incrementCountForPage(int page) = win 0x290350;
    const char* infoKey(int index) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("info_%i", index)->getCString();
    }
    bool init(int background) = win 0x28f8c0;
    cocos2d::CCLayer* layerForPage(int page);
    const char* layerKey(int page) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("layer_%i", page)->getCString();
    }
    cocos2d::CCPoint nextPosition(int page) = win inline {
        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        auto count = this->countForPage(page);
        cocos2d::CCPoint pos = winSize * .5f + cocos2d::CCPoint { count % 2 == 0 ? -160.f : 80.f, m_offset + 80.f };
        if (count > 1) pos.y -= floorf(count / 2.f) * m_gap;
        return pos;
    }
    const char* objectKey(int page) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("object_%i", page)->getCString();
    }
    cocos2d::CCArray* objectsForPage(int page);
    void offsetToNextPage() = win inline, ios inline {
        m_toggleCount += m_togglesPerPage - m_toggleCount % m_togglesPerPage;
    }
    void onInfo(cocos2d::CCObject* sender);
    void onNextPage(cocos2d::CCObject* sender);
    void onPrevPage(cocos2d::CCObject* sender);
    void onToggle(cocos2d::CCObject* sender) = win 0x290bb0;
    const char* pageKey(int page) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("page_%i", page)->getCString();
    }

    float m_gap;
    int m_page;
    int m_togglesPerPage;
    int m_toggleCount;
    int m_maxPage;
    float m_maxLabelScale;
    float m_maxLabelWidth;
    cocos2d::CCDictionary* m_values;
    cocos2d::CCDictionary* m_variables;
    CCMenuItemSpriteExtra* m_prevButton;
    CCMenuItemSpriteExtra* m_nextButton;
    float m_offset;
}

[[link(android)]]
class GJPathPage : FLAlertLayer, FLAlertLayerProtocol, GJPurchaseDelegate {
    // virtual ~GJPathPage();

    static GJPathPage* create(int path, GJPathsLayer* layer) = win 0x285310;

    virtual void registerWithTouchDispatcher() = win 0x42660;
    virtual void keyBackClicked();
    virtual void show();
    virtual void didPurchaseItem(GJStoreItem* item) = win 0x2872d0;

    bool init(int path, GJPathsLayer* layer) = win 0x285440;
    void onActivatePath(cocos2d::CCObject* sender) = win 0x287070;
    void onBack(cocos2d::CCObject* sender) = win 0x288e00;
    void onIconInfo(cocos2d::CCObject* sender) = win 0x2870e0;
    void onUnlock(cocos2d::CCObject* sender) = win 0x2872e0;
    void playUnlockAnimation() = win 0x287b90;
    void showCantAffordMessage(GJStoreItem* item);
    void unlockAnimationFinished() = win 0x288cd0;
    void unlockAnimationStep2() = win 0x2881e0;
    void unlockAnimationStep3() = win 0x288460;

    GJPathsLayer* m_pathsLayer;
    int m_pathNumber;
    bool m_animationPlaying;
    int m_dialogIndex;
}

[[link(android)]]
class GJPathRewardPopup : FLAlertLayer {
    // virtual ~GJPathRewardPopup();
    GJPathRewardPopup() {
        m_pathNumber = 0;
    }

    static GJPathRewardPopup* create(int path) = win inline {
        auto ret = new GJPathRewardPopup();
        if (ret->init(path)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyBackClicked() = win inline {}

    void closePopup() = win 0x285250;
    bool init(int path) = win 0x289d80;
    void onClaim(cocos2d::CCObject* sender) = win 0x28a260;

    int m_pathNumber;
}

[[link(android)]]
class GJPathsLayer : FLAlertLayer, FLAlertLayerProtocol {
    // virtual ~GJPathsLayer();

    static GJPathsLayer* create() = win 0x284960;
    static gd::string nameForPath(int path) = win 0x2846f0;

    virtual bool init() = win 0x284a60;
    virtual void onExit() = win 0x284fc0;
    virtual void registerWithTouchDispatcher() = win 0x42660;
    virtual void keyBackClicked() = win 0x2852b0;
    virtual void show();

    void darkenButtons(bool darken) = win inline, ios inline {
        m_closeSprite->setColor(darken ? cocos2d::ccColor3B { 75, 75, 75 } : cocos2d::ccColor3B { 255, 255, 255 });
    }
    void onClose(cocos2d::CCObject* sender) = win 0x285250;
    void onPath(cocos2d::CCObject* sender) = win 0x285010;

    cocos2d::CCSprite* m_closeSprite;
    bool m_exiting;
}

[[link(android)]]
class GJPathSprite : CCSpriteCOpacity {
    // virtual ~GJPathSprite();

    static GJPathSprite* create(int path) = win 0x288eb0;

    void addRankLabel(int path) = win inline {
        auto rankLabel = cocos2d::CCLabelBMFont::create(GameToolbox::intToString(path).c_str(), "bigFont.fnt");
        rankLabel->setScale(0.55f);
        this->addChild(rankLabel, 1);
        rankLabel->setPosition(this->convertToNodeSpace({ 0.f, 0.f }) + cocos2d::CCPoint { 0.f, 1.f });
    }
    void addShardSprite() = win 0x289520;
    void changeToLockedArt() = win 0x289260;
    bool init(int path) = win inline {
        if (!cocos2d::CCSprite::initWithSpriteFrameName(cocos2d::CCString::createWithFormat("pathIcon_%02d_001.png", path)->getCString())) return false;
        m_pathNumber = path;
        return true;
    }
    void updateState() = win 0x289080;

    int m_pathNumber;
}

[[link(android)]]
class GJPFollowCommandLayer : SetupTriggerPopup {
    // virtual ~GJPFollowCommandLayer();

    static GJPFollowCommandLayer* create(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x28a530;

    virtual void determineStartValues() = win 0x28bf20;
    virtual void onClose(cocos2d::CCObject* sender) = win 0x28cd80;
    virtual void textChanged(CCTextInputNode* node) = win 0x28c4b0;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x28a660;
    void onUpdateGroupID(cocos2d::CCObject* sender) = win 0x28c450;
    void sliderChanged(cocos2d::CCObject* sender) = win 0x271b30;
    void sliderXModChanged(cocos2d::CCObject* sender);
    void sliderYModChanged(cocos2d::CCObject* sender);
    void updateDuration();
    void updateDurLabel(bool decimals);
    void updateMaxSpeed() = win inline {
        if (m_gameObject) {
            m_gameObject->m_followYMaxSpeed = m_maxSpeed;
        }
        else {
            for (int i = 0; i < m_gameObjects->count(); i++) {
                static_cast<EffectGameObject*>(m_gameObjects->objectAtIndex(i))->m_followYMaxSpeed = m_maxSpeed;
            }
        }
    }
    void updateMaxSpeedLabel() = win inline {
        m_disableTextDelegate = true;
        if (m_maxSpeed == -99999.f) m_maxSpeedInput->setString("");
        else m_maxSpeedInput->setString(cocos2d::CCString::createWithFormat("%0.1f", m_maxSpeed)->getCString());
        m_disableTextDelegate = false;
    }
    void updateOffsetLabel() = win inline {
        m_disableTextDelegate = true;
        if (m_offset == -99999) m_offsetInput->setString("");
        else m_offsetInput->setString(cocos2d::CCString::createWithFormat("%i", (int)(m_offset / 3.f))->getCString());
        m_disableTextDelegate = false;
    }
    void updatePlayerOffset() = win inline {
        if (m_gameObject) {
            m_gameObject->m_followYOffset = m_offset;
        }
        else {
            for (int i = 0; i < m_gameObjects->count(); i++) {
                static_cast<EffectGameObject*>(m_gameObjects->objectAtIndex(i))->m_followYOffset = m_offset;
            }
        }
    }
    void updateTargetGroupID();
    void updateTextInputLabel();
    void updateXMod();
    void updateXModLabel();
    void updateYMod();
    void updateYModLabel();

    CCTextInputNode* m_moveTimeInput;
    Slider* m_moveTimeSlider;
    float m_moveTime;
    CCTextInputNode* m_speedInput;
    CCTextInputNode* m_delayInput;
    CCTextInputNode* m_offsetInput;
    CCTextInputNode* m_maxSpeedInput;
    Slider* m_speedSlider;
    Slider* m_delaySlider;
    float m_delay;
    float m_speed;
    int m_offset;
    float m_maxSpeed;
    CCTextInputNode* m_targetIDInput;
    int m_targetGroupID;
}

[[link(android)]]
class GJPromoPopup : FLAlertLayer {
    // virtual ~GJPromoPopup();
    GJPromoPopup() {}

    static GJPromoPopup* create(gd::string filename) = win inline {
        auto ret = new GJPromoPopup();
        if (ret->init(filename)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void onExit() = win 0x2a4db0;
    virtual void registerWithTouchDispatcher() = win 0x42660;
    virtual void keyBackClicked() = win 0x2852b0;
    virtual void show();

    bool init(gd::string filename) = win 0x2a4ab0;
    void onClose(cocos2d::CCObject* sender) = win 0x285250;

    gd::string m_promoFrame;
}

[[link(android)]]
class GJPurchaseDelegate {
    virtual void didPurchaseItem(GJStoreItem* item) {}
}

[[link(android)]]
class GJRequestCell : TableViewCell, FLAlertLayerProtocol, UploadPopupDelegate, UploadActionDelegate {
    GJRequestCell(char const* identifier, float width, float height) = win inline, ios inline : TableViewCell(identifier, width, height) {
        this->init();
    }
    ~GJRequestCell() = win inline {
        auto glm = GameLevelManager::sharedState();
        if (glm->m_uploadActionDelegate == this) glm->m_uploadActionDelegate = nullptr;
        if (m_popup) m_popup->m_delegate = nullptr;
        CC_SAFE_RELEASE(m_score);
    }

    virtual bool init() = win 0xbc340;
    virtual void draw() = win 0xade40;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0xbcf30;
    virtual void uploadActionFinished(int id, int response) = win 0xbd0e0;
    virtual void uploadActionFailed(int id, int response) = win 0xbd2c0;
    virtual void onClosePopup(UploadActionPopup* popup);

    void loadFromScore(GJUserScore* score) = win 0xbc360;
    void markAsRead() = win 0xbcc90; // inlined on macos
    void onDeleteRequest(cocos2d::CCObject* sender) = win 0xbcd70;
    void onToggle(cocos2d::CCObject* sender);
    void onViewFriendRequest(cocos2d::CCObject* sender) = win 0xbcbe0;
    void onViewProfile(cocos2d::CCObject* sender);
    void updateBGColor(int index) = win inline {
        m_backgroundLayer->setColor(index % 2 == 0 ? cocos2d::ccColor3B { 161, 88, 44 } : cocos2d::ccColor3B { 194, 114, 62 });
        m_backgroundLayer->setOpacity(255);
    }
    void updateToggle() = win inline, ios inline {
        if (m_score && m_toggler) m_toggler->toggle(m_score->m_toggled);
    }

    GJUserScore* m_score;
    UploadActionPopup* m_popup;
    CCMenuItemToggler* m_toggler;
}

[[link(android)]]
class GJRewardDelegate {
    virtual void rewardsStatusFinished(int type) {}
    virtual void rewardsStatusFailed() {}
}

[[link(android)]]
class GJRewardItem : cocos2d::CCObject {
    // virtual ~GJRewardItem();

    static GJRewardItem* create() = win 0x1f3e90;
    static GJRewardItem* create(int chestID, int timeRemaining, gd::string rewardStr) = win 0x1f41d0;
    static GJRewardItem* createSpecial(GJRewardType rewardType, int orbs, int diamonds, SpecialRewardItem specialType1, int specialCount1, SpecialRewardItem specialType2, int specialCount2, int unlockType, int itemID) = win 0x1f3fe0;
    static GJRewardItem* createWithCoder(DS_Dictionary* dict) = win inline {
        auto ret = create();
        ret->dataLoaded(dict);
        return ret;
    }
    static GJRewardItem* createWithObject(GJRewardType type, GJRewardObject* object) = win 0x1f3ed0, ios inline {
        return createWithObjects(type, cocos2d::CCArray::createWithObject(object));
    }
    static GJRewardItem* createWithObjects(GJRewardType type, cocos2d::CCArray* objects) = win 0x1f3f60, ios inline {
        auto ret = create();
        if (ret->m_rewardObjects != objects) {
            CC_SAFE_RETAIN(objects);
            CC_SAFE_RELEASE(ret->m_rewardObjects);
            ret->m_rewardObjects = objects;
        }
        return ret;
    }
    static SpecialRewardItem getNextShardType(SpecialRewardItem type) = win inline {
        switch (type) {
            case SpecialRewardItem::FireShard: return SpecialRewardItem::IceShard;
            case SpecialRewardItem::IceShard: return SpecialRewardItem::PoisonShard;
            case SpecialRewardItem::PoisonShard: return SpecialRewardItem::ShadowShard;
            case SpecialRewardItem::ShadowShard: return SpecialRewardItem::LavaShard;
            case SpecialRewardItem::LavaShard: return SpecialRewardItem::EarthShard;
            case SpecialRewardItem::EarthShard: return SpecialRewardItem::BloodShard;
            case SpecialRewardItem::BloodShard: return SpecialRewardItem::MetalShard;
            case SpecialRewardItem::MetalShard: return SpecialRewardItem::LightShard;
            case SpecialRewardItem::LightShard: return SpecialRewardItem::SoulShard;
            case SpecialRewardItem::SoulShard: return SpecialRewardItem::FireShard;
            default: return (SpecialRewardItem)0;
        }
    }
    static SpecialRewardItem getRandomNonMaxShardType() = win inline {
        auto type = getRandomShardType();
        for (int i = 10; i > 0; i--) {
            if (GameStatsManager::sharedState()->getStat(rewardItemToStat(type).c_str()) < 100) return type;
            type = getNextShardType(type);
        }
        return (SpecialRewardItem)0;
    }
    static SpecialRewardItem getRandomShardType() = win inline {
        int randomValue = floorf((rand() / (float)RAND_MAX) * 10.f) + 1.f;
        switch (randomValue) {
            case 2: return SpecialRewardItem::IceShard;
            case 3: return SpecialRewardItem::PoisonShard;
            case 4: return SpecialRewardItem::ShadowShard;
            case 5: return SpecialRewardItem::LavaShard;
            case 6: return SpecialRewardItem::EarthShard;
            case 7: return SpecialRewardItem::BloodShard;
            case 8: return SpecialRewardItem::MetalShard;
            case 9: return SpecialRewardItem::LightShard;
            case 10: return SpecialRewardItem::SoulShard;
            default: return SpecialRewardItem::FireShard;
        }
    }
    static bool isShardType(SpecialRewardItem type) = win inline, ios inline {
        return type == SpecialRewardItem::FireShard || type == SpecialRewardItem::IceShard || type == SpecialRewardItem::PoisonShard
            || type == SpecialRewardItem::ShadowShard || type == SpecialRewardItem::LavaShard || type == SpecialRewardItem::EarthShard
            || type == SpecialRewardItem::BloodShard || type == SpecialRewardItem::MetalShard || type == SpecialRewardItem::LightShard
            || type == SpecialRewardItem::SoulShard;
    }
    static gd::string rewardItemToStat(SpecialRewardItem rewardItem) = win 0x1f4500;

    virtual void encodeWithCoder(DS_Dictionary* dict) = win 0x1f4760;
    virtual bool canEncode() = win inline {
        return true;
    }

    void dataLoaded(DS_Dictionary* dict) = win inline {
        m_chestID = dict->getIntegerForKey("1");
        m_rewardType = (GJRewardType)dict->getIntegerForKey("2");
        auto rewardObjects = dict->getArrayForKey("3", false);
        CC_SAFE_RETAIN(rewardObjects);
        CC_SAFE_RELEASE(m_rewardObjects);
        m_rewardObjects = rewardObjects;
    }
    int getRewardCount(SpecialRewardItem type) = win inline {
        if (!m_rewardObjects) return 0;

        int count = 0;
        for (int i = 0; i < m_rewardObjects->count(); i++) {
            auto obj = static_cast<GJRewardObject*>(m_rewardObjects->objectAtIndex(i));
            if (obj->m_specialRewardItem == type) count += obj->m_total;
        }

        return count;
    }
    GJRewardObject* getRewardObjectForType(SpecialRewardItem type) = win inline {
        if (!m_rewardObjects) {
            auto rewardObjects = cocos2d::CCArray::create();
            CC_SAFE_RETAIN(rewardObjects);
            CC_SAFE_RELEASE(m_rewardObjects);
            m_rewardObjects = rewardObjects;
        }

        for (int i = 0; i < m_rewardObjects->count(); i++) {
            auto obj = static_cast<GJRewardObject*>(m_rewardObjects->objectAtIndex(i));
            if (obj->m_specialRewardItem == type) return obj;
        }

        auto obj = GJRewardObject::create(type, 0, 0);
        m_rewardObjects->addObject(obj);
        return obj;
    }
    bool init(int chestID, int timeRemaining, gd::string rewardStr) = win 0x1f42a0;

    int m_chestID;
    int m_timeRemaining;
    GJRewardType m_rewardType;
    cocos2d::CCArray* m_rewardObjects;
    bool m_unk;
}

[[link(android)]]
class GJRewardObject : cocos2d::CCObject {
    // virtual ~GJRewardObject();

    static GJRewardObject* create() = win inline, ios inline {
        auto ret = create(SpecialRewardItem::FireShard, 0, 0); // the first param is meant to be 0
        return ret;
    }
    static GJRewardObject* create(SpecialRewardItem type, int total, int itemID) = win 0x1f3d90;
    static GJRewardObject* createItemUnlock(UnlockType type, int id) = win 0x1f3d20, ios inline {
        auto ret = create(SpecialRewardItem::CustomItem, 1, id);
        ret->m_unlockType = type;
        return ret;
    }
    static GJRewardObject* createWithCoder(DS_Dictionary* dict) = win inline {
        auto ret = create();
        ret->dataLoaded(dict);
        return ret;
    }

    virtual void encodeWithCoder(DS_Dictionary* dict) = win 0x1f3e00;
    virtual bool canEncode() = win inline {
        return true;
    }

    void dataLoaded(DS_Dictionary* dict) = win inline {
        m_specialRewardItem = (SpecialRewardItem)dict->getIntegerForKey("1");
        m_itemID = dict->getIntegerForKey("2");
        m_total = dict->getIntegerForKey("3");
        m_unlockType = (UnlockType)dict->getIntegerForKey("4");
    }
    bool init(SpecialRewardItem specialRewardItem, int total, int itemID) = win inline, ios inline {
        this->m_specialRewardItem = specialRewardItem;
        this->m_total = total;
        this->m_itemID = itemID;
        return true;
    }
    bool isSpecialType() = win inline {
        auto type = m_specialRewardItem;
        return type == SpecialRewardItem::FireShard || type == SpecialRewardItem::IceShard || type == SpecialRewardItem::PoisonShard
            || type == SpecialRewardItem::ShadowShard || type == SpecialRewardItem::LavaShard || type == SpecialRewardItem::BonusKey
            || type == SpecialRewardItem::EarthShard || type == SpecialRewardItem::BloodShard || type == SpecialRewardItem::MetalShard
            || type == SpecialRewardItem::LightShard || type == SpecialRewardItem::SoulShard;
    }

    SpecialRewardItem m_specialRewardItem;
    UnlockType m_unlockType;
    int m_itemID;
    int m_total;
}

[[link(android)]]
class GJRobotSprite : CCAnimatedSprite {
    // virtual ~GJRobotSprite();
    // GJRobotSprite();

    static GJRobotSprite* create(int frame) = win 0x2a64f0;

    virtual void setOpacity(unsigned char opacity) = win 0x2a71e0;
    virtual void hideSecondary() = win 0x2a78d0;

    void hideGlow() = win inline {
        m_glowSprite->setVisible(false);
    }
    bool init(int frame) = win inline {
        return GJRobotSprite::init(frame, "Robot");
    }
    bool init(int frame, gd::string animName) = win 0x2a65a0;
    void showGlow() = win inline {
        m_glowSprite->setVisible(true);
    }
    void updateColor01(cocos2d::ccColor3B color) = win inline {
        m_color = color;
        this->updateColors();
    }
    void updateColor02(cocos2d::ccColor3B color) = win inline {
        m_secondColor = color;
        this->updateColors();
    }
    void updateColors() = win 0x2a6d30;
    void updateFrame(int frame) = win 0x2a72e0;
    void updateGlowColor(cocos2d::ccColor3B color, bool simple) = win inline {
        auto children = m_glowSprite->getChildren();
        for (int i = 0; i < children->count(); i++) {
            static_cast<cocos2d::CCSprite*>(children->objectAtIndex(i))->setColor(color);
        }
    }

    cocos2d::CCArray* m_unkArray;
    bool m_hasExtra;
    cocos2d::ccColor3B m_color;
    cocos2d::ccColor3B m_secondColor;
    cocos2d::CCArray* m_secondArray;
    cocos2d::CCSprite* m_glowSprite;
    cocos2d::CCSprite* m_extraSprite;
    IconType m_iconType;
    int m_iconRequestID;
    CCSpritePart* m_headSprite;
    CCSpritePart* m_footSprite;
}

[[link(android)]]
class GJRotateCommandLayer : SetupTriggerPopup {
    // virtual ~GJRotateCommandLayer();

    static GJRotateCommandLayer* create(EffectGameObject* object, cocos2d::CCArray* objects);

    virtual void determineStartValues();
    virtual void onClose(cocos2d::CCObject* sender);
    virtual void textChanged(CCTextInputNode* node);
    virtual void valuePopupClosed(ConfigureValuePopup* popup, float value);

    bool init(EffectGameObject* object, cocos2d::CCArray* objects);
    void onEasing(cocos2d::CCObject* sender);
    void onEasingRate(cocos2d::CCObject* sender);
    void onFollowRotation(cocos2d::CCObject* sender);
    void onLockRotation(cocos2d::CCObject* sender);
    void onUpdateGroupID(cocos2d::CCObject* sender);
    void onUpdateGroupID2(cocos2d::CCObject* sender);
    void sliderChanged(cocos2d::CCObject* sender);
    void sliderDegreesChanged(cocos2d::CCObject* sender);
    void sliderTimesChanged(cocos2d::CCObject* sender);
    void toggleEasingRateVisibility();
    void updateCommandDegrees();
    void updateCommandTimes();
    void updateDegreesLabel();
    void updateDuration();
    void updateDurLabel(bool decimals);
    void updateEasingLabel();
    void updateEasingRateLabel();
    void updateMoveCommandEasing();
    void updateMoveCommandEasingRate();
    void updateTargetGroupID();
    void updateTargetGroupID2();
    void updateTextInputLabel();
    void updateTextInputLabel2();
    void updateTimesLabel();

    CCTextInputNode* m_moveTimeInput;
    Slider* m_moveTimeSlider;
    float m_moveTime;
    cocos2d::CCLabelBMFont* m_rotateEasingLabel;
    EasingType m_rotateEasingType;
    float m_rotateEasingRate;
    CCMenuItemSpriteExtra* m_rotateEasingRateButton;
    cocos2d::CCLabelBMFont* m_rotateEasingRateLabel;
    CCTextInputNode* m_degreesInput;
    CCTextInputNode* m_timesInput;
    Slider* m_degreesSlider;
    Slider* m_timesSlider;
    float m_degrees;
    int m_times360;
    CCTextInputNode* m_targetIDInput;
    bool m_disableTextChanged;
    int m_targetGroupID;
    CCTextInputNode* m_centerIDInput;
    int m_centerGroupID;
    bool m_lockObjectRotation;
    bool m_followP1;
    bool m_followP2;
    CCMenuItemToggler* m_followP1Toggler;
    CCMenuItemToggler* m_followP2Toggler;
}

[[link(android)]]
class GJRotationControl : cocos2d::CCLayer {
    // virtual ~GJRotationControl();
    GJRotationControl() {
        m_controlSprite = nullptr;
        m_startingRotation = 0.0f;
        m_currentRotation = 0.0f;
        m_touchID = -1;
        m_delegate = nullptr;
    }

    static GJRotationControl* create() = win inline {
        auto ret = new GJRotationControl();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x1295d0;
    virtual void draw() = win 0x129a30;
    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x129770;
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x129870;
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x129a10;
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event);

    void finishTouch() = win 0x1296f0;
    void setAngle(float angle) = win inline {
        m_startingRotation = angle;
        m_currentRotation = angle;
        m_controlPosition.x = cosf(-angle * (M_PI / 180.f)) * 60.f;
        m_controlPosition.y = sinf(-angle * (M_PI / 180.f)) * 60.f;
        m_controlSprite->setPosition(m_controlPosition);
    }
    void updateSliderPosition(cocos2d::CCPoint position) = win inline {
        auto angle = atan2f(position.y - m_cursorDifference.y, position.x - m_cursorDifference.x);
        m_controlPosition.x = cosf(angle) * 60.f;
        m_controlPosition.y = sinf(angle) * 60.f;
        m_controlSprite->setPosition(m_controlPosition);
        auto degrees = roundf(-(angle * (180.f / M_PI)) * 1000.f) / 1000.f;
        auto rotation = m_currentRotation;
        if (degrees != m_currentRotation) {
            m_currentRotation = degrees;
            if (m_delegate) m_delegate->angleChanged(degrees - rotation);
        }
    }

    cocos2d::CCPoint m_cursorDifference;
    cocos2d::CCPoint m_controlPosition;
    cocos2d::CCSprite* m_controlSprite;
    float m_startingRotation;
    float m_currentRotation;
    int m_touchID;
    GJRotationControlDelegate* m_delegate;
}

[[link(android)]]
class GJRotationControlDelegate {
    virtual void angleChanged(float angle) {}
    virtual void angleChangeBegin() {}
    virtual void angleChangeEnded() {}
}

[[link(android)]]
class GJScaleControl : cocos2d::CCLayer {
    // virtual ~GJScaleControl();
    GJScaleControl() {
        m_sliderX = nullptr;
        m_sliderY = nullptr;
        m_sliderXY = nullptr;
        m_touchID = -1;
        m_valueX = 0.0f;
        m_valueY = 0.0f;
        m_unkSize4 = 0;
        m_changedValueX = 0.0f;
        m_changedValueY = 0.0f;
        m_scale1Lock = false;
        m_scaleButtonType = 0;
        m_delegate = nullptr;
        m_upperBound = 2.0f;
        m_lowerBound = 0.5f;
        m_senderTag = 0;
        m_scaleLockButton = nullptr;
        m_scaleLocked = false;
    }

    static GJScaleControl* create() = win inline {
        auto ret = new GJScaleControl();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x129ab0;
    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x12a5a0;
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x12a7b0;
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x12abd0;
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event);

    void finishTouch() = win inline, ios inline {
        if (m_touchID != -1) {
            m_touchID = -1;
            if (m_delegate) m_delegate->scaleChangeEnded();
        }
    }
    void loadValues(GameObject* object, cocos2d::CCArray* objects, gd::unordered_map<int, GameObjectEditorState>& editorStates) = win 0x129f80;
    void onToggleLockScale(cocos2d::CCObject* sender);
    float scaleFromValue(float value) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("%.02f", (m_upperBound - m_lowerBound) * value + m_lowerBound)->floatValue();
    }
    float skewFromValue(float value) = win inline, ios inline {
        return (m_upperBound - m_lowerBound) * value + m_lowerBound;
    }
    void sliderChanged(cocos2d::CCObject* sender);
    void updateLabelX(float value);
    void updateLabelXY(float value);
    void updateLabelY(float value);
    float valueFromScale(float scale) = win inline, ios inline {
        auto value = (scale - m_lowerBound) / (m_upperBound - m_lowerBound);
        return value < 0 ? 0 : (value > 1 ? 1 : value);
    }
    float valueFromSkew(float value) = win inline, ios inline {
        return std::clamp<float>((value - m_lowerBound) / (m_upperBound - m_lowerBound), 0.f, 1.f);
    }

    Slider* m_sliderX;
    Slider* m_sliderY;
    Slider* m_sliderXY;
    int m_touchID;
    float m_valueX;
    float m_valueY;
    int m_unkSize4;
    float m_changedValueX;
    float m_changedValueY;
    bool m_scale1Lock;
    short m_scaleButtonType;
    cocos2d::CCLabelBMFont* m_scaleXLabel;
    cocos2d::CCLabelBMFont* m_scaleYLabel;
    cocos2d::CCLabelBMFont* m_scaleLabel;
    GJScaleControlDelegate* m_delegate;
    float m_upperBound;
    float m_lowerBound;
    int m_senderTag;
    CCMenuItemSpriteExtra* m_scaleLockButton;
    bool m_scaleLocked;
}

[[link(android)]]
class GJScaleControlDelegate {
    virtual void scaleXChanged(float scaleX, bool lock) {}
    virtual void scaleYChanged(float scaleY, bool lock) {}
    virtual void scaleXYChanged(float scaleX, float scaleY, bool lock) {}
    virtual void scaleChangeBegin() {}
    virtual void scaleChangeEnded() {}
    virtual void updateScaleControl() {}
    virtual void anchorPointMoved(cocos2d::CCPoint newAnchor) {}
}

[[link(android)]]
class GJScoreCell : TableViewCell, FLAlertLayerProtocol {
    // virtual ~GJScoreCell();
    GJScoreCell(char const* identifier, float width, float height) = win inline, ios inline : TableViewCell(identifier, width, height) {
        this->init();
    }

    virtual bool init();
    virtual void draw() = win 0xade40;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0xb9bd0;

    void loadFromScore(GJUserScore* score);
    void onBan(cocos2d::CCObject* sender) = win inline, ios inline {}
    void onCheck(cocos2d::CCObject* sender) = win inline, ios inline {}
    void onMoreLevels(cocos2d::CCObject* sender) = win inline, ios inline {
        ProfilePage::create(m_score->m_accountID, false)->show();
    }
    void onViewProfile(cocos2d::CCObject* sender) = win 0xb9a50;
    void updateBGColor(int index) = win inline {
        m_backgroundLayer->setColor(index % 2 == 0 ? cocos2d::ccColor3B { 161, 88, 44 } : cocos2d::ccColor3B { 194, 114, 62 });
        m_backgroundLayer->setOpacity(255);
    }

    GJUserScore* m_score;
}

[[link(android)]]
class GJSearchObject : cocos2d::CCNode {
    // virtual ~GJSearchObject();

    static GJSearchObject* create(SearchType searchType) = win 0x174740;
    static GJSearchObject* create(SearchType searchType, gd::string searchQuery) = win 0x174820;
    static GJSearchObject* create(SearchType searchType, gd::string searchQuery, gd::string difficulty, gd::string length, int page, bool star, bool uncompleted, bool featured, int songID, bool original, bool twoPlayer, bool customSong, bool songFilter, bool noStar, bool coins, bool epic, bool legendary, bool mythic, bool onlyCompleted, int demonFilter, int folder, int searchMode) = win 0x174950;
    static GJSearchObject* createFromKey(char const* key) = win 0x174040;
    static char const* getSearchKey(SearchType searchType, gd::string searchQuery, gd::string difficulty, gd::string length, int page, bool star, bool uncompleted, bool featured, int songID, bool original, bool twoPlayer, bool customSong, bool songFilter, bool noStar, bool coins, bool epic, bool legendary, bool mythic, bool onlyCompleted, int demonFilter, int folder, int searchMode) = win 0x174f50;

    char const* getKey() = win 0x174c90;
    char const* getNextPageKey() = win inline {
        return this->getSearchKey(m_searchType, m_searchQuery, m_difficulty, m_length, m_page + 1, m_starFilter, m_uncompletedFilter, m_featuredFilter, m_songID, m_originalFilter, m_twoPlayerFilter, m_customSongFilter, m_songFilter, m_noStarFilter, m_coinsFilter, m_epicFilter, m_legendaryFilter, m_mythicFilter, m_completedFilter, (int)m_demonFilter, m_folder, m_searchMode);
    }
    GJSearchObject* getNextPageObject() = win inline {
        return this->getPageObject(m_page + 1);
    }
    GJSearchObject* getPageObject(int page) = win 0x174de0;
    GJSearchObject* getPrevPageObject() = win inline {
        return this->getPageObject(std::max(m_page - 1, 0));
    }
    bool init(SearchType searchType, gd::string searchQuery, gd::string difficulty, gd::string length, int page, bool star, bool uncompleted, bool featured, int songID, bool original, bool twoPlayer, bool customSong, bool songFilter, bool noStar, bool coins, bool epic, bool legendary, bool mythic, bool onlyCompleted, int demonFilter, int folder, int searchMode) = win inline {
        m_searchType = searchType;
        m_searchQuery = searchQuery;
        m_difficulty = difficulty;
        m_length = length;
        m_page = page;
        m_starFilter = star;
        m_uncompletedFilter = uncompleted;
        m_featuredFilter = featured;
        m_songID = songID;
        m_originalFilter = original;
        m_twoPlayerFilter = twoPlayer;
        m_customSongFilter = customSong;
        m_songFilter = songFilter;
        m_noStarFilter = noStar;
        m_coinsFilter = coins;
        m_epicFilter = epic;
        m_mythicFilter = mythic;
        m_legendaryFilter = legendary;
        m_completedFilter = onlyCompleted;
        m_demonFilter = (GJDifficulty)demonFilter;
        m_folder = folder;
        m_searchMode = searchMode;
        return true;
    }
    bool isLevelSearchObject() = win 0x175230;

    SearchType m_searchType;
    gd::string m_searchQuery;
    gd::string m_difficulty;
    gd::string m_length;
    int m_page;
    bool m_starFilter;
    bool m_noStarFilter;
    int m_total;
    bool m_uncompletedFilter;
    bool m_completedFilter;
    bool m_featuredFilter;
    bool m_originalFilter;
    bool m_twoPlayerFilter;
    bool m_coinsFilter;
    bool m_epicFilter;
    bool m_legendaryFilter;
    bool m_mythicFilter;
    GJDifficulty m_demonFilter;
    int m_folder;
    int m_songID;
    bool m_customSongFilter;
    bool m_songFilter;
    bool m_searchIsOverlay;
    int m_searchMode;
}

[[link(android), depends(GJValueTween)]]
class GJShaderState {
    GJShaderState() {
        m_time = 0.0;
        m_prevTime = -1.0;
        m_textureScaleX = 1.f;
        m_textureScaleY = 1.f;
        m_blurRefChannel = 0;
        m_shockWaveStartTime = 0.f;
        m_shockWaveSpeed = 0.f;
        m_shockLineStartTime = 0.0;
        m_shockLineTargetID = 0;
        m_shockLineTarget = false;
        m_glitchStrength = 0.f;
        m_chromaticTargetX = 0.f;
        m_chromaticTargetY = 0.f;
        m_cGRGBOffset = 0.f;
        m_cGStrength = 0.f;
        m_cGSegmentHeight = 1.f;
        m_cGLineThickness = 0.f;
        m_cGLineStrength = 0.f;
        m_cGEnable = false;
        m_cGActive = false;
        m_pixelateTargetX = 1.f;
        m_pixelateTargetY = 1.f;
        m_pixelateSnapGrid = false;
        m_pixelatePixelating = false;
        m_lensCircleSize = 1.f;
        m_lensCircleFade = 0.f;
        m_lensCircleStrength = 0.f;
        m_lensCircleTargetID = 0;
        m_lensCircleTintChannel = 0;
        m_lensCircleRelative = false;
        m_lensCircleAdditive = false;
        m_radialBlurSize = 0.f;
        m_radialBlurFade = 0.f;
        m_motionBlurTargetX = 0.f;
        m_motionBlurTargetY = 0.f;
        m_motionBlurSpeedX = 0.f;
        m_motionBlurSpeedY = 0.f;
        m_motionBlurFollowEaseX = 1.f;
        m_motionBlurFollowEaseY = 1.f;
        m_motionBlurTargetIDX = 0;
        m_motionBlurTargetIDY = 0;
        m_motionBlurDual = false;
        m_bulgeValue = 0.f;
        m_bulgeRelative = false;
        m_bulgeTargetID = 0;
        m_bulgeRadius = 0.f;
        m_pinchTargetX = 0.f;
        m_pinchTargetY = 0.f;
        m_pinchTargetEnabledX = false;
        m_pinchTargetEnabledY = false;
        m_pinchTargetIDX = 0;
        m_pinchTargetIDY = 0;
        m_pinchRadius = 0.f;
        m_grayscaleValue = 0.f;
        m_grayscaleTintChannel = 0;
        m_sepiaValue = 0.f;
        m_invertColorEditRGB = 0.f;
        m_invertColorR = 1.f;
        m_invertColorG = 1.f;
        m_invertColorB = 1.f;
        m_invertColorClampRGB = false;
        m_hueShiftDegrees = 0.f;
        m_colorChangeCR = 1.f;
        m_colorChangeCG = 1.f;
        m_colorChangeCB = 1.f;
        m_colorChangeBR = 0.f;
        m_colorChangeBG = 0.f;
        m_colorChangeBB = 0.f;
        m_splitTargetRows = 0.f;
        m_splitTargetCols = 0.f;
        m_splitActive = false;
        m_minBlendingLayer = 0;
        m_maxBlendingLayer = 0;
        m_zLayerDirty = false;
        m_noPlayerParticles = false;
        m_usesShaders = false;
    }

    void reset() = win inline {
        m_cGSegmentHeight = 1.f;
        m_shockWaveStartTime = 0.f;
        m_shockLineStartTime = 0.0;
        m_glitchStrength = 0.f;
        m_chromaticTargetX = 0.f;
        m_chromaticTargetY = 0.f;
        m_blurIntensity = 0.f;
        m_cGEnable = false;
        m_cGSpeed = 0.f;
        m_cGRGBOffset = 0.f;
        m_cGStrength = 0.f;
        m_cGLineThickness = 0.f;
        m_cGLineStrength = 0.f;
        m_pixelateTargetX = 0.f;
        m_pixelateTargetY = 0.f;
        m_pixelateSnapGrid = false;
        m_lensCircleStrength = 0.f;
        m_lensCircleTargetID = 0;
        m_lensCircleTintChannel = 0;
        m_radialBlurSize = 0.f;
        m_motionBlurTargetX = 0.f;
        m_motionBlurTargetY = 0.f;
        m_motionBlurTargetIDX = 0;
        m_motionBlurTargetIDY = 0;
        m_motionBlurSpeedX = 0.f;
        m_motionBlurSpeedY = 0.f;
        m_textureScaleX = 1.f;
        m_textureScaleY = 1.f;
        m_lensCircleSize = 1.f;
        m_lensCircleFade = 0.f;
        m_radialBlurCenter.x = 0.f;
        m_radialBlurCenter.y = 0.f;
        m_bulgeValue = 0.f;
        m_pinchTargetX = 0.f;
        m_pinchTargetY = 0.f;
        m_pinchTargetIDX = 0;
        m_pinchTargetIDY = 0;
        m_pinchTargetEnabledX = false;
        m_pinchTargetEnabledY = false;
        m_pinchScreenOffset.x = 0.f;
        m_pinchScreenOffset.y = 0.f;
        m_grayscaleValue = 0.f;
        m_prevTime = -1.f;
        m_sepiaValue = 0.f;
        m_invertColorEditRGB = 0.f;
        m_hueShiftDegrees = 0.f;
        m_invertColorR = 1.f;
        m_invertColorG = 1.f;
        m_invertColorB = 1.f;
        m_colorChangeCR = 1.f;
        m_colorChangeCG = 1.f;
        m_colorChangeCB = 1.f;
        m_colorChangeBR = 0.f;
        m_colorChangeBG = 0.f;
        m_colorChangeBB = 0.f;
        m_invertColorClampRGB = false;
        m_splitTargetRows = 0.f;
        m_splitTargetCols = 0.f;
        m_zLayerDirty = false;
        m_noPlayerParticles = false;
        m_minBlendingLayer = 0;
        m_maxBlendingLayer = 0;
    }
    void stopTweenAction(int action) = win inline, ios inline {
        m_tweenActions.erase(action);
    }
    void timesyncShaderAction(int action) = win 0x481830;
    void timesyncShaderActions() = win inline {
        for (auto& pair : m_tweenTimes) {
            this->timesyncShaderAction(pair.first);
        }
    }
    void tweenValue(float fromValue, float toValue, int action, float duration, int easingType, float easingRate) = win inline {
        this->stopTweenAction(action);
        if (duration <= 0.f) {
            this->updateTweenAction(toValue, action);
            return;
        }
        GJValueTween tween;
        tween.m_easingRate = easingRate;
        tween.m_duration = duration;
        tween.m_deltaTime = 0.f;
        tween.m_currentValue = 0.f;
        tween.m_finished = false;
        tween.m_disabled = false;
        tween.m_easingType = easingType;
        tween.m_uniqueID = -1;
        tween.m_controlID = -1;
        tween.m_fromValue = fromValue;
        tween.m_toValue = toValue;
        m_tweenActions.emplace(action, tween);
        m_tweenTimes[action] = m_time;
    }
    void updateTweenAction(float value, int actionID) = win 0x481470;
    void updateTweenActions(float tweenValue) = win inline {
        for (auto it = m_tweenActions.begin(); it != m_tweenActions.end();) {
            it->second.step(tweenValue);
            this->updateTweenAction(it->second.m_currentValue, it->first);
            if (it->second.m_finished) it = m_tweenActions.erase(it);
            else ++it;
        }
    }

    gd::unordered_map<int, GJValueTween> m_tweenActions;
    gd::unordered_map<int, double> m_tweenTimes;
    double m_time;
    double m_prevTime;
    double m_startTime;
    float m_textureScaleX;
    float m_textureScaleY;
    cocos2d::ccColor3B m_blurRefColor;
    float m_blurIntensity;
    int m_blurRefChannel;
    bool m_blurOnlyEmpty;
    float m_shockWaveStartTime;
    float m_shockWaveTime;
    float m_shockWaveTimeOffset;
    float m_shockWaveSpeed;
    float m_shockWaveThickness;
    float m_shockWaveStrength;
    float m_shockWaveWidth;
    float m_shockWaveFadeIn;
    float m_shockWaveFadeOut;
    bool m_shockWaveInvert;
    float m_shockWaveInner;
    float m_shockWaveOuter;
    int m_shockWaveTargetID;
    bool m_shockWaveTarget;
    bool m_shockWaveCenterMoving;
    bool m_shockWaveRelative;
    float m_shockWaveMaxSize;
    cocos2d::CCPoint m_shockWaveScreenOffset;
    bool m_shockWaveCenterDirty;
    cocos2d::CCPoint m_shockWaveCenter;
    double m_shockLineStartTime;
    float m_shockLineTime;
    float m_shockLineTimeOffset;
    float m_shockLineSpeed;
    bool m_shockLineAxis;
    bool m_shockLineDirection;
    bool m_shockLineDual;
    bool m_shockLineInvert;
    float m_shockLineScreenOffset;
    float m_shockLineStrength;
    float m_shockLineWidth;
    float m_shockLineFadeIn;
    float m_shockLineFadeOut;
    float m_shockLineThickness;
    int m_shockLineTargetID;
    bool m_shockLineTarget;
    bool m_shockLineCenterMoving;
    bool m_shockLineRelative;
    float m_shockLineMaxSize;
    cocos2d::CCPoint m_shockLineScreenOffset2;
    bool m_shockLineCenterDirty;
    cocos2d::CCPoint m_shockLineCenter;
    float m_glitchStrength;
    float m_glitchSpeed;
    float m_glitchSliceHeight;
    float m_glitchMaxSliceXOff;
    float m_glitchMaxColXOff;
    float m_glitchMaxColYOff;
    bool m_glitchRelative;
    float m_chromaticTargetX;
    float m_chromaticTargetY;
    bool m_chromaticRelative;
    float m_cGStartTime;
    float m_cGTime;
    float m_cGSpeed;
    float m_cGRGBOffset;
    float m_cGStrength;
    float m_cGSegmentHeight;
    float m_cGLineThickness;
    float m_cGLineStrength;
    bool m_cGEnable;
    bool m_cGActive;
    bool m_cGRelative;
    bool m_cGRelativePos;
    float m_pixelateTargetX;
    float m_pixelateTargetY;
    bool m_pixelateSnapGrid;
    bool m_pixelatePixelating;
    bool m_pixelateRelative;
    bool m_pixelateHardEdges;
    float m_lensCircleSize;
    float m_lensCircleFade;
    float m_lensCircleStrength;
    int m_lensCircleTargetID;
    int m_lensCircleTintChannel;
    bool m_lensCircleRelative;
    bool m_lensCircleAdditive;
    cocos2d::ccColor3B m_lensCircleTint;
    cocos2d::CCPoint m_lensCircleCenter;
    cocos2d::CCPoint m_lensCircleScreenOffset;
    float m_radialBlurSize;
    float m_radialBlurFade;
    bool m_radialBlurTarget;
    int m_radialBlurTargetID;
    cocos2d::CCPoint m_radialBlurCenter;
    cocos2d::CCPoint m_radialBlurScreenOffset;
    float m_motionBlurTargetX;
    float m_motionBlurTargetY;
    float m_motionBlurSpeedX;
    float m_motionBlurSpeedY;
    float m_motionBlurFollowEaseX;
    float m_motionBlurFollowEaseY;
    int m_motionBlurTargetIDX;
    int m_motionBlurTargetIDY;
    bool m_motionBlurDual;
    bool m_motionBlurRelative;
    float m_bulgeValue;
    bool m_bulgeRelative;
    int m_bulgeTargetID;
    float m_bulgeRadius;
    cocos2d::CCPoint m_bulgeCenter;
    cocos2d::CCPoint m_bulgeScreenOffset;
    float m_pinchTargetX;
    float m_pinchTargetY;
    bool m_pinchTargetEnabledX;
    bool m_pinchTargetEnabledY;
    int m_pinchTargetIDX;
    int m_pinchTargetIDY;
    cocos2d::CCPoint m_pinchCenter;
    cocos2d::CCPoint m_pinchScreenOffset;
    bool m_pinchRelative;
    float m_pinchRadius;
    cocos2d::CCPoint m_pinchModifier;
    float m_grayscaleValue;
    bool m_grayscaleUseLum;
    int m_grayscaleTintChannel;
    cocos2d::ccColor3B m_grayscaleTint;
    float m_sepiaValue;
    float m_invertColorEditRGB;
    float m_invertColorR;
    float m_invertColorG;
    float m_invertColorB;
    bool m_invertColorClampRGB;
    float m_hueShiftDegrees;
    float m_colorChangeCR;
    float m_colorChangeCG;
    float m_colorChangeCB;
    float m_colorChangeBR;
    float m_colorChangeBG;
    float m_colorChangeBB;
    float m_splitTargetRows;
    float m_splitTargetCols;
    bool m_splitActive;
    int m_minBlendingLayer;
    int m_maxBlendingLayer;
    bool m_zLayerDirty;
    bool m_noPlayerParticles;
    bool m_usesShaders;
}

[[link(android)]]
class GJShopLayer : cocos2d::CCLayer, GJPurchaseDelegate, DialogDelegate, RewardedVideoDelegate {
    GJShopLayer() {
        m_closing = false;
        m_currencyLabel = nullptr;
        m_shopItems = nullptr;
        m_type = ShopType::Normal;
        m_unkNode1 = nullptr;
        m_unkNode2 = nullptr;
        m_videoPlaying = false;
        m_unkBool = false;
        m_shopKeeper = nullptr;
        m_zolgurothDialogIndex = 0;
        m_affordDialogIndex = 0;
    }
    ~GJShopLayer() = win inline {
        cocos2d::CCDirector::sharedDirector()->getTouchDispatcher()->unregisterForcePrio(this);
        auto gm = GameManager::sharedState();
        if (gm->m_rewardedVideoDelegate == this) gm->m_rewardedVideoDelegate = nullptr;
        CC_SAFE_RELEASE(m_shopItems);
    }

    static GJShopLayer* create(ShopType type) = win inline {
        auto ret = new GJShopLayer();
        if (ret->init(type)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static cocos2d::CCScene* scene(ShopType type) = win 0x2a9410;

    virtual void onExit() = win 0x2ab680;
    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x2ae7b0;
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline {}
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline {}
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event);
    virtual void registerWithTouchDispatcher() = win 0x42660;
    virtual void keyBackClicked() = win 0x2acdf0;
    virtual void didPurchaseItem(GJStoreItem* item) = win 0x2ac3f0;
    virtual void rewardedVideoFinished() = win 0x2aba40;
    virtual void dialogClosed(DialogLayer* layer) = win 0x2ae480;

    void exitVideoAdItems();
    bool init(ShopType type) = win 0x2a9590;
    void onBack(cocos2d::CCObject* sender) = win 0x2acbd0;
    void onCommunityCredits(cocos2d::CCObject* sender) = win 0x2ab900;
    void onPlushies(cocos2d::CCObject* sender) = win inline {}
    void onSelectItem(cocos2d::CCObject* sender) = win 0x2abb10;
    void onVideoAd(cocos2d::CCObject* sender);
    void showCantAffordMessage(GJStoreItem* item);
    void showReactMessage() = win 0x2ace00;
    void updateCurrencyCounter();

    bool m_closing;
    CCCounterLabel* m_currencyLabel;
    cocos2d::CCDictionary* m_shopItems;
    ShopType m_type;
    gd::string m_sheetName;
    cocos2d::CCNode* m_unkNode1;
    cocos2d::CCNode* m_unkNode2;
    bool m_videoPlaying;
    bool m_unkBool;
    AnimatedShopKeeper* m_shopKeeper;
    int m_zolgurothDialogIndex;
    int m_affordDialogIndex;
}

[[link(android), depends(SmartPrefabResult)]]
class GJSmartBlockPreview : cocos2d::CCNode {
    // virtual ~GJSmartBlockPreview();

    static GJSmartBlockPreview* create(gd::string key) = win 0x2b5830;

    void addChance(int count, int total) = win 0x2b65d0;
    void addCount(int count) = win inline {
        this->createInfoLabel();
        m_infoLabel->setPosition({ 90.f, 90.f });
        m_infoLabel->setString(cocos2d::CCString::createWithFormat("%i", count)->getCString());
        m_infoLabel->limitLabelWidth(20.f, .6f, .0f);
    }
    void addPreview(gd::string key, gd::string data, LevelEditorLayer* layer) = win 0x2b6450;
    cocos2d::CCArray* addTemplateGuide(SmartPrefabResult result, float opacity) = win 0x2b5c00;
    void addTemplateGuide(gd::string key, int type) = win 0x2b5970;
    void createInfoLabel() = win inline {
        if (m_infoLabel) return;
        m_infoLabel = cocos2d::CCLabelBMFont::create(" ", "bigFont.fnt");
        this->addChild(m_infoLabel);
    }
    bool init(gd::string key) = win inline {
        if (!cocos2d::CCNode::init()) return false;
        this->setContentSize({ 90.f, 90.f });
        m_prefabKey = key;
        return true;
    }
    void toggleSelectItem(bool selected) = win inline {
        if (m_selected == selected) return;
        m_selected = selected;
        if (!m_selectSprite) {
            m_selectSprite = cocos2d::CCSprite::createWithSpriteFrameName("GJ_select_001.png");
            this->addChild(m_selectSprite);
            m_selectSprite->setScale(2.8f);
            m_selectSprite->setPosition({ 45.f, 45.f });
        }
        m_selectSprite->setVisible(m_selected);
    }

    gd::string m_prefabKey;
    cocos2d::CCLabelBMFont* m_infoLabel;
    cocos2d::CCSprite* m_selectSprite;
    bool m_selected;
}

[[link(android)]]
class GJSmartBlockPreviewSprite : cocos2d::CCNode {
    // virtual ~GJSmartBlockPreviewSprite();
    GJSmartBlockPreviewSprite() {}

    static GJSmartBlockPreviewSprite* create() = win inline {
        auto ret = new GJSmartBlockPreviewSprite();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init();
    virtual void visit() = win 0x2b67d0;
}

[[link(android)]]
class GJSmartPrefab : cocos2d::CCObject {
    // virtual ~GJSmartPrefab();

    static GJSmartPrefab* create() = win 0x2b5750;
    static GJSmartPrefab* createWithCoder(DS_Dictionary* dict) = win inline {
        auto ret = GJSmartPrefab::create();
        ret->dataLoaded(dict);
        return ret;
    }

    virtual void encodeWithCoder(DS_Dictionary* dict) = win 0x2b57d0;
    virtual bool canEncode() = win inline { return true; }

    void dataLoaded(DS_Dictionary* dict) = win inline {
        m_prefabData = dict->getStringForKey("1");
        m_prefabChance = dict->getIntegerForKey("2");
    }
    bool init() = win inline, ios inline {
        m_prefabID = (*reinterpret_cast<int*>(geode::base::get() + GEODE_WINDOWS(0x69c174) GEODE_IOS(0x83ef48)))++;
        return true;
    }

    gd::string m_prefabKey;
    gd::string m_prefabData;
    int m_prefabID;
    int m_prefabChance;
}

[[link(android), depends(SmartPrefabResult)]]
class GJSmartTemplate : cocos2d::CCObject {
    // virtual ~GJSmartTemplate();

    static void applyTransformationsForType(SmartBlockType type, cocos2d::CCSprite* sprite) = win 0x2b35a0;
    static GJSmartTemplate* create() = win 0x2b0800;
    static GJSmartTemplate* createWithCoder(DS_Dictionary* dict) = win inline {
        auto ret = GJSmartTemplate::create();
        ret->dataLoaded(dict);
        return ret;
    }
    static SmartBlockType flipBlockType(SmartBlockType type, bool flipX, bool flipY) = win 0x2b3ed0;
    static SmartBlockType flipBlockTypeX(SmartBlockType type) = win inline {
        switch (type) {
            case SmartBlockType::NormalSlope1: return SmartBlockType::NormalSlope2;
            case SmartBlockType::NormalSlope2: return SmartBlockType::NormalSlope1;
            case SmartBlockType::NormalSlope3: return SmartBlockType::NormalSlope4;
            case SmartBlockType::NormalSlope4: return SmartBlockType::NormalSlope3;
            case SmartBlockType::WideSlope1: return SmartBlockType::WideSlope3;
            case SmartBlockType::WideSlope2: return SmartBlockType::WideSlope4;
            case SmartBlockType::WideSlope3: return SmartBlockType::WideSlope1;
            case SmartBlockType::WideSlope4: return SmartBlockType::WideSlope2;
            case SmartBlockType::WideSlope5: return SmartBlockType::WideSlope7;
            case SmartBlockType::WideSlope6: return SmartBlockType::WideSlope8;
            case SmartBlockType::WideSlope7: return SmartBlockType::WideSlope5;
            case SmartBlockType::WideSlope8: return SmartBlockType::WideSlope6;
            case SmartBlockType::WideSlope9: return SmartBlockType::WideSlope11;
            case SmartBlockType::WideSlope10: return SmartBlockType::WideSlope12;
            case SmartBlockType::WideSlope11: return SmartBlockType::WideSlope9;
            case SmartBlockType::WideSlope12: return SmartBlockType::WideSlope10;
            case SmartBlockType::WideSlope13: return SmartBlockType::WideSlope15;
            case SmartBlockType::WideSlope14: return SmartBlockType::WideSlope16;
            case SmartBlockType::WideSlope15: return SmartBlockType::WideSlope13;
            case SmartBlockType::WideSlope16: return SmartBlockType::WideSlope14;
            default: return type;
        }
    }
    static SmartBlockType flipBlockTypeY(SmartBlockType type) = win inline {
        switch (type) {
            case SmartBlockType::NormalSlope1: return SmartBlockType::NormalSlope3;
            case SmartBlockType::NormalSlope2: return SmartBlockType::NormalSlope4;
            case SmartBlockType::NormalSlope3: return SmartBlockType::NormalSlope1;
            case SmartBlockType::NormalSlope4: return SmartBlockType::NormalSlope2;
            case SmartBlockType::WideSlope1: return SmartBlockType::WideSlope5;
            case SmartBlockType::WideSlope2: return SmartBlockType::WideSlope6;
            case SmartBlockType::WideSlope3: return SmartBlockType::WideSlope7;
            case SmartBlockType::WideSlope4: return SmartBlockType::WideSlope8;
            case SmartBlockType::WideSlope5: return SmartBlockType::WideSlope1;
            case SmartBlockType::WideSlope6: return SmartBlockType::WideSlope2;
            case SmartBlockType::WideSlope7: return SmartBlockType::WideSlope3;
            case SmartBlockType::WideSlope8: return SmartBlockType::WideSlope4;
            case SmartBlockType::WideSlope9: return SmartBlockType::WideSlope13;
            case SmartBlockType::WideSlope10: return SmartBlockType::WideSlope14;
            case SmartBlockType::WideSlope11: return SmartBlockType::WideSlope15;
            case SmartBlockType::WideSlope12: return SmartBlockType::WideSlope16;
            case SmartBlockType::WideSlope13: return SmartBlockType::WideSlope9;
            case SmartBlockType::WideSlope14: return SmartBlockType::WideSlope10;
            case SmartBlockType::WideSlope15: return SmartBlockType::WideSlope11;
            case SmartBlockType::WideSlope16: return SmartBlockType::WideSlope12;
            default: return type;
        }
    }
    static gd::string flipKey(gd::string key, bool flipX, bool flipY) = win 0x2b44e0;
    static cocos2d::CCDictionary* generateRemapDict();
    static gd::string getSimplifiedKey(gd::string key) = win 0x2b0f30;
    static SmartBlockType getSimplifiedType(SmartBlockType type, bool& changed) = win inline, ios inline {
        switch (type) {
            case SmartBlockType::NormalSlope1: case SmartBlockType::NormalSlope2:
            case SmartBlockType::NormalSlope3: case SmartBlockType::NormalSlope4:
            case SmartBlockType::WideSlope1: case SmartBlockType::WideSlope2:
            case SmartBlockType::WideSlope3: case SmartBlockType::WideSlope4:
            case SmartBlockType::WideSlope5: case SmartBlockType::WideSlope6:
            case SmartBlockType::WideSlope7: case SmartBlockType::WideSlope8:
            case SmartBlockType::WideSlope9: case SmartBlockType::WideSlope10:
            case SmartBlockType::WideSlope11: case SmartBlockType::WideSlope12:
            case SmartBlockType::WideSlope13: case SmartBlockType::WideSlope14:
            case SmartBlockType::WideSlope15: case SmartBlockType::WideSlope16:
                changed = true;
                return SmartBlockType::Block;
            default: return type;
        }
    }
    static gd::string getVerySimplifiedKey(gd::string key) = win 0x2b1710;
    static gd::string keyFromNeighbors(SmartBlockType type, SmartBlockType left, SmartBlockType right, SmartBlockType top, SmartBlockType bottom, SmartBlockType topLeft, SmartBlockType topRight, SmartBlockType bottomLeft, SmartBlockType bottomRight) = win inline {
        std::string result;
        result += (char)type;
        result += (char)left;
        result += (char)right;
        result += (char)top;
        result += (char)bottom;
        result += (char)topLeft;
        result += (char)topRight;
        result += (char)bottomLeft;
        result += (char)bottomRight;
        return result;
    }
    static gd::string keyFromNeighbors(cocos2d::CCPoint position, SmartGameObject* object, SmartGameObject* left, SmartGameObject* right, SmartGameObject* top, SmartGameObject* bottom, SmartGameObject* topLeft, SmartGameObject* topRight, SmartGameObject* bottomLeft, SmartGameObject* bottomRight) = win 0x2b3970;
    static gd::string keyFromNeighborsOld(bool left, bool right, bool top, bool bottom, bool topLeft, bool topRight, bool bottomLeft, bool bottomRight) = win inline, ios inline {
        fmt::memory_buffer buffer;
        fmt::format_to(std::back_inserter(buffer), "{}{}{}{}{}{}{}{}{}", 1, (int)left, (int)right, (int)top, (int)bottom, (int)topLeft, (int)topRight, (int)bottomLeft, (int)bottomRight);
        return fmt::to_string(buffer);
    }
    static cocos2d::CCPoint offsetForDir(GJSmartDirection direction, int key) = win 0x2b33b0;
    static cocos2d::CCPoint offsetForObject(SmartGameObject* object) = win inline {
        return object ? offsetForType(smartObjectToType(object, { 0.f, 0.f })) : cocos2d::CCPoint{ 0.f, 0.f };
    }
    static cocos2d::CCPoint offsetForType(SmartBlockType type) = win 0x2b34b0;
    static SmartBlockType rotateBlockType(SmartBlockType type, int degrees) = win 0x2b3d60, ios inline {
        if (type == SmartBlockType::Block || degrees == 0) return type;
        for (; degrees > 0; degrees -= 90) {
            type = rotateBlockType90(type);
        }
        return type;
    }
    static SmartBlockType rotateBlockType90(SmartBlockType type) = win inline {
        switch (type) {
            case SmartBlockType::NormalSlope1: return SmartBlockType::NormalSlope2;
            case SmartBlockType::NormalSlope2: return SmartBlockType::NormalSlope4;
            case SmartBlockType::NormalSlope3: return SmartBlockType::NormalSlope1;
            case SmartBlockType::NormalSlope4: return SmartBlockType::NormalSlope3;
            case SmartBlockType::WideSlope1: return SmartBlockType::WideSlope11;
            case SmartBlockType::WideSlope2: return SmartBlockType::WideSlope12;
            case SmartBlockType::WideSlope3: return SmartBlockType::WideSlope15;
            case SmartBlockType::WideSlope4: return SmartBlockType::WideSlope16;
            case SmartBlockType::WideSlope5: return SmartBlockType::WideSlope9;
            case SmartBlockType::WideSlope6: return SmartBlockType::WideSlope10;
            case SmartBlockType::WideSlope7: return SmartBlockType::WideSlope13;
            case SmartBlockType::WideSlope8: return SmartBlockType::WideSlope14;
            case SmartBlockType::WideSlope9: return SmartBlockType::WideSlope3;
            case SmartBlockType::WideSlope10: return SmartBlockType::WideSlope4;
            case SmartBlockType::WideSlope11: return SmartBlockType::WideSlope7;
            case SmartBlockType::WideSlope12: return SmartBlockType::WideSlope8;
            case SmartBlockType::WideSlope13: return SmartBlockType::WideSlope1;
            case SmartBlockType::WideSlope14: return SmartBlockType::WideSlope2;
            case SmartBlockType::WideSlope15: return SmartBlockType::WideSlope5;
            case SmartBlockType::WideSlope16: return SmartBlockType::WideSlope6;
            default: return type;
        }
    }
    static gd::string rotateKey(gd::string key, int degrees) = win 0x2b4180;
    static bool shouldDiscardObject(SmartBlockType type, GJSmartDirection direction) = win inline {
        switch (type) {
            case SmartBlockType::WideSlope2: case SmartBlockType::WideSlope6:
                return direction == GJSmartDirection::Top ||
                    direction == GJSmartDirection::Bottom ||
                    direction == GJSmartDirection::TopRight ||
                    direction == GJSmartDirection::BottomRight;
            case SmartBlockType::WideSlope4: case SmartBlockType::WideSlope8:
                return direction == GJSmartDirection::Top ||
                    direction == GJSmartDirection::Bottom ||
                    direction == GJSmartDirection::TopLeft ||
                    direction == GJSmartDirection::BottomLeft;
            case SmartBlockType::WideSlope10: case SmartBlockType::WideSlope12:
                return direction == GJSmartDirection::Left ||
                    direction == GJSmartDirection::Right ||
                    direction == GJSmartDirection::BottomLeft ||
                    direction == GJSmartDirection::BottomRight;
            case SmartBlockType::WideSlope14: case SmartBlockType::WideSlope16:
                return direction == GJSmartDirection::Left ||
                    direction == GJSmartDirection::Right ||
                    direction == GJSmartDirection::TopLeft ||
                    direction == GJSmartDirection::TopRight;
            default:
                return false;
        }
    }
    static SmartBlockType smartObjectToType(SmartGameObject* object, cocos2d::CCPoint point) = win 0x2b36e0;
    static int smartTypeToObjectKey(SmartBlockType type) = win inline {
        switch (type) {
            case SmartBlockType::NormalSlope1:
            case SmartBlockType::NormalSlope2:
            case SmartBlockType::NormalSlope3:
            case SmartBlockType::NormalSlope4:
                return 2896;
            case SmartBlockType::WideSlope1:
            case SmartBlockType::WideSlope2:
            case SmartBlockType::WideSlope3:
            case SmartBlockType::WideSlope4:
            case SmartBlockType::WideSlope5:
            case SmartBlockType::WideSlope6:
            case SmartBlockType::WideSlope7:
            case SmartBlockType::WideSlope8:
            case SmartBlockType::WideSlope9:
            case SmartBlockType::WideSlope10:
            case SmartBlockType::WideSlope11:
            case SmartBlockType::WideSlope12:
            case SmartBlockType::WideSlope13:
            case SmartBlockType::WideSlope14:
            case SmartBlockType::WideSlope15:
            case SmartBlockType::WideSlope16:
                return 2897;
            default:
                return 2895;
        }
    }

    virtual void encodeWithCoder(DS_Dictionary* dict) = win 0x2b5670;
    virtual bool canEncode() = win inline { return true; }

    void dataLoaded(DS_Dictionary* dict) = win 0x2b53a0;
    gd::string getNoCornerKey(gd::string key) = win 0x2b1820;
    GJSmartPrefab* getPrefab(gd::string key, bool flipX, bool flipY) = win 0x2b2a00;
    GJSmartPrefab* getPrefab(cocos2d::CCPoint position, SmartGameObject* object, SmartGameObject* left, SmartGameObject* right, SmartGameObject* top, SmartGameObject* bottom, SmartGameObject* topLeft, SmartGameObject* topRight, SmartGameObject* bottomLeft, SmartGameObject* bottomRight) = win inline, ios inline {
        return this->getPrefab(keyFromNeighbors(position, object, left, right, top, bottom, topLeft, topRight, bottomLeft, bottomRight), false, false);
    }
    cocos2d::CCArray* getPrefabs(gd::string key) = win inline {
        return static_cast<cocos2d::CCArray*>(m_prefabArrays->objectForKey(key));
    }
    GJSmartPrefab* getPrefabWithID(gd::string key, int id) = win 0x2b32f0;
    GJSmartPrefab* getRandomPrefab(gd::string key) = win 0x2b2890;
    void getTemplateState(gd::vector<SmartPrefabResult>& results) = win 0x2b4db0;
    int getTotalChanceForPrefab(gd::string key) = win 0x2b27d0;
    bool init() = win inline {
        CC_SAFE_RELEASE(m_prefabArrays);
        m_prefabArrays = cocos2d::CCDictionary::create();
        m_prefabArrays->retain();
        m_remapDict1 = cocos2d::CCDictionary::create();
        m_remapDict1->retain();
        m_remapDict2 = cocos2d::CCDictionary::create();
        m_remapDict2->retain();
        m_remapDict3 = cocos2d::CCDictionary::create();
        m_remapDict3->retain();
        m_remapDict4 = cocos2d::CCDictionary::create();
        m_remapDict4->retain();
        m_remapDict5 = cocos2d::CCDictionary::create();
        m_remapDict5->retain();
        m_remapDict6 = cocos2d::CCDictionary::create();
        m_remapDict6->retain();
        return true;
    }
    bool isUnrequired(gd::string key) = win 0x2b4c10;
    gd::string logTemplateStatus(bool unused) = win 0x2b4810;
    void removePrefab(gd::string prefabKey, int prefabID) = win inline {
        if (prefabID <= 0) return;
        auto prefabArray = static_cast<cocos2d::CCArray*>(m_prefabArrays->objectForKey(prefabKey));
        if (!prefabArray || prefabArray->count() == 0) return;
        for (int i = 0; i < prefabArray->count(); i++) {
            auto prefab = static_cast<GJSmartPrefab*>(prefabArray->objectAtIndex(i));
            if (prefab->m_prefabID == prefabID) {
                prefabArray->removeObjectAtIndex(i);
                break;
            }
        }
    }
    void resetScannedPrefabs() = win inline {
        m_prefabResults.clear();
    }
    void savePrefab(gd::string key, gd::string data) = win inline {
        m_unk0a8 = "";
        auto prefabArray = static_cast<cocos2d::CCArray*>(m_prefabArrays->objectForKey(key));
        if (!prefabArray) {
            prefabArray = cocos2d::CCArray::create();
            m_prefabArrays->setObject(prefabArray, key);
        }
        for (int i = 0; i < prefabArray->count(); i++) {
            if (static_cast<GJSmartPrefab*>(prefabArray->objectAtIndex(i))->m_prefabData == data) return;
        }
        auto prefab = GJSmartPrefab::create();
        prefab->m_prefabKey = key;
        prefab->m_prefabData = data;
        prefabArray->addObject(prefab);
        this->saveRemap(key);
    }
    void saveRemap(gd::string key) = win 0x2b0980;
    void saveRemapToDict(gd::string key, gd::string remap, cocos2d::CCDictionary* dict) = win 0x2b0d50;
    SmartPrefabResult scanForPrefab(gd::string key) = win 0x2b19a0;

    cocos2d::CCDictionary* m_prefabArrays;
    cocos2d::CCDictionary* m_remapDict1;
    cocos2d::CCDictionary* m_remapDict2;
    cocos2d::CCDictionary* m_remapDict3;
    cocos2d::CCDictionary* m_remapDict4;
    cocos2d::CCDictionary* m_remapDict5;
    cocos2d::CCDictionary* m_remapDict6;
    gd::map<gd::string, SmartPrefabResult> m_prefabResults;
    bool m_allowFlipX;
    bool m_allowFlipY;
    bool m_allowRotation;
    bool m_ignoreCorners;
    gd::string m_templateName;
    gd::string m_unk0a8;
    int m_nameIndex;
    int m_prefabIndex;
}

[[link(android)]]
class GJSongBrowser : GJDropDownLayer, FLAlertLayerProtocol, TableViewCellDelegate {
    // virtual ~GJSongBrowser();

    static GJSongBrowser* create() = win 0x2b6fd0;

    virtual bool init() = win 0x2b7150;
    virtual void customSetup() = win 0x2b7250;
    virtual void exitLayer(cocos2d::CCObject* sender);
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x2b7990;
    virtual bool cellPerformedAction(TableViewCell* cell, int listType, CellAction action, cocos2d::CCNode* parent) = win 0x2b7a90;
    virtual int getSelectedCellIdx() = win 0x2b7ac0;

    void loadPage(int page) = win 0x2b75d0;
    void onDeleteAll(cocos2d::CCObject* sender);
    void onNextPage(cocos2d::CCObject* sender) = win 0x2b7860;
    void onPrevPage(cocos2d::CCObject* sender) = win 0x2b7870;
    void setupPageInfo(int itemCount, int pageStartIdx, int pageEndIdx) = win inline {
        m_leftArrow->setVisible(pageStartIdx != 0);
        auto nextIndex = pageStartIdx + pageEndIdx;
        m_rightArrow->setVisible(itemCount > nextIndex);
        nextIndex = std::min(nextIndex, itemCount);
        m_countText->setString(cocos2d::CCString::createWithFormat("%i to %i of %i", pageStartIdx + 1, nextIndex, itemCount)->getCString());
    }
    void setupSongBrowser(cocos2d::CCArray* songs) = win inline {
        m_listLayer->removeChildByTag(9, true);
        m_listView = CustomListView::create(songs, this, 220.f, 356.f, 0, BoomListType::CustomSong, 0.f);
        m_listView->setTag(9);
        m_listLayer->addChild(m_listView, 6);
    }

    int m_page;
    int m_songID;
    bool m_selected;
    CCMenuItemSpriteExtra* m_rightArrow;
    CCMenuItemSpriteExtra* m_leftArrow;
    cocos2d::CCLabelBMFont* m_countText;
    cocos2d::CCPoint m_unk298;
    cocos2d::CCArray* m_downloadedSongs;
    CustomListView* m_listView;
}

[[link(android)]]
class GJSpecialColorSelect : FLAlertLayer {
    // virtual ~GJSpecialColorSelect();

    static GJSpecialColorSelect* create(int id, GJSpecialColorSelectDelegate* delegate, ColorSelectType type) = win 0x2b7b90;
    static const char* textForColorIdx(int index) = win 0x2b88e0;

    virtual void keyBackClicked() = win 0x2b8890;

    ButtonSprite* getButtonByTag(int tag) = win inline, ios inline {
        for (int i = 0; i < m_buttonSprites->count(); i++) {
            auto sprite = static_cast<ButtonSprite*>(m_buttonSprites->objectAtIndex(i));
            if (sprite->getTag() == tag) return sprite;
        }
        return nullptr;
    }
    void highlightSelected(ButtonSprite* sprite) = win inline {
        for (int i = 0; i < m_buttonSprites->count(); i++) {
            auto sprite = static_cast<ButtonSprite*>(m_buttonSprites->objectAtIndex(i));
            sprite->updateBGImage(sprite->getTag() == 1008 ? "GJ_button_05.png" : "GJ_button_04.png");
        }
        if (sprite) sprite->updateBGImage("GJ_button_02.png");
    }
    bool init(int id, GJSpecialColorSelectDelegate* delegate, ColorSelectType type) = win 0x2b7ca0;
    void onClose(cocos2d::CCObject* sender) = win 0x2b8840;
    void onSelectColor(cocos2d::CCObject* sender) = win 0x2b8760;

    GJSpecialColorSelectDelegate* m_delegate;
    int m_colorID;
    cocos2d::CCArray* m_buttonSprites;
}

[[link(android)]]
class GJSpecialColorSelectDelegate {
    virtual void colorSelectClosed(GJSpecialColorSelect* select, int id) {}
}

[[link(android)]]
class GJSpiderSprite : GJRobotSprite {
    // virtual ~GJSpiderSprite();

    static GJSpiderSprite* create(int frame) = win 0x2a7940;

    bool init(int frame) = win inline {
        return GJRobotSprite::init(frame, "Spider");
    }
}

[[link(android)]]
class GJSpriteColor {
    GJSpriteColor() {
        m_colorID = 0;
        m_defaultColorID = 0;
        m_opacity = 1.f;
        m_baseOpacity = 1.f;
        m_hsv.h = 0.f;
        m_hsv.s = 1.f;
        m_hsv.v = 1.f;
        m_hsv.absoluteSaturation = false;
        m_hsv.absoluteBrightness = false;
        m_usesHSV = false;
        m_usesCustomBlend = false;
        m_customColor.r = 255;
        m_customColor.g = 255;
        m_customColor.b = 255;
    }

    int getColorMode() {
        return m_defaultColorID == m_colorID || m_colorID != 0 ? m_colorID : m_defaultColorID;
    }

    int m_colorID;
    int m_defaultColorID;
    float m_opacity;
    float m_baseOpacity;
    cocos2d::ccHSVValue m_hsv;
    bool m_usesHSV;
    bool m_usesCustomBlend;
    cocos2d::ccColor3B m_customColor;
}

[[link(android)]]
class GJStoreItem : cocos2d::CCNode {
    // virtual ~GJStoreItem();
    GJStoreItem() {
        m_index = 0;
        m_typeID = 0;
        m_unlockType = 0;
        m_price = 0;
        m_shopType = ShopType::Normal;
    }

    static GJStoreItem* create(int index, int typeID, int unlockType, int price, ShopType shopType) = win inline {
        auto ret = new GJStoreItem();
        if (ret->init(index, typeID, unlockType, price, shopType)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    gd::string getCurrencyKey() = win inline {
        return m_shopType == ShopType::Diamond ? "29" : "14";
    }
    bool init(int index, int typeID, int unlockType, int price, ShopType shopType) = win inline {
        if (!CCNode::init()) return false;
        m_index = index;
        m_typeID = typeID;
        m_unlockType = unlockType;
        m_price = price;
        m_shopType = shopType;
        return true;
    }

    geode::SeedValueRSV m_index;
    geode::SeedValueRSV m_typeID;
    geode::SeedValueRSV m_unlockType;
    geode::SeedValueRSV m_price;
    ShopType m_shopType;
}

[[link(android)]]
class GJTransformControl : cocos2d::CCLayer {
    GJTransformControl() {
        m_objects = nullptr;
        m_touchID = -1;
        m_transformButtonType = 0;
        m_delegate = nullptr;
        m_warpSprites = nullptr;
        m_warpLockButton = nullptr;
        m_scaleX = 1.0f;
        m_scaleY = 1.0f;
        m_warpLocked = false;
        m_rotationX = 0.0f;
        m_rotationY = 0.0f;
        m_rotation = 0.0f;
        m_buttonScale = 1.0f;
    }
    ~GJTransformControl() = win inline {
        CC_SAFE_RELEASE(m_warpSprites);
        CC_SAFE_RELEASE(m_objects);
    }

    static GJTransformControl* create() = win inline {
        auto ret = new GJTransformControl();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x12ae90;
    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x12c520;
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x12c6f0;
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x12cc50;
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event);

    void applyRotation(float rotation) = win inline {
        if (m_rotationY != rotation) {
            m_rotationY = rotation;
            m_mainNode->setRotation(rotation);
            if (m_delegate) m_delegate->transformRotationChanged(rotation);
        }
        this->updateButtons(false, false);
    }
    void calculateRotationOffset() = win inline, ios inline {
        m_rotation = (-(atan2f(m_rotatePosition.y, m_rotatePosition.x) * (180.f / M_PI)) * 100.f) / 100.f;
    }
    void finishTouch() = win inline, ios inline {
        if (m_touchID != -1) {
            m_touchID = -1;
            if (m_delegate) m_delegate->transformChangeEnded();
        }
    }
    void loadFromState(GJTransformState& state) = win inline {
        m_rotationX = state.m_transformRotationX;
        m_rotationY = state.m_transformRotationY;
        m_scaleX = state.m_transformScaleX;
        m_scaleY = state.m_transformScaleY;
        m_mainNode->setRotation(m_rotationY);
        this->setPosition(state.m_transformPosition);
        this->spriteByTag(1)->setPosition({ 0.f, 0.f });
        this->spriteByTag(10)->setPosition(state.m_transformSkewX);
        this->spriteByTag(11)->setPosition(state.m_transformSkewY);
    }
    void loadValues(GameObject* object, cocos2d::CCArray* objects, gd::unordered_map<int, GameObjectEditorState>& states) = win inline {
        if (object && !objects || objects->count() == 0) objects = cocos2d::CCArray::createWithObject(object);
        CC_SAFE_RELEASE(m_objects);
        m_objects = objects;
        objects->retain();
        if (objects->count() != 0) {
            for (int i = 0; i < objects->count(); i++) {
                auto obj = static_cast<GameObject*>(objects->objectAtIndex(i));
                obj->updateStartPos();
                states[obj->m_uniqueID].loadValues(obj);
            }
        }
        this->updateButtons(true, false);
    }
    void logCurrentZeroPos() = win inline, ios inline {}
    void onToggleLockScale(cocos2d::CCObject* sender);
    void refreshControl() = win 0x12b3e0;
    void saveToState(GJTransformState& state) = win inline {
        state.m_transformScaleX = m_scaleX;
        state.m_transformScaleY = m_scaleY;
        state.m_transformRotationX = m_rotationX;
        state.m_transformRotationY = m_rotationY;
        state.m_transformPosition = this->spriteByTag(1)->getPosition();
        state.m_transformSkewX = this->spriteByTag(10)->getPosition();
        state.m_transformSkewY = this->spriteByTag(11)->getPosition();
    }
    void scaleButtons(float scale) = win 0x12b600;
    cocos2d::CCSprite* spriteByTag(int tag) = win inline, ios inline {
        return static_cast<cocos2d::CCSprite*>(m_warpSprites->objectAtIndex(tag - 1));
    }
    void updateAnchorSprite(cocos2d::CCPoint position) = win inline {
        this->spriteByTag(0)->setPosition(position);
        if (m_delegate) m_delegate->updateTransformControl();
    }
    void updateButtons(bool transform, bool skew) = win 0x12b6c0;
    void updateMinMaxPositions() = win inline, ios inline {
        auto topRightPosition = this->spriteByTag(7)->getPosition();
        auto bottomLeftPosition = this->spriteByTag(8)->getPosition();
        if (m_transformButtonType == 10) {
            auto divisor = m_topRightPosition.x / m_topRight.x;
            m_topRight.x = topRightPosition.x / divisor;
            m_bottomLeft.x = bottomLeftPosition.x / divisor;
        }
        else if (m_transformButtonType == 11) {
            auto divisor = m_bottomLeftPosition.y / m_bottomLeft.y;
            m_topRight.y = topRightPosition.y / divisor;
            m_bottomLeft.y = bottomLeftPosition.y / divisor;
        }
    }

    cocos2d::CCNode* m_mainNodeParent;
    cocos2d::CCNode* m_mainNode;
    cocos2d::CCArray* m_objects;
    int m_touchID;
    short m_transformButtonType;
    GJTransformControlDelegate* m_delegate;
    cocos2d::CCPoint m_cursorDifference;
    cocos2d::CCPoint m_topRight;
    cocos2d::CCPoint m_bottomLeft;
    cocos2d::CCPoint m_topRightPosition;
    cocos2d::CCPoint m_bottomLeftPosition;
    cocos2d::CCPoint m_topRightOrigin;
    cocos2d::CCPoint m_bottomLeftOrigin;
    cocos2d::CCArray* m_warpSprites;
    cocos2d::CCPoint m_rotatePosition;
    CCMenuItemSpriteExtra* m_warpLockButton;
    float m_scaleX;
    float m_scaleY;
    bool m_warpLocked;
    float m_rotationX;
    float m_rotationY;
    float m_rotation;
    float m_buttonScale;
}

[[link(android)]]
class GJTransformControlDelegate {
    virtual void transformScaleXChanged(float scaleX) {}
    virtual void transformScaleYChanged(float scaleY) {}
    virtual void transformScaleXYChanged(float scaleX, float scaleY) {}
    virtual void transformRotationXChanged(float rotationX) {}
    virtual void transformRotationYChanged(float rotationY) {}
    virtual void transformRotationChanged(float rotation) {}
    virtual void transformResetRotation() {}
    virtual void transformRestoreRotation() {}
    virtual void transformSkewXChanged(float skewX) {}
    virtual void transformSkewYChanged(float skewY) {}
    virtual void transformChangeBegin() {}
    virtual void transformChangeEnded() {}
    virtual void updateTransformControl() {}
    virtual void anchorPointMoved(cocos2d::CCPoint anchorPoint) {}
    virtual cocos2d::CCNode* getTransformNode() { return nullptr; }
    virtual EditorUI* getUI() { return nullptr; }
}

[[link(android)]]
class GJUINode : cocos2d::CCNode {
    // virtual ~GJUINode();

    static GJUINode* create(UIButtonConfig& config) = win 0x4ce6d0;

    virtual void draw() = win 0x4cf210;

    int activeRangeTouchTest(cocos2d::CCPoint position) = win inline {
        cocos2d::CCPoint rangePos = { m_firstSprite->getPosition().x, position.y + 40.f };
        auto xDiff = position.x - rangePos.x;
        int touchResult;
        if (m_deadzone <= std::abs(xDiff)) {
            auto radius = m_radius;
            rangePos.x = std::abs(xDiff) > radius ? position.x + radius : position.x - radius;
            touchResult = xDiff > 0.f ? 3 : 2;
        }
        else {
            touchResult = 0;
        }
        auto centerX = m_rect.size.width * .5f;
        auto reverseCenterX = -m_rect.size.width * .5f;
        if (std::min(rangePos.x, centerX) > reverseCenterX) rangePos.x = reverseCenterX;
        else rangePos.x = std::min(rangePos.x, centerX);
        auto centerY = 40.f + m_rect.size.height * .5f;
        auto reverseCenterY = 40.f - m_rect.size.height * .5f;
        if (std::min(rangePos.y, centerY) > reverseCenterY) rangePos.y = reverseCenterY;
        else rangePos.y = std::min(rangePos.y, centerY);
        m_firstSprite->setVisible(true);
        m_firstSprite->setPosition(rangePos);
        return touchResult;
    }
    int activeTouchTest(cocos2d::CCPoint position) = win 0x4ceee0;
    float getButtonScale() = win inline {
        return m_firstSprite->getScale();
    }
    uint8_t getOpacity() = win inline {
        return m_firstSprite->getOpacity();
    }
    void highlightButton(int button) = win inline {
        if (m_modeB) return;
        this->toggleHighlight(button, true);
        this->toggleHighlight(button == 2 ? 3 : 2, false);
    }
    bool init(UIButtonConfig& config) = win 0x4ce7b0;
    void loadFromConfig(UIButtonConfig& config) = win inline {
        this->updateSize(config.m_width, config.m_height);
        this->updateDragRadius(config.m_radius);
        this->updateDeadzone(config.m_deadzone);
        this->toggleModeB(config.m_modeB);
        m_snap = config.m_snap;
        this->updateButtonScale(config.m_scale);
        this->setOpacity(config.m_opacity);
        m_oneButton = config.m_oneButton;
        m_split = config.m_split;
        this->updateButtonFrames();
        if (config.m_player2) {
            this->setPosition({ cocos2d::CCDirector::sharedDirector()->getWinSize().width - config.m_position.x, config.m_position.y });
        }
        else {
            this->setPosition(config.m_position);
        }
    }
    void resetState() = win inline {
        m_touchID = -1;
        m_swiping = false;
        m_moving = false;
        this->toggleHighlight(2, false);
        this->toggleHighlight(3, false);
    }
    void saveToConfig(UIButtonConfig& config) = win 0x4cea60;
    void setOpacity(unsigned char opacity) = win inline {
        m_firstSprite->setOpacity(opacity);
        if (m_secondSprite) m_secondSprite->setOpacity(opacity);
    }
    void toggleHighlight(int button, bool highlight) = win 0x4cf180, ios inline {
        if (m_modeB) {
            if (m_firstSprite) m_firstSprite->setColor({ 255, 255, 255 });
        }
        else {
            auto sprite = button == 3 ? m_secondSprite : m_firstSprite;
            if (sprite) sprite->setColor(highlight ? cocos2d::ccColor3B { 150, 150, 150 } : cocos2d::ccColor3B { 255, 255, 255 });
        }
    }
    void toggleModeB(bool modeB) = win inline {
        if (m_secondSprite) {
            m_modeB = modeB;
            m_firstSprite->setVisible(!modeB);
            m_secondSprite->setVisible(!m_modeB);
            this->updateButtonFrames();
        }
    }
    void touchEnded() = win 0x4cf0c0;
    int touchTest(cocos2d::CCPoint position) = win 0x4cedd0;
    void updateButtonFrames() = win 0x4ceb10;
    void updateButtonPositions() = win 0x4cecd0;
    void updateButtonScale(float scale) = win inline {
        if (scale < .1f) scale = .1f;
        m_firstSprite->setScale(scale);
        if (m_secondSprite) m_secondSprite->setScale(scale);
        this->updateButtonPositions();
    }
    void updateDeadzone(int deadzone) = win inline, ios inline {
        m_deadzone = deadzone;
    }
    void updateDragRadius(float radius) = win inline {
        if (radius < 0.f) radius = 0.f;
        m_radius = radius;
        this->updateButtonPositions();
    }
    void updateHeight(float height) = win 0x4cec60;
    void updateRangePos(cocos2d::CCPoint position) = win inline {
        m_firstSprite->setPosition(position + cocos2d::CCPoint { 0.f, 40.f });
        m_firstSprite->setVisible(true);
        m_swiping = true;
    }
    void updateSize(float width, float height) = win inline {
        if (width < 10.f) width = 10.f;
        if (height < 10.f) height = 10.f;
        m_rect.origin.x = width * -.5f;
        m_rect.origin.y = height * -.5f;
        m_rect.size.width = width;
        m_rect.size.height = height;
    }
    void updateWidth(float width) = win 0x4cebf0;

    cocos2d::CCSprite* m_firstSprite;
    cocos2d::CCSprite* m_secondSprite;
    cocos2d::CCRect m_rect;
    int m_touchID;
    cocos2d::CCPoint m_touchDelta;
    cocos2d::CCPoint m_touchPosition;
    float m_radius;
    float m_deadzone;
    bool m_drawLines;
    bool m_modeB;
    bool m_snap;
    bool m_swiping;
    bool m_moving;
    bool m_player2;
    bool m_oneButton;
    bool m_split;
    PlayerButton m_currentButton;
}

[[link(android)]]
class GJUnlockableItem : cocos2d::CCObject {
    // virtual ~GJUnlockableItem();
    GJUnlockableItem() {}

    static GJUnlockableItem* create() = win inline {
        auto ret = new GJUnlockableItem();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init() = win inline, ios inline {
        return true;
    }
}

[[link(android)]]
class GJUserCell : TableViewCell, FLAlertLayerProtocol, UploadPopupDelegate, UploadActionDelegate {
    GJUserCell(char const* identifier, float width, float height) = win inline, ios inline : TableViewCell(identifier, width, height) {
        this->init();
    }
    ~GJUserCell() = win inline {
        if (m_uploadPopup) m_uploadPopup->m_delegate = nullptr;
        CC_SAFE_RELEASE(m_userScore);
    }

    virtual bool init() = win 0xbac60;
    virtual void draw() = win 0xade40;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0xbbb90;
    virtual void uploadActionFinished(int id, int response) = win 0xbbf50;
    virtual void uploadActionFailed(int id, int response);
    virtual void onClosePopup(UploadActionPopup* popup);

    void loadFromScore(GJUserScore* score) = win 0xbac80;
    void onCancelFriendRequest(cocos2d::CCObject* sender) = win 0xbb770;
    void onRemoveFriend(cocos2d::CCObject* sender) = win 0xbb910;
    void onSendMessage(cocos2d::CCObject* sender);
    void onUnblockUser(cocos2d::CCObject* sender) = win 0xbb560;
    void onViewFriendRequest(cocos2d::CCObject* sender) = win inline, ios inline {
        if (!m_userScore || m_userScore->m_accountID <= 0) return;
        if (auto request = GameLevelManager::sharedState()->friendRequestFromAccountID(m_userScore->m_accountID)) {
            if (m_userScore->m_newFriendRequest) {
                if (auto child = m_mainLayer->getChildByTag(100)) child->setVisible(false);
                m_userScore->m_newFriendRequest = false;
            }
            FriendRequestPopup::create(request)->show();
        }
    }
    void onViewProfile(cocos2d::CCObject* sender);
    void updateBGColor(int index) = win inline {
        m_backgroundLayer->setColor(index % 2 == 0 ? cocos2d::ccColor3B { 161, 88, 44 } : cocos2d::ccColor3B { 194, 114, 62 });
        m_backgroundLayer->setOpacity(255);
    }

    GJUserScore* m_userScore;
    UploadActionPopup* m_uploadPopup;
}

[[link(android)]]
class GJUserMessage : cocos2d::CCNode {
    // virtual ~GJUserMessage();
    GJUserMessage() {
        m_messageID = 0;
        m_accountID = 0;
        m_userID = 0;
        m_read = false;
        m_outgoing = false;
        m_toggled = false;
    }

    static GJUserMessage* create() = win 0x173f10;
    static GJUserMessage* create(cocos2d::CCDictionary* dict) = win 0x1733d0;

    virtual bool init();

    int m_messageID;
    int m_accountID;
    int m_userID;
    gd::string m_title;
    gd::string m_content;
    gd::string m_username;
    gd::string m_uploadDate;
    bool m_read;
    bool m_outgoing;
    bool m_toggled;
}

[[link(android)]]
class GJUserScore : cocos2d::CCNode {
    GJUserScore() = win 0x142140 {
        m_scoreType = 0;
        m_userID = 0;
        m_accountID = 0;
        m_stars = 0;
        m_moons = 0;
        m_diamonds = 0;
        m_demons = 0;
        m_playerRank = 0;
        m_creatorPoints = 0;
        m_secretCoins = 0;
        m_iconID = 0;
        m_color1 = 0;
        m_color2 = 0;
        m_special = 0;
        m_iconType = IconType::Cube;
        m_messageState = 0;
        m_friendStatus = 0;
        m_commentHistoryStatus = 0;
        m_glowEnabled = false;
        m_modBadge = 0;
        m_globalRank = 0;
        m_friendReqStatus = 0;
        m_newMsgCount = 0;
        m_friendReqCount = 0;
        m_newFriendCount = 0;
        m_newFriendRequest = false;
        m_toggled = false;
        m_playerCube = 1;
        m_playerShip = 1;
        m_playerBall = 1;
        m_playerUfo = 1;
        m_playerWave = 1;
        m_playerRobot = 1;
        m_playerSpider = 1;
        m_playerSwing = 1;
        m_playerStreak = 1;
        m_unkInt = 0;
        m_unkInt2 = 0;
        m_levelMode = 0;
        m_leaderboardMode = LevelLeaderboardMode::Time;
    }

    // virtual ~GJUserScore();
    static GJUserScore* create() = win inline {
        auto ret = new GJUserScore();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }

        delete ret;
        return nullptr;
    }
    static GJUserScore* create(cocos2d::CCDictionary* dict) = win 0x16ae70;

    virtual bool init();

    bool isCurrentUser() = win 0x172be0;
    void mergeWithScore(GJUserScore* score) = win inline, ios inline {
        m_stars = std::max(m_stars, score->m_stars);
        m_moons = std::max(m_moons, score->m_moons);
        m_diamonds = std::max(m_diamonds, score->m_diamonds);
        m_demons = std::max(m_demons, score->m_demons);
        m_creatorPoints = std::max(m_creatorPoints, score->m_creatorPoints);
        m_secretCoins = std::max(m_secretCoins, score->m_secretCoins);
    }

    gd::string m_userName;
    gd::string m_userUDID;
    int m_scoreType;
    int m_userID;
    int m_accountID;
    int m_stars;
    int m_moons;
    int m_diamonds;
    int m_demons;
    int m_playerRank;
    int m_creatorPoints;
    int m_secretCoins;
    int m_userCoins;
    int m_iconID;
    int m_color1;
    int m_color2;
    int m_color3;
    int m_special;
    IconType m_iconType;
    int m_messageState;
    int m_friendStatus;
    int m_commentHistoryStatus;
    gd::string m_youtubeURL;
    gd::string m_twitterURL;
    gd::string m_twitchURL;
    int m_playerCube;
    int m_playerShip;
    int m_playerBall;
    int m_playerUfo;
    int m_playerWave;
    int m_playerRobot;
    int m_playerSpider;
    int m_playerSwing;
    int m_playerJetpack;
    int m_playerStreak;
    bool m_glowEnabled;
    int m_playerExplosion;
    int m_modBadge;
    int m_globalRank;
    int m_friendReqStatus;
    int m_newMsgCount;
    int m_friendReqCount;
    int m_newFriendCount;
    bool m_newFriendRequest;
    bool m_toggled;
    gd::string m_unkString;
    int m_unkInt;
    int m_unkInt2;
    gd::string m_demonInfo;
    gd::string m_starsInfo;
    gd::string m_platformerInfo;
    int m_levelMode;
    LevelLeaderboardMode m_leaderboardMode;
}

[[link(android)]]
class GJValueTween {
    void step(float delta) = win 0x205350;

    float m_fromValue;
    float m_toValue;
    float m_duration;
    float m_deltaTime;
    float m_currentValue;
    int m_easingType;
    float m_easingRate;
    bool m_finished;
    bool m_disabled;
    int m_uniqueID;
    int m_controlID;
}

[[link(android)]]
class GJWorldNode : cocos2d::CCNode {
    // virtual ~GJWorldNode();

    static GJWorldNode* create(int type, WorldSelectLayer* layer);

    float addDotsToLevel(int levelID, bool animate);
    cocos2d::CCPoint dotPositionForLevel(int levelID, int index);
    bool init(int type, WorldSelectLayer* layer);
    void onLevel(cocos2d::CCObject* sender);
    void playStep1();
    void playStep2();
    void playStep3();
    cocos2d::CCPoint positionForLevelButton(int levelID);
    void unlockActiveItem();

    cocos2d::CCArray* m_activeObjects;
    CCMenuItemSpriteExtra* m_activeButton;
    GJGameLevel* m_level;
    WorldSelectLayer* m_selectLayer;
    bool m_unlocked;
    cocos2d::CCPoint m_levelPosition;
    cocos2d::ccColor3B m_particleColor;
    int m_islandType;
    bool m_islandUnlocked;
    cocos2d::CCSprite* m_arrowSprite;
}

[[link(android)]]
class GJWriteMessagePopup : FLAlertLayer, TextInputDelegate, UploadMessageDelegate, UploadPopupDelegate, FLAlertLayerProtocol {
    // virtual ~GJWriteMessagePopup();

    static GJWriteMessagePopup* create(int accountID, int messageID) = win 0x298f10;

    virtual void registerWithTouchDispatcher() = win 0x42660;
    virtual void keyBackClicked();
    virtual void textInputOpened(CCTextInputNode* node) = win inline {}
    virtual void textInputClosed(CCTextInputNode* node);
    virtual void textChanged(CCTextInputNode* node) = win 0x29a5a0;
    virtual void uploadMessageFinished(int accountID) = win 0x29ab80;
    virtual void uploadMessageFailed(int accountID) = win 0x29ac00;
    virtual void onClosePopup(UploadActionPopup* popup) = win 0x29acb0;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x29ad50;
    virtual void textInputShouldOffset(CCTextInputNode* node, float yOffset) = win 0x7b620;
    virtual void textInputReturn(CCTextInputNode* node) = win 0x7b680;

    void closeMessagePopup(bool fullExit) = win 0x29a3b0;
    bool init(int accountID, int messageID) = win 0x2990a0;
    void onClearBody(cocos2d::CCObject* sender);
    void onClose(cocos2d::CCObject* sender);
    void onSend(cocos2d::CCObject* sender) = win 0x299f40;
    void updateBody(gd::string body);
    void updateCharCountLabel(int type) = win inline {
        cocos2d::CCLabelBMFont* label;
        int count;
        int maxCount;
        if (type == 0) {
            label = m_subjectCountLabel;
            count = m_subjectText.size();
            maxCount = 35;
        }
        else {
            label = m_messageCountLabel;
            count = m_messageText.size();
            maxCount = 200;
        }
        if (maxCount * .9f <= count) {
            label->setOpacity(255);
            label->setColor({ 255, 0, 0 });
        }
        else if (maxCount * .7f <= count) {
            label->setOpacity(255);
            label->setColor({ 255, 255, 255 });
        }
        else {
            label->setOpacity(100);
            label->setColor({ 255, 255, 255 });
        }
        label->setString(cocos2d::CCString::createWithFormat("%i", maxCount - count)->getCString());
    }
    void updateSubject(gd::string subject);
    void updateText(gd::string text, int type) = win 0x29a7f0;

    int m_unk298;
    int m_messageID;
    int m_accountID;
    CCTextInputNode* m_messageInput;
    CCTextInputNode* m_subjectInput;
    gd::string m_messageText;
    gd::string m_subjectText;
    cocos2d::CCLabelBMFont* m_messageCountLabel;
    cocos2d::CCLabelBMFont* m_subjectCountLabel;
    UploadActionPopup* m_uploadPopup;
    bool m_uploadSuccess;
}

[[link(android)]]
class GManager : cocos2d::CCNode {
    GManager() = win 0x51660 {
        m_setup = false;
        m_saved = false;
        m_quickSave = false;
    }

    virtual bool init() = win 0x6a810;
    virtual void setup() = win 0x6a820;
    virtual void encodeDataTo(DS_Dictionary* dict) = win inline {}
    virtual void dataLoaded(DS_Dictionary* dict) = win inline {}
    virtual void firstLoad() = win inline {}

    gd::string getCompressedSaveString() = win 0x6a840;
    gd::string getSaveString() = win inline {
        auto dict = new DS_Dictionary();
        this->encodeDataTo(dict);
        auto str = dict->saveRootSubDictToString();
        delete dict;
        return str;
    }
    void load() = win inline, ios inline {
        this->loadDataFromFile(m_fileName);
    }
    void loadDataFromFile(gd::string const& filename) = win 0x6aae0;
    void loadFromCompressedString(gd::string& str) = win 0x6a910;
    void loadFromString(gd::string& str) = win inline {
        auto dict = new DS_Dictionary();
        auto loaded = dict->loadRootSubDictFromString(str.c_str());
        str.clear();
        if (loaded) this->dataLoaded(dict);
        delete dict;
    }
    void save() = win 0x6a9f0;
    void saveData(DS_Dictionary* dict, gd::string filename) = win inline {
        dict->saveRootSubDictToCompressedFile(filename.c_str());
    }
    void saveGMTo(gd::string filename) = win inline {
        auto dict = new DS_Dictionary();
        this->encodeDataTo(dict);
        this->saveData(dict, filename);
        m_saved = false;
        delete dict;
    }
    bool tryLoadData(DS_Dictionary* dict, gd::string const& filename) = win inline {
        return dict->loadRootSubDictFromCompressedFile(filename.c_str());
    }

    gd::string m_fileName;
    bool m_setup;
    bool m_saved;
    bool m_quickSave;
}

[[link(android)]]
class GooglePlayDelegate {
    virtual void googlePlaySignedIn() {}
}

[[link(android)]]
class GooglePlayManager : cocos2d::CCNode {
    // virtual ~GooglePlayManager();

    static GooglePlayManager* sharedState();

    virtual bool init() = win inline { return true; }

    void googlePlaySignedIn() = win inline, ios inline {
        if (m_delegate1) m_delegate1->googlePlaySignedIn();
        if (m_delegate2) m_delegate2->googlePlaySignedIn();
    }

    GooglePlayDelegate* m_delegate1;
    GooglePlayDelegate* m_delegate2;
}

[[link(android)]]
class GradientTriggerObject : EffectGameObject {
    // virtual ~GradientTriggerObject();
    GradientTriggerObject() {
        m_blendingLayer = 0;
        m_blendingMode = 0;
        m_gradientID = 0;
        m_upBottomLeftID = 0;
        m_downBottomRightID = 0;
        m_leftTopLeftID = 0;
        m_rightTopRightID = 0;
        m_vertexMode = false;
        m_disable = false;
        m_disableAll = false;
        m_previewOpacity = 1.f;
    }

    static GradientTriggerObject* create() = win inline {
        auto ret = new GradientTriggerObject();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x498eb0;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x499540;
    virtual gd::string getSaveString(GJBaseGameLayer* layer);

    // property 202
    int m_blendingLayer;
    // property 174
    int m_blendingMode;
    // property 209
    int m_gradientID;
    // property 203
    int m_upBottomLeftID;
    // property 204
    int m_downBottomRightID;
    // property 205
    int m_leftTopLeftID;
    // property 206
    int m_rightTopRightID;
    // property 207
    bool m_vertexMode;
    // property 208
    bool m_disable;
    // property 508
    bool m_disableAll;
    // property 456
    float m_previewOpacity;
}

[[link(android)]]
class GraphicsReloadLayer : cocos2d::CCLayer {
    // virtual ~GraphicsReloadLayer();
    GraphicsReloadLayer() {}

    static GraphicsReloadLayer* create(cocos2d::TextureQuality quality, cocos2d::CCSize resolution, bool fullscreen, bool borderless, bool fix, bool changedResolution) = win inline, ios inline {
        auto ret = new GraphicsReloadLayer();
        if (ret->init(quality, resolution, fullscreen, borderless, fix, changedResolution)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static cocos2d::CCScene* scene(cocos2d::TextureQuality quality, cocos2d::CCSize resolution, bool fullscreen, bool borderless, bool fix, bool changedResolution) = win inline, ios inline {
        auto scene = cocos2d::CCScene::create();
        AppDelegate::get()->m_runningScene = scene;
        auto layer = GraphicsReloadLayer::create(quality, resolution, fullscreen, borderless, fix, changedResolution);
        scene->addChild(layer);
        return scene;
    }

    bool init(cocos2d::TextureQuality quality, cocos2d::CCSize resolution, bool fullscreen, bool borderless, bool fix, bool changedResolution) = win inline, ios inline {
        if (!CCLayer::init()) return false;
        m_quality = quality;
        m_resolution = resolution;
        m_changedResolution = changedResolution;
        m_fullscreen = fullscreen;
        m_borderless = borderless;
        m_fix = fix;
        this->runAction(cocos2d::CCSequence::create(
            cocos2d::CCDelayTime::create(.1f),
            cocos2d::CCCallFunc::create(this, callfunc_selector(GraphicsReloadLayer::performReload)),
            nullptr
        ));
        return true;
    }
    void performReload() = win 0x37bf30, ios inline {
        auto director = cocos2d::CCDirector::sharedDirector();
        director->replaceScene(cocos2d::CCScene::create());
        auto oldQuality = director->getLoadedTextureQuality();
        director->updateContentScale(m_quality);
        auto newQuality = director->getLoadedTextureQuality();
        auto gameManager = GameManager::sharedState();
        if (gameManager->getGameVariable("0025") == m_fullscreen) {
            gameManager->setGameVariable("0025", !m_fullscreen);
            gameManager->setGameVariable("0170", m_borderless);
            gameManager->setGameVariable("0175", m_fix);
            gameManager->switchScreenMode(m_fullscreen, m_borderless, m_fix, true);
        }
        else if (!m_fullscreen || m_borderless == gameManager->getGameVariable("0170") || m_fix == gameManager->getGameVariable("0175")) {
            gameManager->setGameVariable("0170", m_borderless);
            gameManager->setGameVariable("0175", m_fix);
            if (oldQuality == newQuality) gameManager->queueReloadMenu();
            else gameManager->reloadAll(false, false, false, false, true);
        }
        if (gameManager->getGameVariable("0115")) director->toggleShowFPS(1, "chatFont.fnt", { 0.f, 0.f });
    }

    cocos2d::TextureQuality m_quality;
    cocos2d::CCSize m_resolution;
    bool m_fullscreen;
    bool m_borderless;
    bool m_fix;
    bool m_changedResolution;
}

[[link(android)]]
class GravityEffectSprite : cocos2d::CCSprite {
    // virtual ~GravityEffectSprite();
    GravityEffectSprite() {}

    static GravityEffectSprite* create() = win inline {
        auto ret = new GravityEffectSprite();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x3baf50;
    virtual void draw() = win inline {}

    void updateSpritesColor(cocos2d::ccColor3B color) = win inline {
        if (auto gravityBatchNode = this->getChildByTag(1)) {
            auto children = gravityBatchNode->getChildren();
            for (int i = 0; i < children->count(); i++) {
                static_cast<cocos2d::CCSprite*>(children->objectAtIndex(i))->setColor(color);
            }
        }
    }
}

[[link(android), depends(KeyframeObject)]]
class GroupCommandObject2 {
    // ~GroupCommandObject2();
    GroupCommandObject2() = win 0x2574a0;

    // GroupCommandObject2(GroupCommandObject2 const&);
    void reset() = win 0x257510;
    void resetDelta(bool intermediate) = win inline {
        m_oldDeltaX = m_deltaX;
        m_oldDeltaY = m_deltaY;
        m_oldDeltaX_3 = m_deltaX_3;
        m_oldDeltaY_3 = m_deltaY_3;
        m_deltaX = 0.0;
        m_deltaY = 0.0;
        m_currentRotateOrTransformDelta = 0.0;
        if (!intermediate) {
            m_deltaX_3 = 0.0;
            m_deltaY_3 = 0.0;
            m_Delta_3_Related = 0.0;
        }
    }
    void runFollowCommand(double xMod, double yMod, double duration) = win inline {
        m_commandType = 2;
        m_followXMod = xMod;
        m_followYMod = yMod;
        m_duration = duration;
        if (xMod == 0.0 && yMod == 0.0) {
            m_finished = true;
            m_finishRelated = true;
        }
    }
    void runMoveCommand(cocos2d::CCPoint offset, double duration, int easingType, double easingRate, bool lockPlayerX, bool lockPlayerY, bool lockCameraX, bool lockCameraY, double moveModX, double moveModY) = win inline {
        m_commandType = 0;
        m_moveOffset = offset;
        m_duration = duration;
        m_easingType = (EasingType)easingType;
        m_easingRate = easingRate;
        m_lockToPlayerX = lockPlayerX;
        m_lockToPlayerY = lockPlayerY;
        m_lockToCameraX = lockCameraX;
        m_lockToCameraY = lockCameraY;
        m_moveModX = moveModX != 0.0 ? moveModX : 1.0;
        m_moveModY = moveModY != 0.0 ? moveModY : 1.0;
        m_lockedInX = lockPlayerX || lockCameraX;
        m_lockedInY = lockPlayerY || lockCameraY;
        if (offset.x != 0.f || offset.y != 0.f || lockPlayerX || lockPlayerY || lockCameraX || lockCameraY) {
            if (offset.x != 0.f && !lockCameraX && !lockPlayerX) {
                m_actionType1 = 1;
                m_actionValue1 = offset.x;
            }
            if (offset.y != 0.f && !lockCameraY && !lockPlayerY) {
                if (m_actionType1 == 0) {
                    m_actionType1 = 2;
                    m_actionValue1 = offset.y;
                }
                else {
                    m_actionType2 = 2;
                    m_actionValue2 = offset.y;
                }
            }
        }
        else {
            m_finished = true;
            m_finishRelated = true;
        }
    }
    void runPlayerFollowCommand(double delay, double speed, int offset, double maxSpeed, double duration) = win inline {
        m_commandType = 3;
        m_followYDelay = delay;
        m_followYSpeed = std::clamp(speed, 0.0, 500.0);
        m_followYOffset = offset;
        m_followYMaxSpeed = maxSpeed;
        m_duration = duration;
        if (delay <= 0.0) {
            m_finished = true;
            m_finishRelated = true;
        }
    }
    void runRotateCommand(double offset, double duration, int easingType, double easingRate, bool lockRotation, int targetType) = win inline {
        m_commandType = 1;
        m_rotationOffset = offset;
        m_duration = duration;
        m_easingType = (EasingType)easingType;
        m_easingRate = easingRate;
        m_lockObjectRotation = lockRotation;
        m_targetPlayer = targetType;
        if (offset == 0.0) {
            m_finished = true;
            m_finishRelated = true;
        }
        else {
            m_actionType1 = 3;
            m_actionValue1 = offset;
        }
    }
    void runTransformCommand(double duration, int easingType, double easingRate) = win inline {
        m_commandType = 4;
        m_duration = duration;
        m_easingType = (EasingType)easingType;
        m_easingRate = easingRate;
        m_actionType1 = 4;
        m_actionValue1 = 1.0;
    }
    void step(float dt) = win 0x257710;
    void stepTransformCommand(float dt, bool intermediate, bool skipStep) = win inline {
        if (!m_finishRelated) {
            if (!skipStep) this->step(dt);
            m_someInterpValue1RelatedZero = m_someInterpValue1RelatedOne;
            m_someInterpValue1RelatedOne += m_currentRotateOrTransformDelta;
            m_someInterpValue2RelatedZero = m_someInterpValue2RelatedOne;
            if (!intermediate) m_someInterpValue2RelatedOne = m_someInterpValue1RelatedOne;
        }
        m_someInterpValue1RelatedZero = m_someInterpValue1RelatedOne;
        m_someInterpValue2RelatedZero = m_someInterpValue2RelatedOne;
        m_someInterpValue2RelatedOne = m_someInterpValue1RelatedOne;
    }
    void updateAction(int type, float value) = win 0x2577e0;
    void updateEffectAction(float value, int type) = win inline {
        switch (type) {
            case 1:
                if (!m_lockedInX) {
                    m_currentXOffset = value;
                    m_deltaX += value;
                    m_deltaX_3 += value;
                }
                break;
            case 2:
                if (!m_lockedInY) {
                    m_currentYOffset = value;
                    m_deltaY += value;
                    m_deltaY_3 += value;
                }
                break;
            case 3:
            case 4:
                m_currentRotateOrTransformDelta += value - m_currentRotateOrTransformValue;
                m_currentRotateOrTransformValue = value;
                break;
        }
    }

    int m_groupCommandUniqueID;
    cocos2d::CCPoint m_moveOffset;
    EasingType m_easingType;
    double m_easingRate;
    double m_duration;
    double m_deltaTime;
    int m_targetGroupID;
    int m_centerGroupID;
    double m_currentXOffset;
    double m_currentYOffset;
    double m_deltaX;
    double m_deltaY;
    double m_oldDeltaX;
    double m_oldDeltaY;
    double m_lockedCurrentXOffset;
    double m_lockedCurrentYOffset;
    bool m_finished;
    bool m_disabled;
    bool m_finishRelated;
    bool m_lockToPlayerX;
    bool m_lockToPlayerY;
    bool m_lockToCameraX;
    bool m_lockToCameraY;
    bool m_lockedInX;
    bool m_lockedInY;
    double m_moveModX;
    double m_moveModY;
    double m_currentRotateOrTransformValue;
    double m_currentRotateOrTransformDelta;
    double m_someInterpValue1RelatedOne;
    double m_someInterpValue2RelatedOne;
    double m_rotationOffset;
    bool m_lockObjectRotation;
    int m_targetPlayer;
    double m_followXMod;
    double m_followYMod;
    int m_commandType;
    double m_someInterpValue1;
    double m_someInterpValue2;
    double m_keyframeRelated;
    double m_targetScaleX;
    double m_targetScaleY;
    double m_transformTriggerProperty450;
    double m_transformTriggerProperty451;
    double m_someInterpValue1RelatedZero;
    double m_someInterpValue2RelatedZero;
    bool m_onlyMove;
    bool m_transformRelatedFalse;
    bool m_relativeRotation;
    double m_someInterpValue1Related;
    double m_someInterpValue2Related;
    double m_followYSpeed;
    double m_followYDelay;
    int m_followYOffset;
    double m_followYMaxSpeed;
    int m_triggerUniqueID;
    int m_controlID;
    double m_deltaX_3;
    double m_deltaY_3;
    double m_oldDeltaX_3;
    double m_oldDeltaY_3;
    double m_Delta_3_Related;
    double m_unkDoubleMaybeUnused;
    int m_actionType1;
    int m_actionType2;
    double m_actionValue1;
    double m_actionValue2;
    bool m_someInterpValue1RelatedFalse;
    float m_deltaTimeInFloat;
    bool m_alreadyUpdated;
    bool m_doUpdate;
    gd::vector<KeyframeObject> m_keyframes;
    cocos2d::CCPoint m_splineRelated;
    GameObject* m_gameObject;
    float m_gameObjectRotation;
    gd::vector<int> m_remapKeys;
    bool m_someInterpValue2RelatedTrue;
    int m_unkInt204; // formerly m_unkFloat204
}

[[link(android)]]
class HardStreak : cocos2d::CCDrawNode {
    // virtual ~HardStreak();

    static HardStreak* create() = win 0x2b8ba0;

    virtual bool init() = win 0x2b8c60;

    void addPoint(cocos2d::CCPoint point) = win 0x2b9660;
    void clearAboveXPos(float x) = win inline {
        while (m_pointArray->count() > 1) {
            auto pointNode = static_cast<PointNode*>(m_pointArray->objectAtIndex(1));
            if (pointNode->m_point.x > x) m_pointArray->removeObjectAtIndex(0);
            else break;
        }
    }
    void clearBehindXPos(float x) = win inline {
        while (m_pointArray->count() > 1) {
            auto pointNode = static_cast<PointNode*>(m_pointArray->objectAtIndex(1));
            if (pointNode->m_point.x < x) m_pointArray->removeObjectAtIndex(0);
            else break;
        }
    }
    HardStreak* createDuplicate() = win inline {
        auto ret = HardStreak::create();
        ret->setBlendFunc(this->getBlendFunc());
        ret->m_currentPoint = m_currentPoint;
        ret->m_isSolid = m_isSolid;
        ret->m_waveSize = m_waveSize;
        ret->m_isSolid = m_isSolid;
        ret->m_isFlipped = m_isFlipped;
        ret->m_pulseSize = m_pulseSize;
        ret->setOpacity(this->getOpacity());
        ret->setColor(this->getColor());

        CCObject* obj;
        CCARRAY_FOREACH(m_pointArray, obj){
            auto nodePoint = static_cast<PointNode*>(obj);
            ret->addPoint(nodePoint->m_point);
        }

        return ret;
    }
    void firstSetup() = win inline {
        this->addPoint({ 0.f, 0.f });
        m_currentPoint.x = 10.f;
        m_currentPoint.y = 10.f;
        this->updateStroke(0.f);
        this->visit();
        this->reset();
    }
    double normalizeAngle(double angle) = win inline, ios inline {
        if (angle > 360.0) return angle - 360.0;
        if (angle < 0.0) return angle + 360.0;
        return angle;
    }
    cocos2d::CCPoint quadCornerOffset(cocos2d::CCPoint start, cocos2d::CCPoint end, float width) = win inline {
        if (width < 1.f) return { 0.f, 0.f };
        float angle = this->normalizeAngle(atan2f(end.y - start.y, end.x - start.x) * 180.f / M_PI + 90.f) * M_PI / 180.f;
        return { cosf(angle) * width * .5f, sinf(angle) * width * .5f };
    }
    void reset() = win inline {
        this->clear();
        m_pointArray->removeAllObjects();
    }
    void resumeStroke() = win inline {
        this->m_drawStreak = true;
        updateStroke(0.f);
    }
    void scheduleAutoUpdate() = win inline {
        this->schedule(schedule_selector(HardStreak::updateStroke));
    }
    void stopStroke() = win 0x2b8d10;
    callback void updateStroke(float dt) = win 0x2b8d50;

    cocos2d::CCArray* m_pointArray;
    cocos2d::CCPoint m_currentPoint;
    float m_waveSize;
    float m_pulseSize;
    bool m_isSolid;
    bool m_isFlipped;
    bool m_drawStreak;
}

[[link(android)]]
class HSVLiveOverlay : FLAlertLayer, HSVWidgetDelegate {
    HSVLiveOverlay() {
        m_object = nullptr;
        m_objects = nullptr;
        m_controls = nullptr;
        m_unkArray = nullptr;
        m_delegate = nullptr;
        m_activeTab = -1;
        m_widget = nullptr;
        m_unkBool1 = false;
        m_unkBool2 = false;
        m_unkBool3 = false;
    }
    ~HSVLiveOverlay() = win inline {
        CCNode::removeAllChildrenWithCleanup(true);
        CC_SAFE_RELEASE(m_unkArray);
        CC_SAFE_RELEASE(m_controls);
        CC_SAFE_RELEASE(m_object);
        CC_SAFE_RELEASE(m_objects);
    }

    static HSVLiveOverlay* create(GameObject* object, cocos2d::CCArray* objects) = win inline {
        auto ret = new HSVLiveOverlay();
        if (ret->init(object, objects)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyBackClicked();
    virtual void show() = win 0x8bb10;
    virtual void hsvChanged(ConfigureHSVWidget* widget) = win 0x2ba130;

    void closeColorSelect(cocos2d::CCObject* sender);
    void createHSVWidget(int tab) = win 0x2b9f40;
    void determineStartValues() = win 0x2b9cc0;
    bool init(GameObject* object, cocos2d::CCArray* objects) = win 0x1f8530;
    void onSelectTab(cocos2d::CCObject* sender) = win 0x2b9f10;
    void toggleControls(bool visible) = win inline, ios inline {
        for (int i = 0; i < m_controls->count(); i++) {
            static_cast<cocos2d::CCNode*>(m_controls->objectAtIndex(i))->setVisible(visible);
        }
    }

    GameObject* m_object;
    cocos2d::CCArray* m_objects;
    cocos2d::CCArray* m_controls;
    cocos2d::CCArray* m_unkArray;
    ColorSelectDelegate* m_delegate;
    int m_activeTab;
    ConfigureHSVWidget* m_widget;
    bool m_unkBool1;
    bool m_unkBool2;
    bool m_unkBool3;
}

[[link(android)]]
class HSVWidgetDelegate {
    virtual void hsvPopupClosed(HSVWidgetPopup* popup, cocos2d::ccHSVValue value) {}
    virtual void hsvChanged(ConfigureHSVWidget* widget) {}
}

[[link(android)]]
class HSVWidgetPopup : FLAlertLayer {
    // virtual ~HSVWidgetPopup();

    static HSVWidgetPopup* create(cocos2d::ccHSVValue hsv, HSVWidgetDelegate* delegate, gd::string title) = win 0x964f0;

    virtual void keyBackClicked();

    bool init(cocos2d::ccHSVValue hsv, HSVWidgetDelegate* delegate, gd::string title) = win 0x96610;
    void onClose(cocos2d::CCObject* sender) = win 0x96940;

    ConfigureHSVWidget* m_widget;
    HSVWidgetDelegate* m_delegate;
}

[[link(android)]]
class InfoAlertButton : CCMenuItemSpriteExtra {
    // virtual ~InfoAlertButton();

    static InfoAlertButton* create(gd::string title, gd::string desc, float spriteScale) = win 0x2ba2b0;

    virtual void activate() = win 0x2ba4b0;

    bool init(gd::string title, gd::string desc, float spriteScale) = win inline {
        auto infoSprite = cocos2d::CCSprite::createWithSpriteFrameName("GJ_infoBtn_001.png");
        infoSprite->setScale(spriteScale);
        if (!CCMenuItemSpriteExtra::init(infoSprite, nullptr, nullptr, nullptr)) return false;
        this->setSizeMult(1.5f);
        m_title = title;
        m_description = desc;
        return true;
    }

    gd::string m_title;
    gd::string m_description;
    float m_textScale;
    bool m_scroll;
}

[[link(android)]]
class InfoLayer : FLAlertLayer, LevelCommentDelegate, CommentUploadDelegate, FLAlertLayerProtocol {
    // virtual ~InfoLayer();

    static InfoLayer* create(GJGameLevel* level, GJUserScore* score, GJLevelList* list) = win 0x2ba730;

    virtual void registerWithTouchDispatcher() = win 0x42660;
    virtual void keyBackClicked();
    virtual void show();
    virtual void loadCommentsFinished(cocos2d::CCArray* comments, char const* key) = win 0x2be9b0;
    virtual void loadCommentsFailed(char const* key) = win 0x2bea20;
    virtual void setupPageInfo(gd::string info, char const* key) = win 0x2bea70;
    virtual void commentUploadFinished(int parentID) = win 0x2bedb0;
    virtual void commentUploadFailed(int parentID, CommentError errorType) = win 0x2bee80;
    virtual void updateUserScoreFinished() = win 0x2bec60;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x2bd210;

    void confirmReport(cocos2d::CCObject* sender) = win 0x2bccb0;
    int getAccountID() = win inline, ios inline {
        if (m_levelList) return m_levelList->m_accountID;
        if (m_level) return m_level->m_accountID.value();
        return 0;
    }
    int getID() = win inline, ios inline {
        if(m_score) return m_score->m_userID;
        if(m_levelList) return - m_levelList->m_listID;
        if(m_level) return m_level->m_levelID;
        return 0;
    }
    int getRealID() = win inline, ios inline {
        if (m_score) return m_score->m_userID;
        if (m_levelList) return m_levelList->m_listID;
        if (m_level) return m_level->m_levelID.value();
        return 0;
    }
    CCMenuItemSpriteExtra* getSpriteButton(char const* frame, cocos2d::SEL_MenuHandler selector, cocos2d::CCMenu* menu, float scale, cocos2d::CCPoint position) = win 0x2bc810;
    bool init(GJGameLevel* level, GJUserScore* score, GJLevelList* list) = win 0x2ba8d0;
    bool isCorrect(char const* key);
    void loadPage(int page, bool noSetup) = win 0x2be1b0;
    void onClose(cocos2d::CCObject* sender) = win 0x2bdff0;
    void onComment(cocos2d::CCObject* sender) = win 0x2bd450;
    void onCopyLevelID(cocos2d::CCObject* sender) = win 0x2bd0d0;
    void onGetComments(cocos2d::CCObject* sender) = win 0x2bda00;
    void onLevelInfo(cocos2d::CCObject* sender) = win 0x2bda10;
    void onMore(cocos2d::CCObject* sender) = win 0x2bd330;
    void onNextPage(cocos2d::CCObject* sender) = win 0x2bed90;
    void onOriginal(cocos2d::CCObject* sender) = win 0x2bd390;
    void onPrevPage(cocos2d::CCObject* sender) = win 0x2beda0;
    void onRefreshComments(cocos2d::CCObject* sender);
    void onSimilar(cocos2d::CCObject* sender) = win inline, ios inline {
        auto searchObject = GJSearchObject::create(SearchType::Similar, cocos2d::CCString::createWithFormat("%i", m_level->m_levelID.value())->getCString());
        cocos2d::CCDirector::sharedDirector()->replaceScene(cocos2d::CCTransitionFade::create(.5f, LevelBrowserLayer::scene(searchObject)));
        m_buttonMenu->setEnabled(false);
    }
    void reloadWindow() = win 0x2bf120;
    void setupCommentsBrowser(cocos2d::CCArray* comments) = win 0x2be720;
    void setupLevelInfo() = win 0x2bc950;
    void toggleCommentMode(cocos2d::CCObject* sender) = win 0x2bf340;
    void toggleExtendedMode(cocos2d::CCObject* sender);
    void toggleSmallCommentMode(cocos2d::CCObject* sender) = win 0x2bf030;
    void updateCommentModeButtons() = win 0x2bf400;
    void updateLevelsLabel() = win inline {
        auto end = m_pageEndIdx + m_pageStartIdx;
        auto count = m_itemCount;
        if (end > count) end = count;
        m_pageLabel->setString(cocos2d::CCString::createWithFormat("%i to %i of %i", m_pageStartIdx + 1, end, count)->getCString());
    }

    GJGameLevel* m_level;
    GJUserScore* m_score;
    GJLevelList* m_levelList;
    gd::string m_commentKey;
    LoadingCircle* m_loadingCircle;
    cocos2d::CCLabelBMFont* m_pageLabel;
    cocos2d::CCLabelBMFont* m_noComments;
    GJCommentListLayer* m_list;
    CCMenuItemSpriteExtra* m_rightArrow;
    CCMenuItemSpriteExtra* m_leftArrow;
    CCMenuItemSpriteExtra* m_likeBtn;
    CCMenuItemSpriteExtra* m_timeBtn;
    CCMenuItemSpriteExtra* m_reportBtn;
    CCMenuItemSpriteExtra* m_commentsBtn;
    CCMenuItemSpriteExtra* m_refreshCommentsBtn;
    int m_itemCount;
    int m_pageStartIdx;
    int m_pageEndIdx;
    int m_page;
    bool m_canUpdateUserScore;
    CommentKeyType m_mode;
}

[[link(android)]]
class InheritanceNode : cocos2d::CCObject {
    // virtual ~InheritanceNode();
    InheritanceNode() {
        m_colorID = 0;
        m_inheritanceNode = nullptr;
        m_colorAction = nullptr;
        m_unk050 = false;
        m_unk051 = false;
    }

    static InheritanceNode* create(int colorID, InheritanceNode* node) = win inline {
        auto ret = new InheritanceNode();
        if (ret->init(colorID, node)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init(int colorID, InheritanceNode* node) = win inline, ios inline {
        m_colorID = colorID;
        m_inheritanceNode = node;
        return true;
    }

    int m_colorID;
    InheritanceNode* m_inheritanceNode;
    ColorAction* m_colorAction;
    bool m_unk050;
    bool m_unk051;
}

[[link(android)]]
class ItemInfoPopup : FLAlertLayer {
    // virtual ~ItemInfoPopup();

    static ItemInfoPopup* create(int id, UnlockType type) = win 0x27b5c0;
    static gd::string nameForUnlockType(int id, UnlockType type) = win 0x27d680;

    virtual void keyBackClicked() = win 0x846c0;

    bool init(int id, UnlockType type) = win 0x27b6b0;
    bool isUnlockedByDefault(int id, UnlockType type) = win inline, ios inline {
        if (type == UnlockType::Cube) return id < 5;
        if (type == UnlockType::Col1 || type == UnlockType::Col2) return id < 4;
        return id < 2;
    }
    void onClose(cocos2d::CCObject* sender) = win 0x84690;
    void onCredit(cocos2d::CCObject* sender) = win 0x27d650;

    int m_itemID;
    UnlockType m_unlockType;
    int m_accountID;
}

[[link(android)]]
class ItemTriggerGameObject : EffectGameObject {
    // virtual ~ItemTriggerGameObject();
    ItemTriggerGameObject() {
        m_item1Mode = 0;
        m_item2Mode = 0;
        m_targetItemMode = 1;
        m_mod1 = 1.0f;
        m_mod2 = 1.0f;
        m_resultType1 = 0;
        m_resultType2 = 1;
        m_resultType3 = 3;
        m_tolerance = 0.0f;
        m_roundType1 = 0;
        m_roundType2 = 0;
        m_signType1 = 0;
        m_signType2 = 0;
        m_persistent = false;
        m_targetAll = false;
        m_reset = false;
        m_timer = false;
    }

    static ItemTriggerGameObject* create(char const* frame) = win inline {
        auto ret = new ItemTriggerGameObject();
        if (ret->init(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void customSetup();
    virtual void triggerObject(GJBaseGameLayer* layer, int uniqueID, gd::vector<int> const* remapKeys) = win 0x4bf980;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4c0a60;
    virtual gd::string getSaveString(GJBaseGameLayer* layer);

    bool init(char const* frame) = win inline, ios inline {
        return EffectGameObject::init(frame);
    }

    // property 476
    int m_item1Mode;
    // property 477
    int m_item2Mode;
    // property 478
    int m_targetItemMode;
    // property 479
    float m_mod1;
    // property 484
    float m_mod2;
    // property 480
    int m_resultType1;
    // property 481
    int m_resultType2;
    // property 482
    int m_resultType3;
    // property 483
    float m_tolerance;
    // property 485
    int m_roundType1;
    // property 486
    int m_roundType2;
    // property 578
    int m_signType1;
    // property 579
    int m_signType2;
    // property 491
    bool m_persistent;
    // property 492
    bool m_targetAll;
    // property 493
    bool m_reset;
    // property 494
    bool m_timer;
}

[[link(android)]]
class KeybindingsLayer : FLAlertLayer {
    // virtual ~KeybindingsLayer();

    static KeybindingsLayer* create();

    virtual bool init() = win 0x2bf7f0;
    virtual void keyBackClicked() = win 0x846c0;

    cocos2d::CCLabelBMFont* addKeyPair(char const* action, char const* key) = win 0x2c0100;
    int countForPage(int page);
    void goToPage(int page);
    void incrementCountForPage(int page) = win inline {
        m_values->setObject(cocos2d::CCString::createWithFormat("%i", this->countForPage(page) + 1), this->pageKey(page));
    }
    const char* infoKey(int index) = win inline {
        return cocos2d::CCString::createWithFormat("info_%i", index)->getCString();
    }
    cocos2d::CCLayer* layerForPage(int page);
    const char* layerKey(int page) = win inline {
        return cocos2d::CCString::createWithFormat("layer_%i", page)->getCString();
    }
    cocos2d::CCPoint nextPosition(int page) = win inline {
        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        return winSize * .5f + cocos2d::CCPoint { 0.f, 100.f - (this->countForPage(page) * 30 + 30) };
    }
    const char* objectKey(int page) = win inline {
        return cocos2d::CCString::createWithFormat("object_%i", page)->getCString();
    }
    cocos2d::CCArray* objectsForPage(int page) = win inline {
        auto key = this->objectKey(page);
        auto objects = static_cast<cocos2d::CCArray*>(m_values->objectForKey(key));
        if (!objects) {
            objects = cocos2d::CCArray::create();
            m_values->setObject(objects, key);
        }
        return objects;
    }
    void onClose(cocos2d::CCObject* sender) = win 0x84690;
    void onInfo(cocos2d::CCObject* sender) = win inline {
        FLAlertLayer::create(
            nullptr,
            "Info",
            m_values->valueForKey(this->infoKey(sender->getTag()))->getCString(),
            "OK",
            nullptr,
            300.f
        )->show();
    }
    void onNextPage(cocos2d::CCObject* sender);
    void onPrevPage(cocos2d::CCObject* sender);
    void onToggle(cocos2d::CCObject* sender) = win inline {
        if (auto variable = static_cast<cocos2d::CCString*>(m_variables->objectForKey(sender->getTag()))) {
            GameManager::sharedState()->toggleGameVariable(variable->getCString());
        }
    }
    const char* pageKey(int page) = win inline {
        return cocos2d::CCString::createWithFormat("page_%i", page)->getCString();
    }

    int m_page;
    int m_keyCount;
    int m_maxPage;
    cocos2d::CCDictionary* m_values;
    cocos2d::CCDictionary* m_variables;
    CCMenuItemSpriteExtra* m_prevButton;
    CCMenuItemSpriteExtra* m_nextButton;
}

[[link(android)]]
class KeybindingsManager : cocos2d::CCNode {
    // virtual ~KeybindingsManager();

    static KeybindingsManager* sharedState();

    virtual bool init() = win inline { return true; }

    bool commandForKey(cocos2d::enumKeyCodes key, GJKeyGroup group, bool control, bool alt, bool shift);
    bool commandForKeyMods(cocos2d::enumKeyCodes key, GJKeyGroup group);
    bool commandForKeyNoMods(cocos2d::enumKeyCodes key, GJKeyGroup group);
    cocos2d::CCDictionary* commandToKeyForGroup(GJKeyGroup group);
    void dataLoaded(DS_Dictionary* dict) = win inline {
        auto keyToCommandDict = dict->getDictForKey("KBM_001", false);
        if (m_keyToCommandDict != keyToCommandDict) {
            CC_SAFE_RETAIN(keyToCommandDict);
            CC_SAFE_RELEASE(m_keyToCommandDict);
            m_keyToCommandDict = keyToCommandDict;
        }
        auto commandToKeyDict = dict->getDictForKey("KBM_002", false);
        if (m_commandToKeyDict != commandToKeyDict) {
            CC_SAFE_RETAIN(commandToKeyDict);
            CC_SAFE_RELEASE(m_commandToKeyDict);
            m_commandToKeyDict = commandToKeyDict;
        }
    }
    void encodeDataTo(DS_Dictionary* dict) = win inline {
        dict->setObjectForKey("KBM_001", m_keyToCommandDict);
        dict->setObjectForKey("KBM_002", m_commandToKeyDict);
    }
    void firstSetup() = win inline {
        auto keyToCommandDict = cocos2d::CCDictionary::create();
        if (m_keyToCommandDict != keyToCommandDict) {
            CC_SAFE_RETAIN(keyToCommandDict);
            CC_SAFE_RELEASE(m_keyToCommandDict);
            m_keyToCommandDict = keyToCommandDict;
        }
        auto commandToKeyDict = cocos2d::CCDictionary::create();
        if (m_commandToKeyDict != commandToKeyDict) {
            CC_SAFE_RETAIN(commandToKeyDict);
            CC_SAFE_RELEASE(m_commandToKeyDict);
            m_commandToKeyDict = commandToKeyDict;
        }
    }
    GJKeyGroup groupForCommand(GJKeyCommand command);
    cocos2d::enumKeyCodes keyForCommand(GJKeyCommand command);
    cocos2d::CCDictionary* keyToCommandForGroup(GJKeyGroup group);

    cocos2d::CCDictionary* m_keyToCommandDict;
    cocos2d::CCDictionary* m_commandToKeyDict;
}

[[link(android)]]
class KeyframeAnimTriggerObject : EffectGameObject {
    // virtual ~KeyframeAnimTriggerObject();
    KeyframeAnimTriggerObject() {
        m_timeMod = 1.0f;
        m_positionXMod = 1.0f;
        m_positionYMod = 1.0f;
        m_rotationMod = 1.0f;
        m_scaleXMod = 1.0f;
        m_scaleYMod = 1.0f;
    }

    static KeyframeAnimTriggerObject* create() = win inline {
        auto ret = new KeyframeAnimTriggerObject();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init();
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists);
    virtual gd::string getSaveString(GJBaseGameLayer* layer);

    // property 520
    float m_timeMod;
    // property 521
    float m_positionXMod;
    // property 545
    float m_positionYMod;
    // property 522
    float m_rotationMod;
    // property 523
    float m_scaleXMod;
    // property 546
    float m_scaleYMod;
}

[[link(android)]]
class KeyframeGameObject : EffectGameObject {
    KeyframeGameObject() {
        m_shadowObjects = nullptr;
        m_previewSprite = nullptr;
        m_keyframeGroup = 0;
        m_keyframeIndex = 0;
        m_referenceOnly = false;
        m_proximity = false;
        m_curve = false;
        m_closeLoop = false;
        m_timeMode = 0;
        m_unk760 = 0.0f;
        m_spawnDelay = 0.0f;
        m_previewArt = false;
        m_keyframeActive = false;
        m_autoLayer = false;
        m_direction = 0;
        m_revolutions = 0;
        m_lineOpacity = 1.0f;
    }
    ~KeyframeGameObject() = win inline {
        CC_SAFE_RELEASE(m_shadowObjects);
    }

    static KeyframeGameObject* create() = win inline {
        auto ret = new KeyframeGameObject();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x4b50c0;
    virtual void setOpacity(unsigned char opacity) = win 0x4b5380;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4b5440;
    virtual gd::string getSaveString(GJBaseGameLayer* layer);

    void updateShadowObjects(GJBaseGameLayer* layer, EditorUI* ui) = win 0x4b5150;

    cocos2d::CCArray* m_shadowObjects;
    cocos2d::CCSprite* m_previewSprite;
    // property 373
    int m_keyframeGroup;
    // property 374
    int m_keyframeIndex;
    // property 375
    bool m_referenceOnly;
    // property 377
    bool m_proximity;
    // property 378
    bool m_curve;
    // property 376
    bool m_closeLoop;
    // property 379
    int m_timeMode;
    float m_unk760;
    // property 557
    float m_spawnDelay;
    // property 380
    bool m_previewArt;
    bool m_keyframeActive;
    // property 459
    bool m_autoLayer;
    // property 536
    int m_direction;
    // property 537
    int m_revolutions;
    // property 524
    float m_lineOpacity;
}

[[link(android), depends(tk_spline)]]
class KeyframeObject {
    // KeyframeObject();
    // KeyframeObject(KeyframeObject const&);

    void setupSpline(gd::vector<KeyframeObject*>& objects) = win 0x2c0c60;

    double m_unk000;
    int m_unk008;
    float m_unk00c;
    bool m_unk010;
    int m_unk014;
    float m_unk018;
    bool m_unk01c;
    bool m_unk01d;
    bool m_unk01e;
    tk_spline m_spline1;
    tk_spline m_spline2;
    double m_unk170;
    double m_unk178;
    int m_unk180;
    int m_unk184;
    cocos2d::CCPoint m_unk188;
    cocos2d::CCPoint m_unk190;
    double m_unk198;
    double m_unk1a0;
    double m_unk1a8;
    double m_unk1b0;
    float m_unk1b8;
}

[[link(android)]]
class LabelGameObject : EffectGameObject {
    // virtual ~LabelGameObject();
    LabelGameObject() {
        m_label = nullptr;
        m_labelDirty = false;
        m_labelColorLocked = false;
        m_alignment = 0;
        m_showSecondsOnly = false;
        m_shownSpecial = 0;
        m_isTimeCounter = false;
        m_kerning = 0;
        m_updateLabel = false;
    }

    static LabelGameObject* create() = win inline {
        auto ret = new LabelGameObject();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x4b30e0;
    virtual void setOpacity(unsigned char opacity);
    virtual void setupCustomSprites(gd::string frameName);
    virtual void addMainSpriteToParent(bool reorder);
    virtual void resetObject();
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4b3770;
    virtual gd::string getSaveString(GJBaseGameLayer* layer);
    virtual void setObjectColor(cocos2d::ccColor3B const& color);
    virtual void updateTextKerning(int kerning) = win 0x4b3500;
    virtual int getTextKerning();

    void createLabel(gd::string text) = win 0x4b31c0;
    void queueUpdateLabel(gd::string text) = win inline {
        if (!m_updateLabel) {
            m_labelString = text;
            m_labelDirty = true;
        }
    }
    void removeLabel() = win 0x4b3360;
    void unlockLabelColor() = win inline, ios inline {
        m_labelColorLocked = false;
    }
    void updateLabel(float value) = win inline, ios inline {
        this->updateLabel(GameToolbox::intToString(value));
    }
    void updateLabel(gd::string text) = win 0x4b36e0;
    void updateLabelAlign(int alignment) = win 0x4b3480;
    void updateLabelIfDirty() = win inline {
        if (m_labelDirty) updateLabel(m_labelString);
    }
    void updatePreviewLabel() = win 0x4b3520;

    cocos2d::CCLabelBMFont* m_label;
    bool m_labelDirty;
    gd::string m_labelString;
    bool m_labelColorLocked;
    // property 391
    int m_alignment;
    // property 389
    bool m_showSecondsOnly;
    // property 390
    int m_shownSpecial;
    // property 466
    bool m_isTimeCounter;
    // property 488
    int m_kerning;
    bool m_updateLabel;
}

[[link(android)]]
class LeaderboardManagerDelegate {
    virtual void updateUserScoreFinished() {}
    virtual void updateUserScoreFailed() {}
    virtual void loadLeaderboardFinished(cocos2d::CCArray* scores, char const* key) {}
    virtual void loadLeaderboardFailed(char const* key) {}
}

[[link(android)]]
class LeaderboardsLayer : cocos2d::CCLayer, LeaderboardManagerDelegate, FLAlertLayerProtocol {
    LeaderboardsLayer() {
        m_list = nullptr;
        m_userScores = nullptr;
        m_state = LeaderboardState::Default;
        m_topBtn = nullptr;
        m_globalBtn = nullptr;
        m_creatorsBtn = nullptr;
        m_friendsBtn = nullptr;
        m_circle = nullptr;
        m_noInternet = nullptr;
    }
    ~LeaderboardsLayer() = win inline {
        auto glm = GameLevelManager::sharedState();
        if (glm->m_leaderboardManagerDelegate == this) glm->m_leaderboardManagerDelegate = nullptr;
    }

    static LeaderboardsLayer* create(LeaderboardState state) = win inline {
        auto ret = new LeaderboardsLayer();
        if (ret->init(state)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static cocos2d::CCScene* scene(LeaderboardState state) = win inline {
        auto scene = cocos2d::CCScene::create();
        AppDelegate::get()->m_runningScene = scene;
        auto layer = LeaderboardsLayer::create(state);
        scene->addChild(layer);
        return scene;
    }

    virtual void keyBackClicked();
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2);
    virtual void updateUserScoreFinished();
    virtual void updateUserScoreFailed();
    virtual void loadLeaderboardFinished(cocos2d::CCArray* scores, char const* key);
    virtual void loadLeaderboardFailed(char const* key);

    bool init(LeaderboardState state);
    bool isCorrect(char const* key);
    void onBack(cocos2d::CCObject* sender) = win 0x2c3f30;
    void onCreators(cocos2d::CCObject* sender);
    void onGlobal(cocos2d::CCObject* sender);
    void onInfo(cocos2d::CCObject* sender) = win 0x2c3a00;
    void onTop(cocos2d::CCObject* sender);
    void onWeek(cocos2d::CCObject* sender) = win 0x2c3060;
    void refreshTabs() = win 0x2c2f60;
    void selectLeaderboard(LeaderboardState state);
    void setupLevelBrowser(cocos2d::CCArray* scores) = win 0x2c2e00;
    void setupTabs();
    void toggleTabButtons();

    GJListLayer* m_list;
    cocos2d::CCArray* m_userScores;
    LeaderboardState m_state;
    CCMenuItemToggler* m_topBtn;
    CCMenuItemToggler* m_globalBtn;
    CCMenuItemToggler* m_creatorsBtn;
    CCMenuItemToggler* m_friendsBtn;
    LoadingCircle* m_circle;
    TextArea* m_noInternet;
    cocos2d::CCArray* m_tabs;
}

[[link(android)]]
class LevelAreaInnerLayer : cocos2d::CCLayer, DialogDelegate {
    // virtual ~LevelAreaInnerLayer();
    LevelAreaInnerLayer() {
        m_nextFloorButton = nullptr;
        m_enteringLevel = false;
        m_levelID = 0;
        m_exiting = false;
    }

    static LevelAreaInnerLayer* create(bool returning) = win inline {
        auto ret = new LevelAreaInnerLayer();
        if (ret->init(returning)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static cocos2d::CCScene* scene(bool returning) = win 0x2c6230;

    virtual void keyBackClicked() = win 0x2c85b0;
    virtual void dialogClosed(DialogLayer* layer) = win 0x2c7a00;
    virtual void onExit() = win 0x2c8560;

    bool init(bool returning) = win 0x2c6340;
    void onBack(cocos2d::CCObject* sender) = win 0x2c8500;
    void onDoor(cocos2d::CCObject* sender) = win 0x2c8030;
    void onInfo(cocos2d::CCObject* sender);
    void onNextFloor(cocos2d::CCObject* sender) = win 0x2c7320;
    void onOnlineVault(cocos2d::CCObject* sender) = win 0x2c8320;
    bool playStep1() = win 0x2c81f0;
    void showFloor1CompleteDialog() = win 0x2c7420;
    void tryResumeTowerMusic() = win 0x2c7f90;
    void tryShowAd() = win inline, ios inline {
        GameManager::sharedState()->tryShowInterstitial(120, 140, 0);
    }

    CCMenuItemSpriteExtra* m_nextFloorButton;
    bool m_enteringLevel;
    int m_levelID;
    bool m_exiting;
}

[[link(android)]]
class LevelAreaLayer : cocos2d::CCLayer, DialogDelegate {
    LevelAreaLayer() {
        m_towerSprite = nullptr;
        m_godRays = nullptr;
        m_enteringTower = false;
        m_exiting = false;
    }
    ~LevelAreaLayer() = win inline {
        CC_SAFE_RELEASE(m_godRays);
    }

    static void addTorch(cocos2d::CCNode* parent, cocos2d::CCPoint position, int fireType, float scale, int zOrder, bool noTorch, int colorType, cocos2d::CCArray* nodes) = win 0x2c56f0;
    static LevelAreaLayer* create() = win inline {
        auto ret = new LevelAreaLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static cocos2d::CCScene* scene() = win 0x2c4120;

    virtual bool init() = win 0x2c4230;
    virtual void keyBackClicked() = win 0x2c6220;
    virtual void dialogClosed(DialogLayer* layer);
    virtual void onExit() = win 0x2c61d0;

    void addGodRay(float startOpacity, float midOpacity, float endOpacity, float fadeDuration, float scaleY, cocos2d::CCPoint position) = win 0x2c5d80;
    void fadeInsideTower() = win 0x2c5590;
    void onBack(cocos2d::CCObject* sender) = win 0x2c6120;
    void onClickDoor(cocos2d::CCObject* sender) = win 0x2c5420;
    bool onEnterTower() = win 0x2c5640;
    void showDialog() = win 0x2c50e0;

    cocos2d::CCSprite* m_towerSprite;
    cocos2d::CCArray* m_godRays;
    bool m_enteringTower;
    bool m_exiting;
}

[[link(android)]]
class LevelBrowserLayer : cocos2d::CCLayerColor, LevelManagerDelegate, FLAlertLayerProtocol, SetIDPopupDelegate, SetTextPopupDelegate, TableViewCellDelegate, ShareCommentDelegate {
    LevelBrowserLayer() = win 0x2c8630 {
        m_unk = false;
        m_allSelected = false;
        m_noInternet = nullptr;
        m_list = nullptr;
        m_rightArrow = nullptr;
        m_leftArrow = nullptr;
        m_lastBtn = nullptr;
        m_cancelSearchBtn = nullptr;
        m_refreshBtn = nullptr;
        m_levels = nullptr;
        m_searchObject = nullptr;
        m_countText = nullptr;
        m_pageText = nullptr;
        m_pageBtn = nullptr;
        m_folderText = nullptr;
        m_folderBtn = nullptr;
        m_allObjectsToggler = nullptr;
        m_itemCount = 0;
        m_pageStartIdx = 0;
        m_pageEndIdx = 0;
        m_circle = nullptr;
        m_lastPage = 0;
        m_isOverlay = false;
        m_scene = nullptr;
        m_zOffset = 0;
        m_unk2 = false;
        m_listHeight = 0;
        m_unkFloat = .0f;
        m_unkFloat2 = .0f;
        m_delegate = nullptr;
        m_cached = false;
    }
    ~LevelBrowserLayer() = win 0x2c8820;

    static LevelBrowserLayer* create(GJSearchObject* object) = win 0x2c8a50;
    static cocos2d::CCScene* scene(GJSearchObject* object) = win 0x2c8a00;

    virtual void onEnter() = win 0x2cfaf0;
    virtual void onEnterTransitionDidFinish();
    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline { return true; }
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline {}
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline {}
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline {}
    virtual void registerWithTouchDispatcher() = win 0x2cfc30;
    virtual void keyBackClicked();
    virtual void keyDown(cocos2d::enumKeyCodes key) = win 0x2ccd90;
    virtual void loadLevelsFinished(cocos2d::CCArray* levels, char const* key, int type) = win 0x2cc280;
    virtual void loadLevelsFailed(char const* key, int type) = win 0x2cc3b0;
    virtual void setupPageInfo(gd::string info, char const* key) = win 0x2cc400;
    virtual void onBack(cocos2d::CCObject* sender) = win 0x2ccce0;
    virtual void shareCommentClosed(gd::string text, ShareCommentLayer* layer) = win 0x2cdf90;
    virtual void setTextPopupClosed(SetTextPopup* popup, gd::string text) = win 0x2ced00;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x2cf530;
    virtual void setIDPopupClosed(SetIDPopup* popup, int value) = win 0x2cc8b0;
    virtual cocos2d::CCArray* updateResultArray(cocos2d::CCArray* results) = win 0x2c87d0;
    virtual bool cellPerformedAction(TableViewCell* cell, int listType, CellAction action, cocos2d::CCNode* parent) = win 0x2cfb90;

    void createNewLevel(cocos2d::CCObject* sender) = win inline {
        this->setKeypadEnabled(false);
        this->setKeyboardEnabled(false);
        GameLevelManager* glm = GameLevelManager::sharedState();
        GJGameLevel* newLevel = glm->createNewLevel();
        glm->m_returnToLocalLevels = true;
        cocos2d::CCDirector::sharedDirector()->replaceScene(cocos2d::CCTransitionFade::create(0.5f, EditLevelLayer::scene(newLevel)));
    }
    void createNewList(cocos2d::CCObject* sender) = win inline {
        if (m_isOverlay) {
            auto layer = ShareCommentLayer::create("List Name", 25, CommentType::ListName, 0, {});
            layer->m_delegate = this;
            layer->show();
        }
        else {
            this->setKeypadEnabled(false);
            this->setKeyboardEnabled(false);
            auto glm = GameLevelManager::sharedState();
            auto list = glm->createNewLevelList();
            glm->m_returnToLocalLevels = true;
            cocos2d::CCDirector::sharedDirector()->replaceScene(cocos2d::CCTransitionFade::create(0.5f, LevelListLayer::scene(list)));
        }
    }
    void createNewSmartTemplate(cocos2d::CCObject* sender) = win inline {
        this->setKeypadEnabled(false);
        this->setKeyboardEnabled(false);
        auto glm = GameLevelManager::sharedState();
        auto smartTemplate = glm->createSmartTemplate();
        glm->m_returnToLocalLevels = true;
        SetupSmartTemplateLayer::create(smartTemplate)->show();
        this->onBack(nullptr);
    }
    void deleteSelected() = win inline {
        auto selected = cocos2d::CCArray::create();
        CCObject* obj;
        CCARRAY_FOREACH(m_levels, obj) {
            auto level = static_cast<GJGameLevel*>(obj);
            if (level->m_selected) selected->addObject(level);
        }
        if (selected->count() == 0) return;
        auto glm = GameLevelManager::sharedState();
        CCARRAY_FOREACH(selected, obj) {
            glm->deleteLevel(static_cast<GJGameLevel*>(obj));
        }
        m_allSelected = false;
        m_allObjectsToggler->toggle(false);
        this->loadPage(m_searchObject);
    }
    void exitLayer(cocos2d::CCObject* sender) = win inline {
        cocos2d::CCDirector::sharedDirector()->getTouchDispatcher()->unregisterForcePrio(this);
        this->removeFromParentAndCleanup(true);
    }
    cocos2d::CCArray* getItemsMatchingSearch(cocos2d::CCArray* items, gd::string query, GJSearchObject* object) = win 0x2cedc0;
    gd::string getSearchTitle() = win 0x2cba20;
    bool init(GJSearchObject* object) = win 0x2c8ac0;
    bool isCorrect(char const* key) = win 0x2ca3b0;
    void loadPage(GJSearchObject* object) = win 0x2ca580;
    void onClearSearch(cocos2d::CCObject* sender) = win 0x2ce9e0;
    void onDeleteAll(cocos2d::CCObject* sender) = win 0x2ce430;
    void onDeleteSelected(cocos2d::CCObject* sender) = win 0x2cf150;
    void onFavorites(cocos2d::CCObject* sender) = win 0x2ce270;
    void onGoToFolder(cocos2d::CCObject* sender) = win 0x2cc800;
    void onGoToLastPage(cocos2d::CCObject* sender);
    void onGoToPage(cocos2d::CCObject* sender) = win 0x2cc6f0;
    void onHelp(cocos2d::CCObject* sender) = win inline, ios inline {}
    void onInfo(cocos2d::CCObject* sender) = win 0x2cce30;
    void onLocalMode(cocos2d::CCObject* sender) = win 0x2cdeb0;
    void onMyOnlineLevels(cocos2d::CCObject* sender) = win 0x2ce0a0;
    void onNew(cocos2d::CCObject* sender) = win 0x2cda00;
    void onNextPage(cocos2d::CCObject* sender);
    void onPrevPage(cocos2d::CCObject* sender);
    void onRefresh(cocos2d::CCObject* sender) = win 0x2ce8a0;
    void onRemoveAllFavorites(cocos2d::CCObject* sender) = win 0x2ce5d0;
    void onSaved(cocos2d::CCObject* sender) = win 0x2ce350;
    void onSavedMode(cocos2d::CCObject* sender) = win 0x2cddd0;
    void onSearch(cocos2d::CCObject* sender) = win 0x2cea80;
    void onToggleAllObjects(cocos2d::CCObject* sender) = win 0x2cf490;
    void reloadAllObjects() = win inline, ios inline {
        static_cast<CustomListView*>(m_list->m_listView)->reloadAll();
    }
    void setSearchObject(GJSearchObject* object) = win inline {
        if (m_searchObject != object) {
            CC_SAFE_RETAIN(object);
            CC_SAFE_RELEASE(m_searchObject);
            m_searchObject = object;
        }
    }
    void setupLevelBrowser(cocos2d::CCArray* items) = win 0x2cb710;
    void show();
    void updateLevelsLabel() = win inline {
        auto end = m_pageEndIdx + m_pageStartIdx;
        auto count = m_itemCount;
        if (end > count) end = count;
        m_countText->setString(cocos2d::CCString::createWithFormat("%i to %i of %i", m_pageStartIdx + 1, end, count)->getCString());
        m_countText->limitLabelWidth(100.f, .6f, .0f);
        this->updatePageLabel();
    }
    void updatePageLabel() = win 0x2ccab0;

    bool m_unk;
    bool m_allSelected;
    TextArea* m_noInternet;
    GJListLayer* m_list;
    CCMenuItemSpriteExtra* m_rightArrow;
    CCMenuItemSpriteExtra* m_leftArrow;
    CCMenuItemSpriteExtra* m_lastBtn;
    CCMenuItemSpriteExtra* m_cancelSearchBtn;
    CCMenuItemSpriteExtra* m_refreshBtn;
    cocos2d::CCArray* m_levels;
    GJSearchObject* m_searchObject;
    cocos2d::CCLabelBMFont* m_countText;
    cocos2d::CCLabelBMFont* m_pageText;
    CCMenuItemSpriteExtra* m_pageBtn;
    cocos2d::CCLabelBMFont* m_folderText;
    CCMenuItemSpriteExtra* m_folderBtn;
    CCMenuItemToggler* m_allObjectsToggler;
    int m_itemCount;
    int m_pageStartIdx;
    int m_pageEndIdx;
    LoadingCircle* m_circle;
    int m_lastPage;
    bool m_isOverlay;
    cocos2d::CCScene* m_scene;
    int m_zOffset;
    bool m_unk2;
    int m_listHeight;
    float m_unkFloat;
    float m_unkFloat2;
    TableViewCellDelegate* m_delegate;
    bool m_cached;
}

[[link(android)]]
class LevelCell : TableViewCell {
    // virtual ~LevelCell();
    LevelCell(char const* identifier, float width, float height);

    static LevelCell* create(float width, float height) = win inline {
        auto ret = new LevelCell(" ", width, height);
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0xae050;
    virtual void draw() = win 0xb1a80;

    void loadCustomLevelCell() = win 0xae250;
    void loadFromLevel(GJGameLevel* level) = win 0xae070;
    void loadLocalLevelCell() = win 0xb0d90;
    void onClick(cocos2d::CCObject* sender) = win 0xb1820;
    void onToggle(cocos2d::CCObject* sender);
    void onViewProfile(cocos2d::CCObject* sender) = win 0xb1a40;
    void updateBGColor(int index) = win inline {
        m_backgroundLayer->setColor(index % 2 == 0 ? cocos2d::ccColor3B { 161, 88, 44 } : cocos2d::ccColor3B { 194, 114, 62 });
        m_backgroundLayer->setOpacity(255);
    }
    void updateCellMode(int mode) = win 0xb1590;
    void updateToggle() = win inline, ios inline {
        if (m_level && m_toggler) m_toggler->toggle(m_level->m_selected);
    }

    CCMenuItemSpriteExtra* m_button;
    GJGameLevel* m_level;
    bool m_cellDrawn;
    CCMenuItemToggler* m_toggler;
    cocos2d::CCPoint m_point;
    cocos2d::CCMenu* m_mainMenu;
    bool m_compactView;
    int m_cellMode;
}

[[link(android)]]
class LevelCommentDelegate {
    virtual void loadCommentsFinished(cocos2d::CCArray* comments, char const* key) {}
    virtual void loadCommentsFailed(char const* key) {}
    virtual void updateUserScoreFinished() {}
    virtual void setupPageInfo(gd::string info, char const* key) {}
}

[[link(android)]]
class LevelDeleteDelegate {
    virtual void levelDeleteFinished(int id) {}
    virtual void levelDeleteFailed(int id) {}
}

[[link(android)]]
class LevelDownloadDelegate {
    virtual void levelDownloadFinished(GJGameLevel* level) {}
    virtual void levelDownloadFailed(int response) {}
}

[[link(android)]]
class LevelEditorLayer : GJBaseGameLayer, LevelSettingsDelegate {
    // virtual ~LevelEditorLayer();
    LevelEditorLayer();

    static LevelEditorLayer* create(GJGameLevel* level, bool noUI);
    static LevelEditorLayer* get() {
        return GameManager::sharedState()->m_levelEditorLayer;
    }
    static cocos2d::CCScene* scene(GJGameLevel* level, bool noUI) = win inline {
        auto scene = cocos2d::CCScene::create();
        AppDelegate::get()->m_runningScene = scene;
        auto layer = LevelEditorLayer::create(level, noUI);
        scene->addChild(layer);
        scene->setObjType(cocos2d::CCObjectType::LevelEditorLayer);
        return scene;
    }
    static void updateObjectLabel(GameObject* object) = win 0x2d74c0;

    virtual void draw();
    virtual void postUpdate(float dt) = win 0x2e0da0;
    virtual void updateVisibility(float dt) = win 0x2d8cd0;
    virtual void playerTookDamage(PlayerObject* player) = win 0x2e0d90;
    virtual void updateColor(cocos2d::ccColor3B& color, float fadeTime, int colorID, bool blending, float opacity, cocos2d::ccHSVValue& copyHSV, int colorIDToCopy, bool copyOpacity, EffectGameObject* callerObject, int unk1, int unk2) = win 0x2dd870;
    virtual void updateDebugDraw() = win 0x2e6ad0;
    virtual void addToGroup(GameObject* object, int groupID, bool triggerGroup) = win 0x2de860;
    virtual void removeFromGroup(GameObject* object, int groupID) = win 0x2de9c0;
    virtual void updateObjectSection(GameObject* object) = win 0x2df790;
    virtual void updateDisabledObjectsLastPos(cocos2d::CCArray* objects) = win 0x2dfa40;
    virtual float timeForPos(cocos2d::CCPoint position, int order, int channel, bool songTriggers, int id) = win 0x2de650;
    virtual cocos2d::CCPoint posForTime(float time) = win 0x2de700;
    virtual void resetSPTriggered() = win 0x2de770;
    virtual void didRotateGameplay() = win 0x2df720;
    virtual void manualUpdateObjectColors(GameObject* object) = win 0x2d9cd0;
    virtual cocos2d::CCParticleSystemQuad* claimCustomParticle(gd::string const& key, cocos2d::ParticleStruct const& particleStruct, int zLayer, int zOrder, int uiObject, bool dontAdd) = win 0x2e1530;
    virtual void unclaimCustomParticle(gd::string const& key, cocos2d::CCParticleSystemQuad* particle) = win 0x2e15f0;
    virtual void activatedAudioTrigger(SFXTriggerGameObject* object) = win 0x2e0c90;
    virtual void checkpointActivated(CheckpointGameObject* object) = win 0x2e0cc0;
    virtual void addKeyframe(KeyframeGameObject* object) = win 0x2e1630;
    virtual void levelSettingsUpdated() = win 0x2d3580;

    bool activateTriggerEffect(EffectGameObject* object, float currentTime, float playTime, float boundTime, bool active) = win 0x2dcda0;
    void addDelayedSpawn(EffectGameObject* object, float delay) = win 0x2dd5f0, ios inline {
        auto node = this->getDelayedSpawnNode();
        node->m_gameObject = object;
        node->m_spawnDelay = delay;
        if (m_delayedSpawnNodes.size() > 1) m_sortSpawnNodes = true;
    }
    void addExclusionList(cocos2d::CCArray* groups, cocos2d::CCDictionary* dict) = win inline {
        if (!groups || !dict) return;
        auto node = cocos2d::CCNode::create();
        for (int i = 0; i < groups->count(); i++) {
            auto group = static_cast<cocos2d::CCInteger*>(groups->objectAtIndex(i))->getValue();
            if (!dict->objectForKey(group)) dict->setObject(node, group);
        }
    }
    GameObject* addObjectFromVector(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win inline {
        auto object = GameObject::objectFromVector(values, exists, this, false);
        if (!object) return nullptr;
        if (object->m_objectID == 1329 && m_coinCount.value() > 2) return nullptr;
        if (object->m_objectID == 142) return nullptr;
        object->setVisible(false);
        this->addToSection(object);
        this->addSpecial(object);
        return object;
    }
    void addObjectsAtPosition(cocos2d::CCPoint position, cocos2d::CCArray* objects, cocos2d::CCArray* result) = win inline, ios inline {
        for (int i = 0; i < objects->count(); i++) {
            auto object = static_cast<GameObject*>(objects->objectAtIndex(i));
            if (this->validGroup(object, true)) {
                if (m_nonSquareRotation) {
                    if (!m_currentOBB2D->overlaps(m_obb2)) continue;
                }
                else {
                    if (!this->getObjectRect(object, false, false).containsPoint(position)) continue;
                }
                result->addObject(object);
            }
        }
    }
    void addObjectsInRect(cocos2d::CCRect rect, bool ignoreGroups, cocos2d::CCArray* objects, cocos2d::CCArray* result) = win inline, ios inline {
        for (int i = 0; i < objects->count(); i++) {
            auto object = static_cast<GameObject*>(objects->objectAtIndex(i));
            if (ignoreGroups || this->validGroup(object, true)) {
                if (m_nonSquareRotation) {
                    if (!m_currentOBB2D->overlaps(m_obb2)) continue;
                }
                else {
                    if (!rect.intersectsRect(this->getObjectRect(object, false, false))) continue;
                }
                result->addObject(object);
            }
        }
    }
    void addObjectToGroup(GameObject* object, int group) = win inline {
        if (object->addToGroup(group) != 1) {
            return;
        }
        this->addToGroup(object,group,false);
    }
    void addPlayer2Point(cocos2d::CCPoint point, bool newGroup) = win inline {
        if (newGroup || m_player2Points.empty()) m_player2Points.emplace_back();
        m_player2Points.back().push_back(point);
    }
    void addPlayerCollisionBlock() = win inline, ios inline {
        if (m_collisionBlocksAdded) return;
        m_collisionBlocksAdded = true;
        this->addToSection(m_player1CollisionBlock);
        this->addToSection(m_player2CollisionBlock);
    }
    void addPlayerPoint(cocos2d::CCPoint point) = win inline {
        m_playerPoints.push_back(point);
    }
    void addSpecial(GameObject* object);
    void addToRedoList(UndoObject* object) = win inline {
        if (m_redoObjects->count() >= (m_increaseMaxUndoRedo ? 1000 : 200)) m_redoObjects->removeObjectAtIndex(0, true);
        m_redoObjects->addObject(object);
    }
    void addTouchPoint(cocos2d::CCPoint point) = win inline {
        m_touchPoints.push_back(point);
    }
    void addToUndoList(UndoObject* object, bool keepRedo) = win inline {
        if (!keepRedo) m_redoObjects->removeAllObjects();
        if (m_undoObjects->count() >= (m_increaseMaxUndoRedo ? 1000 : 200)) m_undoObjects->removeObjectAtIndex(0, true);
        m_undoObjects->addObject(object);
    }
    void applyAttributeState(GameObject* dest, GameObject* src) = win inline, ios inline {
        dest->duplicateAttributes(src);
        dest->m_updateParents = true;
    }
    void applyGroupState(GameObject* dest, GameObject* src) = win 0x2e1230;
    void breakApartTextObject(TextGameObject* object) = win 0x2df410;
    bool canPasteState() = win inline {
        return m_copyStateObject != nullptr;
    }
    void clearPlayerPoints() = win inline, ios inline {
        m_playerPoints.clear();
        m_player2Points.clear();
    }
    void clearTouchPoints() = win inline, ios inline {
        m_touchPoints.clear();
    }
    void copyObjectState(GameObject* object) = win 0x2e1090;
    void copyParticleState(ParticleGameObject* object) = win inline {
        if (!object) return;
        if (!m_particleObject) {
            m_particleObject = ParticleGameObject::create();
            m_particleObject->addColorSprite("edit_eCParticleBtn_001.png");
            m_particleObject->setupCustomSprites("edit_eCParticleBtn_001.png");
            m_particleObject->retain();
        }
        m_particleObject->setParticleString(object->m_particleData);
        m_particleObject->m_hasUniformObjectColor = object->m_hasUniformObjectColor;
        m_particleObject->m_animateOnTrigger = object->m_animateOnTrigger;
    }
    GameObject* createObject(int key, cocos2d::CCPoint position, bool noUndo) = win 0x2d4500;
    void createObjectsFromSetup(gd::string& setup) = win 0x2d3660;
    cocos2d::CCArray* createObjectsFromString(gd::string const& str, bool noUndo, bool noLimit) = win 0x2d3e80;
    void dirtifyTriggers() = win inline {
        m_triggersChanged = true;
        m_colorTriggersChanged = true;
        m_pulseTriggersChanged = true;
        m_alphaTriggersChanged = true;
        m_spawnTriggersChanged = true;
    }
    cocos2d::CCArray* duplicateKeyframeAnimation(int keyframeGroup) = win 0x2e16e0;
    void fastUpdateDisabledGroups() = win inline, ios inline {}
    GameObject* findGameObject(int uniqueID) = win inline {
        CCObject* obj;
        CCARRAY_FOREACH(m_objects, obj) {
            auto object = static_cast<GameObject*>(obj);
            if (object->m_uniqueID == uniqueID) return object;
        }
        return nullptr;
    }
    StartPosObject* findStartPosObject() = win inline {
        StartPosObject* ret = nullptr;
        auto xPos = 0.0f;
        auto order = -1;
        CCObject* obj;
        CCARRAY_FOREACH(m_objects, obj) {
            auto object = static_cast<StartPosObject*>(obj);
            if (object->m_objectID == 31 && !object->m_startSettings->m_disableStartPos) {
                auto currentXPos = object->getPosition().x;
                auto currentOrder = object->m_startSettings->m_targetOrder;
                auto reverseGameplay = object->m_startSettings->m_reverseGameplay;
                if (
                    order < currentOrder ||
                    (xPos < currentXPos && !reverseGameplay && order <= currentOrder) ||
                    (currentXPos < xPos && reverseGameplay && order <= currentOrder)
                ) {
                    ret = object;
                    order = currentOrder;
                    xPos = currentXPos;
                }
            }
        }
        return ret;
    }
    void forceShowSelectedObjects(bool show) = win inline {
        if (!m_editorUI) return;
        cocos2d::CCArray* objects;
        if (m_editorUI->m_selectedObjects->count() == 0) {
            if (!m_editorUI->m_selectedObject) return;
            objects = cocos2d::CCArray::createWithObject(m_editorUI->m_selectedObject);
        }
        else {
            objects = m_editorUI->m_selectedObjects;
        }
        CCObject* obj;
        CCARRAY_FOREACH(objects, obj) {
            auto object = static_cast<GameObject*>(obj);
            if (show) {
                object->m_unk28B = object->m_isGroupDisabled;
                object->m_isGroupDisabled = false;
            }
            else {
                object->m_isGroupDisabled = object->m_unk28B;
            }
        }
    }
    void fullUpdateDisabledGroups() = win inline, ios inline {}
    cocos2d::CCArray* getAllObjects() = win inline {
        return m_objects;
    }
    DelayedSpawnNode* getDelayedSpawnNode() = win inline {
        DelayedSpawnNode* ret;
        if (m_delayedSpawnNodes2.empty()) {
            ret = new DelayedSpawnNode();
            ret->m_gameObject = nullptr;
            ret->m_spawnDelay = 0.f;
        }
        else {
            ret = m_delayedSpawnNodes2.back();
            m_delayedSpawnNodes2.pop_back();
        }
        m_delayedSpawnNodes.push_back(ret);
        return ret;
    }
    cocos2d::CCPoint getGridPos(cocos2d::CCPoint position) = win inline, ios inline {
        return position / 30.f;
    }
    float getLastObjectX() = win 0x2de7c0;
    gd::string getLevelString() = win 0x2d6ab0;
    gd::string getLockedLayers() = win inline {
        auto isFirst = true;
        fmt::memory_buffer buffer;
        for (int i = 0; i < 10000; i++) {
            if (m_lockedLayers[i]) {
                if (!isFirst) fmt::format_to(std::back_inserter(buffer), ",");
                fmt::format_to(std::back_inserter(buffer), "{}", i);
                isFirst = false;
            }
        }
        return fmt::to_string(buffer);
    }
    int getNextColorChannel();
    int getNextFreeAreaEffectID(cocos2d::CCArray* exclude);
    int getNextFreeBlockID(cocos2d::CCArray* exclude) = win inline {
        auto dict = cocos2d::CCDictionary::create();
        auto node = cocos2d::CCNode::create();
        auto objects = this->getAllObjects();
        this->addExclusionList(exclude, dict);
        for (int i = 0; i < objects->count(); i++) {
            auto object = static_cast<EffectGameObject*>(objects->objectAtIndex(i));
            if (object->m_classType == GameObjectClassType::Effect || object->m_objectID == 1816) {
                auto id = object->m_itemID;
                if (!dict->objectForKey(id)) dict->setObject(node, id);
            }
        }
        for (int i = 0; i < 1001; i++) {
            if (!dict->objectForKey(i)) return i;
        }
        return 1000;
    }
    int getNextFreeEditorLayer(cocos2d::CCArray* exclude);
    int getNextFreeEnterChannel(cocos2d::CCArray* exclude);
    int getNextFreeGradientID(cocos2d::CCArray* exclude);
    int getNextFreeGroupID(cocos2d::CCArray* exclude);
    int getNextFreeItemID(cocos2d::CCArray* exclude);
    int getNextFreeOrderChannel(cocos2d::CCArray* exclude);
    int getNextFreeSFXGroupID(cocos2d::CCArray* exclude) = win inline {
        auto dict = cocos2d::CCDictionary::create();
        auto node = cocos2d::CCNode::create();
        auto objects = this->getAllObjects();
        this->addExclusionList(exclude, dict);
        for (int i = 0; i < objects->count(); i++) {
            auto object = static_cast<SFXTriggerGameObject*>(objects->objectAtIndex(i));
            if (object->m_objectID == 3602 || object->m_objectID == 3603) {
                auto id = object->m_sfxGroup;
                if (id > 0 && !dict->objectForKey(id)) dict->setObject(node, id);
            }
        }
        for (int i = 0; i < 1001; i++) {
            if (!dict->objectForKey(i)) return i;
        }
        return 1000;
    }
    int getNextFreeSFXID(cocos2d::CCArray* exclude) = win inline {
        auto dict = cocos2d::CCDictionary::create();
        auto node = cocos2d::CCNode::create();
        auto objects = this->getAllObjects();
        this->addExclusionList(exclude, dict);
        for (int i = 0; i < objects->count(); i++) {
            auto object = static_cast<SFXTriggerGameObject*>(objects->objectAtIndex(i));
            if (object->m_objectID == 3602) {
                auto id = object->getUniqueSFXID();
                if (id > 0 && !dict->objectForKey(id)) dict->setObject(node, id);
            }
        }
        for (int i = 0; i < 1001; i++) {
            if (!dict->objectForKey(i)) return i;
        }
        return 1000;
    }
    cocos2d::CCRect getObjectRect(GameObject* object, bool forceSize, bool dontCalculate) = win 0x2d5660;
    cocos2d::CCPoint getRelativeOffset(GameObject* object) = win inline, ios inline {
        return GameToolbox::getRelativeOffset(object, object->m_obUnflippedOffsetPositionFromCenter);
    }
    cocos2d::CCPoint getSavedEditorPosition(int index) = win inline {
        return index < 10 ? m_savedPositions[index] : cocos2d::CCPoint { 0.f, 0.f };
    }
    gd::string getSavedEditorPositions() = win inline {
        fmt::memory_buffer buffer;
        for (int i = 0; i < 10; i++) {
            if (i != 0) fmt::format_to(std::back_inserter(buffer), ",");
            fmt::format_to(std::back_inserter(buffer), "{},{}", (int)m_savedPositions[i].x, (int)m_savedPositions[i].y);
        }
        return fmt::to_string(buffer);
    }
    int getSectionCount() = win inline {
        return m_sections.size();
    }
    int getSelectedEditorOrder() = win inline {
        if (!m_playbackObject) return 0;
        if (m_playbackObject->m_objectID != 31) return m_playbackObject->m_ordValue;
        return static_cast<StartPosObject*>(m_playbackObject)->m_startSettings->m_targetOrder;
    }
    cocos2d::CCPoint getSelectedEffectPos() = win inline {
        if (!m_playbackObject) return cocos2d::CCPoint { 0.f, 0.f };
        if (m_playbackObject->m_objectID != 1816) return m_playbackObject->m_speedStart;
        return m_playbackObject->getRealPosition();
    }
    int getSelectedOrderChannel() = win inline {
        if (!m_playbackObject) return 0;
        if (m_playbackObject->m_objectID != 31) return m_playbackObject->m_channelValue;
        return static_cast<StartPosObject*>(m_playbackObject)->m_startSettings->m_targetChannel;
    }
    gd::string getSFXIDs() = win 0x2d71c0;
    gd::string getSongIDs(bool& multipleSongs) = win 0x2d6e10;
    cocos2d::CCArray* getTriggerGroup(int id) = win 0x2deb10;
    void handleAction(bool undo, cocos2d::CCArray* undoObjects) = win 0x2d63b0;
    bool hasAction(bool redo) = win inline {
        if (redo) return m_redoObjects->count() != 0;
        else return m_undoObjects->count() != 0;
    }
    bool init(GJGameLevel* level, bool noUI) = win 0x2d1c30;
    bool isLayerLocked(int layer) = win inline {
        if (layer < 10000 && m_layerLockingEnabled) {
            return m_lockedLayers[layer];
        }
        return false;
    }
    GameObject* objectAtPosition(cocos2d::CCPoint position) = win 0x2d4eb0;
    void objectMoved(GameObject* object);
    cocos2d::CCArray* objectsAtPosition(cocos2d::CCPoint position) = win 0x2d5270;
    cocos2d::CCArray* objectsInRect(cocos2d::CCRect rect, bool ignoreGroups) = win 0x2d5b00;
    void onPausePlaytest() = win inline {
        auto director = cocos2d::CCDirector::sharedDirector();
        director->getKeyboardDispatcher()->setBlockRepeat(false);
        m_uiLayer->editorPlaytest(false);
        this->quickUpdateAllPositions();
        this->removePlayerCollisionBlock();
        if (m_playTestSmoothFix) {
            director->resetSmoothFixCounter();
            director->setSmoothFixCheck(false);
        }
        m_playbackMode = PlaybackMode::Paused;
        m_player1->pauseSchedulerAndActions();
        m_player2->pauseSchedulerAndActions();
        m_playtestTimeWarp = m_gameState.m_timeWarp;
        this->updateTimeWarp(1.f);
        m_playtestCameraZoom = m_gameState.m_cameraZoom;
        this->pauseAudio();
        if (m_playtestOrderChanged) this->timeObjectChanged();
    }
    void onPlaytest() = win 0x2dfb30;
    void onResumePlaytest();
    void onStopPlaytest() = win 0x2e0490;
    void pasteAttributeState(GameObject* object, cocos2d::CCArray* objects) = win inline {
        if (!m_copyStateObject) return;

        if (!object) {
            CCObject* obj;
            CCARRAY_FOREACH(objects, obj) {
                this->applyAttributeState(static_cast<GameObject*>(obj), m_copyStateObject);
            }
        }
        else this->applyAttributeState(object, m_copyStateObject);

        if (!GameManager::sharedState()->getGameVariable("0156")) this->pasteGroupState(object, objects);
    }
    void pasteColorState(GameObject* object, cocos2d::CCArray* objects) = win inline {
        if (!m_copyStateObject) return;

        if (object) {
            object->duplicateColorMode(m_copyStateObject);
            object->m_updateParents = true;
        }
        else {
            CCObject* obj;
            CCARRAY_FOREACH(objects, obj) {
                auto gameObject = static_cast<GameObject*>(obj);
                gameObject->duplicateColorMode(m_copyStateObject);
                gameObject->m_updateParents = true;
            }
        }
    }
    void pasteGroupState(GameObject* object, cocos2d::CCArray* objects) = win inline {
        if (!m_copyStateObject) return;

        if (object) return this->applyGroupState(object, m_copyStateObject);

        CCObject* obj;
        CCARRAY_FOREACH(objects, obj) {
            this->applyGroupState(static_cast<GameObject*>(obj), m_copyStateObject);
        }
    }
    void pasteParticleState(ParticleGameObject* object, cocos2d::CCArray* objects) = win inline {
        if (!m_particleObject) return;

        if (object) {
            object->setParticleString(m_particleObject->m_particleData);
            object->m_hasUniformObjectColor = m_particleObject->m_hasUniformObjectColor;
            object->m_animateOnTrigger = m_particleObject->m_animateOnTrigger;
            object->updateParticle();
        }
        else {
            CCObject* obj;
            CCARRAY_FOREACH(objects, obj) {
                auto gameObject = static_cast<ParticleGameObject*>(obj);
                gameObject->setParticleString(m_particleObject->m_particleData);
                gameObject->m_hasUniformObjectColor = m_particleObject->m_hasUniformObjectColor;
                gameObject->m_animateOnTrigger = m_particleObject->m_animateOnTrigger;
                gameObject->updateParticle();
            }
        }
    }
    void processLoadedMoveActions();
    void quickUpdateAllPositions() = win 0x2df8c0;
    void recreateGroups() = win 0x2deb70;
    void redoLastAction() = win inline {
        return this->handleAction(false, m_redoObjects);
    }
    void refreshSpecial(GameObject* object) = win inline {
        this->removeSpecial(object);
        this->addSpecial(object);
    }
    void removeAllObjects() = win inline {
        m_removingAll = true;
        if (m_editorUI) m_editorUI->deselectAll();
        auto objectsCopy = cocos2d::CCArray::createWithCapacity(m_objects->count());
        objectsCopy->addObjectsFromArray(m_objects);
        CCObject* obj;
        CCARRAY_FOREACH(objectsCopy, obj) {
            this->removeObject(static_cast<GameObject*>(obj), true);
        }
        m_redoObjects->removeAllObjects();
        m_undoObjects->removeAllObjects();
        m_objectCount = 0;
        m_removingAll = false;
    }
    void removeAllObjectsOfType(int objectID);
    void removeObject(GameObject* object, bool noUndo);
    void removePlayerCollisionBlock() = win inline {
        if (!m_collisionBlocksAdded) return;
        m_collisionBlocksAdded = false;
        this->removeObjectFromSection(m_player1CollisionBlock);
        this->removeObjectFromSection(m_player2CollisionBlock);
    }
    void removeSpecial(GameObject* object) = win 0x2d8170;
    void resetDelayedSpawnNodes() = win inline {
        for (auto node : m_delayedSpawnNodes) {
            m_delayedSpawnNodes2.push_back(node);
        }
        m_delayedSpawnNodes.clear();
    }
    void resetEffectTriggerOptim(GameObject* object, cocos2d::CCArray* objects) = win inline {
        if (object) {
            if (object->m_dontIgnoreDuration) static_cast<EffectGameObject*>(object)->m_endPosition = cocos2d::CCPoint { 0.f, 0.f };
        }
        else {
            CCObject* obj;
            CCARRAY_FOREACH(objects, obj) {
                auto gameObject = static_cast<EffectGameObject*>(obj);
                if (gameObject->m_dontIgnoreDuration) gameObject->m_endPosition = cocos2d::CCPoint { 0.f, 0.f };
            }
        }
    }
    void resetMovingObjects() = win inline {
        auto objects = this->getAllObjects();
        for (int i = 0; i < objects->count(); i++) {
            auto object = static_cast<GameObject*>(objects->objectAtIndex(i));
            object->resetMoveOffset();
            object->setPosition(object->getRealPosition());
            this->updateObjectSection(object);
        }
    }
    void resetObjectVector() = win inline, ios inline {
        for (int i = 0; i < 10000; i++) {
            m_objectVector[i] = nullptr;
        }
    }
    void resetPlayback() = win inline {
        m_playbackOrder = 0;
        this->clearActivatedAudioTriggers();
        m_activateAudioTriggers = true;
    }
    void resetToggledGroups() = win inline, ios inline {
        for (int i = 0; i < 10000; i++) {
            m_toggledGroupStates[i] = 0;
            m_toggledGroups[i] = false;
        }
    }
    void resetToggledGroupsAndObjects() = win 0x2de470;
    void resetUnusedColorChannels();
    void reverseKeyframeAnimationOrder(int keyframeGroup) = win inline {
        static_cast<cocos2d::CCArray*>(m_keyframeGroups->objectForKey(keyframeGroup))->reverseObjects();
        this->updateKeyframeOrder(keyframeGroup);
    }
    void reverseObjectChanged(EffectGameObject* object) = win inline {
        if (object->m_isReverse) m_drawGridLayer->addToSpeedObjects(object);
        else m_drawGridLayer->removeFromSpeedObjects(object);
    }
    float rotationForSlopeNearObject(GameObject* object) = win 0x2d4d20;
    ColorAction* runColorEffect(EffectGameObject* object, int colorID, float delay, float interval, bool instant) = win 0x2dd6d0;
    void saveEditorPosition(cocos2d::CCPoint& position, int index) = win inline {
        if (index < 10) m_savedPositions[index] = position;
    }
    void setObjectCount(int count) {
        m_objectCount = count;
    }
    bool shouldBlend(int colorID) = win 0x2d3530;
    void sortBatchnodeChildren(float unused) = win inline {
        CCObject* obj;
        CCARRAY_FOREACH(m_batchNodes, obj) {
            static_cast<cocos2d::CCSpriteBatchNode*>(obj)->manualSortAllChildren();
        }
    }
    void spawnGroupPreview(int groupID, float xPos, float delay, float currentTime, float playTime, float boundTime, bool ordered, bool active) = win 0x2ddda0;
    void stopPlayback() = win inline {
        auto engine = FMODAudioEngine::sharedEngine();
        engine->stopAllMusic(true);
        engine->stopAllEffects();
    }
    void stopTriggersInGroup(int id, float delay) = win 0x2dd9e0;
    void timeObjectChanged() = win inline {
        m_spawnOrderObjectsChanged = true;
    }
    void toggleBackground(bool visible) = win inline, ios inline {
        if (m_background) m_background->setVisible(visible);
    }
    void toggleGrid(bool visible) = win inline, ios inline {
        m_drawGridLayer->setVisible(visible);
    }
    void toggleGround(bool enable) = win inline {
        m_hideGround = !enable;
        m_groundLayer->setVisible(enable);
    }
    void toggleGroupPreview(int id, bool enable) = win 0x2de1a0;
    void toggleLockActiveLayer() = win inline {
        if (m_currentLayer < 0 || m_currentLayer > 9999 || !m_layerLockingEnabled) return;
        m_lockedLayers[m_currentLayer] = !m_lockedLayers[m_currentLayer];
    }
    void transferDefaultColors(GJEffectManager* src, GJEffectManager* dest) = win 0x2dbc40;
    void triggerFollowCommand(EffectGameObject* object) = win inline, ios inline {
        m_levelSettings->m_effectManager->createFollowCommand(
            object->m_followXMod,
            object->m_followYMod,
            object->m_duration,
            object->m_targetGroupID,
            object->m_centerGroupID,
            object->m_uniqueID,
            object->m_controlID
        );
    }
    void triggerPlayerFollowCommand(EffectGameObject* object) = win inline, ios inline {
        m_levelSettings->m_effectManager->createPlayerFollowCommand(
            object->m_followYSpeed,
            object->m_followYDelay,
            object->m_followYOffset,
            object->m_followYMaxSpeed,
            object->m_duration,
            object->m_targetGroupID,
            object->m_uniqueID,
            object->m_controlID
        );
    }
    void triggerRotateCommand(EffectGameObject* object) = win inline, ios inline {
        m_levelSettings->m_effectManager->createRotateCommand(
            object->m_times360 * 360.f + object->m_rotationDegrees,
            object->m_duration,
            object->m_targetGroupID,
            object->m_centerGroupID,
            (int)object->m_easingType,
            object->m_easingRate,
            object->m_lockObjectRotation,
            object->m_targetPlayer1,
            object->m_targetPlayer2,
            object->m_uniqueID,
            object->m_controlID
        );
    }
    bool tryUpdateSpeedObject(EffectGameObject* object, bool noPreview) = win 0x2d8760;
    bool typeExistsAtPosition(int objectID, cocos2d::CCPoint position, bool flipX, bool flipY, float rotation) = win 0x2d48b0;
    void undoLastAction() = win inline {
        return this->handleAction(true, m_undoObjects);
    }
    void unlockAllLayers() = win inline {
        for (int i = 0; i < 10000; i++) {
            m_lockedLayers[i] = false;
        }
    }
    void updateAnimateOnTriggerObjects(bool animate) = win 0x2e1300;
    void updateArt(float dt) = win inline, ios inline {
        if (m_playbackMode != PlaybackMode::Not) return;
        this->updateGridLayerParent();
        m_inShaderParent->setVisible(m_inShaderParent->getChildrenCount() > 1 || m_inShaderObjectLayer->getChildrenCount() != 0);
        m_aboveShaderParent->setVisible(m_aboveShaderParent->getChildrenCount() > 1 || m_aboveShaderObjectLayer->getChildrenCount() != 0);
        this->updateGradientLayers();
        this->updateExtraGameLayers();
    }
    void updateBlendValues() = win 0x2de510;
    void updateEditor(float dt);
    void updateEditorMode() = win 0x2db600;
    void updateGameObjects() = win 0x119670;
    void updateGridLayer() = win inline {
        auto parent = m_shaderLayer && m_shaderLayer->m_state.m_usesShaders ? m_aboveShaderObjectLayer : m_objectLayer;
        if (m_drawGridLayer->getParent() != parent) {
            m_drawGridLayer->retain();
            m_drawGridLayer->removeFromParentAndCleanup(false);
            parent->addChild(m_drawGridLayer, m_drawGridLayer->getZOrder());
            m_drawGridLayer->release();
        }
    }
    void updateGridLayerParent() = win 0x2d3480;
    void updateKeyframeObjects() = win 0x2e1960;
    void updateKeyframeVisibility(bool visible) = win inline, ios inline {}
    void updateLevelFont(int index) = win 0x2deed0;
    void updateObjectColors(cocos2d::CCArray* gameObjects) = win 0x2d9d60;
    void updateOptions();
    void updatePreviewAnim() = win inline {
        auto previewAnimations = GameManager::sharedState()->getGameVariable("0118");
        if (m_previewAnimations == previewAnimations) return;
        m_previewAnimations = previewAnimations;
        for (int i = 0; i < m_objects->count(); i++) {
            auto object = static_cast<EnhancedGameObject*>(m_objects->objectAtIndex(i));
            if (object->m_classType == GameObjectClassType::Animated) {
                static_cast<AnimatedGameObject*>(object)->updateObjectAnimation();
            }
            if (!m_previewAnimations) {
                if (object->getHasSyncedAnimation()) object->resetSyncedAnimation();
                if (object->getHasRotateAction()) object->updateRotateAction(0.f);
            }
        }
    }
    void updatePreviewParticle(ParticleGameObject* object) = win 0x2e14a0;
    void updatePreviewParticles();
    void updateToggledGroups() = win 0x2de340;
    bool validGroup(GameObject* object, bool checkLockedLayers) = win inline {
        int currentLayer = m_currentLayer;
        int editorLayer = object->m_editorLayer;
        int editorLayer2 = object->m_editorLayer2;
        if (editorLayer2 == 0) editorLayer2 = -1;
        auto result = currentLayer == -1 || editorLayer2 == currentLayer || editorLayer == currentLayer;
        if (checkLockedLayers) {
            editorLayer2 = std::clamp(editorLayer2, -1, 9999);
            result = false;
            if (currentLayer == -1 || editorLayer2 == currentLayer || editorLayer == currentLayer) {
                editorLayer = std::clamp(editorLayer, 0, 9999);
                result = !m_lockedLayers[editorLayer] && (editorLayer2 == -1 || !m_lockedLayers[editorLayer2]);
            }
        }
        return result;
    }

    bool m_drawTriggerBoxes;
    bool m_showGrid;
    bool m_hideGridOnPlay;
    bool m_drawEffectLines;
    bool m_showGround;
    bool m_showDurationLines;
    bool m_increaseMaxUndoRedo;
    bool m_hideBackground;
    bool m_gv0120;
    bool m_layerLockingEnabled;
    bool m_playtestOrderChanged;
    bool m_previewParticles;
    bool m_previewAnimations;
    bool m_previewShaders;
    bool m_hideParticleIcons;
    bool m_alwaysHideParticleIcons;
    bool m_playTestSmoothFix;
    bool m_hasHighDetail;
    bool m_unk36ca;
    int m_unk36cc;
    bool m_collisionBlocksAdded;
    int m_unk36d4;
    cocos2d::CCArray* m_durationObjects;
    cocos2d::CCArray* m_pulseTriggers;
    cocos2d::CCArray* m_colorTriggers;
    cocos2d::CCArray* m_alphaTriggers;
    cocos2d::CCArray* m_spawnTriggers;
    cocos2d::CCArray* m_moveTriggers;
    cocos2d::CCArray* m_cameraGuideTriggers;
    cocos2d::CCArray* m_particleObjects;
    cocos2d::CCArray* m_keyframeObjects;
    cocos2d::CCDictionary* m_unk3720;
    cocos2d::CCArray* m_playtestTriggers;
    GameObject* m_copyStateObject;
    ParticleGameObject* m_particleObject;
    cocos2d::CCDictionary* m_unk3740;
    cocos2d::CCArray* m_unk3748;
    bool m_keepEditorLayer;
    bool m_unk3751;
    geode::SeedValueRSV m_coinCount;
    bool m_triggersChanged;
    bool m_colorTriggersChanged;
    bool m_pulseTriggersChanged;
    bool m_alphaTriggersChanged;
    bool m_spawnTriggersChanged;
    cocos2d::CCArray* m_spawnOrderObjects;
    bool m_spawnOrderObjectsChanged;
    bool m_sortSpawnNodes;
    cocos2d::CCDictionary* m_unk3778;
    cocos2d::CCDictionary* m_unk3780;
    bool m_initializing;
    short m_currentLayer;
    float m_playtestZoom;
    OBB2D* m_currentOBB2D;
    float m_playtestTimeWarp;
    float m_playtestCameraZoom;
    cocos2d::CCSprite* m_playtestDeathSprite;
    float m_trailTimer;
    bool m_soloMode;
    bool m_nonSquareRotation;
    EditorUI* m_editorUI;
    cocos2d::CCArray* m_undoObjects;
    cocos2d::CCArray* m_redoObjects;
    geode::SeedValueRSV m_objectCount;
    DrawGridLayer* m_drawGridLayer;
    bool m_updateColorSprites;
    bool m_previewMode;
    bool m_alwaysPreviewMode;
    gd::string m_levelString;
    gd::vector<GameObject*> m_objectVector;
    gd::vector<GameObject*> m_loadedMoveObjects;
    cocos2d::CCDictionary* m_triggerGroupsDict;
    gd::vector<cocos2d::CCArray*> m_triggerGroups;
    gd::vector<cocos2d::CCPoint> m_playerPoints;
    gd::vector<gd::vector<cocos2d::CCPoint>> m_player2Points;
    gd::vector<cocos2d::CCPoint> m_touchPoints;
    gd::vector<bool> m_sortedGroups;
    gd::vector<bool> m_toggledGroups;
    gd::vector<bool> m_lockedLayers;
    gd::vector<cocos2d::CCPoint> m_savedPositions;
    cocos2d::CCPoint m_previewPosition;
    gd::vector<bool> m_blendingColors;
    gd::vector<bool> m_blendingColors2;
    gd::vector<unsigned char> m_toggledGroupStates;
    gd::vector<float> m_spawnGroupDelays;
    double m_sessionTime;
    bool m_removingAll;
    EffectGameObject* m_playbackObject;
    int m_playbackOrder;
    int m_duplicateKeyframeGroup;
    gd::vector<DelayedSpawnNode*> m_delayedSpawnNodes;
    gd::vector<DelayedSpawnNode*> m_delayedSpawnNodes2;
    bool m_playbackActive;
    bool m_activateAudioTriggers;
}

[[link(android)]]
class LevelFeatureLayer : FLAlertLayer {
    // virtual ~LevelFeatureLayer();

    static LevelFeatureLayer* create(int levelID);

    virtual void keyBackClicked();

    bool init(int levelID);
    void onClose(cocos2d::CCObject* sender);
    void onDown(cocos2d::CCObject* sender);
    void onDown2(cocos2d::CCObject* sender);
    void onRemoveValues(cocos2d::CCObject* sender);
    void onSetEpicOnly(cocos2d::CCObject* sender);
    void onSetFeatured(cocos2d::CCObject* sender);
    void onToggleEpic(cocos2d::CCObject* sender);
    void onUp(cocos2d::CCObject* sender);
    void onUp2(cocos2d::CCObject* sender);
    void updateStars();

    cocos2d::CCLabelBMFont* m_featureLabel;
    int m_levelID;
    int m_featurePosition;
    bool m_epicOnly;
    cocos2d::CCSprite* m_epicSprite;
}

[[link(android)]]
class LevelInfoLayer : cocos2d::CCLayer, LevelDownloadDelegate, LevelUpdateDelegate, RateLevelDelegate, LikeItemDelegate, FLAlertLayerProtocol, LevelDeleteDelegate, NumberInputDelegate, SetIDPopupDelegate, TableViewCellDelegate {
    LevelInfoLayer() {
        m_isBusy = false;
        m_playBtnMenu = nullptr;
        m_level = nullptr;
        m_coins = nullptr;
        m_likeBtn = nullptr;
        m_starRateBtn = nullptr;
        m_demonRateBtn = nullptr;
        m_unk2 = nullptr;
        m_lengthLabel = nullptr;
        m_exactLengthLabel = nullptr;
        m_downloadsLabel = nullptr;
        m_likesLabel = nullptr;
        m_orbsLabel = nullptr;
        m_folderLabel = nullptr;
        m_cloneBtn = nullptr;
        m_unk3 = nullptr;
        m_likesIcon = nullptr;
        m_orbsIcon = nullptr;
        m_levelType = GJLevelType::Default;
        m_noUpdateAlert = false;
        m_enterTransitionFinished = false;
        m_circle = nullptr;
        m_difficultySprite = nullptr;
        m_starsIcon = nullptr;
        m_starsLabel = nullptr;
        m_icons = nullptr;
        m_iconOffset = 0.f;
        m_challenge = false;
        m_playScene = nullptr;
        m_playSprite = nullptr;
        m_progressTimer = nullptr;
        m_songWidget = nullptr;
    }
    ~LevelInfoLayer() = win inline {
        CC_SAFE_RELEASE(m_level);
        CC_SAFE_RELEASE(m_circle);
        CC_SAFE_RELEASE(m_coins);
        CC_SAFE_RELEASE(m_icons);
        auto glm = GameLevelManager::sharedState();
        if (glm->m_levelDownloadDelegate == this) glm->m_levelDownloadDelegate = nullptr;
        if (glm->m_levelUpdateDelegate == this) glm->m_levelUpdateDelegate = nullptr;
    }

    static LevelInfoLayer* create(GJGameLevel* level, bool challenge) = win 0x2f6eb0;
    static cocos2d::CCScene* scene(GJGameLevel* level, bool challenge) = win 0x2f6e60;

    virtual void keyBackClicked() = win 0x3005a0;
    virtual void keyDown(cocos2d::enumKeyCodes key) = win 0x3005b0;
    virtual void numberInputClosed(NumberInputLayer* layer) = win 0x2fd420;
    virtual bool cellPerformedAction(TableViewCell* cell, int listType, CellAction action, cocos2d::CCNode* parent) = win 0x2f9770;
    virtual void levelDownloadFinished(GJGameLevel* level) = win 0x2fb7f0;
    virtual void levelDownloadFailed(int response) = win 0x2fbb60;
    virtual void levelUpdateFinished(GJGameLevel* level, UpdateResponse response) = win 0x1fb000;
    virtual void levelUpdateFailed(int response) = win 0x2fbdf0;
    virtual void levelDeleteFinished(int id) = win 0x2fbf20;
    virtual void levelDeleteFailed(int id) = win 0x2fc060;
    virtual void rateLevelClosed() = win 0x2fe4a0;
    virtual void likedItem(LikeItemType type, int id, bool liked) = win 0x2fe720;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x2fffe0;
    virtual void setIDPopupClosed(SetIDPopup* popup, int value);
    virtual void onEnterTransitionDidFinish();

    void confirmClone(cocos2d::CCObject* sender) = win 0x2fd5f0;
    void confirmDelete(cocos2d::CCObject* sender) = win 0x2fd760;
    void confirmMoveToBottom(cocos2d::CCObject* sender) = win 0x2ff070;
    void confirmMoveToTop(cocos2d::CCObject* sender) = win 0x2fef30;
    void confirmOwnerDelete(cocos2d::CCObject* sender) = win 0x2fd8a0;
    void downloadLevel();
    void incrementDislikes() = win inline, ios inline {
        m_level->m_dislikes++;
        this->updateLabelValues();
    }
    void incrementLikes() = win inline, ios inline {
        m_level->m_likes++;
        this->updateLabelValues();
    }
    bool init(GJGameLevel* level, bool challenge);
    void loadLevelStep() = win 0x2fcff0;
    void onAddToList(cocos2d::CCObject* sender) = win 0x2f9720;
    void onBack(cocos2d::CCObject* sender) = win 0x3004b0;
    void onClone(cocos2d::CCObject* sender) = win inline {
        if (this->shouldDownloadLevel() || m_isBusy) return;
        this->setKeypadEnabled(false);
        m_isBusy = true;
        GameManager::sharedState()->m_sceneEnum = 2;
        auto level = GameLevelManager::sharedState()->createNewLevel();
        level->copyLevelInfo(m_level);
        if (m_level->m_originalLevel.value() == 0) {
            if (m_level->m_levelID.value() != 0) {
                level->m_originalLevel = m_level->m_levelID;
            }
        }
        else {
            level->m_originalLevel = m_level->m_originalLevel;
        }
        cocos2d::CCDirector::sharedDirector()->replaceScene(cocos2d::CCTransitionFade::create(0.5f, EditLevelLayer::scene(level)));
    }
    void onDelete(cocos2d::CCObject* sender) = win inline {
        m_playBtnMenu->setEnabled(false);
        GameLevelManager::sharedState()->deleteLevel(m_level);
        this->onBack(nullptr);
        m_isBusy = true;
    }
    void onFavorite(cocos2d::CCObject* sender) = win 0x2f99f0;
    void onFeatured(cocos2d::CCObject* sender) = win inline, ios inline {}
    void onGarage(cocos2d::CCObject* sender) = win 0x2f9b70;
    void onInfo(cocos2d::CCObject* sender) = win 0x2fd150;
    void onLevelInfo(cocos2d::CCObject* sender) = win 0x2fece0;
    void onLevelLeaderboard(cocos2d::CCObject* sender) = win 0x2f9a90;
    void onLevelOptions(cocos2d::CCObject* sender) = win 0x2feb90;
    void onLike(cocos2d::CCObject* sender) = win 0x2fe630;
    void onOwnerDelete(cocos2d::CCObject* sender) = win inline {
        if (m_isBusy) return;
        auto glm = GameLevelManager::sharedState();
        glm->m_levelDeleteDelegate = this;
        glm->deleteServerLevel(m_level->m_levelID.value());
        m_circle->setVisible(true);
    }
    void onPlay(cocos2d::CCObject* sender) = win 0x2fc1c0;
    void onPlayReplay(cocos2d::CCObject* sender) = win inline, ios inline {
        if (m_isBusy) return;
        if (this->shouldDownloadLevel()) {
            this->downloadLevel();
        }
        else {
            auto audioEngine = FMODAudioEngine::sharedEngine();
            audioEngine->stopAllMusic(true);
            audioEngine->playEffect("playSound_01.ogg", 1.f, 0.f, .3f);
            GameManager::sharedState()->m_sceneEnum = 3;
            cocos2d::CCDirector::sharedDirector()->replaceScene(cocos2d::CCTransitionFade::create(.5f, PlayLayer::scene(m_level, true, false)));
        }
    }
    void onRate(cocos2d::CCObject* sender) = win 0x2fdcd0;
    void onRateDemon(cocos2d::CCObject* sender) = win 0x2fe4b0;
    void onRateStars(cocos2d::CCObject* sender) = win 0x2fdfb0;
    void onRateStarsMod(cocos2d::CCObject* sender);
    void onSetFolder(cocos2d::CCObject* sender) = win 0x2f98c0;
    void onUpdate(cocos2d::CCObject* sender) = win 0x2fea50;
    void onViewProfile(cocos2d::CCObject* sender) = win 0x2fec30;
    void playStep2();
    void playStep3() = win 0x2fcf20;
    void playStep4() = win 0x2fd0a0;
    void setupLevelInfo() = win 0x2faba0;
    void setupPlatformerStats() = win 0x2fa060;
    void setupProgressBars() = win 0x2fa490;
    bool shouldDownloadLevel() = win 0x2f9c00;
    void showSongWarning() = win inline {
        auto alert = FLAlertLayer::create(
            this,
            "No Song",
            "This level uses a <cl>custom song</c> that has not been <cg>downloaded</c> yet.\n"
            "Do you want to play without music?\n"
            "<cy>Download by using the bar below</c>",
            "Cancel",
            "Play",
            300.f
        );
        alert->setTag(9);
        alert->show();
    }
    void showUpdateAlert(UpdateResponse type) = win 0x2fbd00;
    void tryCloneLevel(cocos2d::CCObject* sender) = win 0x2fd190;
    void tryShowAd() = win inline, ios inline {
        GameManager::sharedState()->tryShowInterstitial(120, 140, 0);
    }
    void updateLabelValues() = win 0x2ff1a0;
    void updateSideButtons() = win 0x2fe790;

    bool m_isBusy;
    cocos2d::CCMenu* m_playBtnMenu;
    GJGameLevel* m_level;
    cocos2d::CCArray* m_coins;
    CCMenuItemSpriteExtra* m_likeBtn;
    CCMenuItemSpriteExtra* m_starRateBtn;
    CCMenuItemSpriteExtra* m_demonRateBtn;
    void* m_unk2;
    cocos2d::CCLabelBMFont* m_lengthLabel;
    cocos2d::CCLabelBMFont* m_exactLengthLabel;
    cocos2d::CCLabelBMFont* m_downloadsLabel;
    cocos2d::CCLabelBMFont* m_likesLabel;
    cocos2d::CCLabelBMFont* m_orbsLabel;
    cocos2d::CCLabelBMFont* m_folderLabel;
    CCMenuItemSpriteExtra* m_cloneBtn;
    void* m_unk3;
    cocos2d::CCSprite* m_likesIcon;
    cocos2d::CCSprite* m_orbsIcon;
    GJLevelType m_levelType;
    bool m_noUpdateAlert;
    bool m_enterTransitionFinished;
    LoadingCircle* m_circle;
    GJDifficultySprite* m_difficultySprite;
    cocos2d::CCSprite* m_starsIcon;
    cocos2d::CCLabelBMFont* m_starsLabel;
    cocos2d::CCArray* m_icons;
    float m_iconOffset;
    cocos2d::CCPoint m_basePosition;
    float m_baseStarsY;
    bool m_challenge;
    cocos2d::CCScene* m_playScene;
    cocos2d::CCSprite* m_playSprite;
    cocos2d::CCProgressTimer* m_progressTimer;
    CustomSongWidget* m_songWidget;
}

[[link(android)]]
class LevelLeaderboard : FLAlertLayer, LeaderboardManagerDelegate, FLAlertLayerProtocol {
    // virtual ~LevelLeaderboard();

    static LevelLeaderboard* create(GJGameLevel* level, LevelLeaderboardType type, LevelLeaderboardMode mode) = win 0x300750;

    virtual void registerWithTouchDispatcher() = win 0x42660;
    virtual void keyBackClicked() = win 0x846c0;
    virtual void show();
    virtual void loadLeaderboardFinished(cocos2d::CCArray* scores, char const* key) = win 0x302910;
    virtual void loadLeaderboardFailed(char const* key) = win 0x3029b0;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x301d40;
    virtual void updateUserScoreFinished() = win 0x302360;
    virtual void updateUserScoreFailed() = win 0x302370;

    void deleteLocalScores() = win inline {
        m_level->m_localBestTimes.clear();
        m_level->m_localBestPoints.clear();
        auto parent = this->getParent();
        this->onClose(nullptr);
        if (parent) {
            parent->addChild(TextAlertPopup::create("Local scores reset.", 1.f, .6f, 150, ""), 100);
        }
    }
    cocos2d::CCArray* getLocalScores() = win 0x301ec0;
    CCMenuItemSpriteExtra* getSpriteButton(gd::string frame, cocos2d::SEL_MenuHandler selector, cocos2d::CCMenu* menu, float scale, cocos2d::CCPoint position, int button) = win 0x301a20;
    bool init(GJGameLevel* level, LevelLeaderboardType type, LevelLeaderboardMode mode) = win 0x300890;
    bool isCorrect(char const* key) = win 0x302710;
    void loadScores() = win 0x302090;
    void onChangeMode(cocos2d::CCObject* sender) = win 0x302510;
    void onChangeType(cocos2d::CCObject* sender);
    void onClose(cocos2d::CCObject* sender) = win 0x84690;
    void onDeleteLocalScores(cocos2d::CCObject* sender);
    void onUpdate(cocos2d::CCObject* sender);
    void reloadLeaderboard(LevelLeaderboardType type, LevelLeaderboardMode mode) = win 0x302380;
    void setupLeaderboard(cocos2d::CCArray* scores) = win 0x302ac0;

    GJGameLevel* m_level;
    LevelLeaderboardType m_type;
    LevelLeaderboardMode m_mode;
    cocos2d::CCArray* m_scores;
    GJCommentListLayer* m_list;
    LoadingCircle* m_circle;
    TextArea* m_noInternet;
    CCMenuItemSpriteExtra* m_refreshBtn;
    CCMenuItemSpriteExtra* m_timeBtn;
    CCMenuItemSpriteExtra* m_pointsBtn;
}

[[link(android)]]
class LevelListCell : TableViewCell {
    LevelListCell(char const* identifier, float width, float height) = ios inline : TableViewCell(identifier, width, height) {
        m_levelList = nullptr;
        m_addingLevel = false;
        this->init();
    }
    ~LevelListCell() = win inline {
        CC_SAFE_RELEASE(m_levelList);
    }

    static LevelListCell* create(float width, float height) = win inline, ios inline {
        auto ret = new LevelListCell(" ", width, height);
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win inline { return true; }
    virtual void draw() = win 0xade40;

    void loadFromList(GJLevelList* list) = win 0xbecd0;
    void onClick(cocos2d::CCObject* sender) = win 0xc0100;
    void onListInfo(cocos2d::CCObject* sender);
    void onViewProfile(cocos2d::CCObject* sender) = win 0xc0230;
    void updateBGColor(int index) = win inline {
        m_backgroundLayer->setColor(index % 2 == 0 ? cocos2d::ccColor3B { 161, 88, 44 } : cocos2d::ccColor3B { 194, 114, 62 });
        m_backgroundLayer->setOpacity(255);
    }

    GJLevelList* m_levelList;
    bool m_addingLevel;
}

[[link(android)]]
class LevelListDeleteDelegate {
    virtual void levelListDeleteFinished(int id) {}
    virtual void levelListDeleteFailed(int id) {}
}

[[link(android)]]
class LevelListLayer : LevelBrowserLayer, TextInputDelegate, SelectListIconDelegate, LikeItemDelegate, LevelListDeleteDelegate {
    LevelListLayer() {
        m_buttonMenu = nullptr;
        m_levelList = nullptr;
        m_likeButton = nullptr;
        m_exiting = false;
        m_titleInput = nullptr;
        m_editMode = 0;
        m_objects = nullptr;
        m_diffSprite = nullptr;
        m_featureSprite = nullptr;
        m_exited = false;
    }
    ~LevelListLayer() = win inline {
        GameManager::sharedState()->m_sceneEnum = 13;
        CC_SAFE_RELEASE(m_levelList);
        CC_SAFE_RELEASE(m_objects);
        auto glm = GameLevelManager::sharedState();
        if (glm->m_levelListDeleteDelegate == this) glm->m_levelListDeleteDelegate = nullptr;
    }

    static LevelListLayer* create(GJLevelList* list) = win inline {
        auto ret = new LevelListLayer();
        if (ret->init(list)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static cocos2d::CCScene* scene(GJLevelList* list) = win 0x303190;

    virtual void onEnter() = win 0x304e50;
    virtual void onExit();
    virtual void loadLevelsFinished(cocos2d::CCArray* levels, char const* key, int type) = win 0x306650;
    virtual void loadLevelsFailed(char const* key, int type) = win 0x2cc3b0;
    virtual void onBack(cocos2d::CCObject* sender) = win 0x306eb0;
    virtual void shareCommentClosed(gd::string text, ShareCommentLayer* layer) = win 0x3076b0;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x3072d0;
    virtual void setIDPopupClosed(SetIDPopup* popup, int value) = win 0x306e00;
    virtual cocos2d::CCArray* updateResultArray(cocos2d::CCArray* results);
    virtual bool cellPerformedAction(TableViewCell* cell, int listType, CellAction action, cocos2d::CCNode* parent) = win 0x3069b0;
    virtual void likedItem(LikeItemType type, int id, bool liked) = win 0x3078d0;
    virtual void iconSelectClosed(SelectListIconLayer* layer) = win 0x307b80;
    virtual void levelListDeleteFinished(int id) = win 0x3084a0;
    virtual void levelListDeleteFailed(int id) = win 0x3085d0;
    virtual void textInputOpened(CCTextInputNode* node) = win 0x308990;
    virtual void textInputClosed(CCTextInputNode* node) = win 0x308700;
    virtual void textChanged(CCTextInputNode* node) = win 0x308af0;

    void cloneList() = win 0x307f60;
    void confirmClone(cocos2d::CCObject* sender) = win 0x307e70;
    void confirmDelete(cocos2d::CCObject* sender) = win 0x3081f0;
    void confirmOwnerDelete(cocos2d::CCObject* sender) = win 0x308320;
    bool init(GJLevelList* list) = win 0x3033c0;
    void onClaimReward(cocos2d::CCObject* sender) = win 0x305e20;
    void onDelete() = win inline {
        m_buttonMenu->setEnabled(false);
        GameLevelManager::sharedState()->deleteLevelList(m_levelList);
        this->onBack(nullptr);
        m_exiting = true;
    }
    void onDescription(cocos2d::CCObject* sender) = win 0x3075e0;
    void onFavorite(cocos2d::CCObject* sender) = win 0x3074b0;
    void onInfo(cocos2d::CCObject* sender) = win 0x3077b0;
    void onLike(cocos2d::CCObject* sender) = win 0x3077f0;
    void onListInfo(cocos2d::CCObject* sender);
    void onRefreshLevelList(cocos2d::CCObject* sender) = win 0x306490;
    void onSelectIcon(cocos2d::CCObject* sender) = win 0x307a30;
    void onShare(cocos2d::CCObject* sender) = win 0x307ba0;
    void onToggleEditMode(cocos2d::CCObject* sender) = win 0x307e30;
    void onViewProfile(cocos2d::CCObject* sender) = win 0x307470;
    void ownerDelete() = win inline {
        auto glm = GameLevelManager::sharedState();
        glm->m_levelListDeleteDelegate = this;
        glm->deleteServerLevelList(m_levelList->m_listID);
        m_circle->setVisible(true);
    }
    void updateEditMode() = win inline, ios inline {
        if (!m_list) return;
        auto listView = static_cast<CustomListView*>(m_list->m_listView);
        listView->m_cellMode = m_editMode;
        listView->reloadAll();
    }
    void updateSideButtons() = win 0x307930;
    void updateStatsArt() = win 0x304ea0;
    void verifyListName() = win inline {
        if (!m_levelList->m_listName.empty()) return;
        m_levelList->m_listName = m_levelList->m_unkString.empty() ? "Unknown" : m_levelList->m_unkString;
    }

    cocos2d::CCMenu* m_buttonMenu;
    gd::string m_searchKey1;
    GJLevelList* m_levelList;
    gd::string m_searchKey2;
    CCMenuItemSpriteExtra* m_likeButton;
    bool m_exiting;
    CCTextInputNode* m_titleInput;
    int m_editMode;
    cocos2d::CCArray* m_objects;
    cocos2d::CCSprite* m_diffSprite;
    cocos2d::CCSprite* m_featureSprite;
    cocos2d::CCPoint m_rewardPosition;
    bool m_exited;
}

[[link(android)]]
class LevelManagerDelegate {
    virtual void loadLevelsFinished(cocos2d::CCArray* levels, char const* key) {
        this->loadLevelsFinished(levels, key, 0);
    }
    virtual void loadLevelsFailed(char const* key) {
        this->loadLevelsFailed(key, 0);
    }
    virtual void loadLevelsFinished(cocos2d::CCArray* levels, char const* key, int type) {}
    virtual void loadLevelsFailed(char const* key, int type) {}
    virtual void setupPageInfo(gd::string info, char const* key) {}
}

[[link(android)]]
class LevelOptionsLayer : GJOptionsLayer {
    // virtual ~LevelOptionsLayer();
    LevelOptionsLayer() {
        m_settingsObject = nullptr;
    }

    static LevelOptionsLayer* create(LevelSettingsObject* object) = win inline {
        auto ret = new LevelOptionsLayer();
        if (ret->init(object)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void valueDidChange(int tag, float value) = win 0x324490;
    virtual float getValue(int tag) = win 0x3244b0;
    virtual void setupOptions() = win 0x323df0;
    virtual void didToggle(int tag) = win 0x3244d0;

    bool init(LevelSettingsObject* object) = win 0x323d80;
    void onSettings(cocos2d::CCObject* sender) = win 0x3242b0;

    LevelSettingsObject* m_settingsObject;
}

[[link(android)]]
class LevelOptionsLayer2 : LevelOptionsLayer {
    // virtual ~LevelOptionsLayer2();
    LevelOptionsLayer2() {}

    static LevelOptionsLayer2* create(LevelSettingsObject* object) = win inline {
        auto ret = new LevelOptionsLayer2();
        if (ret->init(object)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void setupOptions() = win 0x324730;

    bool init(LevelSettingsObject* object) = win inline {
        if (!LevelOptionsLayer::init(object)) return false;
        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        auto titleLabel = cocos2d::CCLabelBMFont::create("Legacy Options", "goldFont.fnt");
        titleLabel->setScale(.7f);
        titleLabel->setPosition(winSize * .5f + cocos2d::CCPoint { 0.f, m_height * .5f - 20.f });
        m_mainLayer->addChild(titleLabel);
        return true;
    }
}

[[link(android)]]
class LevelPage : cocos2d::CCLayer, DialogDelegate {
    LevelPage() {
        m_isBusy = false;
        m_level = nullptr;
        m_levelMenu = nullptr;
        m_coinObject = nullptr;
        m_secretDoor = nullptr;
    }
    ~LevelPage() = win inline {
        CC_SAFE_RELEASE(m_level);
        CC_SAFE_RELEASE(m_dynamicObjects);
        CC_SAFE_RELEASE(m_progressObjects);
        CC_SAFE_RELEASE(m_coins);
        CC_SAFE_RELEASE(m_levelObjects);
    }

    static LevelPage* create(GJGameLevel* level) = win inline {
        auto ret = new LevelPage();
        if (ret->init(level)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x31e010;
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline {}
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline {}
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event);
    virtual void registerWithTouchDispatcher() = win 0x9b7f0;
    virtual void dialogClosed(DialogLayer* layer) = win 0x31d520;

    void addSecretCoin() = win 0x31c120;
    void addSecretDoor();
    bool init(GJGameLevel* level) = win 0x3199a0;
    void onInfo(cocos2d::CCObject* sender) = win 0x31db70;
    void onMoreGames(cocos2d::CCObject* sender) = win inline, ios inline {
        GameManager::sharedState()->reportAchievementWithID("geometry.ach.moreGames", 100, false);
        auto layer = GJMoreGamesLayer::create();
        cocos2d::CCDirector::sharedDirector()->getRunningScene()->addChild(layer, 100);
        layer->showLayer(false);
    }
    void onPlay(cocos2d::CCObject* sender) = win 0x31d600, ios 0x1234567, imac 0x1234567, m1 0x1234567;
    void onSecretDoor(cocos2d::CCObject* sender) = win 0x31ca40;
    void onTheTower(cocos2d::CCObject* sender) = win 0x31ba60;
    void playCoinEffect() = win 0x31c360;
    void playStep2();
    void playStep3() = win 0x31da70;
    void updateDynamicPage(GJGameLevel* level);

    bool m_isBusy;
    GJGameLevel* m_level;
    cocos2d::CCMenu* m_levelMenu;
    cocos2d::extension::CCScale9Sprite* m_levelDisplay;
    cocos2d::CCLabelBMFont* m_normalProgressLabel;
    cocos2d::CCLabelBMFont* m_practiceProgressLabel;
    cocos2d::CCLabelBMFont* m_nameLabel;
    cocos2d::CCLabelBMFont* m_starsLabel;
    float m_progressWidth;
    cocos2d::CCSprite* m_normalProgressBar;
    cocos2d::CCSprite* m_practiceProgressBar;
    cocos2d::CCSprite* m_difficultySprite;
    cocos2d::CCSprite* m_starsSprite;
    cocos2d::CCSize m_levelDisplaySize;
    cocos2d::CCArray* m_coins;
    cocos2d::CCArray* m_dynamicObjects;
    cocos2d::CCArray* m_levelObjects;
    cocos2d::CCArray* m_progressObjects;
    GameObject* m_coinObject;
    cocos2d::CCSprite* m_secretDoor;
}

[[link(android)]]
class LevelSearchLayer : cocos2d::CCLayer, TextInputDelegate, FLAlertLayerProtocol, DemonFilterDelegate {
    LevelSearchLayer() {
        m_type = 0;
        m_searchInput = nullptr;
        m_starsSprite = nullptr;
        m_difficultySprites = nullptr;
        m_lengthSprites = nullptr;
        m_difficultyDict = nullptr;
        m_lastDifficultySprite = nullptr;
        m_demonTypeButton = nullptr;
    }
    ~LevelSearchLayer() = win inline {
        CC_SAFE_RELEASE(m_difficultyDict);
        CC_SAFE_RELEASE(m_difficultySprites);
        CC_SAFE_RELEASE(m_lengthSprites);
    }

    static LevelSearchLayer* create(int type) = win inline {
        auto ret = new LevelSearchLayer();
        if (ret->init(type)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static cocos2d::CCScene* scene(int type) = win 0x30bdc0;

    virtual void keyBackClicked() = win 0x3125f0;
    virtual void textInputOpened(CCTextInputNode* node);
    virtual void textInputClosed(CCTextInputNode* node);
    virtual void textChanged(CCTextInputNode* node);
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x30f530;
    virtual void demonFilterSelectClosed(int filter) = win 0x30e060;

    bool checkDiff(int diff);
    bool checkTime(int time);
    void clearFilters() = win 0x30e510;
    void confirmClearFilters(cocos2d::CCObject* sender);
    char const* getDiffKey(int diff) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("D%i", diff)->getCString();
    }
    gd::string getLevelLenKey() = win inline {
        return GameLevelManager::sharedState()->getLengthStr(
            this->checkTime(0),
            this->checkTime(1),
            this->checkTime(2),
            this->checkTime(3),
            this->checkTime(4),
            this->checkTime(5)
        );
    }
    gd::string getSearchDiffKey() = win inline {
        return GameLevelManager::sharedState()->getDifficultyStr(
            this->checkDiff(0),
            this->checkDiff(1),
            this->checkDiff(2),
            this->checkDiff(3),
            this->checkDiff(4),
            this->checkDiff(5),
            this->checkDiff(6),
            this->checkDiff(7)
        );
    }
    GJSearchObject* getSearchObject(SearchType type, gd::string query) = win 0x30fb00;
    char const* getTimeKey(int time) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("T%i", time)->getCString();
    }
    bool init(int type) = win 0x30bf10;
    void onBack(cocos2d::CCObject* sender) = win 0x311970;
    void onClearFreeSearch(cocos2d::CCObject* sender) = win 0x311930;
    void onClose(cocos2d::CCObject* sender) = win inline, ios inline {
        m_searchInput->onClickTrackNode(false);
    }
    void onFollowed(cocos2d::CCObject* sender) = win 0x311330;
    void onFriends(cocos2d::CCObject* sender) = win 0x311270;
    void onLatestStars(cocos2d::CCObject* sender) = win 0x3111b0;
    void onMagic(cocos2d::CCObject* sender) = win 0x311030;
    void onMoreOptions(cocos2d::CCObject* sender) = win 0x30e2f0;
    void onMostDownloaded(cocos2d::CCObject* sender) = win 0x310d30;
    void onMostLikes(cocos2d::CCObject* sender) = win 0x310df0;
    void onMostRecent(cocos2d::CCObject* sender) = win 0x3110f0;
    void onSearch(cocos2d::CCObject* sender) = win 0x3114b0;
    void onSearchMode(cocos2d::CCObject* sender) = win 0x30e2a0;
    void onSearchUser(cocos2d::CCObject* sender) = win 0x3116f0;
    void onSpecialDemon(cocos2d::CCObject* sender) = win 0x30df00;
    void onStarAward(cocos2d::CCObject* sender) = win inline, ios inline {
        this->onClose(nullptr);
        cocos2d::CCDirector::sharedDirector()->pushScene(cocos2d::CCTransitionFade::create(.5f, LevelBrowserLayer::scene(this->getSearchObject(SearchType::Sends, ""))));
    }
    void onSuggested(cocos2d::CCObject* sender) = win 0x310eb0;
    void onTrending(cocos2d::CCObject* sender) = win 0x310f70;
    void toggleDifficulty(cocos2d::CCObject* sender) = win 0x311cf0;
    void toggleDifficultyNum(int diff, bool enabled) = win 0x312050;
    void toggleStar(cocos2d::CCObject* sender) = win 0x3119e0;
    void toggleTime(cocos2d::CCObject* sender) = win 0x3122b0;
    void toggleTimeNum(int time, bool enabled) = win 0x312460;
    void updateSearchLabel(char const* label) = win 0x30f790;

    int m_type;
    CCTextInputNode* m_searchInput;
    cocos2d::CCSprite* m_starsSprite;
    cocos2d::CCArray* m_difficultySprites;
    cocos2d::CCArray* m_lengthSprites;
    cocos2d::CCDictionary* m_difficultyDict;
    cocos2d::CCSprite* m_lastDifficultySprite;
    CCMenuItemSpriteExtra* m_demonTypeButton;
}

[[link(android)]]
class LevelSelectLayer : cocos2d::CCLayer, BoomScrollLayerDelegate, DynamicScrollDelegate {
    // virtual ~LevelSelectLayer();
    LevelSelectLayer() {
        m_width = 0.f;
        m_backgroundSprite = nullptr;
        m_groundLayer = nullptr;
        m_scrollLayer = nullptr;
        m_unknown = 0;
        m_scrolls = 0;
        m_masterDetectiveUnlocked = false;
    }

    static LevelSelectLayer* create(int page) = win inline {
        auto ret = new LevelSelectLayer();
        if (ret->init(page)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static cocos2d::CCScene* scene(int page) = win 0x318040;

    virtual void keyBackClicked() = win 0x319800;
    virtual void keyDown(cocos2d::enumKeyCodes key) = win 0x319850;
    virtual void updatePageWithObject(cocos2d::CCObject* layer, cocos2d::CCObject* object) = win 0x318f80;
    virtual void scrollLayerMoved(cocos2d::CCPoint position) = win 0x318ff0;

    cocos2d::ccColor3B colorForPage(int page) = win 0x319310;
    cocos2d::ccColor3B getColorValue(int page1, int page2, float progress) = win inline {
        auto modifier = std::clamp(progress * 2.f / 3.f - .2f, 0.f, 1.f);
        auto color1 = this->colorForPage(page1);
        auto color2 = this->colorForPage(page2);
        if (modifier > .8f) modifier = 1.f;
        else if (modifier < .2f) modifier = 0.f;
        else modifier = (modifier - .2f) / .6f;
        auto complement = 1.f - modifier;
        cocos2d::ccColor3B ret;
        ret.r = color1.r * complement + color2.r * modifier;
        ret.g = color1.g * complement + color2.g * modifier;
        ret.b = color1.b * complement + color2.b * modifier;
        return ret;
    }
    bool init(int page) = win 0x318170;
    void onBack(cocos2d::CCObject* sender) = win 0x3197b0;
    void onDownload(cocos2d::CCObject* sender);
    void onInfo(cocos2d::CCObject* sender) = win 0x319930;
    void onNext(cocos2d::CCObject* sender);
    void onPlay(cocos2d::CCObject* sender) = win inline {
        if (!*reinterpret_cast<bool*>(geode::base::get() + 0x6a3048)) {
            static_cast<LevelPage*>(m_scrollLayer->getPage(m_scrollLayer->m_page))->onPlay(nullptr);
        }
    }
    void onPrev(cocos2d::CCObject* sender);
    void tryShowAd() = win inline, ios inline {
        GameManager::sharedState()->tryShowInterstitial(120, 140, 0);
    }

    float m_width;
    cocos2d::CCSprite* m_backgroundSprite;
    GJGroundLayer* m_groundLayer;
    BoomScrollLayer* m_scrollLayer;
    int m_unknown;
    int m_scrolls;
    bool m_masterDetectiveUnlocked;
}

[[link(android)]]
class LevelSettingsDelegate {
    virtual void levelSettingsUpdated() {}
}

[[link(android)]]
class LevelSettingsLayer : FLAlertLayer, ColorSelectDelegate, SelectArtDelegate, SelectSettingDelegate, FLAlertLayerProtocol, CustomSongLayerDelegate, TextInputDelegate {
    // virtual ~LevelSettingsLayer();

    static LevelSettingsLayer* create(LevelSettingsObject* object, LevelEditorLayer* layer) = win 0x31e5b0;

    virtual void registerWithTouchDispatcher() = win 0x321060;
    virtual void keyBackClicked() = win 0x321f00;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0xc3e50;
    virtual void colorSelectClosed(cocos2d::CCNode* popup) = win 0x321790;
    virtual void selectArtClosed(SelectArtLayer* layer) = win 0x321bb0;
    virtual void selectSettingClosed(SelectSettingLayer* layer) = win 0x320ee0;
    virtual void textInputClosed(CCTextInputNode* node);
    virtual void textChanged(CCTextInputNode* node) = win 0x321390;

    void createToggleButton(gd::string label, cocos2d::SEL_MenuHandler selector, bool toggled, cocos2d::CCMenu* menu, cocos2d::CCPoint position) = win 0x3210e0;
    bool init(LevelSettingsObject* object, LevelEditorLayer* layer) = win 0x31e7a0;
    void onBGArt(cocos2d::CCObject* sender) = win 0x321970;
    void onClose(cocos2d::CCObject* sender) = win 0x321560;
    void onCol(cocos2d::CCObject* sender);
    void onDisable(cocos2d::CCObject* sender);
    void onFGArt(cocos2d::CCObject* sender) = win 0x321a40;
    void onGameplayMode(cocos2d::CCObject* sender) = win 0x320cb0;
    void onGArt(cocos2d::CCObject* sender) = win 0x3219c0;
    void onLiveEdit(cocos2d::CCObject* sender) = win 0x3216a0;
    void onMode(cocos2d::CCObject* sender) = win 0x320e80;
    void onOptionToggle(cocos2d::CCObject* sender) = win 0x321350;
    void onSelectFont(cocos2d::CCObject* sender);
    void onSelectMode(cocos2d::CCObject* sender);
    void onSelectSpeed(cocos2d::CCObject* sender);
    void onSettings(cocos2d::CCObject* sender) = win 0x320dc0;
    void onShowPicker(cocos2d::CCObject* sender) = win 0x3216f0;
    void onSpeed(cocos2d::CCObject* sender) = win 0x320e30;
    void showPicker(ColorAction* action) = win inline, ios inline {
        auto popup = ColorSelectPopup::create(action);
        popup->m_delegate = this;
        popup->show();
    }
    void updateColorSprite(ColorChannelSprite* sprite) = win 0x321810;
    void updateColorSprites() = win 0x3217a0;
    void updateGameplayModeButtons() = win 0x320cf0;

    SongSelectNode* m_songSelectNode;
    Speed m_speed;
    ColorChannelSprite* m_bgColorSprite;
    ColorChannelSprite* m_gColorSprite;
    ColorChannelSprite* m_g2ColorSprite;
    ColorChannelSprite* m_lineColorSprite;
    ColorChannelSprite* m_mgColorSprite;
    ColorChannelSprite* m_mg2ColorSprite;
    cocos2d::CCSprite* m_moreColorsSprite;
    cocos2d::CCSprite* m_backgroundSprite;
    cocos2d::CCSprite* m_groundSprite;
    cocos2d::CCSprite* m_middlegroundSprite;
    cocos2d::CCSprite* m_speedSprite;
    cocos2d::CCSprite* m_modeSprite;
    LevelSettingsObject* m_settingsObject;
    void* m_unkPtr;
    cocos2d::CCArray* m_modeToggles;
    cocos2d::CCArray* m_speedButtons;
    LevelSettingsDelegate* m_delegate;
    LevelEditorLayer* m_editorLayer;
    CCTextInputNode* m_orderInput;
    CCTextInputNode* m_channelInput;
    CCMenuItemSpriteExtra* m_classicButton;
    CCMenuItemSpriteExtra* m_platformerButton;
    bool m_disableInput;
}

[[link(android)]]
class LevelSettingsObject : cocos2d::CCNode {
    // virtual ~LevelSettingsObject();

    static LevelSettingsObject* create();
    static LevelSettingsObject* objectFromDict(cocos2d::CCDictionary* dict);
    static LevelSettingsObject* objectFromString(gd::string const& str) = win inline {
        return objectFromDict(GameToolbox::stringSetupToDict(str, ","));
    }

    virtual bool init() = win 0x2eaab0;

    gd::string getSaveString() = win 0x2eadc0;
    void setupColorsFromLegacyMode(cocos2d::CCDictionary* dict) = win 0x2ee090;
    bool shouldUseYSection() = win inline {
        return m_platformerMode || m_dynamicLevelHeight;
    }

    GJEffectManager* m_effectManager;
    // property kA2
    int m_startMode;
    // property kA4
    Speed m_startSpeed;
    // property kA3
    bool m_startMini;
    // property kA8
    bool m_startDual;
    // property kA28
    bool m_mirrorMode;
    // property kA29
    bool m_rotateGameplay;
    // property kA10
    bool m_twoPlayerMode;
    // property kA22
    bool m_platformerMode;
    // property kA13
    float m_songOffset;
    // property kA15
    bool m_fadeIn;
    // property kA16
    bool m_fadeOut;
    // property kA46
    bool m_dontReset;
    // property kA6
    int m_backgroundIndex;
    // property kA7
    int m_groundIndex;
    // property kA18
    int m_fontIndex;
    // property kA25
    int m_middleGroundIndex;
    // property kA9
    bool m_startsWithStartPos;
    // property kA11
    bool m_isFlipped;
    // property kA20
    bool m_reverseGameplay;
    // property kA21
    bool m_disableStartPos;
    // property kA19
    int m_targetOrder;
    // property kA26
    int m_targetChannel;
    GJGameLevel* m_level;
    // property kA14
    gd::string m_guidelineString;
    bool m_guidelinesUpdated;
    // property kS39
    int m_colorPage;
    // property kA17
    int m_groundLineIndex;
    // property kA23
    bool m_propertykA23;
    // property kA24
    bool m_propertykA24;
    // property kA43
    bool m_noTimePenalty;
    // property kA44
    int m_propertykA44;
    // property kA35
    bool m_resetCamera;
    // property kA36
    int m_spawnGroup;
    // property kA27
    bool m_allowMultiRotation;
    // property kA31
    bool m_enablePlayerSqueeze;
    // property kA32
    bool m_fixGravityBug;
    // property kA33
    bool m_fixNegativeScale;
    // property kA34
    bool m_fixRobotJump;
    // property kA37
    bool m_dynamicLevelHeight;
    // property kA38
    bool m_sortGroups;
    // property kA39
    bool m_fixRadiusCollision;
    // property kA40
    bool m_enable22Changes;
    // property kA41
    bool m_allowStaticRotate;
    // property kA42
    bool m_reverseSync;
    // property kA45
    bool m_decreaseBoostSlide;
}

[[link(android)]]
class LevelTools {
    static int artistForAudio(int id) = win 0x328d70;
    static gd::string base64DecodeString(gd::string str) = win inline {
        return str.empty() ? str : cocos2d::ZipUtils::base64URLDecode(str);
    }
    static gd::string base64EncodeString(gd::string str) = win inline {
        return str.empty() ? str : cocos2d::ZipUtils::base64URLEncode(str);
    }
    static cocos2d::CCDictionary* createStarPackDict() = win inline {
        auto dict = cocos2d::CCDictionary::create();
        std::string packs = "1,3,2,4,3,4,5,5,6,6,7,6,8,7,9,8,10,8,11,9,19,10,20,10,21,10,22,10,26,"
                            "10,27,10,28,10,29,10,30,10,31,10,32,4,33,5,34,6,35,8,36,8,37,5,38,5,39,"
                            "6,40,7,41,8,42,8,43,8,44,9,45,6,46,10,47,10,48,10,49,10,50,10,52,4,53,3,"
                            "54,4,55,4,56,5,57,6,58,7,59,8,60,8,61,8,62,9,63,9,64,10,65,10,66,10";
        auto parts = cocos2d::CCArray::create();
        auto start = 0;
        auto index = packs.find_first_of(",");
        auto size = packs.size();
        while (index != std::string::npos) {
            auto str = packs.substr(start, index - start);
            if (!str.empty() || start != size) {
                parts->addObject(cocos2d::CCString::create(str));
            }
            start = index + 1;
            index = packs.find_first_of(",", start);
        }
        for (int i = 1; i < parts->count(); i += 2) {
            dict->setObject(parts->stringAtIndex(i), parts->stringAtIndex(i - 1)->intValue());
        }
        return dict;
    }
    static gd::string fbURLForArtist(int id);
    static int getAudioBPM(int id) = win inline, ios inline {
        switch (id) {
            case 0: return 160;
            case 1: return 142;
            case 2: return 163;
            case 3: return 145;
            case 4: return 142;
            case 5: return 170;
            case 6: return 178;
            case 7: return 143;
            case 8: return 140;
            case 10: return 140;
            case 12: return 170;
            default: return 130;
        }
    }
    static gd::string getAudioFileName(int id) = win 0x3281a0;
    static gd::string getAudioString(int id) = win 0x32b380;
    static gd::string getAudioTitle(int id) = win 0x327620;
    static bool getLastGameplayReversed() = win inline, ios inline {
        return *reinterpret_cast<bool*>(geode::base::get() + GEODE_WINDOWS(0x6a4c06) GEODE_IOS(0x85f0c0));
    }
    static bool getLastGameplayRotated() = win inline {
        return *reinterpret_cast<bool*>(geode::base::get() + 0x6a4c05);
    }
    static float getLastTimewarp() = win inline {
        return *reinterpret_cast<float*>(geode::base::get() + 0x69c198);
    }
    static GJGameLevel* getLevel(int id, bool noString) = win 0x324d70;
    static gd::unordered_set<int> getLevelList() = win inline {
        auto levelStart = reinterpret_cast<int*>(geode::base::get() + 0x608580);
        auto levelList = std::unordered_set<int>(levelStart, levelStart + 40);
        levelList.insert(5002);
        levelList.insert(5003);
        levelList.insert(5004);
        return levelList;
    }
    static SongInfoObject* getSongObject(int id) = win inline {
        auto artistID = artistForAudio(id);
        return SongInfoObject::create(id, getAudioTitle(id), nameForArtist(artistID), artistID, 0.f, "", "", "", 0, "", false, 0, -1);
    }
    static void moveTriggerObjectsToArray(cocos2d::CCArray* objects, cocos2d::CCDictionary* objectsDict, int index) = win 0x32d310;
    static gd::string nameForArtist(int id) = win 0x328e40;
    static gd::string ngURLForArtist(int id) = win 0x32a460;
    static float offsetBPMForTrack(int id) = win inline, ios inline {
        return id == 11 ? .1f : id == 13 ? .07f : .0f;
    }
    static cocos2d::CCPoint posForTime(float time, cocos2d::CCArray* objects, int speed, bool platformer, int& rotateChannel) = win inline {
        return posForTimeInternal(time, objects, speed, platformer, false, false, rotateChannel, 0);
    }
    static cocos2d::CCPoint posForTimeInternal(float time, cocos2d::CCArray* objects, int speed, bool platformer, bool ignoreMinorAxis, bool ignoreWarp, int& rotateChannel, int unused) = win 0x32c8d0;
    static void sortChannelOrderObjects(cocos2d::CCArray* objects, cocos2d::CCDictionary* objectsDict, bool moveObjects) = win 0x32d3e0;
    static void sortSpeedObjects(cocos2d::CCArray* objects, GJBaseGameLayer* layer) = win 0x32d660;
    static float timeForPos(cocos2d::CCPoint position, cocos2d::CCArray* objects, int speed, int order, int channel, bool songTriggers, bool platformer, bool ignoreWarp, bool ignoreRotate, int id) = win 0x32bef0;
    static void toggleDebugLogging(bool enabled) = win inline, ios inline {}
    static gd::string urlForAudio(int id) = win 0x329140;
    static float valueForSpeedMod(int speed) = win inline, ios inline {
        switch (speed) {
            case 1: return 251.16008f;
            case 2: return 387.42014f;
            case 3: return 468.00015f;
            case 4: return 576.00018f;
            default: return 311.5801f;
        }
    }
    static bool verifyLevelIntegrity(gd::string str, int id) = win 0x32d0f0;
    static gd::string ytURLForArtist(int id) = win 0x32a900;
}

[[link(android)]]
class LevelUpdateDelegate {
    virtual void levelUpdateFinished(GJGameLevel* level, UpdateResponse response) {}
    virtual void levelUpdateFailed(int response) {}
}

[[link(android)]]
class LevelUploadDelegate {
    virtual void levelUploadFinished(GJGameLevel* level) {}
    virtual void levelUploadFailed(GJGameLevel* level) {}
}

[[link(android)]]
class LikeItemDelegate {
    virtual void likedItem(LikeItemType type, int id, bool liked) {}
}

[[link(android)]]
class LikeItemLayer : FLAlertLayer {
    // virtual ~LikeItemLayer();
    LikeItemLayer() {
        m_itemType = LikeItemType::Unknown;
        m_itemID = 0;
        m_commentSourceID = 0;
        m_likeDelegate = nullptr;
    }

    static LikeItemLayer* create(LikeItemType type, int id, int parentID) = win 0x32da90;

    virtual void keyBackClicked() = win 0x846c0;

    bool init(LikeItemType type, int id, int parentID) = win 0x32db90;
    void onClose(cocos2d::CCObject* sender) = win 0x84690;
    void onDislike(cocos2d::CCObject* sender);
    void onLike(cocos2d::CCObject* sender) = win 0x32df60;
    void triggerLike(bool isLiked) = win 0x32df80;

    LikeItemType m_itemType;
    int m_itemID;
    int m_commentSourceID;
    LikeItemDelegate* m_likeDelegate;
}

[[link(android)]]
class ListButtonBar : cocos2d::CCNode {
    // virtual ~ListButtonBar();

    static ListButtonBar* create(cocos2d::CCArray* items, cocos2d::CCPoint position, int columns, int rows, float columnOffset, float rowOffset, float offset, float arrowOffset, int arrowType) = win 0x6adc0;

    int getPage() = win inline, ios inline {
        return m_scrollLayer->getRelativePageForNum(m_scrollLayer->m_page);
    }
    void goToPage(int page) = win 0x6b3d0;
    bool init(cocos2d::CCArray* items, cocos2d::CCPoint position, int columns, int rows, float columnOffset, float rowOffset, float offset, float arrowOffset, int arrowType) = win 0x6aed0;
    void onLeft(cocos2d::CCObject* sender) = win 0x6b480;
    void onRight(cocos2d::CCObject* sender) = win 0x6b460;

    BoomScrollLayer* m_scrollLayer;
    cocos2d::CCArray* m_pages;
    ListButtonBarDelegate* m_delegate;
    bool m_useMoveAnimation;
}

[[link(android)]]
class ListButtonBarDelegate {
    virtual void listButtonBarSwitchedPage(ListButtonBar* bar, int page) {}
}

[[link(android)]]
class ListButtonPage : cocos2d::CCLayer {
    // virtual ~ListButtonPage();

    static ListButtonPage* create(cocos2d::CCArray* items, cocos2d::CCPoint position, int columns, int rows, float columnOffset, float rowOffset, float offset) = win 0x6b4a0;

    bool init(cocos2d::CCArray* items, cocos2d::CCPoint position, int columns, int rows, float columnOffset, float rowOffset, float offset) = win inline {
        if (!cocos2d::CCLayer::init()) return false;
        auto menu = cocos2d::CCMenu::create();
        this->addChild(menu);
        auto x = position.x;
        auto y = position.y;
        auto index = 0;
        for (int i = 0; i < items->count(); i++) {
            auto row = index / columns;
            auto item = static_cast<cocos2d::CCNode*>(items->objectAtIndex(i));
            if (item->getTag() == 2) {
                index += columns - (index % columns);
            }
            else {
                menu->addChild(item);
                item->setPosition(menu->convertToNodeSpace({
                    (columnOffset + offset) * (index % columns) + offset * .5f + (x - columns * .5f * offset - (columns - 1) * .5f * columnOffset),
                    ((rows - 1) * .5f * (rowOffset + offset) + y) - row * (rowOffset + offset)
                }));
                index++;
            }
        }
        return true;
    }
}

[[link(android)]]
class ListCell : TableViewCell {
    // virtual ~ListCell();
    ListCell(char const* identifier, float width, float height) = win inline, ios inline : TableViewCell(identifier, width, height) {
        this->init();
    }

    virtual bool init() = win inline { return true; }
    virtual void draw() = win 0x3c750;

    void loadFromObject(cocos2d::CCObject* object, int id, int page, int index) = win inline, ios inline {}
    void updateBGColor(int index) = win inline, ios inline {}

    int m_unk230;
}

[[link(android)]]
class ListUploadDelegate {
    virtual void listUploadFinished(GJLevelList* list) {}
    virtual void listUploadFailed(GJLevelList* list, int response) {}
}

[[link(android)]]
class LoadingCircle : cocos2d::CCLayerColor {
    // virtual ~LoadingCircle();
    LoadingCircle() {
        m_sprite = nullptr;
        m_parentLayer = nullptr;
        m_fade = false;
    }

    static LoadingCircle* create() = win 0x6b890;

    virtual bool init() = win 0x6b990;
    virtual void draw() = win 0x6bc10;
    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) { return true; }
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) {}
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) {}
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) {}
    virtual void registerWithTouchDispatcher() = win 0x6bc30;

    void fadeAndRemove() = win 0x6bb70;
    void setFade(bool fade) {
        m_fade = fade;
    }
    void setParentLayer(cocos2d::CCLayer* layer) {
        m_parentLayer = layer;
    }
    void show() = win 0x6ba70;

    cocos2d::CCSprite* m_sprite;
    cocos2d::CCLayer* m_parentLayer;
    bool m_fade;
}

[[link(android)]]
class LoadingCircleSprite : cocos2d::CCSprite {
    // virtual ~LoadingCircleSprite();

    /// Create a Loading Circle Sprite with a spinning action
    /// @param spinSpeed A speed modifier, higher is faster and lower is slower
    static LoadingCircleSprite* create(float spinSpeed) = win 0x6bc80;

    cocos2d::CCAction* fadeInCircle(bool resetOpacity, float duration, float opacity) = win 0x6bd80;
    void hideCircle() = win inline {
        this->stopActionByTag(0);
        this->setOpacity(0);
        this->setVisible(false);
    }
    bool init(float spinSpeed) = win inline {
        if (!CCSprite::initWithFile("loadingCircle.png")) return false;
        this->setBlendFunc({ GL_SRC_ALPHA, GL_ONE });
        this->runAction(cocos2d::CCRepeatForever::create(cocos2d::CCRotateBy::create(1.f, spinSpeed * 360.f)));
        return true;
    }
}

[[link(android)]]
class LoadingLayer : cocos2d::CCLayer {
    LoadingLayer() {
        m_unknown = false;
        m_unknown2 = false;
        m_loadStep = 0;
        m_caption = nullptr;
        m_textArea = nullptr;
        m_sliderBar = nullptr;
        m_sliderGrooveXPos = 0.f;
        m_sliderGrooveHeight = 0.f;
        m_fromRefresh = false;
    }
    ~LoadingLayer() = win inline {
        CCNode::removeAllChildrenWithCleanup(true);
    }

    static LoadingLayer* create(bool refresh) = win inline {
        auto ret = new LoadingLayer();
        if (ret->init(refresh)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static cocos2d::CCScene* scene(bool refresh) = win 0x32e0e0;

    const char* getLoadingString() = win 0x32f520;
    bool init(bool refresh) = win 0x32e1f0, ios 0x1234567, imac 0x1234567, m1 0x1234567;
    void loadAssets() = win 0x32ea90, ios 0x1234567, imac 0x1234567, m1 0x1234567;
    void loadingFinished() = win inline {
        cocos2d::CCDirector::sharedDirector()->replaceScene(MenuLayer::scene(m_fromRefresh));
    }
    void updateProgress(int progress) = win 0x32ea10;

    bool m_unknown;
    bool m_unknown2;
    int m_loadStep;
    cocos2d::CCLabelBMFont* m_caption;
    TextArea* m_textArea;
    cocos2d::CCSprite* m_sliderBar;
    float m_sliderGrooveXPos;
    float m_sliderGrooveHeight;
    bool m_fromRefresh;
}

[[link(android)]]
class LocalLevelManager : GManager {
    static LocalLevelManager* get() {
        return LocalLevelManager::sharedState();
    }
    // virtual ~LocalLevelManager();
    static LocalLevelManager* sharedState() = win 0x32fc60;

    virtual bool init() = win 0x32fd00;
    virtual void encodeDataTo(DS_Dictionary* dict) = win 0x3306d0;
    virtual void dataLoaded(DS_Dictionary* dict) = win 0x330730;
    virtual void firstLoad() = win 0x330640;

    cocos2d::CCDictionary* getAllLevelsInDict() = win 0x3300d0;
    cocos2d::CCArray* getAllLevelsWithName(gd::string name) = win inline {
        auto ret = cocos2d::CCArray::create();
        for (int i = 0; i < m_localLevels->count(); i++) {
            auto level = static_cast<GJGameLevel*>(m_localLevels->objectAtIndex(i));
            if (level->m_levelName == name) ret->addObject(level);
        }
        return ret;
    }
    cocos2d::CCArray* getCreatedLevels(int folder) = win inline {
        if (folder < 1) return m_localLevels;
        auto ret = cocos2d::CCArray::create();
        CCObject* obj;
        CCARRAY_FOREACH(m_localLevels, obj) {
            if (!obj) return ret;
            if (static_cast<GJGameLevel*>(obj)->m_levelFolder == folder) ret->addObject(obj);
        }
        return ret;
    }
    cocos2d::CCArray* getCreatedLists(int folder) = win inline {
        if (folder < 1) return m_localLists;
        auto ret = cocos2d::CCArray::create();
        CCObject* obj;
        CCARRAY_FOREACH(m_localLists, obj) {
            if (!obj) return ret;
            if (static_cast<GJLevelList*>(obj)->m_folder == folder) ret->addObject(obj);
        }
        return ret;
    }
    cocos2d::CCDictionary* getLevelsInNameGroups() = win inline {
        auto dict = cocos2d::CCDictionary::create();
        for (int i = 0; i < m_localLevels->count(); i++) {
            auto level = static_cast<GJGameLevel*>(m_localLevels->objectAtIndex(i));
            auto key = level->m_levelName;
            auto arr = static_cast<cocos2d::CCArray*>(dict->objectForKey(key));
            if (!arr) {
                arr = cocos2d::CCArray::create();
                dict->setObject(arr, key);
            }
            arr->addObject(level);
        }
        return dict;
    }
    gd::string getMainLevelString(int id) = win 0x32ffc0;
    void markLevelsAsUnmodified() = win inline {
        for (int i = 0; i < m_localLevels->count(); i++) {
            static_cast<GJGameLevel*>(m_localLevels->objectAtIndex(i))->m_hasBeenModified = false;
        }
    }
    void moveLevelToTop(GJGameLevel* level) = win inline {
        if (level && m_localLevels->containsObject(level)) {
            level->retain();
            m_localLevels->removeObject(level);
            m_localLevels->insertObject(level, 0);
            level->release();
            this->updateLevelOrder();
        }
    }
    void reorderLevels() = win inline {
        if (m_localLevels->count() != 0) {
            qsort(m_localLevels->data->arr, m_localLevels->data->num, sizeof(GJGameLevel*), [](void const* a, void const* b) {
                auto la = *static_cast<GJGameLevel* const*>(a);
                auto lb = *static_cast<GJGameLevel* const*>(b);
                return lb->m_levelIndex - la->m_levelIndex;
            });
        }
    }
    void reorderLists() = win inline {
        if (m_localLists->count() != 0) {
            qsort(m_localLists->data->arr, m_localLists->data->num, sizeof(GJLevelList*), [](void const* a, void const* b) {
                auto la = *static_cast<GJLevelList* const*>(a);
                auto lb = *static_cast<GJLevelList* const*>(b);
                return lb->m_listOrder - la->m_listOrder;
            });
        }
    }
    void tryLoadMainLevelString(int id) = win 0x32fd40;
    int updateLevelOrder() = win 0x3305c0;
    void updateLevelRevision() = win 0x330230;
    int updateListOrder() = win inline {
        int i = 0;
        for (; i < m_localLists->count(); i++) {
            static_cast<GJLevelList*>(m_localLists->objectAtIndex(m_localLists->count() - 1 - i))->m_listOrder = i;
        }
        return i;
    }

    cocos2d::CCArray* m_localLevels;
    cocos2d::CCArray* m_localLists;
    gd::unordered_map<int, gd::string> m_mainLevels;
}

[[link(android)]]
class MapPackCell : TableViewCell {
    MapPackCell(char const* identifier, float width, float height) = win inline : TableViewCell(identifier, width, height) {
        this->init();
    }
    ~MapPackCell() = win inline {
        CC_SAFE_RELEASE(m_rewardLabels);
        CC_SAFE_RELEASE(m_rewardSprites);
    }

    virtual bool init() = win 0xb1c20;
    virtual void draw() = win 0xade40;

    void loadFromMapPack(GJMapPack* pack) = win 0xb1c80;
    void onClaimReward(cocos2d::CCObject* sender);
    void onClick(cocos2d::CCObject* sender) = win 0xb27a0;
    void playCompleteEffect() = win 0xb2970;
    void reloadCell() = win inline, ios inline {
        this->loadFromMapPack(m_mapPack);
    }
    void updateBGColor(int index) = win inline {
        m_backgroundLayer->setColor(index % 2 == 0 ? cocos2d::ccColor3B { 161, 88, 44 } : cocos2d::ccColor3B { 194, 114, 62 });
        m_backgroundLayer->setOpacity(255);
    }

    GJMapPack* m_mapPack;
    CCMenuItemSpriteExtra* m_viewButton;
    CCMenuItemSpriteExtra* m_rewardButton;
    cocos2d::CCArray* m_rewardLabels;
    cocos2d::CCArray* m_rewardSprites;
}

[[link(android)]]
class MapSelectLayer : cocos2d::CCLayer {
    // virtual ~MapSelectLayer();

    static MapSelectLayer* create();
    static cocos2d::CCScene* scene();

    virtual void update(float dt);
    virtual bool init();
    virtual void onExit();
    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event);
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event);
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event);
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event);
    virtual void registerWithTouchDispatcher();
    virtual void keyBackClicked();
    virtual void scrollWheel(float y, float x);

    bool checkTouchMonster(cocos2d::CCPoint position);
    GJMapObject* createObjectAtPoint(cocos2d::CCPoint position);
    cocos2d::CCPoint getConstrainedMapPos(cocos2d::CCPoint position);
    void onBack(cocos2d::CCObject* sender);

    GJBigSprite* m_bigSprite;
    SimplePlayer* m_player;
    cocos2d::CCNode* m_mainLayer;
    bool m_unloadTexturesOnExit;
    bool m_backPressed;
    bool m_blockExit;
    bool m_inTouch;
    double m_lastTouchTime;
    bool m_editMode;
    cocos2d::CCPoint m_lastTouchPos;
    cocos2d::CCPoint m_mapPos;
    cocos2d::CCArray* m_monsters;
    LevelEditorLayer* m_editorLayer;
}

[[link(android), depends(GJGroundLayer), depends(GameToolbox)]]
class MenuGameLayer : cocos2d::CCLayer {
    // virtual ~MenuGameLayer();
    MenuGameLayer() {
        m_videoOptionsOpen = false;
        m_deltaCount = 0.f;
        m_isDestroyingPlayer = false;
        m_initCount = 0;
        m_playerObject = nullptr;
        m_backgroundSprite = nullptr;
        m_groundLayer = nullptr;
        m_backgroundWrapPosition = 0.f;
    }

    static MenuGameLayer* create() = win inline {
        auto ret = new MenuGameLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void update(float dt) = win 0x331f70;
    virtual bool init() = win 0x331150;
    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x333330;
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline {}
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline {}
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event);
    virtual void registerWithTouchDispatcher() = win 0x3334e0;

    void destroyPlayer() = win 0x333070;
    cocos2d::ccColor3B getBGColor(int index) = win 0x3319d0;
    void resetPlayer() = win 0x332440;
    void tryJump(float dt) = win 0x331ca0;
    void updateColor(float dt) = win 0x331880;
    void updateColors() = win inline {
        m_groundLayer->updateGround01Color(m_groundLayer->m_ground1Sprite->getColor());
        if (m_groundLayer->m_ground2Sprite) {
            m_groundLayer->updateGround02Color(m_groundLayer->m_ground2Sprite->getColor());
        }
    }

    bool m_videoOptionsOpen;
    float m_deltaCount;
    bool m_isDestroyingPlayer;
    int m_initCount;
    cocos2d::CCPoint m_realBackgroundPosition;
    PlayerObject* m_playerObject;
    cocos2d::CCSprite* m_backgroundSprite;
    GJGroundLayer* m_groundLayer;
    float m_backgroundWrapPosition;
}

[[link(android)]]
class MenuLayer : cocos2d::CCLayer, FLAlertLayerProtocol, GooglePlayDelegate {
    // static MenuLayer* create() = ios 0x2655a4;
    // virtual ~MenuLayer();

    static MenuLayer* get() {
        return GameManager::get()->m_menuLayer;
    }
    static cocos2d::CCScene* scene(bool isVideoOptionsOpen) = win 0x333630;

    virtual bool init() = win 0x3337c0, ios 0x1234567, imac 0x1234567, m1 0x1234567;
    virtual void keyBackClicked() = win 0x335cb0;
    virtual void keyDown(cocos2d::enumKeyCodes key);
    virtual void googlePlaySignedIn() = win 0x3356b0;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x335e80;

    void endGame() = win 0x336100;
    void firstNetworkTest() = win 0x335020;
    void onAchievements(cocos2d::CCObject* sender) = win 0x335550;
    void onCreator(cocos2d::CCObject* sender) = win 0x335a60;
    void onDaily(cocos2d::CCObject* sender) = win 0x334dd0;
    void onDiscord(cocos2d::CCObject* sender);
    void onEveryplay(cocos2d::CCObject* sender) = win inline, ios inline {}
    void onFacebook(cocos2d::CCObject* sender);
    void onFreeLevels(cocos2d::CCObject* sender);
    void onFullVersion(cocos2d::CCObject* sender);
    void onGameCenter(cocos2d::CCObject* sender) = win inline {
        auto gameManager = GameManager::sharedState();
        if (gameManager->getGameVariable("0034")) {
            gameManager->syncPlatformAchievements();
            PlatformToolbox::showAchievements();
        }
        this->showGCQuestion();
    }
    void onGarage(cocos2d::CCObject* sender) = win 0x335af0;
    void onGooglePlayGames(cocos2d::CCObject* sender) = win inline, ios inline {
        if (PlatformToolbox::isSignedInGooglePlay()) {
            GameManager::sharedState()->syncPlatformAchievements();
            PlatformToolbox::showAchievements();
        }
        else PlatformToolbox::signInGooglePlay();
    }
    void onMoreGames(cocos2d::CCObject* sender) = win 0x1234567, ios 0x1234567, imac 0x1234567, m1 0x1234567;
    void onMyProfile(cocos2d::CCObject* sender);
    void onNewgrounds(cocos2d::CCObject* sender);
    void onOptions(cocos2d::CCObject* sender) = win 0x3357a0;
    void onOptionsInstant() = win 0x3357b0;
    void onPlay(cocos2d::CCObject* sender) = win 0x335700;
    void onQuit(cocos2d::CCObject* sender);
    void onRobTop(cocos2d::CCObject* sender);
    void onStats(cocos2d::CCObject* sender) = win 0x335940;
    void onTrailer(cocos2d::CCObject* sender) = win inline, ios inline {
        PlatformToolbox::logEvent("gjl_trailer");
        if (GameToolbox::doWeHaveInternet()) {
            cocos2d::CCApplication::sharedApplication()->openURL("https://www.youtube.com/watch?v=k90y6PIzIaE");
        }
    }
    void onTwitch(cocos2d::CCObject* sender);
    void onTwitter(cocos2d::CCObject* sender);
    void onYouTube(cocos2d::CCObject* sender);
    void openOptions(bool videoOptions) = win 0x3357c0;
    void showGCQuestion() = win inline {
        auto alert = FLAlertLayer::create(
            this,
            "Game Center",
            "Do you want to <cg>enable</c>\n<cy>Game Center</c>? You can change this anytime in the options menu.",
            "NO",
            "YES",
            300.f
        );
        alert->setTag(1);
        alert->m_scene = AppDelegate::get()->m_runningScene;
        alert->show();
    }
    void showMeltdownPromo() = win inline, ios inline {}
    void showTOS() = win 0x3351f0;
    void syncPlatformAchievements(float dt) = win inline {
        this->unschedule(schedule_selector(MenuLayer::syncPlatformAchievements));
        GameManager::sharedState()->syncPlatformAchievements();
    }
    void tryShowAd(float dt) = win inline, ios inline {
        auto gameManager = GameManager::sharedState();
        if (gameManager->shouldShowInterstitial(180, 140, 0)) {
            gameManager->showInterstitial();
            this->unschedule(schedule_selector(MenuLayer::tryShowAd));
        }
    }
    void updateUserProfileButton();
    void videoOptionsClosed() = win inline {
        m_menuGameLayer->m_videoOptionsOpen = false;
    }
    void videoOptionsOpened() = win inline {
        m_menuGameLayer->m_videoOptionsOpen = true;
    }
    void willClose();

    bool m_showingTOS;
    cocos2d::CCSprite* m_gpSprite;
    cocos2d::CCSprite* m_viewProfileSprite;
    cocos2d::CCLabelBMFont* m_profileLabel;
    CCMenuItemSpriteExtra* m_profileButton;
    void* m_unknown;
    MenuGameLayer* m_menuGameLayer;
}

[[link(android)]]
class MessageListDelegate {
    virtual void loadMessagesFinished(cocos2d::CCArray* messages, char const* key) {}
    virtual void loadMessagesFailed(char const* key, GJErrorCode errorType) {}
    virtual void forceReloadMessages(bool sent) {}
    virtual void setupPageInfo(gd::string info, char const* key) {}
}

[[link(android)]]
class MessagesProfilePage : FLAlertLayer, FLAlertLayerProtocol, UploadActionDelegate, UploadPopupDelegate, MessageListDelegate {
    // virtual ~MessagesProfilePage();

    static MessagesProfilePage* create(bool sent) = win 0x3362a0;

    virtual void registerWithTouchDispatcher() = win 0x42660;
    virtual void keyBackClicked();
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x337640;
    virtual void onClosePopup(UploadActionPopup* popup) = win 0x13ef20;
    virtual void uploadActionFinished(int id, int response);
    virtual void uploadActionFailed(int id, int response) = win 0x13f0e0;
    virtual void loadMessagesFinished(cocos2d::CCArray* messages, char const* key) = win 0x337ef0;
    virtual void loadMessagesFailed(char const* key, GJErrorCode errorType) = win 0x13f8d0;
    virtual void forceReloadMessages(bool sent) = win 0x338040;
    virtual void setupPageInfo(gd::string info, char const* key);

    void deleteSelected() = win 0x3373c0;
    bool init(bool sent) = win 0x336440;
    bool isCorrect(char const* key);
    void loadPage(int page);
    void onClose(cocos2d::CCObject* sender) = win 0x3377e0;
    void onDeleteSelected(cocos2d::CCObject* sender);
    void onNextPage(cocos2d::CCObject* sender) = win 0x338200;
    void onPrevPage(cocos2d::CCObject* sender) = win 0x338210;
    void onSentMessages(cocos2d::CCObject* sender) = win 0x337040;
    void onToggleAllObjects(cocos2d::CCObject* sender);
    void onUpdate(cocos2d::CCObject* sender);
    void setupCommentsBrowser(cocos2d::CCArray* messages) = win 0x337d60;
    void untoggleAll();
    void updateLevelsLabel() = win inline, ios inline {
        auto end = m_pageEndIdx + m_pageStartIdx;
        auto count = m_itemCount;
        if (end > count) end = count;
        m_levelsLabel->setString(cocos2d::CCString::createWithFormat("%i to %i of %i", m_pageStartIdx + 1, end, count)->getCString());
    }
    void updatePageArrows() = win inline, ios inline {
        m_prevButton->setVisible(m_pageStartIdx != 0);
        m_nextButton->setVisible(m_pageEndIdx + m_pageStartIdx < m_itemCount);
    }

    bool m_sentMessages;
    gd::string m_messageKey;
    cocos2d::CCLabelBMFont* m_levelsLabel;
    cocos2d::CCLabelBMFont* m_errorLabel;
    GJCommentListLayer* m_listLayer;
    LoadingCircle* m_loadingCircle;
    UploadActionPopup* m_actionPopup;
    void* m_unkPtr;
    CCMenuItemSpriteExtra* m_nextButton;
    CCMenuItemSpriteExtra* m_prevButton;
    CCMenuItemSpriteExtra* m_refreshButton;
    CCMenuItemToggler* m_toggleAllToggler;
    int m_itemCount;
    int m_pageStartIdx;
    int m_pageEndIdx;
    int m_page;
    bool m_toggledAll;
}

[[link(android)]]
class MoreOptionsLayer : FLAlertLayer, TextInputDelegate, GooglePlayDelegate, GJDropDownLayerDelegate {
    MoreOptionsLayer() {
        m_page = -1;
        m_toggleCount = 0;
        m_pageCount = 0;
        m_gpSignInBtn = nullptr;
        m_gpSignOutBtn = nullptr;
        m_categoryLabel = nullptr;
    }
    ~MoreOptionsLayer() = win inline {
        CC_SAFE_RELEASE(m_objects);
        CC_SAFE_RELEASE(m_variables);
        auto gpm = GooglePlayManager::sharedState();
        if (gpm->m_delegate2 == this) gpm->m_delegate2 = nullptr;
    }

    static MoreOptionsLayer* create() = win inline {
        auto ret = new MoreOptionsLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x373470;
    virtual void keyBackClicked();
    virtual void textInputShouldOffset(CCTextInputNode* node, float yOffset) = win 0x7b620;
    virtual void textInputReturn(CCTextInputNode* node) = win 0x7b680;
    virtual void googlePlaySignedIn() = win 0x376740;
    virtual void dropDownLayerWillClose(GJDropDownLayer* layer);

    void addToggle(char const* label, char const* key, char const* description);
    int countForPage(int page);
    void goToPage(int page) = win 0x375330;
    void incrementCountForPage(int page) = win inline {
        m_objects->setObject(cocos2d::CCString::createWithFormat("%i", this->countForPage(page) + 1), this->pageKey(page));
    }
    const char* infoKey(int index) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("info_%i", index)->getCString();
    }
    cocos2d::CCLayer* layerForPage(int page);
    const char* layerKey(int page) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("layer_%i", page)->getCString();
    }
    cocos2d::CCPoint nextPosition(int page) = win inline {
        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        auto count = this->countForPage(page);
        cocos2d::CCPoint pos = winSize * .5f + cocos2d::CCPoint { count % 2 == 0 ? -160.f : 80.f, 80.f };
        if (count > 1) pos.y -= (int)(count * .5f) * 48;
        return pos;
    }
    const char* objectKey(int page) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("object_%i", page)->getCString();
    }
    cocos2d::CCArray* objectsForPage(int page);
    void offsetToNextPage() = win inline, ios inline {
        if (m_toggleCount % 10 != 0) m_toggleCount = (m_toggleCount - (m_toggleCount % 10)) + 10;
    }
    void onClose(cocos2d::CCObject* sender) = win 0x3765d0;
    void onFMODDebug(cocos2d::CCObject* sender) = win 0x376140;
    void onGPSignIn(cocos2d::CCObject* sender) = win inline, ios inline {
        if (!PlatformToolbox::isSignedInGooglePlay()) PlatformToolbox::signInGooglePlay();
        else this->toggleGP();
    }
    void onGPSignOut(cocos2d::CCObject* sender) = win inline, ios inline {
        if (PlatformToolbox::isSignedInGooglePlay()) {
            PlatformToolbox::signOutGooglePlay();
            GameManager::sharedState()->m_googlePlaySignedIn = false;
            m_gpSignInBtn->setVisible(true);
            m_gpSignOutBtn->setVisible(false);
        }
        else this->toggleGP();
    }
    void onInfo(cocos2d::CCObject* sender);
    void onKeybindings(cocos2d::CCObject* sender);
    void onNextPage(cocos2d::CCObject* sender);
    void onParental(cocos2d::CCObject* sender);
    void onPrevPage(cocos2d::CCObject* sender);
    void onSongBrowser(cocos2d::CCObject* sender);
    void onToggle(cocos2d::CCObject* sender) = win 0x3758d0;
    const char* pageKey(int page) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("page_%i", page)->getCString();
    }
    void toggleGP() = win inline {
        if (PlatformToolbox::isSignedInGooglePlay()) {
            m_gpSignInBtn->setVisible(false);
            m_gpSignOutBtn->setVisible(true);
        }
        else {
            m_gpSignInBtn->setVisible(true);
            m_gpSignOutBtn->setVisible(false);
        }
    }

    int m_page;
    int m_toggleCount;
    int m_pageCount;
    cocos2d::CCDictionary* m_variables;
    cocos2d::CCDictionary* m_objects;
    CCMenuItemSpriteExtra* m_leftBtn;
    CCMenuItemSpriteExtra* m_rightBtn;
    CCTextInputNode* m_offsetInput;
    CCMenuItemSpriteExtra* m_gpSignInBtn;
    CCMenuItemSpriteExtra* m_gpSignOutBtn;
    cocos2d::CCLabelBMFont* m_categoryLabel;
}

[[link(android)]]
class MoreSearchLayer : FLAlertLayer, TextInputDelegate {
    MoreSearchLayer() {}
    ~MoreSearchLayer() = win inline {
        CC_SAFE_RELEASE(m_commonSongNodes);
        CC_SAFE_RELEASE(m_normalSongNodes);
        CC_SAFE_RELEASE(m_customSongNodes);
    }

    static MoreSearchLayer* create() = win inline {
        auto ret = new MoreSearchLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x312950;
    virtual void keyBackClicked() = win 0x3176c0;
    virtual void textInputShouldOffset(CCTextInputNode* node, float yOffset) = win 0x7b620;
    virtual void textInputReturn(CCTextInputNode* node) = win 0x7b680;

    void audioNext(cocos2d::CCObject* sender);
    void audioPrevious(cocos2d::CCObject* sender);
    CCMenuItemToggler* createToggleButton(gd::string label, cocos2d::SEL_MenuHandler callback, bool toggled, cocos2d::CCMenu* menu, cocos2d::CCPoint position) = win 0x317060;
    void onClose(cocos2d::CCObject* sender) = win 0x3172c0;
    void onCoins(cocos2d::CCObject* sender);
    void onCompleted(cocos2d::CCObject* sender);
    void onEpic(cocos2d::CCObject* sender);
    void onFeatured(cocos2d::CCObject* sender);
    void onFollowed(cocos2d::CCObject* sender) = win inline, ios inline {
        auto glm = GameLevelManager::sharedState();
        glm->setBoolForKey(!glm->getBoolForKey("follow_filter"), "follow_filter");
    }
    void onFriends(cocos2d::CCObject* sender) = win inline, ios inline {
        auto glm = GameLevelManager::sharedState();
        glm->setBoolForKey(!glm->getBoolForKey("friend_filter"), "friend_filter");
    }
    void onInfo(cocos2d::CCObject* sender) = win 0x316f10;
    void onLegendary(cocos2d::CCObject* sender);
    void onMythic(cocos2d::CCObject* sender);
    void onNoStar(cocos2d::CCObject* sender);
    void onOriginal(cocos2d::CCObject* sender);
    void onSongFilter(cocos2d::CCObject* sender) = win 0x315bf0;
    void onSongMode(cocos2d::CCObject* sender) = win 0x316910;
    void onTwoPlayer(cocos2d::CCObject* sender);
    void onUncompleted(cocos2d::CCObject* sender);
    void selectSong(int songID) = win 0x3167d0;
    void toggleSongNodes(bool custom, bool disable) = win 0x316dd0;
    void updateAudioLabel() = win 0x3162d0;

    cocos2d::CCLabelBMFont* m_audioTrackName;
    CCMenuItemSpriteExtra* m_songLeftBtn;
    CCMenuItemSpriteExtra* m_songRightBtn;
    CCMenuItemSpriteExtra* m_normalBtn;
    CCMenuItemSpriteExtra* m_customBtn;
    CCTextInputNode* m_enterSongID;
    cocos2d::CCArray* m_commonSongNodes;
    cocos2d::CCArray* m_normalSongNodes;
    cocos2d::CCArray* m_customSongNodes;
}

[[link(android)]]
class MoreVideoOptionsLayer : FLAlertLayer, TextInputDelegate {
    MoreVideoOptionsLayer() {
        m_page = 0;
        m_toggleCount = 0;
        m_pageCount = 0;
        m_fpsInput = nullptr;
        m_fpsNodes = nullptr;
    }
    ~MoreVideoOptionsLayer() = win inline {
        CC_SAFE_RELEASE(m_values);
        CC_SAFE_RELEASE(m_variables);
    }

    static MoreVideoOptionsLayer* create() = win inline {
        auto ret = new MoreVideoOptionsLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x378950;
    virtual void keyBackClicked() = win 0x37b270;

    void addToggle(char const* label, char const* key, char const* description);
    int countForPage(int page);
    void goToPage(int page);
    void incrementCountForPage(int page) = win inline {
        m_values->setObject(cocos2d::CCString::createWithFormat("%i", this->countForPage(page) + 1), this->pageKey(page));
    }
    const char* infoKey(int index) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("info_%i", index)->getCString();
    }
    cocos2d::CCLayer* layerForPage(int page);
    const char* layerKey(int page) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("layer_%i", page)->getCString();
    }
    cocos2d::CCPoint nextPosition(int page) = win inline {
        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        auto count = this->countForPage(page);
        cocos2d::CCPoint pos = winSize * .5f + cocos2d::CCPoint { count % 2 == 0 ? -135.f : 35.f, 60.f };
        if (count > 1) pos.y -= (int)(count * .5f) * 48;
        return pos;
    }
    const char* objectKey(int page) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("object_%i", page)->getCString();
    }
    cocos2d::CCArray* objectsForPage(int page);
    void onApplyFPS(cocos2d::CCObject* sender) = win 0x37ad50, ios inline {
        auto fps = std::max(cocos2d::CCString::createWithFormat("%.03f", atof(m_fpsInput->getString().c_str()))->floatValue(), 60.f);
        if (fps == floorf(fps)) {
            m_fpsInput->setString(cocos2d::CCString::createWithFormat("%i", (int)fps)->getCString());
        }
        else {
            m_fpsInput->setString(cocos2d::CCString::createWithFormat("%.03f", fps)->getCString());
        }
        auto gameManager = GameManager::sharedState();
        gameManager->m_customFPSTarget = fps;
        gameManager->updateCustomFPS();
    }
    void onClose(cocos2d::CCObject* sender) = win 0x37b220;
    void onInfo(cocos2d::CCObject* sender);
    void onNextPage(cocos2d::CCObject* sender);
    void onPrevPage(cocos2d::CCObject* sender);
    void onToggle(cocos2d::CCObject* sender) = win 0x37a2e0;
    const char* pageKey(int page) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("page_%i", page)->getCString();
    }
    void updateFPSButtons();

    int m_page;
    int m_toggleCount;
    int m_pageCount;
    cocos2d::CCDictionary* m_values;
    cocos2d::CCDictionary* m_variables;
    CCMenuItemSpriteExtra* m_prevButton;
    CCMenuItemSpriteExtra* m_nextButton;
    CCTextInputNode* m_fpsInput;
    cocos2d::CCArray* m_fpsNodes;
}

[[link(android)]]
class MPLobbyLayer : cocos2d::CCLayer, GJMPDelegate, UploadPopupDelegate, UploadActionDelegate, FLAlertLayerProtocol, TextInputDelegate {
    // virtual ~MPLobbyLayer();

    static MPLobbyLayer* create(int type);
    static cocos2d::CCScene* scene(int type);

    virtual void keyBackClicked();
    virtual void keyDown(cocos2d::enumKeyCodes key);
    virtual void joinLobbyFinished(int id);
    virtual void joinLobbyFailed(int id, GJMPErrorCode errorType);
    virtual void updateComments();
    virtual void didUploadMPComment(int id);
    virtual void textInputOpened(CCTextInputNode* node);
    virtual void textInputClosed(CCTextInputNode* node);
    virtual void textChanged(CCTextInputNode* node);
    virtual void keyUp(cocos2d::enumKeyCodes key);
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2);
    virtual void uploadActionFinished(int id, int response);
    virtual void uploadActionFailed(int id, int response);
    virtual void onClosePopup(UploadActionPopup* popup);

    bool init(int type);
    void onBack(cocos2d::CCObject* sender);
    void onBtn1(cocos2d::CCObject* sender);
    void onBtn2(cocos2d::CCObject* sender);
    void onBtn3(cocos2d::CCObject* sender);
    void onComment(cocos2d::CCObject* sender);
    void onUpdateLobby();
    void postComment();
    void tryExitLobby();
    void updateLobby(float delay);

    int m_lobbyID;
    cocos2d::CCLabelBMFont* m_lobbyLabel;
    UploadActionPopup* m_uploadPopup;
    GJCommentListLayer* m_listLayer;
    CCTextInputNode* m_commentInput;
    float m_lobbyDelay;
    bool m_awaitingLobby;
    bool m_lobbyJoined;
}

[[link(android)]]
class MultilineBitmapFont : cocos2d::CCSprite {
    MultilineBitmapFont() {
        m_specialDescriptors = nullptr;
        m_characters = nullptr;
        m_lines = nullptr;
        m_unkInt = 0;
        m_unkBool = false;
        m_unkPtr = nullptr;
        m_height = 0;
        m_width = 0;
        m_maxWidth = 0.f;
        m_disableColor = false;
    }
    ~MultilineBitmapFont() = win inline {
        CC_SAFE_RELEASE(m_characters);
        CC_SAFE_RELEASE(m_lines);
        CC_SAFE_RELEASE(m_specialDescriptors);
    }

    static MultilineBitmapFont* createWithFont(char const* font, gd::string text, float scale, float width, cocos2d::CCPoint anchor, int height, bool disableColor) = win inline {
        auto ret = new MultilineBitmapFont();
        if (ret->initWithFont(font, text, scale, width, anchor, height, disableColor)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void setOpacity(unsigned char opacity) = win 0x6c7a0;

    bool initWithFont(char const* font, gd::string text, float scale, float width, cocos2d::CCPoint anchor, int height, bool disableColor) = win 0x6bef0;
    void moveSpecialDescriptors(int index, int size) = win 0x6d0f0;
    gd::string readColorInfo(gd::string text) = win 0x6c820;
    gd::string stringWithMaxWidth(gd::string text, float width, float scale) = win 0x6d180;

    std::array<int, 300> m_fontWidths;
    cocos2d::CCArray* m_specialDescriptors;
    cocos2d::CCArray* m_characters;
    cocos2d::CCArray* m_lines;
    int m_unkInt;
    bool m_unkBool;
    void* m_unkPtr;
    int m_height;
    int m_width;
    cocos2d::CCPoint m_position;
    float m_maxWidth;
    bool m_disableColor;
}

[[link(android)]]
class MultiplayerLayer : cocos2d::CCLayer {
    // virtual ~MultiplayerLayer();

    static MultiplayerLayer* create();
    static cocos2d::CCScene* scene();

    virtual bool init();
    virtual void keyBackClicked();

    void onBack(cocos2d::CCObject* sender);
    void onBtn1(cocos2d::CCObject* sender);
    void onBtn2(cocos2d::CCObject* sender);
}

[[link(android)]]
class MultiTriggerPopup : SetupTriggerPopup {
    // virtual ~MultiTriggerPopup();

    static MultiTriggerPopup* create(EffectGameObject* object, cocos2d::CCArray* objects);

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x469290;
}

[[link(android)]]
class MusicArtistObject : cocos2d::CCObject {
    // virtual ~MusicArtistObject();

    static MusicArtistObject* create(int id, gd::string name, gd::string url, gd::string youtube) = win 0x3477f0;

    bool init(int id, gd::string name, gd::string url, gd::string youtube) = win inline, ios inline {
        m_artistID = id;
        m_artistName = name;
        m_artistURL = url;
        m_artistYouTube = youtube;
        return true;
    }

    int m_artistID;
    gd::string m_artistName;
    gd::string m_artistURL;
    gd::string m_artistYouTube;
}

[[link(android)]]
class MusicBrowser : FLAlertLayer, MusicDownloadDelegate, TableViewCellDelegate, SetTextPopupDelegate, FLAlertLayerProtocol, SliderDelegate {
    // virtual ~MusicBrowser();

    static MusicBrowser* create(int songID, GJSongType songType) = win 0x338430;

    virtual void update(float dt) = win 0x3391b0;
    virtual void registerWithTouchDispatcher() = win 0x42660;
    virtual void keyBackClicked();
    virtual void musicActionFinished(GJMusicAction action);
    virtual void musicActionFailed(GJMusicAction action) = win 0x339b20;
    virtual void sliderEnded(Slider* slider) = win 0x3397f0;
    virtual void setTextPopupClosed(SetTextPopup* popup, gd::string text);
    virtual bool cellPerformedAction(TableViewCell* cell, int listType, CellAction action, cocos2d::CCNode* parent) = win 0x33a350;
    virtual int getSelectedCellIdx();
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x33a7a0;

    bool init(int songID, GJSongType songType) = win 0x3385e0;
    void onArtistFilters(cocos2d::CCObject* sender) = win 0x33a710;
    void onClearSearch(cocos2d::CCObject* sender);
    void onClose(cocos2d::CCObject* sender) = win 0x33a800;
    void onPage(cocos2d::CCObject* sender) = win 0x33a390;
    void onPlaybackControl(cocos2d::CCObject* sender) = win 0x339790;
    void onSearch(cocos2d::CCObject* sender) = win 0x33a4b0;
    void onTagFilters(cocos2d::CCObject* sender) = win 0x33a6a0;
    void onUpdateLibrary(cocos2d::CCObject* sender);
    void setupList(MusicSearchResult* result) = win 0x339c50;
    void setupMusicBrowser() = win inline {
        auto mdm = MusicDownloadManager::sharedState();
        if (mdm->m_customContentURL.empty()) mdm->getCustomContentURL();
        auto searchResult = MusicSearchResult::create(m_songType);
        searchResult->setTag(m_songType == GJSongType::NCS ? 6 : 0);
        this->setupList(searchResult);
        if (!mdm->m_downloadingMusicLibrary) this->onUpdateLibrary(nullptr);
    }
    void setupSongControls() = win 0x3394b0;
    void sliderChanged(cocos2d::CCObject* sender);
    void trySetupMusicBrowser();
    void updatePageLabel() = win inline {
        auto count = m_searchResult->m_filterObjects->count();
        if (count > 0) {
            auto start = m_searchResult->m_startIndex * 10;
            auto end = std::min<int>(start + 10, count);
            m_pageLabel->setString(cocos2d::CCString::createWithFormat("%i to %i of %i", start + 1, end, count)->getCString());
        }
        else m_pageLabel->setString("No matches");
    }

    GJSongType m_songType;
    MusicSearchResult* m_searchResult;
    GJCommentListLayer* m_listLayer;
    cocos2d::CCLabelBMFont* m_infoLabel;
    cocos2d::CCLabelBMFont* m_pageLabel;
    CCMenuItemSpriteExtra* m_prevButton;
    CCMenuItemSpriteExtra* m_nextButton;
    CCMenuItemSpriteExtra* m_refreshButton;
    CCMenuItemSpriteExtra* m_clearSearchButton;
    CCMenuItemSpriteExtra* m_tagFilterButton;
    CCMenuItemSpriteExtra* m_artistFilterButton;
    LoadingCircleSprite* m_circleSprite;
    int m_songID;
    int m_libraryVersion;
    bool m_gettingURL;
    bool m_selectedCell;
    MusicBrowserDelegate* m_delegate;
    Slider* m_playSlider;
    cocos2d::CCLabelBMFont* m_playLabel;
    CCMenuItemSpriteExtra* m_playButton;
    bool m_autoUpdating;
}

[[link(android)]]
class MusicBrowserDelegate {
    virtual void musicBrowserClosed(MusicBrowser* browser) {}
}

[[link(android)]]
class MusicDelegateHandler : cocos2d::CCNode {
    // virtual ~MusicDelegateHandler();
    MusicDelegateHandler() {
        m_delegate = nullptr;
    }

    static MusicDelegateHandler* create(MusicDownloadDelegate* delegate) = win inline {
        auto ret = new MusicDelegateHandler();
        if (ret->init(delegate)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init(MusicDownloadDelegate* delegate) = win inline, ios inline {
        if (!cocos2d::CCNode::init()) return false;
        m_delegate = delegate;
        return true;
    }

    MusicDownloadDelegate* m_delegate;
}

[[link(android)]]
class MusicDownloadDelegate {
    virtual void loadSongInfoFinished(SongInfoObject* object) {}
    virtual void loadSongInfoFailed(int id, GJSongError errorType) {}
    virtual void downloadSongFinished(int id) {}
    virtual void downloadSongFailed(int id, GJSongError errorType) {}
    virtual void songStateChanged() {}
    virtual void downloadSFXFinished(int id) {}
    virtual void downloadSFXFailed(int id, GJSongError errorType) {}
    virtual void musicActionFinished(GJMusicAction action) {}
    virtual void musicActionFailed(GJMusicAction action) {}
}

[[link(android)]]
class MusicDownloadManager : cocos2d::CCNode, PlatformDownloadDelegate {
    // virtual ~MusicDownloadManager();

    static MusicDownloadManager* sharedState() = win 0x33c930;

    virtual bool init() = win 0x33cf10;

    void addDLToActive(char const* tag) = win inline, ios inline {
        addDLToActive(tag, cocos2d::CCNode::create());
    }
    void addDLToActive(char const* tag, cocos2d::CCObject* obj) = win 0x33ecf0;
    void addMusicDownloadDelegate(MusicDownloadDelegate* delegate) = win 0x33d0b0;
    SongInfoObject* addSongObjectFromString(gd::string str) = win 0x33d770;
    void clearSong(int songID) = win inline {
        const char* key = cocos2d::CCString::createWithFormat("%i", songID)->getCString();
        m_songObjects->removeObjectForKey(key);
    }
    void clearUnusedSongs() = win 0x33e3d0;
    cocos2d::CCDictionary* createArtistsInfo(gd::string str) = win 0x33dec0;
    void createSongsInfo(gd::string songsStr, gd::string artistsStr) = win 0x33db10;
    void dataLoaded(DS_Dictionary* dict) = win 0x33f750;
    void deleteSFX(int id) = win inline {
        remove(this->pathForSFX(id).c_str());
    }
    void deleteSong(int id) = win inline {
        remove(this->pathForSong(id).c_str());
    }
    void downloadCustomSong(int id);
    void downloadMusicLibrary() = win 0x340670;
    void downloadSFX(int id) = win 0x341f70;
    void downloadSFXFailed(int id, GJSongError errorCode);
    void downloadSFXFinished(int id) = win inline {
        for (int i = 0; i < m_musicDownloadDelegates->count(); i++) {
            static_cast<MusicDelegateHandler*>(m_musicDownloadDelegates->objectAtIndex(i))->m_delegate->downloadSFXFinished(id);
        }
    }
    void downloadSFXLibrary() = win 0x342710;
    void downloadSong(int id) = win 0x33e750;
    void downloadSongFailed(int id, GJSongError errorCode);
    void downloadSongFinished(int id) = win inline {
        for (int i = 0; i < m_musicDownloadDelegates->count(); i++) {
            static_cast<MusicDelegateHandler*>(m_musicDownloadDelegates->objectAtIndex(i))->m_delegate->downloadSongFinished(id);
        }
    }
    void encodeDataTo(DS_Dictionary* dict) = win inline {
        dict->setDictForKey("MDLM_001", m_songObjects);
        dict->setDictForKey("MDLM_003", m_MDLM003);
        dict->setIntegerForKey("MDLM_002", m_songPriority);
    }
    cocos2d::CCArray* filterMusicByArtistID(int id, cocos2d::CCArray* songs) = win 0xcce30;
    cocos2d::CCArray* filterMusicByTag(int id, cocos2d::CCArray* songs) = win 0x341ec0;
    void firstSetup() = win inline {
        if (!m_songObjects) {
            auto songObjects = cocos2d::CCDictionary::create();
            CC_SAFE_RETAIN(songObjects);
            CC_SAFE_RELEASE(m_songObjects);
            m_songObjects = songObjects;
        }
        m_songPriority = 0;
    }
    gd::string generateCustomContentURL(gd::string path) = win 0x3437d0;
    void generateResourceAssetList() = win inline {
        auto sfxStart = reinterpret_cast<int*>(geode::base::get() + 0x608140);
        m_resourceSfxUnorderedSet.clear();
        m_resourceSfxUnorderedSet.insert(sfxStart, sfxStart + 260);

        auto songStart = reinterpret_cast<int*>(geode::base::get() + 0x608660);
        m_resourceSongUnorderedSet.clear();
        m_resourceSongUnorderedSet.insert(songStart, songStart + 8);
        m_resourceSongUnorderedSet.insert(10006555);
    }
    cocos2d::CCArray* getAllMusicArtists(OptionsObjectDelegate* delegate) = win inline {
        auto ret = cocos2d::CCArray::createWithCapacity(m_musicArtists->count());
        cocos2d::CCDictElement* element;
        cocos2d::CCDictElement* temp;
        if (m_musicArtists) {
            HASH_ITER(hh, m_musicArtists->m_pElements, element, temp) {
                auto object = static_cast<MusicArtistObject*>(element->getObject());
                ret->addObject(OptionsObject::create(object->m_artistID, false, object->m_artistName, delegate));
            }
        }
        if (ret->count() > 1) {
            qsort(ret->data->arr, ret->data->num, sizeof(OptionsObject*), [](void const* a, void const* b) {
                auto objA = *static_cast<OptionsObject* const*>(a);
                auto objB = *static_cast<OptionsObject* const*>(b);
                return objA->m_name.compare(objB->m_name);
            });
        }
        return ret;
    }
    cocos2d::CCArray* getAllMusicObjects(GJSongType type) = win inline {
        auto ret = cocos2d::CCArray::createWithCapacity(m_musicObjects->count());
        cocos2d::CCDictElement* element;
        cocos2d::CCDictElement* temp;
        if (m_musicObjects) {
            if (type == GJSongType::Music) {
                HASH_ITER(hh, m_musicObjects->m_pElements, element, temp) {
                    ret->addObject(element->getObject());
                }
            }
            else {
                HASH_ITER(hh, m_musicObjects->m_pElements, element, temp) {
                    auto musicObject = static_cast<SongInfoObject*>(element->getObject());
                    if (musicObject->m_nongType == (int)type) {
                        ret->addObject(musicObject);
                    }
                }
            }
        }
        return ret;
    }
    cocos2d::CCArray* getAllMusicTags(OptionsObjectDelegate* delegate) = win inline {
        auto ret = cocos2d::CCArray::createWithCapacity(m_musicTags.size());
        for (auto& tag : m_musicTags) {
            ret->addObject(OptionsObject::create(tag.first, false, tag.second, delegate));
        }
        if (ret->count() > 1) {
            qsort(ret->data->arr, ret->data->num, sizeof(OptionsObject*), [](void const* a, void const* b) {
                auto objA = *static_cast<OptionsObject* const*>(a);
                auto objB = *static_cast<OptionsObject* const*>(b);
                return objA->m_name.compare(objB->m_name);
            });
        }
        return ret;
    }
    cocos2d::CCArray* getAllSFXObjects(bool onlySFX) = win inline {
        auto ret = cocos2d::CCArray::create();
        cocos2d::CCDictElement* element;
        cocos2d::CCDictElement* temp;
        if (m_sfxObjects) {
            if (onlySFX) {
                HASH_ITER(hh, m_sfxObjects->m_pElements, element, temp) {
                    auto sfxObject = static_cast<SFXInfoObject*>(element->getObject());
                    if (!sfxObject->m_folder) {
                        ret->addObject(sfxObject);
                    }
                }
            }
            else {
                HASH_ITER(hh, m_sfxObjects->m_pElements, element, temp) {
                    ret->addObject(element->getObject());
                }
            }
        }
        return ret;
    }
    cocos2d::CCArray* getAllSongs() = win inline {
        auto ret = cocos2d::CCArray::create();
        cocos2d::CCDictElement* element;
        cocos2d::CCDictElement* temp;
        if (m_songObjects) {
            HASH_ITER(hh, m_songObjects->m_pElements, element, temp) {
                ret->addObject(element->getObject());
            }
        }
        return ret;
    }
    void getCustomContentURL() = win 0x33fc40;
    cocos2d::CCObject* getDLObject(char const* id) = win 0x39d70;
    cocos2d::CCArray* getDownloadedSongs() = win 0x33e310;
    int getDownloadProgress(int id) = win inline {
        if (auto dlObject = static_cast<cocos2d::extension::CCHttpRequest*>(this->getDLObject(this->getSongDownloadKey(id)))) {
            return dlObject->getDownloadProgress();
        }
        return -1;
    }
    MusicArtistObject* getMusicArtistForID(int id) = win inline {
        return m_musicArtists ? static_cast<MusicArtistObject*>(m_musicArtists->objectForKey(id)) : nullptr;
    }
    SongInfoObject* getMusicObject(int id) = win inline, ios inline {
        return m_musicObjects ? static_cast<SongInfoObject*>(m_musicObjects->objectForKey(id)) : nullptr;
    }
    char const* getSFXDownloadKey(int id) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("sfx_%i", id)->getCString();
    }
    int getSFXDownloadProgress(int id) = win inline {
        if (auto dlObject = static_cast<cocos2d::extension::CCHttpRequest*>(this->getDLObject(this->getSFXDownloadKey(id)))) {
            return dlObject->getDownloadProgress();
        }
        return -1;
    }
    SFXFolderObject* getSFXFolderObjectForID(int id) = win inline {
        if (auto sfxObject = sharedState()->getSFXObject(id)) {
            if (sfxObject->m_folder) return static_cast<SFXFolderObject*>(sfxObject);
            if (auto folderObject = static_cast<SFXFolderObject*>(sharedState()->getSFXObject(sfxObject->m_folderID))) {
                if (folderObject->m_folder) return folderObject;
            }
        }
        return nullptr;
    }
    gd::string getSFXFolderPathForID(int id, bool nextFolder) = win 0x3435b0;
    SFXInfoObject* getSFXObject(int id) = win inline {
        return m_sfxObjects ? static_cast<SFXInfoObject*>(m_sfxObjects->objectForKey(id)) : nullptr;
    }
    char const* getSongDownloadKey(int id) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("d_%i", id)->getCString();
    }
    void getSongInfo(int id, bool download) = win 0x33d300;
    char const* getSongInfoKey(int id) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("i_%i", id)->getCString();
    }
    SongInfoObject* getSongInfoObject(int id) = win 0x33ee70;
    int getSongPriority() = win inline, ios inline {
        return ++m_songPriority;
    }
    void handleIt(bool success, gd::string response, gd::string tag, GJHttpType type) = win 0x33ce20;
    void handleItDelayed(bool success, gd::string response, gd::string tag, GJHttpType type) = win inline, ios inline {
        auto result = GJHttpResult::create(true, response, tag, type);
        result->retain();
        m_pActionManager->addAction(cocos2d::CCSequence::create(
            cocos2d::CCDelayTime::create(.1f),
            cocos2d::CCCallFuncND::create(this, callfuncND_selector(GJMultiplayerManager::handleItND), result),
            nullptr
        ), this, false);
    }
    void handleItND(cocos2d::CCNode* node, void* data) = win inline, ios inline {
        auto result = static_cast<GJHttpResult*>(data);
        this->handleIt(result->m_success, result->m_response, result->m_requestTag, result->m_httpType);
        result->release();
    }
    void incrementPriorityForSong(int id) = win inline {
        if (auto songObject = this->getSongInfoObject(id)) {
            songObject->m_priority = this->getSongPriority();
        }
    }
    bool isDLActive(char const* tag) = win inline, ios inline {
        return this->getDLObject(tag) != nullptr;
    }
    bool isMusicLibraryLoaded() = win inline, ios inline {
        return m_musicObjects && m_musicObjects->count() != 0;
    }
    bool isResourceSFX(int id) = win inline, ios inline {
        return m_resourceSfxUnorderedSet.count(id) != 0;
    }
    bool isResourceSong(int id) = win inline, ios inline {
        return m_resourceSongUnorderedSet.count(id) != 0;
    }
    bool isRunningActionForSongID(int id) = win 0x33d220;
    bool isSFXDownloaded(int id) = win 0x33f2b0;
    bool isSFXLibraryLoaded() = win inline, ios inline {
        return m_sfxObjects && m_sfxObjects->count() != 0;
    }
    bool isSongDownloaded(int id) = win 0x33ef80;
    void limitDownloadedSongs() = win inline {
        auto gameManager = GameManager::sharedState();
        auto menuSongID = gameManager->m_customMenuSongID;
        auto practiceSongID = gameManager->m_customPracticeSongID;
        auto downloadedSongs = this->getDownloadedSongs();
        while (downloadedSongs->count() > 50) {
            auto songObject = static_cast<SongInfoObject*>(downloadedSongs->lastObject());
            if (songObject->m_songID != menuSongID && songObject->m_songID != practiceSongID) {
                this->deleteSong(songObject->m_songID);
            }
            downloadedSongs->removeLastObject();
        }
    }
    void loadSongInfoFailed(int id, GJSongError errorCode);
    void loadSongInfoFinished(SongInfoObject* object) = win 0x344160;
    void musicActionFailed(GJMusicAction action);
    void musicActionFinished(GJMusicAction action);
    gd::string nameForTagID(int id) = win inline {
        return m_musicTags.count(id) ? m_musicTags[id] : "";
    }
    void onDownloadMusicLibraryCompleted(cocos2d::extension::CCHttpClient* client, cocos2d::extension::CCHttpResponse* response) = win 0x340900;
    void onDownloadSFXCompleted(cocos2d::extension::CCHttpClient* client, cocos2d::extension::CCHttpResponse* response) = win 0x3421d0;
    void onDownloadSFXLibraryCompleted(cocos2d::extension::CCHttpClient* client, cocos2d::extension::CCHttpResponse* response) = win 0x342970;
    void onDownloadSongCompleted(cocos2d::extension::CCHttpClient* client, cocos2d::extension::CCHttpResponse* response) = win 0x33ea50;
    void onGetCustomContentURLCompleted(gd::string response, gd::string tag) = win 0x33feb0;
    void onGetSongInfoCompleted(gd::string response, gd::string tag) = win 0x33d5e0;
    void onProcessHttpRequestCompleted(cocos2d::extension::CCHttpClient* client, cocos2d::extension::CCHttpResponse* response);
    void onTryUpdateMusicLibraryCompleted(cocos2d::extension::CCHttpClient* client, cocos2d::extension::CCHttpResponse* response) = win 0x340540;
    void onTryUpdateSFXLibraryCompleted(cocos2d::extension::CCHttpClient* client, cocos2d::extension::CCHttpResponse* response) = win 0x3425d0;
    void parseMusicLibrary();
    void parseSFXLibrary() = win 0x342b00;
    gd::string pathForSFX(int id) = win 0x33f530;
    gd::string pathForSFXFolder(int id) = win 0x33f3e0;
    gd::string pathForSong(int id) = win 0x33f200;
    gd::string pathForSongFolder(int id) = win 0x33f0b0;
    cocos2d::extension::CCHttpRequest* ProcessHttpGetRequest(gd::string url, gd::string tag, cocos2d::extension::SEL_HttpResponse selector, int connectTimeout, int readTimeout) = win 0x33cc00;
    callback void ProcessHttpRequest(gd::string url, gd::string params, gd::string tag, GJHttpType type) = win 0x33cac0;
    void removeDLFromActive(char const* tag);
    void removeMusicDownloadDelegate(MusicDownloadDelegate* delegate) = win 0x33d190;
    cocos2d::CCDictionary* responseToDict(gd::string response, char const* delimiter) = win 0x33e0c0;
    void showTOS(FLAlertLayerProtocol* delegate) = win 0x33f5f0;
    void songStateChanged() = win 0x33d2a0;
    void stopDownload(int id) = win inline {
        auto key = this->getSongDownloadKey(id);
        if (auto dlObject = static_cast<cocos2d::extension::CCHttpRequest*>(this->getDLObject(key))) {
            dlObject->setShouldCancel(true);
        }
        this->removeDLFromActive(key);
    }
    void storeMusicObject(SongInfoObject* object) = win inline, ios inline {
        m_musicObjects->setObject(object, object->m_songID);
    }
    void storeSFXInfoObject(SFXInfoObject* object) = win inline {
        m_sfxObjects->setObject(object, object->m_sfxID);
        if (object->m_folderID > 0) {
            if (auto folderObject = static_cast<SFXFolderObject*>(m_sfxObjects->objectForKey(object->m_folderID))) {
                if (folderObject->m_folder) folderObject->m_sfxObjects->addObject(object);
            }
        }
    }
    void tryLoadLibraries() = win inline {
        if (m_triedToLoadLibraries) return;
        m_triedToLoadLibraries = true;
        if (!this->isSFXLibraryLoaded()) this->parseSFXLibrary();
        if (!this->isMusicLibraryLoaded()) this->parseMusicLibrary();
    }
    void tryUpdateMusicLibrary() = win 0x3402b0;
    void tryUpdateSFXLibrary() = win 0x342330;

    cocos2d::CCDictionary* m_activeDownloads;
    cocos2d::CCArray* m_musicDownloadDelegates;
    cocos2d::CCDictionary* m_songObjects;
    cocos2d::CCDictionary* m_MDLM003;
    int m_songPriority;
    gd::string m_customContentURL;
    cocos2d::CCDictionary* m_sfxObjects;
    cocos2d::CCArray* m_sfxArtists;
    int m_sfxLibraryVersion;
    int m_sfxObjectCount;
    bool m_requestedSfxLibraryDownloaded;
    cocos2d::CCDictionary* m_musicObjects;
    cocos2d::CCDictionary* m_musicArtists;
    gd::map<int, gd::string> m_musicTags;
    int m_musicLibraryVersion;
    int m_musicObjectCount;
    int m_ncsSongCount;
    bool m_downloadingMusicLibrary;
    bool m_triedToLoadLibraries;
    bool m_unkBool;
    gd::unordered_set<int> m_resourceSfxUnorderedSet;
    gd::unordered_set<int> m_resourceSongUnorderedSet;
}

[[link(android)]]
class MusicSearchResult : cocos2d::CCObject, OptionsObjectDelegate {
    MusicSearchResult() = win 0x33b5b0 {
        m_filterObjects = nullptr;
        m_tagFilterObjects = nullptr;
        m_artistFilterObjects = nullptr;
        m_startIndex = 0;
        m_audioType = 0;
        m_sortType = AudioSortType::NameAscending;
        m_tagFilter = false;
        m_artistFilter = false;
        m_songType = GJSongType::Music;
    }
    ~MusicSearchResult() = win inline {
        CC_SAFE_RELEASE(m_filterObjects);
    }

    static MusicSearchResult* create(GJSongType songType) = win inline {
        auto ret = new MusicSearchResult();
        if (ret->init(songType)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void updateObjects(AudioSortType type) = win 0x347060;
    virtual void stateChanged(OptionsObject* object) = win 0x347050;

    cocos2d::CCArray* applyArtistFilters(cocos2d::CCArray* objects) = win inline {
        if (objects->count() == 0) return objects;
        auto filterObjects = cocos2d::CCArray::create();
        m_artistFilter = false;
        CCObject* obj;
        CCARRAY_FOREACH(m_artistFilterObjects, obj) {
            auto object = static_cast<OptionsObject*>(obj);
            if (object->m_enabled) {
                m_artistFilter = true;
                auto filtered = MusicDownloadManager::sharedState()->filterMusicByArtistID(object->m_optionID, objects);
                CCObject* fobj;
                CCARRAY_FOREACH(filtered, fobj) {
                    filterObjects->addObject(fobj);
                }
            }
        }
        return m_artistFilter ? filterObjects : objects;
    }
    cocos2d::CCArray* applyTagFilters(cocos2d::CCArray* objects) = win 0x346f80;
    void createArtistFilterObjects() = win inline {
        if (m_artistFilterObjects) return;
        auto objects = MusicDownloadManager::sharedState()->getAllMusicArtists(this);
        if (m_artistFilterObjects != objects) {
            CC_SAFE_RETAIN(objects);
            CC_SAFE_RELEASE(m_artistFilterObjects);
            m_artistFilterObjects = objects;
        }
    }
    void createTagFilterObjects() = win inline {
        if (m_tagFilterObjects) return;
        auto objects = MusicDownloadManager::sharedState()->getAllMusicTags(this);
        if (m_tagFilterObjects != objects) {
            CC_SAFE_RETAIN(objects);
            CC_SAFE_RELEASE(m_tagFilterObjects);
            m_tagFilterObjects = objects;
        }
    }
    cocos2d::CCArray* getFilesMatchingSearch(cocos2d::CCArray* objects, gd::string query) = win 0x3475b0;
    bool init(GJSongType songType) = win inline, ios inline {
        m_songType = songType;
        return true;
    }
    void updateFutureCount(cocos2d::CCArray* objects, cocos2d::CCArray* allObjects) = win inline {
        auto count = objects->count();
        CCObject* obj;
        CCARRAY_FOREACH(m_tagFilterObjects, obj) {
            auto object = static_cast<OptionsObject*>(obj);
            object->m_count = object->m_enabled ? MusicDownloadManager::sharedState()->filterMusicByTag(object->m_optionID, objects)->count() : count;
        }
        auto filtered = this->applyTagFilters(allObjects);
        CCARRAY_FOREACH(m_artistFilterObjects, obj) {
            auto object = static_cast<OptionsObject*>(obj);
            object->m_count = MusicDownloadManager::sharedState()->filterMusicByArtistID(object->m_optionID, filtered)->count();
        }
    }
    void updateObjects() = win inline {
        this->updateObjects(m_sortType);
    }

    cocos2d::CCArray* m_filterObjects;
    cocos2d::CCArray* m_tagFilterObjects;
    cocos2d::CCArray* m_artistFilterObjects;
    int m_startIndex;
    int m_audioType;
    gd::string m_searchQuery;
    AudioSortType m_sortType;
    bool m_tagFilter;
    bool m_artistFilter;
    GJSongType m_songType;
}

[[link(android)]]
class NCSInfoLayer : FLAlertLayer, FLAlertLayerProtocol {
    // virtual ~NCSInfoLayer();
    NCSInfoLayer() {}

    static NCSInfoLayer* create(CustomSongLayer* layer) = win inline {
        auto ret = new NCSInfoLayer();
        if (ret->init(layer)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyBackClicked() = win 0x846c0;

    bool init(CustomSongLayer* layer) = win 0xc6400;
    void onClose(cocos2d::CCObject* sender) = win 0x84690, ios inline {
        this->setKeypadEnabled(false);
        this->removeFromParentAndCleanup(true);
    }
    void onLibrary(cocos2d::CCObject* sender) = win 0xc6c50;
    void onNCS(cocos2d::CCObject* sender);
    void onNCSIO(cocos2d::CCObject* sender);
    void onNCSUsage(cocos2d::CCObject* sender);

    CustomSongLayer* m_songLayer;
}

[[link(android)]]
class NewgroundsInfoLayer : FLAlertLayer, FLAlertLayerProtocol {
    // virtual ~NewgroundsInfoLayer();
    NewgroundsInfoLayer() {}

    static NewgroundsInfoLayer* create() = win inline {
        auto ret = new NewgroundsInfoLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0xc5670;
    virtual void keyBackClicked() = win 0x846c0;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2);

    void onArtists(cocos2d::CCObject* sender) = win 0xc5fb0;
    void onChanges(cocos2d::CCObject* sender) = win 0xc6270;
    void onClose(cocos2d::CCObject* sender) = win 0x84690;
    void onGuidelines(cocos2d::CCObject* sender);
    void onInfo(cocos2d::CCObject* sender) = win 0xc6120;
    void onNewgrounds(cocos2d::CCObject* sender);
    void onSupporter(cocos2d::CCObject* sender);
}

[[link(android)]]
class NodePoint : cocos2d::CCObject {
    // virtual ~NodePoint();
    NodePoint() {}

    static NodePoint* create(cocos2d::CCPoint point) = win inline, ios inline {
        auto ret = new NodePoint();
        if (ret->init(point)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init(cocos2d::CCPoint point) = win inline, ios inline {
        m_point = point;
        return true;
    }

    cocos2d::CCPoint m_point;
}

[[link(android)]]
class NumberInputDelegate {
    virtual void numberInputClosed(NumberInputLayer* layer) {}
}

[[link(android)]]
class NumberInputLayer : FLAlertLayer {
    // virtual ~NumberInputLayer();
    NumberInputLayer() {
        m_okButton = nullptr;
        m_minimum = 4;
        m_maximum = 4;
        m_delegate = nullptr;
    }

    static NumberInputLayer* create() = win inline {
        auto ret = new NumberInputLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x348130;
    virtual void registerWithTouchDispatcher() = win 0x52df0;
    virtual void keyBackClicked() = win 0x846c0;

    void deleteLast() = win inline {
        if (!m_inputString.empty()) {
            m_inputString = m_inputString.substr(0, m_inputString.size() - 1);
            this->updateNumberState();
        }
    }
    void inputNumber(int num) = win inline {
        if (m_inputString.size() < m_maximum) {
            m_inputString += cocos2d::CCString::createWithFormat("%i", num)->getCString();
            this->updateNumberState();
        }
    }
    void onClose(cocos2d::CCObject* sender) = win 0x84690;
    void onDone(cocos2d::CCObject* sender) = win inline {
        if (m_delegate) m_delegate->numberInputClosed(this);
        this->onClose(nullptr);
    }
    void onNumber(cocos2d::CCObject* sender) = win 0x3486e0;
    void updateNumberState() = win 0x348870;

    cocos2d::CCLabelBMFont* m_inputLabel;
    CCMenuItemSpriteExtra* m_okButton;
    int m_minimum;
    int m_maximum;
    gd::string m_inputString;
    NumberInputDelegate* m_delegate;
}

[[link(android)]]
class OBB2D : cocos2d::CCNode {
    // virtual ~OBB2D();

    static OBB2D* create(cocos2d::CCPoint center, float width, float height, float rotationAngle) = win 0x6d8d0;

    void calculateWithCenter(cocos2d::CCPoint center, float width, float height, float rotationAngle) = win 0x6daa0;
    void computeAxes() = win inline {
        m_edges[0] = m_corners[1] - m_corners[0];
        m_edges[1] = m_corners[3] - m_corners[0];
        for (int i = 0; i < 2; i++) {
            m_edges[i] = m_edges[i] * (1.f / (m_edges[i].x * m_edges[i].x + m_edges[i].y * m_edges[i].y));
            m_projections[i] = m_corners[0].x * m_edges[i].x + m_corners[0].y * m_edges[i].y;
        }
    }
    cocos2d::CCRect getBoundingRect() = win 0x6e290;
    bool init(cocos2d::CCPoint center, float width, float height, float rotationAngle) = win inline {
        if (!CCNode::init()) return false;
        this->calculateWithCenter(center, width, height, rotationAngle);
        return true;
    }
    void orderCorners() = win 0x6ddc0;
    bool overlaps(OBB2D* other) = win inline {
        return this->overlaps1Way(other) && other->overlaps1Way(this);
    }
    bool overlaps1Way(OBB2D* other) = win 0x6e150;

    std::array<cocos2d::CCPoint, 4> m_corners;
    std::array<cocos2d::CCPoint, 4> m_positions;
    std::array<cocos2d::CCPoint, 4> m_edges;
    std::array<double, 2> m_projections;
    cocos2d::CCPoint m_center;
}

[[link(android)]]
class ObjectControlGameObject : EffectGameObject {
    // virtual ~ObjectControlGameObject();
    ObjectControlGameObject() {}

    static ObjectControlGameObject* create() = win inline {
        auto ret = new ObjectControlGameObject();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init();
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists);
    virtual gd::string getSaveString(GJBaseGameLayer* layer);
}

[[link(android)]]
class ObjectManager : cocos2d::CCNode {
    static ObjectManager* instance() = win 0x6e420;
    static cocos2d::CCDictionary* replaceAllOccurencesOfString(cocos2d::CCString* target, cocos2d::CCString* replacement, cocos2d::CCDictionary* dict) = win 0x6f1f0;

    // virtual ~ObjectManager();
    virtual bool init() = win 0x6e4b0;

    bool animLoaded(char const* anim) = win inline {
        return m_loadedAnimations->objectForKey(anim) != nullptr;
    }
    cocos2d::CCDictionary* getDefinition(char const* definitionKey);
    cocos2d::CCDictionary* getGlobalAnimCopy(char const* anim) = win inline {
        return static_cast<cocos2d::CCDictionary*>(static_cast<cocos2d::CCDictionary*>(m_objectDefinitions->objectForKey("GlobalAnimations"))->objectForKey(anim));
    }
    void loadCopiedAnimations() = win 0x6e850;
    void loadCopiedSets() = win 0x6eda0;
    void purgeObjectManager() = win inline {
        auto objectManager = reinterpret_cast<ObjectManager**>(geode::base::get() + 0x6a4e30);
        if (*objectManager) {
            (*objectManager)->release();
            *objectManager = nullptr;
        }
    }
    void setLoaded(char const* objectName) = win inline {
        m_loadedAnimations->setObject(cocos2d::CCNode::create(), objectName);
    }
    void setup() = win 0x6e510;

    cocos2d::CCDictionary* m_objectDefinitions;
    cocos2d::CCDictionary* m_loadedAnimations;
}

[[link(android)]]
class ObjectToolbox : cocos2d::CCNode {
    // virtual ~ObjectToolbox();

    static ObjectToolbox* sharedState() = win 0x3489e0;

    virtual bool init() = win 0x348aa0;

    cocos2d::CCArray* allKeys() = win inline, ios inline {
        return nullptr;
    }
    float gridNodeSizeForKey(int key) = win 0x3708d0;
    const char* intKeyToFrame(int key) = win 0x3708a0;
    const char* perspectiveBlockFrame(int key) = win 0x3712f0;

    gd::map<int, gd::string> m_allKeys;
}

[[link(android)]]
class OnlineListDelegate {
    virtual void loadListFinished(cocos2d::CCArray* objects, char const* key) {}
    virtual void loadListFailed(char const* key) {}
    virtual void setupPageInfo(gd::string info, char const* key) {}
}

[[link(android)]]
class OpacityEffectAction {
    void step(float delta) = win inline {
        if (m_disabled || m_finished) return;

        m_deltaTime += delta;
        auto currentTime = m_deltaTime + m_deltaTimeRelated;
        float factor;
        if (currentTime < m_duration) {
            if (currentTime > 0.f) factor = currentTime / m_duration;
            else factor = 0.f;
        }
        else factor = 1.f;
        m_finished = currentTime >= m_duration;
        m_currentValue = (m_toValue - m_fromValue) * factor + m_fromValue;
    }

    float m_duration;
    float m_fromValue;
    float m_toValue;
    bool m_finished;
    bool m_disabled;
    float m_deltaTime;
    int m_targetGroupID;
    float m_currentValue;
    int m_triggerUniqueID;
    int m_controlID;
    float m_deltaTimeRelated;
    float m_durationRelated;
}

[[link(android)]]
class OptionsCell : TableViewCell {
    // virtual ~OptionsCell();
    OptionsCell(char const* identifier, float width, float height) = win inline : TableViewCell(identifier, width, height) {
        m_optionsObject = nullptr;
        this->init();
    }

    void loadFromObject(OptionsObject* object) = win 0xb5190;
    void onToggleOption(cocos2d::CCObject* sender) = win 0xb5530;
    void updateBGColor(int index) = win inline {
        m_backgroundLayer->setColor(index % 2 == 0 ? cocos2d::ccColor3B { 161, 88, 44 } : cocos2d::ccColor3B { 194, 114, 62 });
        m_backgroundLayer->setOpacity(255);
    }

    OptionsObject* m_optionsObject;
}

[[link(android)]]
class OptionsLayer : GJDropDownLayer, FLAlertLayerProtocol {
    // virtual ~OptionsLayer();
    OptionsLayer() {
        m_optionsMenu = nullptr;
        m_unknown = nullptr;
        m_layerChoice = 0;
        m_recordReplays = false;
        m_lastVaultDialog = -1;
    }

    static OptionsLayer* create() = win inline {
        auto ret = new OptionsLayer();
        if (ret->init("Settings")) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void customSetup() = win 0x371a40;
    virtual void layerHidden() = win 0x373290;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win inline {}

    CCMenuItemToggler* createToggleButton(gd::string text, cocos2d::SEL_MenuHandler selector, bool toggled, cocos2d::CCMenu* menu, cocos2d::CCPoint position) = win inline, ios inline {
        auto onSprite = cocos2d::CCSprite::createWithSpriteFrameName("GJ_checkOn_001.png");
        auto offSprite = cocos2d::CCSprite::createWithSpriteFrameName("GJ_checkOff_001.png");
        onSprite->setScale(.8f);
        offSprite->setScale(.8f);
        auto toggler = CCMenuItemToggler::create(offSprite, onSprite, this, selector);
        toggler->toggle(toggled);
        menu->addChild(toggler);
        toggler->setPosition(menu->convertToNodeSpace(position));
        toggler->setSizeMult(1.5f);
        auto label = cocos2d::CCLabelBMFont::create(text.c_str(), "bigFont.fnt");
        m_mainLayer->addChild(label);
        label->setAnchorPoint({ .0f, .5f });
        label->setPosition(position + cocos2d::CCPoint { onSprite->getContentSize().width * .5f + 6.4f, 0.f });
        auto width = label->getContentSize().width;
        if (width > 120.f) label->setScale(120.f / width);
        label->setScale(std::min(label->getScale(), .35f));
        return toggler;
    }
    void exitLayer() = win inline, ios inline {
        GJDropDownLayer::exitLayer(nullptr);
    }
    void musicSliderChanged(cocos2d::CCObject* sender) = win 0x3726c0;
    void onAccount(cocos2d::CCObject* sender) = win 0x3731b0;
    void onHelp(cocos2d::CCObject* sender) = win 0x373160;
    void onMenuMusic(cocos2d::CCObject* sender) = win 0x3725b0;
    void onOptions(cocos2d::CCObject* sender) = win 0x3728a0;
    void onProgressBar(cocos2d::CCObject* sender) = win inline, ios inline {
        auto gameManager = GameManager::sharedState();
        gameManager->m_showProgressBar = !gameManager->m_showProgressBar;
    }
    void onRate(cocos2d::CCObject* sender) = win 0x373200;
    void onRecordReplays(cocos2d::CCObject* sender) = win inline, ios inline {
        auto gameManager = GameManager::sharedState();
        gameManager->m_recordGameplay = !gameManager->m_recordGameplay;
    }
    void onSecretVault(cocos2d::CCObject* sender) = win 0x372a00;
    void onSoundtracks(cocos2d::CCObject* sender);
    void onSupport(cocos2d::CCObject* sender);
    void onVideo(cocos2d::CCObject* sender) = ios inline {
        VideoOptionsLayer::create()->show();
    }
    void sfxSliderChanged(cocos2d::CCObject* sender);
    void tryEnableRecord() = win inline, ios inline {
        m_recordReplays = false;
        FLAlertLayer::create(
            nullptr,
            "Unavailable",
            "Gameplay recording is not supported on this device.",
            "OK",
            nullptr,
            300.f
        )->show();
    }

    cocos2d::CCMenu* m_optionsMenu;
    void* m_unknown;
    int m_layerChoice;
    bool m_recordReplays;
    Slider* m_musicSlider;
    Slider* m_sfxSlider;
    int m_lastVaultDialog;
}

[[link(android)]]
class OptionsObject : cocos2d::CCObject {
    // virtual ~OptionsObject();

    static OptionsObject* create(int id, bool enabled, gd::string name, OptionsObjectDelegate* delegate) = win 0x29e500;

    bool init(int id, bool enabled, gd::string name, OptionsObjectDelegate* delegate) = win inline, ios inline {
        m_optionID = id;
        m_enabled = enabled;
        m_name = name;
        m_delegate = delegate;
        return true;
    }
    void toggleState() = win inline {
        m_enabled = !m_enabled;
        if (m_delegate) m_delegate->stateChanged(this);
    }

    int m_optionID;
    bool m_enabled;
    gd::string m_name;
    OptionsObjectDelegate* m_delegate;
    int m_count;
}

[[link(android)]]
class OptionsObjectDelegate {
    virtual void stateChanged(OptionsObject* object) {}
}

[[link(android)]]
class OptionsScrollLayer : FLAlertLayer, TableViewCellDelegate {
    // virtual ~OptionsScrollLayer();

    static OptionsScrollLayer* create(cocos2d::CCArray* objects, bool recreate, int minimum) = win 0x33a8a0;

    virtual void registerWithTouchDispatcher() = win 0x42660;
    virtual void keyBackClicked();
    virtual bool cellPerformedAction(TableViewCell* cell, int listType, CellAction action, cocos2d::CCNode* parent) = win 0x33ad60;

    cocos2d::CCArray* getRelevantObjects(cocos2d::CCArray* objects) = win inline {
        auto relevantObjects = cocos2d::CCArray::create();
        CCObject* obj;
        CCARRAY_FOREACH(objects, obj) {
            auto object = static_cast<OptionsObject*>(obj);
            if (object->m_count > m_minCount || object->m_enabled) {
                relevantObjects->addObject(object);
            }
        }
        return relevantObjects;
    }
    bool init(cocos2d::CCArray* objects, bool recreate, int minimum) = win inline {
        if (!FLAlertLayer::init(150)) return false;
        m_noElasticity = true;
        m_recreateList = recreate;
        m_minCount = minimum;
        if (objects) {
            m_optionObjects = objects;
            objects->retain();
        }
        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        m_buttonMenu = cocos2d::CCMenu::create();
        m_mainLayer->addChild(m_buttonMenu, 10);
        m_joystickConnected = -1;
        auto closeButton = CCMenuItemSpriteExtra::create(cocos2d::CCSprite::createWithSpriteFrameName("GJ_closeBtn_001.png"), this, menu_selector(OptionsScrollLayer::onClose));
        closeButton->setSizeMult(1.6f);
        closeButton->setPosition(m_buttonMenu->convertToNodeSpace(winSize * .5f + cocos2d::CCPoint { -210.f, 135.f }));
        this->setupList(m_optionObjects);
        return true;
    }
    void onClose(cocos2d::CCObject* sender) = win 0x33acc0;
    void setupList(cocos2d::CCArray* objects) = win 0x33aaf0;

    cocos2d::CCArray* m_optionObjects;
    GJCommentListLayer* m_listLayer;
    bool m_recreateList;
    int m_minCount;
}

[[link(android)]]
class ParentalOptionsLayer : FLAlertLayer {
    ParentalOptionsLayer() {
        m_page = -1;
        m_toggleCount = 0;
        m_maxPage = 0;
    }
    ~ParentalOptionsLayer() = win inline {
        CC_SAFE_RELEASE(m_variables);
        CC_SAFE_RELEASE(m_values);
    }

    static ParentalOptionsLayer* create() = win inline {
        auto ret = new ParentalOptionsLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x37b2c0;
    virtual void keyBackClicked() = win 0x846c0;

    void addToggle(char const* label, char const* variable, char const* info) = win 0x37b710;
    int countForPage(int page);
    void goToPage(int page);
    void incrementCountForPage(int page) = win inline {
        m_values->setObject(cocos2d::CCString::createWithFormat("%i", this->countForPage(page) + 1), this->pageKey(page));
    }
    const char* infoKey(int index) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("info_%i", index)->getCString();
    }
    cocos2d::CCLayer* layerForPage(int page);
    const char* layerKey(int page) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("layer_%i", page)->getCString();
    }
    cocos2d::CCPoint nextPosition(int page) = win inline {
        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        auto count = this->countForPage(page);
        cocos2d::CCPoint pos = winSize * .5f + cocos2d::CCPoint { count % 2 == 0 ? -135.f : 35.f, 60.f };
        if (count > 1) pos.y -= (int)(count * .5f) * 48;
        return pos;
    }
    const char* objectKey(int page) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("object_%i", page)->getCString();
    }
    cocos2d::CCArray* objectsForPage(int page);
    void onClose(cocos2d::CCObject* sender) = win 0x84690;
    void onInfo(cocos2d::CCObject* sender) = win inline {
        FLAlertLayer::create(
            nullptr,
            "Info",
            m_values->valueForKey(this->infoKey(sender->getTag()))->getCString(),
            "OK",
            nullptr,
            300.f
        )->show();
    }
    void onNextPage(cocos2d::CCObject* sender);
    void onPrevPage(cocos2d::CCObject* sender);
    void onToggle(cocos2d::CCObject* sender) = win 0x37beb0;
    const char* pageKey(int page) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("page_%i", page)->getCString();
    }

    int m_page;
    int m_toggleCount;
    int m_maxPage;
    cocos2d::CCDictionary* m_values;
    cocos2d::CCDictionary* m_variables;
    CCMenuItemSpriteExtra* m_prevButton;
    CCMenuItemSpriteExtra* m_nextButton;
}

[[link(android)]]
class ParticleGameObject : EnhancedGameObject {
    // virtual ~ParticleGameObject();
    ParticleGameObject() {
        m_updatedParticleData = false;
        m_hasUniformObjectColor = false;
        m_popupPage = 0;
        m_shouldQuickStart = false;
        m_respawnResult = -1.f;
        m_startingRespawn = false;
        m_notPreviewing = false;
    }

    static ParticleGameObject* create() = win 0x49f790;

    virtual bool init() = win 0x49f8b0;
    virtual void setScaleX(float scaleX);
    virtual void setScaleY(float scaleY);
    virtual void setScale(float scale);
    virtual void setRotation(float rotation);
    virtual void setRotationX(float rotationX) = win 0x4a08a0;
    virtual void setRotationY(float rotationY) = win 0x4a0a10;
    virtual void setChildColor(cocos2d::ccColor3B const& color);
    virtual void customSetup();
    virtual void addMainSpriteToParent(bool reorder) = win 0x49fbd0;
    virtual void resetObject();
    virtual void deactivateObject(bool deactivate) = win 0x4a1130;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x49f910;
    virtual gd::string getSaveString(GJBaseGameLayer* layer);
    virtual void claimParticle() = win 0x49fcc0;
    virtual void unclaimParticle() = win 0x4a0280;
    virtual void particleWasActivated() = win 0x4a0360;
    virtual void setObjectColor(cocos2d::ccColor3B const& color);
    virtual void blendModeChanged() = win 0x49fb90;
    virtual void updateParticleColor(cocos2d::ccColor3B const& color) {}
    virtual void updateParticleOpacity(unsigned char opacity) {}
    virtual void updateMainParticleOpacity(unsigned char opacity) = win 0x4a1050;
    virtual void updateSecondaryParticleOpacity(unsigned char opacity) = win 0x4a10d0;
    virtual void updateSyncedAnimation(float totalTime, int frameIndex) = win 0x4a11d0;
    virtual void updateAnimateOnTrigger(bool animate) = win 0x4a1340;

    void applyParticleSettings(cocos2d::CCParticleSystemQuad* particle) = win 0x49fec0;
    void createAndAddCustomParticle() = win inline {
        if (!m_particleData.empty()) {
            m_hasParticles = true;
            this->updateParticleStruct();
            m_hasParticles = true;
        }
    }
    void createParticlePreviewArt() = win 0x4a0650;
    void setParticleString(gd::string str) = win 0x4a0420;
    void updateParticle() = win 0x4a04b0;
    void updateParticleAngle(float angle, cocos2d::CCParticleSystemQuad* particle) = win 0x4a0b40;
    void updateParticlePreviewArtOpacity(float opacity) = win 0x4a07e0;
    void updateParticleScale(float scale) = win inline {
        if (m_particle) {
            this->updateParticleAngle(this->getRotation(), m_particle);
            m_particle->loadScaledDefaults(std::abs(scale));
        }
    }
    void updateParticleStruct() = win inline {
        if (!m_updatedParticleData) return;
        m_updatedParticleData = false;
        GameToolbox::particleStringToStruct(m_particleData, m_particleStruct);
    }

    // property 145
    gd::string m_particleData;
    bool m_updatedParticleData;
    cocos2d::ParticleStruct m_particleStruct;
    // property 147
    bool m_hasUniformObjectColor;
    int m_popupPage;
    // property 211
    bool m_shouldQuickStart;
    float m_respawnResult;
    bool m_startingRespawn;
    bool m_notPreviewing;
}

[[link(android)]]
class ParticlePreviewLayer : cocos2d::CCLayerColor {
    // virtual ~ParticlePreviewLayer();
    ParticlePreviewLayer() {
        m_particleMode = 0;
        m_particleSystem = nullptr;
        m_gravityMode = false;
    }

    static ParticlePreviewLayer* create(cocos2d::CCParticleSystemQuad* particleSystem) = win inline {
        auto ret = new ParticlePreviewLayer();
        if (ret->init(particleSystem)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void draw() = win 0x4355b0;
    virtual void visit() = win 0x4354d0;

    bool init(cocos2d::CCParticleSystemQuad* particleSystem) = win inline {
        if (!cocos2d::CCLayerColor::initWithColor({ 0, 0, 0, 255 }, 120.f, 180.f)) return false;
        m_particleSystem = particleSystem;
        this->addChild(particleSystem, 100);
        return true;
    }
    void postVisit() = win inline, ios inline {
        glDisable(GL_SCISSOR_TEST);
    }
    void preVisitWithClippingRect(cocos2d::CCRect rect) = win inline, ios inline {
        if (this->isVisible()) {
            glEnable(GL_SCISSOR_TEST);
            auto position = this->getParent()->convertToWorldSpace(this->getPosition() + rect.origin);
            cocos2d::CCEGLView::sharedOpenGLView()->setScissorInPoints(position.x, position.y, rect.size.width, rect.size.height);
        }
    }

    int m_particleMode;
    int m_drawMode;
    cocos2d::CCParticleSystemQuad* m_particleSystem;
    bool m_gravityMode;
}

[[link(android)]]
class PauseLayer : CCBlockLayer, FLAlertLayerProtocol {
    // virtual ~PauseLayer();
    PauseLayer() {
        m_unfocused = false;
        m_tryingQuit = false;
    }

    static PauseLayer* create(bool unfocused) = win inline {
        auto ret = new PauseLayer();
        if (ret && ret->init(unfocused)) {
            ret->autorelease();
            return ret;
        }
        CC_SAFE_DELETE(ret);
        return nullptr;
    }

    virtual void keyBackClicked() = win 0x37eb10;
    virtual void keyDown(cocos2d::enumKeyCodes key) = win 0x37ea40;
    virtual void customSetup() = win 0x2c24c0;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x37e880;
    virtual void keyUp(cocos2d::enumKeyCodes key) = win inline {}

    void createToggleButton(gd::string label, cocos2d::SEL_MenuHandler selector, bool toggled, cocos2d::CCMenu* menu, cocos2d::CCPoint position) = win inline, ios inline {
        auto onSprite = cocos2d::CCSprite::createWithSpriteFrameName("GJ_checkOn_001.png");
        auto offSprite = cocos2d::CCSprite::createWithSpriteFrameName("GJ_checkOff_001.png");
        onSprite->setScale(.6f);
        offSprite->setScale(.6f);
        auto toggler = CCMenuItemToggler::create(offSprite, onSprite, this, selector);
        toggler->toggle(toggled);
        menu->addChild(toggler);
        toggler->setPosition(menu->convertToNodeSpace(position));
        toggler->setSizeMult(1.5f);
        auto labelNode = cocos2d::CCLabelBMFont::create(label.c_str(), "bigFont.fnt");
        this->addChild(labelNode);
        labelNode->setAnchorPoint({ .0f, .5f });
        labelNode->setPosition(position + cocos2d::CCPoint { onSprite->getContentSize().width * .5f + 3.6f, 0.f });
        labelNode->limitLabelWidth(80.f, .4f, .0f);
    }
    void goEdit() = win 0x37e620;
    bool init(bool unfocused) = win inline, ios inline {
        m_unfocused = unfocused;
        return CCBlockLayer::init();
    }
    void musicSliderChanged(cocos2d::CCObject* sender);
    void onEdit(cocos2d::CCObject* sender) = win 0x37e430;
    void onHelp(cocos2d::CCObject* sender);
    void onNormalMode(cocos2d::CCObject* sender);
    void onPracticeMode(cocos2d::CCObject* sender);
    void onQuit(cocos2d::CCObject* sender) = win 0x37e8f0;
    void onRecordReplays(cocos2d::CCObject* sender);
    void onReplay(cocos2d::CCObject* sender);
    void onRestart(cocos2d::CCObject* sender);
    void onRestartFull(cocos2d::CCObject* sender);
    void onResume(cocos2d::CCObject* sender);
    void onSettings(cocos2d::CCObject* sender) = win 0x37d270;
    void onTime(cocos2d::CCObject* sender);
    void onTryEdit(cocos2d::CCObject* sender) = win 0x37e280;
    void setupProgressBars() = win 0x37d420;
    void sfxSliderChanged(cocos2d::CCObject* sender);
    void tryQuit(cocos2d::CCObject* sender) = win 0x37e6f0;
    void tryShowBanner(float dt);

    bool m_unfocused;
    bool m_tryingQuit;
}

[[link(android)]]
class PlatformDownloadDelegate {
    virtual void downloadFinished(char const* key) {}
    virtual void downloadFailed(char const* key) {}
}

[[link(android)]]
class PlatformToolbox {
    static void activateGameCenter() = win inline {}
    static bool copyToClipboard(gd::string str) = win 0x787b0;
    static bool doesFileExist(gd::string path) = win inline {
        return false;
    }
    static void downloadAndSavePromoImage(gd::string url, gd::string path) = win inline, ios inline {}
    static void gameDidSave() = win inline {
        cocos2d::CCApplication::sharedApplication()->gameDidSave();
    }
    static float getDeviceRefreshRate() {
        return 60.f;
    }
    static cocos2d::CCSize getDisplaySize() = win 0x78720;
    static gd::string getRawPath(char const* path) = win inline {
        return "";
    }
    static gd::string getUniqueUserID() = win 0x78530;
    static gd::string getUserID() = win inline {
        return PlatformToolbox::getUniqueUserID();
    }
    static void hideCursor() = win inline {
        cocos2d::CCEGLView::sharedOpenGLView()->showCursor(false);
    }
    static bool isControllerConnected() = win inline {
        return cocos2d::CCApplication::sharedApplication()->getControllerConnected();
    }
    static bool isHD() = win inline {
        return false;
    }
    static bool isLocalPlayerAuthenticated() = win inline {
        return false;
    }
    static bool isLowMemoryDevice() = win inline {
        return false;
    }
    static bool isNetworkAvailable() = win inline {
        return true;
    }
    static bool isSignedInGooglePlay() = win inline {
        return false;
    }
    static void loadAndDecryptFileToString(char const* dirPath, char const* fileName, gd::string& str);
    static void logEvent(char const* event) = win inline {}
    static void onGameLaunch() = win inline, ios inline {}
    static void onNativePause() = win inline {}
    static void onNativeResume() = win inline {}
    static void onToggleKeyboard() = win inline {}
    static void openAppPage() = win inline {}
    static void platformShutdown();
    static void refreshWindow();
    static void reportAchievementWithID(char const* key, int percent);
    static void reportLoadingFinished() = win inline {}
    static void resizeWindow(float width, float height) = win inline {
        auto view = cocos2d::CCEGLView::sharedOpenGLView();
        view->resizeWindow(width, height);
        view->centerWindow();
    }
    static void saveAndEncryptStringToFile(gd::string& str, char const* dirPath, char const* fileName);
    static void sendMail(char const* title, char const* content, char const* address) = win inline {}
    static void setBlockBackButton(bool block) = win inline, ios inline {}
    static void setKeyboardState(bool state) = win inline {}
    static bool shouldResumeSound() = win inline {
        return true;
    }
    static void showAchievements() = win inline {}
    static void showCursor() = win inline {
        cocos2d::CCEGLView::sharedOpenGLView()->showCursor(true);
    }
    static void signInGooglePlay() = win inline, ios inline {}
    static void signOutGooglePlay() = win inline, ios inline {}
    static cocos2d::CCSprite* spriteFromSavedFile(gd::string path);
    static void toggleCallGLFinish(bool enable) = win inline, ios inline {}
    static void toggleCPUSleepMode(bool enable) = win inline, ios inline {}
    static void toggleForceTimer(bool enable) = win inline {
        cocos2d::CCApplication::sharedApplication()->setForceTimer(enable);
    }
    static void toggleFullScreen(bool fullscreen, bool borderless, bool fix) = win inline {
        cocos2d::CCEGLView::sharedOpenGLView()->toggleFullScreen(fullscreen, borderless, fix);
    }
    static void toggleLockCursor(bool isLocked) = win inline {
        cocos2d::CCEGLView::sharedOpenGLView()->toggleLockCursor(isLocked);
    }
    static void toggleMouseControl(bool enable) = win inline {
        cocos2d::CCApplication::sharedApplication()->toggleMouseControl(enable);
    }
    static void toggleSmoothFix(bool enable) = win inline {
        cocos2d::CCDirector::sharedDirector()->setSmoothFix(enable);
    }
    static void toggleVerticalSync(bool enable) = win inline {
        cocos2d::CCApplication::sharedApplication()->toggleVerticalSync(enable);
    }
    static void tryShowRateDialog(gd::string gameName) = win inline {}
    static void updateMouseControl() = win inline, ios inline {
        #ifdef GEODE_IS_WINDOWS
        cocos2d::CCApplication::sharedApplication()->updateMouseControl();
        #endif
    }
    static void updateWindowedSize(float width, float height) = win inline, ios inline {
        #ifdef GEODE_IS_WINDOWS
        cocos2d::CCEGLView::sharedOpenGLView()->setWindowedSize({ width, height });
        #endif
    }
}

class PlayerButtonCommand {
    PlayerButton m_button;
    bool m_isPush;
    bool m_isPlayer2;
    int m_step;
}

[[link(android)]]
class PlayerCheckpoint : cocos2d::CCNode {
    // virtual ~PlayerCheckpoint();
    PlayerCheckpoint() {
        m_yVelocity = 0.f;
        m_isUpsideDown = false;
        m_isSideways = false;
        m_isShip = false;
        m_isBall = false;
        m_isBird = false;
        m_isSwing = false;
        m_isDart = false;
        m_isRobot = false;
        m_isSpider = false;
        m_isOnGround = false;
        m_ghostType = GhostType::Disabled;
        m_miniMode = false;
        m_speed = 0.f;
        m_hidden = false;
        m_goingLeft = false;
        m_reverseSpeed = 0.f;
        m_dashing = false;
        m_dashX = 0.f;
        m_dashY = 0.f;
        m_dashAngle = 0.f;
        m_dashStartTime = 0.f;
        m_dashRingObject = nullptr;
        m_platformerCheckpoint = false;
        m_lastFlipTime = 0.0;
        m_gravityMod = 1.f;
        m_decreaseBoostSlide = false;
        m_followRelated = 0;
        m_followRelated2 = 0.f;
    }

    static PlayerCheckpoint* create();

    virtual bool init();

    cocos2d::CCPoint m_position;
    cocos2d::CCPoint m_lastPosition;
    float m_yVelocity;
    bool m_isUpsideDown;
    bool m_isSideways;
    bool m_isShip;
    bool m_isBall;
    bool m_isBird;
    bool m_isSwing;
    bool m_isDart;
    bool m_isRobot;
    bool m_isSpider;
    bool m_isOnGround;
    GhostType m_ghostType;
    bool m_miniMode;
    float m_speed;
    bool m_hidden;
    bool m_goingLeft;
    float m_reverseSpeed;
    bool m_dashing;
    float m_dashX;
    float m_dashY;
    float m_dashAngle;
    float m_dashStartTime;
    DashRingObject* m_dashRingObject;
    bool m_platformerCheckpoint;
    double m_lastFlipTime;
    float m_gravityMod;
    bool m_decreaseBoostSlide;
    int m_followRelated;
    gd::vector<float> m_playerFollowFloats;
    float m_followRelated2;
}

[[link(android)]]
class PlayerControlGameObject : EffectGameObject {
    // virtual ~PlayerControlGameObject();
    PlayerControlGameObject() {
        m_stopJump = false;
        m_stopMove = false;
        m_stopRotation = false;
        m_stopSlide = false;
    }

    static PlayerControlGameObject* create() = win inline {
        auto ret = new PlayerControlGameObject();
        if (ret && ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init();
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4c2870;
    virtual gd::string getSaveString(GJBaseGameLayer* layer);

    // property 540
    bool m_stopJump;
    // property 541
    bool m_stopMove;
    // property 542
    bool m_stopRotation;
    // property 543
    bool m_stopSlide;
}

[[link(android)]]
class PlayerFireBoostSprite : cocos2d::CCSprite {
    // virtual ~PlayerFireBoostSprite();

    static PlayerFireBoostSprite* create();

    virtual bool init() = win 0x3a3ad0;

    void animateFireIn() = win inline {
        this->stopAllActions();

        auto scaleto = cocos2d::CCScaleTo::create(0.06f, m_size * 0.6f, m_size * 1.5f);
        auto callfunc = cocos2d::CCCallFunc::create(this, callfunc_selector(PlayerFireBoostSprite::loopFireAnimation));
        auto sequence = cocos2d::CCSequence::create(scaleto, callfunc, nullptr);
        this->runAction(sequence);
    }
    void animateFireOut() = win inline {
        this->stopAllActions();
        auto action = cocos2d::CCScaleTo::create(0.4f, 0.01f, 0.01f);
        this->runAction(action);
    }
    void loopFireAnimation() = win 0x3a3b30;

    float m_size;
}

[[link(android), depends(GJPointDouble)]]
class PlayerObject : GameObject, AnimatedSpriteDelegate {
    // virtual ~PlayerObject();
    PlayerObject() {

        #if defined(__clang__)
        # pragma clang diagnostic push
        # pragma clang diagnostic ignored "-Winvalid-offsetof"
        #endif
        // Almost all members are initialized to zeros, so we can cheat here to avoid unnecessary code
        auto selfSize = sizeof(PlayerObject) - offsetof(PlayerObject, m_mainLayer);
        memset((void*)((uintptr_t)this + offsetof(PlayerObject, m_mainLayer)), 0, selfSize);

        #if defined(__clang__)
        # pragma clang diagnostic pop
        #endif

        m_lastCollisionBottom = -1;
        m_lastCollisionTop = -1;
        m_lastCollisionLeft = -1;
        m_lastCollisionRight = -1;
        m_unk50C = -1;
        m_unk510 = -1;
        new (&m_rotateObjectsRelated) decltype(m_rotateObjectsRelated)();
        new (&m_potentialSlopeMap) decltype(m_potentialSlopeMap)();
        m_rotateSpeed = 1.0f;
        new (&m_ringRelatedSet) decltype(m_ringRelatedSet)();
        m_playerSpeed = 0.9f;
        m_platformerVelocityRelated = 1.0f;
        new (&m_touchedRings) decltype(m_touchedRings)();
        m_gravityMod = 1.0f;
        new (&m_jumpPadRelated) decltype(m_jumpPadRelated)();
        new (&m_holdingButtons) decltype(m_holdingButtons)();
        new (&m_currentRobotAnimation) gd::string("run");
    }
    ~PlayerObject() = win 0x3861d0;

    static PlayerObject* create(int player, int ship, GJBaseGameLayer* gameLayer, cocos2d::CCLayer* layer, bool playLayer) = win 0x386400;

    virtual void update(float dt) = win 0x388ab0;
    virtual void setScaleX(float scale);
    virtual void setScaleY(float scale);
    virtual void setScale(float scale);
    virtual void setPosition(cocos2d::CCPoint const& position) = win 0x39c2d0;
    virtual void setVisible(bool visible) = win 0x3a35f0;
    virtual void setRotation(float rotation);
    virtual void setOpacity(unsigned char opacity);
    virtual void setColor(cocos2d::ccColor3B const& color) = win 0x39cfa0;
    virtual void setFlipX(bool flipX) = win 0x3a3500;
    virtual void setFlipY(bool flipY) = win 0x198240;
    virtual void resetObject() = win 0x396b70;
    virtual cocos2d::CCPoint getRealPosition() = win 0x39d8b0;
    virtual OBB2D* getOrientedBox() = win 0x3a02e0;
    virtual float getObjectRotation();
    virtual void animationFinished(char const* key) = win 0x3a3610;

    void activateStreak() = win 0x39fd20;
    void addAllParticles() = win 0x3883a0;
    void addToTouchedRings(RingObject* object) = win inline {
        if (!m_touchingRings->containsObject(object)) {
            m_touchingRings->addObject(object);
        }
        m_touchedRings.insert(object->m_uniqueID);
    }
    void addToYVelocity(double yVelocity, int type) = win inline, ios inline {
        this->setYVelocity(m_yVelocity + yVelocity, type);
    }
    void animatePlatformerJump(float scale) = win 0x38c9b0;
    void boostPlayer(float yVelocity) = win 0x39fb70;
    void bumpPlayer(float bumpMod, int objectType, bool noEffects, GameObject* object) = win 0x39f330;
    bool buttonDown(PlayerButton button) = win inline, ios inline {
        return button == PlayerButton::Jump || m_jumpBuffered;
    }
    bool canStickToGround() = win inline {
        return (!m_isShip && !m_isDart) || !m_stateRingJump;
    }
    void checkSnapJumpToObject(GameObject* object);
    bool collidedWithObject(float dt, GameObject* object) = win inline {
        return this->collidedWithObject(dt, object, { 0.f, 0.f, 0.f, 0.f }, false);
    }
    bool collidedWithObject(float dt, GameObject* object, cocos2d::CCRect rect, bool skipCheck) = win 0x391640;
    bool collidedWithObjectInternal(float dt, GameObject* object, cocos2d::CCRect rect, bool skipCheck) = win 0x391700;
    void collidedWithSlope(float dt, GameObject* object, bool skipPre) = win inline {
        if (m_isSideways) {
            this->handleRotatedSlopeCollision(dt, object, skipPre);
        } else {
            this->collidedWithSlopeInternal(dt, object, skipPre);
        }
    }
    void collidedWithSlopeInternal(float dt, GameObject* object, bool forced) = win 0x38f4a0;
    float convertToClosestRotation(float rotation) = win 0x38ce30;
    void copyAttributes(PlayerObject* player) = win 0x3a0130;
    void createFadeOutDartStreak() = win 0x3982f0;
    void createRobot(int frame);
    void createSpider(int frame);
    void deactivateParticle() = win inline {
        if (m_hasGroundParticles) m_playerGroundParticles->stopSystem();
        m_hasGroundParticles = false;
    }
    void deactivateStreak(bool stop) = win inline {
        if (!m_alwaysShowStreak || stop) m_regularTrail->stopStroke();
        if (m_fadeOutStreak) {
            m_fadeOutStreak = false;
            this->fadeOutStreak2(m_playEffects ? .2f : .6f);
        }
    }
    bool destroyFromHitHead() = win inline {
        return !this->isFlying() && !m_isBall && !m_isSpider && m_stateHitHead < 1;
    }
    void didHitHead() = win 0x3938c0;
    void disableCustomGlowColor() = win inline, ios inline {
        m_hasCustomGlowColor = false;
    }
    void disablePlayerControls() = win 0x39f040;
    void disableSwingFire() = win 0x39ab90;
    void doReversePlayer(bool reverse) = win 0x3981a0;
    void enableCustomGlowColor(cocos2d::ccColor3B const& color) = win inline {
        m_hasCustomGlowColor = true;
        m_glowColor = color;
    }
    void enablePlayerControls() = win 0x39f190;
    void exitPlatformerAnimateJump() = win 0x38cc60;
    void fadeOutStreak2(float duration) = win 0x39fe20;
    void flashPlayer(float flashDuration, float flashDelay, cocos2d::ccColor3B mainColor, cocos2d::ccColor3B secondColor) = win inline, ios inline {
        m_flashMainColor = mainColor;
        m_flashSecondColor = secondColor;
        this->setColor(m_flashMainColor);
        this->setSecondColor(m_flashSecondColor);
        m_flashTime = m_totalTime;
        m_flashDuration = flashDuration;
        m_flashDelay = flashDelay;
    }
    void flipGravity(bool flip, bool noEffects) = win 0x399e60;
    int flipMod() = win inline, ios inline {
        return m_isUpsideDown ? -1 : 1;
    }
    void gameEventTriggered(int gameEvent, int material) = win inline, ios inline {
        if (this->m_gameLayer) {
            this->m_gameLayer->gameEventTriggered(static_cast<GJGameEvent>(gameEvent), material, static_cast<int>(this->m_uniqueID));
        }
    }
    GameObjectType getActiveMode() = win inline {
        if (this->isFlying()) return GameObjectType::ShipPortal;
        else if (m_isBall) return GameObjectType::BallPortal;
        else if (m_isSpider) return GameObjectType::SpiderPortal;
        else return GameObjectType::CubePortal;
    }
    double getCurrentXVelocity() = win inline {
        return m_isPlatformer ? m_platformerXVelocity : m_playerSpeed * m_speedMultiplier;
    }
    float getModifiedSlopeYVel() = win inline, ios inline {
        auto diff = m_totalTime - m_slopeStartTime;
        if (diff > 0.1) {
            if (diff * 10.0 > 0.4) return m_slopeVelocity * diff;
            else return m_slopeVelocity * .4f;
        }
        else return m_slopeVelocity * 1.f;
    }
    float getOldPosition(float dt) = win inline {
        if (dt <= 0.f) return m_obPosition.y;
        auto index = m_followRelated % 200 - std::clamp<int>(dt / .01f, 0, 199);
        return m_playerFollowFloats[index + (index < 0 ? 200 : 0)];
    }
    cocos2d::ccColor3B getSecondColor() = win inline {
        return m_iconSpriteSecondary->getColor();
    }
    double getYVelocity() = win inline {
        return m_yVelocity;
    }
    void gravityDown() = win inline, ios inline {
        m_gravity -= .001;
        this->logValues();
    }
    void gravityUp() = win inline, ios inline {
        m_gravity += .001;
        this->logValues();
    }
    void handlePlayerCommand(int command) = win inline {
        if (command == 543) {
            m_isAccelerating = false;
            m_affectedByForces = false;
        }
    }
    bool handleRotatedCollisionInternal(float dt, GameObject* object, cocos2d::CCRect rect, bool skipCheck, bool skipPre, bool slope) = win 0x38edd0;
    bool handleRotatedObjectCollision(float dt, GameObject* object, cocos2d::CCRect rect, bool skipCheck) = win inline, ios inline {
        return this->handleRotatedCollisionInternal(dt, object, rect, skipCheck, false, false);
    }
    void handleRotatedSlopeCollision(float dt, GameObject* object, bool skipPre) = win inline, ios inline {
        this->handleRotatedCollisionInternal(dt, object, { 0.f, 0.f, 0.f, 0.f }, false, skipPre, true);
    }
    void hardFlipGravity() = win inline {
        this->flipGravity(!m_isUpsideDown, true);
        this->setYVelocity(this->flipMod() * -2, 42);
    }
    void hitGround(GameObject* object, bool notFlipped) = win 0x39bbc0;
    void hitGroundNoJump(GameObject* object, bool notFlipped) = win 0x39bb60, ios inline {
        auto isOnGround = m_isOnGround;
        auto isOnGround2 = m_isOnGround2;
        auto lastLandTime = m_lastLandTime;
        this->hitGround(nullptr, notFlipped);
        m_isOnGround = isOnGround;
        m_isOnGround2 = isOnGround2;
        m_lastLandTime = lastLandTime;
    }
    void incrementJumps() = win 0x38c8d0;
    bool init(int player, int ship, GJBaseGameLayer* gameLayer, cocos2d::CCLayer* layer, bool playLayer) = win 0x3864a0;
    bool isBoostValid(float yVelocity) = win inline {
        if (m_isUpsideDown) {
            if (!m_isCurrentSlopeTop && m_slopeFlipGravityRelated) return yVelocity > m_yVelocity;
            else return yVelocity < m_yVelocity;
        }
        else {
            if (!m_isCurrentSlopeTop || !m_slopeFlipGravityRelated) return yVelocity > m_yVelocity;
            else return yVelocity < m_yVelocity;
        }
    }
    bool isFlying() = win inline {
        return m_isShip || m_isBird || m_isDart || m_isSwing;
    }
    bool isInBasicMode() = win inline {
        return !this->isFlying() && !m_isBall && !m_isSpider;
    }
    bool isInNormalMode() = win inline {
        return !this->isFlying() && !m_isBall && !m_isRobot && !m_isSpider;
    }
    bool isSafeFlip(float flipTime) = win inline {
        return m_lastFlipTime != 0.0 && m_totalTime - m_lastFlipTime < flipTime;
    }
    bool isSafeHeadTest() = win inline {
        return this->isSafeFlip(0.2f) || this->isSafeMode(0.2f) || m_stateHitHead > 0;
    }
    bool isSafeMode(float changeTime) = win inline, ios inline {
        return m_gameModeChangedTime != 0.0 && m_totalTime - m_gameModeChangedTime < changeTime;
    }
    bool isSafeSpiderFlip(float flipTime) = win inline, ios inline {
        return m_lastSpiderFlipTime != 0.0 && m_totalTime - m_lastSpiderFlipTime < flipTime;
    }
    void levelFlipFinished() = win 0x38b480;
    bool levelFlipping() = win 0x39b180;
    void levelWillFlip() = win 0x38b400;
    void limitDashRotation(float& rotation) = win inline {
        float offset;
        if (m_isSideways) {
            if (m_isGoingLeft) offset = 90.f;
            else offset = -90.f;
            rotation += offset;
            if (rotation > 180.f) rotation -= 360.f;
            else if (rotation < -180.f) rotation += 360.f;
        }
        else {
            if (m_isGoingLeft) {
                offset = 180.f;
                rotation += offset;
                if (rotation > 180.f) rotation -= 360.f;
                else if (rotation < -180.f) rotation += 360.f;
            }
            else offset = 0.f;
        }
        if (std::abs(rotation) > 90.f) {
            if (rotation > 0.f) rotation += 180.f;
            else rotation -= 180.f;
            if (rotation > 180.f) rotation -= 360.f;
            else if (rotation < -180.f) rotation += 360.f;
        }
        if (rotation > 70.f || rotation < -70.f) {
            if (rotation > 0.f) {
                if (rotation <= 70.f || rotation >= 180.f) rotation = -70.f;
            }
            else if (rotation < 70.f || rotation > -180.f) {
                rotation = -70.f;
            }
            else {
                rotation = 70.f;
            }
        }
        if (offset != 0.f) {
            rotation -= offset;
            if (rotation > 180.f) rotation -= 360.f;
            else if (rotation < -180.f) rotation += 360.f;
        }
    }
    void loadFromCheckpoint(PlayerCheckpoint* object);
    void lockPlayer() = win 0x39ef60;
    void logValues() = win inline, ios inline {}
    void modeDidChange() = win inline {
        this->updatePlayerArt();
        this->updateDashArt();
    }
    void performSlideCheck() = win inline {
        if (m_currentSlope2 && (m_isOnSlope || m_wasOnSlope) && !m_maybeUpsideDownSlope && !m_currentSlope2->m_isGripSlope && std::abs(m_slopeAngle * (180.f / M_PI)) > 40.f) {
            auto movingLeft = m_platformerMovingLeft;
            auto movingRight = m_platformerMovingRight;
            if (m_slopeSlidingMaybeRotated) {
                m_platformerMovingLeft = !m_isUpsideDown;
                m_platformerMovingRight = m_isUpsideDown;
            }
            else {
                m_platformerMovingLeft = m_isUpsideDown;
                m_platformerMovingRight = !m_isUpsideDown;
            }
            if (m_platformerMovingLeft != movingLeft || m_platformerMovingRight != movingRight) {
                m_changedDirectionsTime = m_totalTime;
            }
            m_maybeChangedDirectionAngle = std::abs(m_slopeAngle * (180.f / M_PI));
            m_maybeGoingCorrectSlopeDirection = true;
        }
        else {
            m_platformerMovingLeft = false;
            m_platformerMovingRight = false;
        }
    }
    void placeStreakPoint() = win 0x3a0310;
    void playBumpEffect(int objectType, GameObject* player) = win 0x39f6e0;
    void playBurstEffect() = win inline {
        if (!this->levelFlipping() && !m_isHidden) {
            m_ufoClickParticles->resumeSystem();
            this->stopActionByTag(7);
            auto action = cocos2d::CCSequence::create(
                cocos2d::CCDelayTime::create(.12f),
                cocos2d::CCCallFunc::create(this, callfunc_selector(PlayerObject::stopBurstEffect)),
                nullptr
            );
            action->setTag(7);
            this->runAction(action);
        }
    }
    void playCompleteEffect(bool noEffects, bool instant) = win 0x383d50;
    void playDeathEffect() = win 0x37ec40;
    void playDynamicSpiderRun() = win 0x3a1160;
    void playerDestroyed(bool noEffects) = win 0x3979d0;
    bool playerIsFalling(float yVelocity) = win inline, ios inline {
        return m_isUpsideDown ? -yVelocity < m_yVelocity : yVelocity > m_yVelocity;
    }
    bool playerIsFallingBugged() = win 0x39a0c0;
    bool playerIsMovingUp() = win inline, ios inline {
        return m_isUpsideDown ? m_yVelocity < 0.0 : m_yVelocity > 0.0;
    }
    void playerTeleported() = win inline {
        m_isOnGround2 = false;
        m_lastGroundedPos = cocos2d::CCPoint { 0.f, 0.f };
        this->placeStreakPoint();
    }
    void playingEndEffect() = win inline {
        if (m_isSpider) m_spiderSprite->tweenToAnimation("fall_loop", .4f);
    }
    void playSpawnEffect() = win 0x397110;
    void playSpiderDashEffect(cocos2d::CCPoint from, cocos2d::CCPoint to) = win 0x394e00;
    void postCollision(float dt) = win 0x38d2b0;
    void preCollision() = win inline {
        m_wasTeleported = false;
        m_ringJumpRelated = false;
        m_collidedTopMinY = 0.0;
        m_collidedBottomMaxY = 0.0;
        m_collidedLeftMaxX = 0.0;
        m_collidedRightMinX = 0.0;
        m_wasOnSlope = m_isOnSlope;
        m_isOnSlope = false;
        m_isOnGround4 = m_isOnGround2;
        if (m_isOnGround2 && !m_platformerMovingLeft && !m_platformerMovingRight && m_maybeSlidingTime > 0) {
            m_maybeSlidingTime = 0;
            m_maybeSlidingStartTime = m_totalTime;
        }
        if (!m_unk669) m_unk669 = true;
        else m_currentPotentialSlope = nullptr;
        m_potentialSlopeMap.clear();
        if (auto slope = m_currentPotentialSlope) {
            m_potentialSlopeMap[slope->m_uniqueID] = slope;
        }
        if (auto slope = m_currentSlope) {
            m_potentialSlopeMap[slope->m_uniqueID] = slope;
        }
    }
    bool preSlopeCollision(float dt, GameObject* object) = win 0x38ef70;
    void propellPlayer(float yVelocity, bool noEffects, int objectType) = win 0x39f4e0;
    bool pushButton(PlayerButton button) = win 0x397bd0;
    void pushDown() = win inline {
        this->setYVelocity(0.0, 46);
        m_isOnGround2 = false;
        m_isOnGround = false;
    }
    void pushPlayer(float yVelocity) = win inline, ios inline {
        this->addToYVelocity(yVelocity, 68);
    }
    void redirectDash(float rotation) = win inline {
        if (!m_isDashing) return;
        cocos2d::CCPoint dashPos = { (float)m_dashX, (float)m_dashY };
        auto direction = GJBaseGameLayer::convertToClosestDirection(rotation * (M_PI / 180.f) - atan2f(dashPos.y, dashPos.x), M_PI);
        if (direction != 0.f) {
            auto cosDir = cosf(direction);
            auto sinDir = sinf(direction);
            dashPos.x = dashPos.x * cosDir - dashPos.y * sinDir;
            dashPos.y = dashPos.x * sinDir + dashPos.y * cosDir;
        }
        auto angle = ((int)-(atan2f(dashPos.y, dashPos.x) * (180.f / M_PI)) + (m_isSideways ? 90 : 0)) % 360;
        m_dashAngle = -(angle + (angle < 0 ? 360 : 0));
        m_dashX = m_isSideways ? dashPos.y : dashPos.x;
        m_dashY = m_isSideways ? dashPos.x : dashPos.y;
        if (m_dashX < 0.0) this->doReversePlayer(!m_isSideways);
        else if (m_dashX > 0.0) this->doReversePlayer(m_isSideways);
        this->updateDashArt();
    }
    void redirectPlayerForce(float rotation, float modifier, float minimum, float maximum) = win 0x39f8f0;
    void releaseAllButtons() = win 0x39ed90;
    bool releaseButton(PlayerButton button) = win 0x397e60;
    void removeAllParticles() = win inline {
        for (int i = 0; i < m_particleSystems->count(); i++) {
            auto particle = static_cast<cocos2d::CCParticleSystem*>(m_particleSystems->objectAtIndex(i));
            particle->resetSystem();
            particle->stopSystem();
            particle->removeFromParentAndCleanup(true);
        }
    }
    void removePendingCheckpoint() = win 0x3a2f00;
    void removePlacedCheckpoint() = win inline {
        if (m_checkpointTimeout) {
            GameManager::sharedState()->m_playLayer->removeCheckpoint(false);
            m_checkpointTimeout = false;
        }
    }
    void resetAllParticles() = win 0x38b510;
    void resetCollisionLog(bool full) = win inline {
        m_collisionLogTop->removeAllObjects();
        m_collisionLogBottom->removeAllObjects();
        m_collisionLogLeft->removeAllObjects();
        m_collisionLogRight->removeAllObjects();
        if (full) {
            m_unk50C = -1;
            m_unk510 = -1;
        }
        else {
            m_unk50C = m_lastCollisionBottom;
            m_unk510 = m_lastCollisionTop;
        }
        m_lastCollisionBottom = -1;
        m_lastCollisionTop = -1;
        m_lastCollisionLeft = -1;
        m_lastCollisionRight = -1;
    }
    void resetCollisionValues() = win inline, ios inline {
        m_collidedTopMinY = 0.0;
        m_collidedBottomMaxY = 0.0;
        m_collidedLeftMaxX = 0.0;
        m_collidedRightMinX = 0.0;
    }
    void resetPlayerIcon() = win 0x39af70;
    void resetStateVariables() = win inline {
        m_stateOnGround = 0;
        m_stateNoAutoJump = 0;
        m_stateDartSlide = 0;
        m_stateHitHead = 0;
        m_stateFlipGravity = 0;
        m_stateBoostX = 0;
        m_stateBoostY = 0;
        m_maybeStateForce2 = 0;
        m_stateScale = 0;
        m_stateForce = 0;
        m_stateForceVector = cocos2d::CCPoint { 0.f, 0.f };
        m_jumpPadRelated.clear();
    }
    void resetStreak();
    void resetTouchedRings(bool removeAll) = win 0x397f70;
    int reverseMod() = win inline, ios inline {
        return (m_isGoingLeft ? -1 : 1);
    }
    void reversePlayer(EffectGameObject* object) = win 0x3980c0;
    void ringJump(RingObject* object, bool skipCheck) = win 0x398890;
    void rotateGameplay(int moveDirection, int groundDirection, bool editVelocity, float velocityModX, float velocityModY, bool overrideVelocity, bool dontSlide) = win 0x3999e0;
    void rotateGameplayObject(GameObject* object) = win 0x391080;
    void rotateGameplayOnly(bool sideways) = win inline {
        m_isSideways = sideways;
        this->updatePlayerArt();
    }
    void rotatePreSlopeObjects() = win inline, ios inline {
        for (auto& pair : m_potentialSlopeMap) {
            this->rotateGameplayObject(pair.second);
        }
    }
    void runBallRotation(float speed) = win 0x38d080;
    void runBallRotation2() = win 0x38d1b0;
    void runNormalRotation() = win inline, ios inline {
        this->runNormalRotation(false, 1.0f);
    }
    void runNormalRotation(bool notNormalMode, float speed) = win 0x38cf50;
    void runRotateAction(bool ground, int type) = win inline {
        if (!m_isLocked && !m_isDashing) {
            this->stopRotation(ground, 22);
            if (m_isBall) this->runBallRotation(1.f);
            else this->runNormalRotation();
        }
    }
    void saveToCheckpoint(PlayerCheckpoint* checkpoint);
    void setSecondColor(cocos2d::ccColor3B const& color) = win 0x39d030;
    void setupStreak() = win 0x3884f0;
    void setYVelocity(double velocity, int type) = win 0x388a40;
    void spawnCircle();
    void spawnCircle2() = win inline, ios inline {
        if (GameManager::sharedState()->m_performanceMode) return;
        auto circleWave = CCCircleWave::create(5.f, 50.f, .3f, false);
        circleWave->m_color = m_playerColor1;
        circleWave->setPosition(this->getPosition());
        m_parentLayer->addChild(circleWave, 0);
    }
    void spawnDualCircle() = win 0x397800;
    void spawnFromPlayer(PlayerObject* player, bool flip) = win inline {
        this->setVisible(true);
        this->setOpacity(255);
        this->copyAttributes(player);
        if (flip) {
            this->flipGravity(!player->m_isUpsideDown, true);
            this->setYVelocity(-player->getYVelocity(), 49);
        }
        else {
            this->flipGravity(player->m_isUpsideDown, true);
            this->setYVelocity(player->getYVelocity(), 49);
        }
        m_isOnGround = false;
        m_isOnGround2 = false;
        this->toggleVisibility(!player->m_isHidden);
        if (m_isDart) this->placeStreakPoint();
    }
    void spawnPortalCircle(cocos2d::ccColor3B color, float startRadius) = win 0x3973f0;
    void spawnScaleCircle() = win 0x397600;
    void specialGroundHit() = win inline, ios inline {
        this->setYVelocity(this->flipMod() * -5, 47);
        if (!m_isBall && !this->isFlying()) this->stopRotation(false, 21);
        m_maybeSpriteRelated = true;
    }
    void speedDown() = win inline, ios inline {
        m_speedMultiplier -= .005;
        this->logValues();
    }
    void speedUp() = win inline, ios inline {
        m_speedMultiplier += .005;
        this->logValues();
    }
    void spiderTestJump(bool dynamic) = win 0x393fd0;
    void spiderTestJumpInternal(bool dynamic) = win 0x394080;
    void spiderTestJumpX(bool dynamic);
    void spiderTestJumpY(bool dynamic);
    void startDashing(DashRingObject* object) = win 0x3955a0;
    void stopBurstEffect() = win 0x39b170;
    void stopDashing() = win 0x3962e0;
    void stopParticles() = win 0x38b590;
    void stopPlatformerJumpAnimation() = win 0x38cd90;
    void stopRotation(bool ground, int type) = win inline {
        m_isRotating = false;
        m_isBallRotating2 = false;
        m_isBallRotating = false;
        m_rotationSpeed = 0.f;
    }
    void stopStreak2() = win inline {
        m_waveTrail->stopActionByTag(8);
        m_waveTrail->setOpacity(0);
        m_waveTrail->stopStroke();
    }
    void storeCollision(PlayerCollisionDirection direction, int id) = win inline, ios inline {
        switch (direction) {
            case PlayerCollisionDirection::Top: {
                if (m_lastCollisionTop != id) {
                    m_lastCollisionTop = id;
                    if (m_collisionLogTop) m_collisionLogTop->setObject(m_maybeLastGroundObject, id);
                }
                break;
            }
            case PlayerCollisionDirection::Bottom: {
                if (m_lastCollisionBottom != id) {
                    m_lastCollisionBottom = id;
                    if (m_collisionLogBottom) m_collisionLogBottom->setObject(m_maybeLastGroundObject, id);
                }
                break;
            }
            case PlayerCollisionDirection::Left: {
                if (m_lastCollisionLeft != id) {
                    m_lastCollisionLeft = id;
                    if (m_collisionLogLeft) m_collisionLogLeft->setObject(m_maybeLastGroundObject, id);
                }
                break;
            }
            case PlayerCollisionDirection::Right: {
                if (m_lastCollisionRight != id) {
                    m_lastCollisionRight = id;
                    if (m_collisionLogRight) m_collisionLogRight->setObject(m_maybeLastGroundObject, id);
                }
                break;
            }
        }
    }
    bool switchedDirTo(PlayerButton button) = win 0x397ac0;
    void switchedToMode(GameObjectType type) = win 0x39bac0;
    bool testForMoving(float dt, GameObject* object) = win inline {
        auto lastPosition = object->getLastPosition();
        auto realPosition = object->getRealPosition();
        if (realPosition.x == lastPosition.x) {
            if (realPosition.y == lastPosition.y) return false;
            if (m_isUpsideDown) {
                if (realPosition.y < lastPosition.y) return false;
            }
            else {
                if (realPosition.y > lastPosition.y) return false;
            }
        }
        auto objectRect = object->getObjectRect();
        objectRect.size.height += dt * 5.f;
        if (m_isUpsideDown) objectRect.origin.y -= dt * 5.f;
        if (this->getObjectRect().intersectsRect(objectRect)) {
            m_collidedObject = object;
            return true;
        }
        else {
            return false;
        }
    }
    void toggleBirdMode(bool enable, bool noEffects) = win 0x39a4b0;
    void toggleDartMode(bool enable, bool noEffects) = win 0x39ac20;
    void toggleFlyMode(bool enable, bool noEffects) = win 0x39a180;
    void toggleGhostEffect(GhostType type) = win 0x39eac0;
    void togglePlatformerMode(bool val) = win inline {
        m_isPlatformer = val;
    }
    void togglePlayerScale(bool enable, bool noEffects) = win 0x3a0390;
    void toggleRobotMode(bool enable, bool noEffects) = win 0x39b380;
    void toggleRollMode(bool enable, bool noEffects) = win 0x39b200;
    void toggleSpiderMode(bool enable, bool noEffects) = win 0x39b700;
    void toggleSwingMode(bool enable, bool noEffects) = win 0x39a7b0;
    void toggleVisibility(bool visible) = win 0x38b170;
    void touchedObject(GameObject* object) = win inline {
        switch (object->m_objectID) {
            case 1755: {
                m_stateDartSlide = 2;
                break;
            }
            case 1813: {
                m_stateNoAutoJump = 2;
                break;
            }
            case 1829: {
                if (m_isDashing) {
                    this->stopDashing();
                    m_jumpBuffered = false;
                }
            }
            case 1859: {
                m_stateHitHead = 2;
                break;
            }
            case 2069: case 3845: {
                m_stateForce = 2;
                auto forceObject = static_cast<ForceBlockGameObject*>(object);
                auto forceID = forceObject->m_forceID;
                if (forceID > 0) {
                    if (m_jumpPadRelated[forceID]) break;
                    m_jumpPadRelated[forceID] = true;
                }
                m_stateForceVector = m_stateForceVector + forceObject->calculateForceToTarget(this);
                auto magnitude = sqrtf(m_stateForceVector.x * m_stateForceVector.x + m_stateForceVector.y * m_stateForceVector.y);
                if (magnitude > 9999.f) {
                    m_stateForceVector = m_stateForceVector * (9999.f / magnitude);
                }
                break;
            }
            case 2866: {
                m_stateFlipGravity = 2;
                break;
            }
        }
    }
    void tryPlaceCheckpoint() = win 0x3a2f80;
    void unrotateGameplayObject(GameObject* object) = win 0x391370;
    void unrotatePreSlopeObjects() = win inline, ios inline {
        for (auto& pair : m_potentialSlopeMap) {
            this->unrotateGameplayObject(pair.second);
        }
    }
    void updateCheckpointMode(bool enable) = win inline {
        m_quickCheckpointMode = enable;
    }
    void updateCheckpointTest() = win inline {
        if (m_canPlaceCheckpoint) {
            this->tryPlaceCheckpoint();
            m_canPlaceCheckpoint = false;
        }
        if (this->isFlying() && m_uniqueID == 1) {
            if (m_onFlyCheckpointTries + 1 < 20) {
                m_onFlyCheckpointTries++;
            }
            else {
                m_onFlyCheckpointTries = 0;
                this->tryPlaceCheckpoint();
            }
        }
        if (m_checkpointTimeout) {
            __timeb64 current;
            _ftime64_s(&current);
            auto currentTime = ((current.time & 0xfffff) * 1000 + current.millitm) / 1000.0;
            if (currentTime - m_lastCheckpointTime > .1f) m_checkpointTimeout = false;
        }
    }
    void updateCollide(PlayerCollisionDirection direction, GameObject* object) = win 0x393c80;
    void updateCollideBottom(float y, GameObject* object) = win inline {
        auto id = object ? object->m_uniqueID : 0;
        if (m_collidedBottomMaxY == 0.0) {
            m_collidedBottomMaxY = y;
        }
        else {
            m_collidedBottomMaxY = m_isUpsideDown ? std::min<double>(m_collidedBottomMaxY, y) : std::max<double>(m_collidedBottomMaxY, y);
        }
        if (id != 0) this->storeCollision(PlayerCollisionDirection::Bottom, id);
    }
    void updateCollideLeft(float x, GameObject* object) = win 0x393e90;
    void updateCollideRight(float x, GameObject* object) = win 0x393f30;
    void updateCollideTop(float y, GameObject* object) = win inline {
        auto id = object ? object->m_uniqueID : 0;
        if (m_collidedTopMinY == 0.0) {
            m_collidedTopMinY = y;
        }
        else {
            m_collidedTopMinY = m_isUpsideDown ? std::max<double>(m_collidedTopMinY, y) : std::min<double>(m_collidedTopMinY, y);
        }
        if (id != 0) this->storeCollision(PlayerCollisionDirection::Top, id);
    }
    void updateDashAnimation() = win 0x3969b0;
    void updateDashArt() = win 0x395e50;
    void updateEffects(float param) = win inline {
        m_waveTrail->updateStroke(param);
    }
    void updateGlowColor() = win 0x39d0c0;
    void updateInternalActions(float dt) = win 0x3a3bc0;
    void updateJump(float dt) = win 0x38b630;
    void updateJumpVariables() = win inline, ios inline {
        m_stateJumpBuffered = m_jumpBuffered;
        m_stateRingJump2 = m_stateRingJump;
        m_touchedRing = false;
        m_touchedCustomRing = false;
        m_touchedGravityPortal = false;
        m_maybeTouchedBreakableBlock = false;
    }
    void updateLastGroundObject(GameObject* object) = win inline, ios inline {
        if (!object) return;
        m_lastGroundObject = object;
        if (m_isDontBoostY) m_stateBoostX = 2;
        if (m_isDontBoostX) m_stateBoostY = 2;
    }
    void updateMove(float dt) = win 0x389df0;
    void updatePlayerArt() = win 0x3984f0;
    void updatePlayerBirdFrame(int frame) = win 0x39df70;
    void updatePlayerDartFrame(int frame) = win 0x39e670;
    void updatePlayerForce(cocos2d::CCPoint velocity, bool additive) = win inline {
        if (additive) {
            m_yVelocity += velocity.y;
            if (m_isPlatformer) {
                m_platformerXVelocity += velocity.x;
                m_affectedByForces = true;
            }
        }
        else {
            m_yVelocity = velocity.y;
            if (m_isPlatformer) {
                m_platformerXVelocity = velocity.x;
                m_affectedByForces = true;
            }
        }
    }
    void updatePlayerFrame(int frame) = win 0x39d8e0;
    void updatePlayerGlow() = win 0x39ff30;
    void updatePlayerJetpackFrame(int frame) = win 0x39dd40;
    void updatePlayerRobotFrame(int frame) = win inline {
        this->createRobot(std::clamp(frame, 1, 68));
    }
    void updatePlayerRollFrame(int frame) = win 0x39e210;
    void updatePlayerScale() = win 0x39feb0, ios inline {
        m_actionManager->stopInternalAction(6);
        this->setScaleX(m_vehicleSize);
        this->setScaleY(m_vehicleSize);
    }
    void updatePlayerShipFrame(int frame) = win 0x39db10;
    void updatePlayerSpiderFrame(int frame) = win inline {
        this->createSpider(std::clamp(frame, 1, 30));
    }
    void updatePlayerSpriteExtra(gd::string frameName);
    void updatePlayerSwingFrame(int frame) = win 0x39e440;
    void updateRobotAnimationSpeed() = win 0x3a0d70;
    void updateRotation(float dt) = win 0x390cb0;
    void updateRotation(float dt, float rotation) = win 0x390ef0;
    void updateShipRotation(float dt) = win 0x3908d0;
    void updateShipSpriteExtra(gd::string frameName);
    void updateSlopeRotation(float dt) = win 0x390850;
    void updateSlopeYVelocity(float yVelocity) = win inline, ios inline {}
    void updateSpecial(float dt) = win inline {
        m_unk838 += dt;
        if (m_unk838 >= .01f) {
            m_followRelated++;
            m_unk838 -= .01f;
        }
        m_playerFollowFloats[m_followRelated % 200] = m_obPosition.y;
    }
    void updateStateVariables() = win inline {
        m_stateNoAutoJump--;
        m_stateDartSlide--;
        m_stateFlipGravity--;
        m_stateHitHead--;
        m_stateOnGround--;
        m_stateBoostX--;
        m_stateBoostY--;
        m_maybeStateForce2--;
        m_stateScale--;
        m_stateForce--;
        m_stateForceVector = cocos2d::CCPoint { 0.f, 0.f };
        m_jumpPadRelated.clear();
    }
    void updateStaticForce(float rotation, float staticForce, bool additive) = win inline {
        if (staticForce != 0.f || additive) {
            auto point = cocos2d::ccpForAngle(rotation * (M_PI / 180.f));
            auto factor = sqrtf(point.x * point.x + point.y * point.y);
            if (factor > 0.f) {
                point = point * (staticForce / factor);
                if (m_isSideways) std::swap(point.x, point.y);
                this->updatePlayerForce(point, additive);
            }
        }
        else {
            m_yVelocity = 0.0;
            if (m_isPlatformer) {
                m_platformerXVelocity = 0.0;
                m_affectedByForces = false;
            }
        }
    }
    void updateStreakBlend(bool blend) = win 0x3889d0;
    void updateStreaks(float dt) = win inline, ios inline {
        if (m_shipStreak) m_shipStreak->update(dt);
    }
    void updateSwingFire() = win 0x39aa60;
    void updateTimeMod(float speed, bool noEffects) = win 0x3a09e0;
    bool usingWallLimitedMode() = win inline, ios inline {
        return this->isFlying() || m_isBall || m_isSpider;
    }
    void yStartDown() = win inline, ios inline {
        m_yStart -= .01;
        this->logValues();
    }
    void yStartUp() = win inline, ios inline {
        m_yStart += .01;
        this->logValues();
    }

    cocos2d::CCNode* m_mainLayer;
    bool m_wasTeleported;
    bool m_fixGravityBug;
    bool m_reverseSync;
    double m_yVelocityBeforeSlope;
    double m_dashX;
    double m_dashY;
    double m_dashAngle;
    double m_dashStartTime;
    DashRingObject* m_dashRing;
    double m_slopeStartTime;
    bool m_justPlacedStreak;
    cocos2d::CCNode* m_maybeLastGroundObject;
    cocos2d::CCDictionary* m_collisionLogTop;
    cocos2d::CCDictionary* m_collisionLogBottom;
    cocos2d::CCDictionary* m_collisionLogLeft;
    cocos2d::CCDictionary* m_collisionLogRight;
    int m_lastCollisionBottom;
    int m_lastCollisionTop;
    int m_lastCollisionLeft;
    int m_lastCollisionRight;
    int m_unk50C;
    int m_unk510;
    GameObject* m_currentSlope2;
    GameObject* m_preLastGroundObject;
    float m_slopeAngle;
    bool m_slopeSlidingMaybeRotated;
    bool m_quickCheckpointMode;
    GameObject* m_collidedObject;
    GameObject* m_lastGroundObject;
    GameObject* m_collidingWithLeft;
    GameObject* m_collidingWithRight;
    int m_maybeSavedPlayerFrame;
    double m_scaleXRelated2;
    double m_groundYVelocity;
    double m_yVelocityRelated;
    double m_scaleXRelated3;
    double m_scaleXRelated4;
    double m_scaleXRelated5;
    bool m_isCollidingWithSlope;
    cocos2d::CCSprite* m_dashFireSprite;
    bool m_isBallRotating;
    bool m_unk669;
    GameObject* m_currentPotentialSlope;
    GameObject* m_currentSlope;
    double unk_584;
    int m_collidingWithSlopeId;
    bool m_slopeFlipGravityRelated;
    cocos2d::CCArray* m_particleSystems;
    float m_slopeAngleRadians;
    gd::unordered_map<int, GJPointDouble> m_rotateObjectsRelated;
    gd::unordered_map<int, GameObject*> m_potentialSlopeMap;
    float m_rotationSpeed;
    float m_rotateSpeed;
    bool m_isRotating;
    bool m_isBallRotating2;
    bool m_hasGlow;
    bool m_isHidden;
    GhostType m_ghostType;
    GhostTrailEffect* m_ghostTrail;
    cocos2d::CCSprite* m_iconSprite;
    cocos2d::CCSprite* m_iconSpriteSecondary;
    cocos2d::CCSprite* m_iconSpriteWhitener;
    cocos2d::CCSprite* m_iconGlow;
    cocos2d::CCSprite* m_vehicleSprite;
    cocos2d::CCSprite* m_vehicleSpriteSecondary;
    cocos2d::CCSprite* m_birdVehicle;
    cocos2d::CCSprite* m_vehicleSpriteWhitener;
    cocos2d::CCSprite* m_vehicleGlow;
    PlayerFireBoostSprite* m_swingFireMiddle;
    PlayerFireBoostSprite* m_swingFireBottom;
    PlayerFireBoostSprite* m_swingFireTop;
    cocos2d::CCSprite* m_dashSpritesContainer;
    cocos2d::CCMotionStreak* m_regularTrail;
    cocos2d::CCMotionStreak* m_shipStreak;
    HardStreak* m_waveTrail;
    double m_speedMultiplier;
    double m_yStart;
    double m_gravity;
    float m_trailingParticleLife;
    float m_unk648;
    double m_gameModeChangedTime;
    bool m_padRingRelated;
    bool m_maybeReducedEffects;
    bool m_maybeIsFalling;
    bool m_shouldTryPlacingCheckpoint;
    bool m_playEffects;
    bool m_maybeCanRunIntoBlocks;
    bool m_hasGroundParticles;
    bool m_hasShipParticles;
    bool m_isOnGround3;
    bool m_checkpointTimeout;
    double m_lastCheckpointTime;
    double m_lastJumpTime;
    double m_lastFlipTime;
    double m_flashTime;
    float m_flashDuration;
    float m_flashDelay;
    cocos2d::ccColor3B m_flashMainColor;
    cocos2d::ccColor3B m_flashSecondColor;
    double m_lastSpiderFlipTime;
    bool m_unkBool5;
    bool m_maybeIsVehicleGlowing;
    bool m_switchWaveTrailColor;
    bool m_practiceDeathEffect;
    double m_accelerationOrSpeed;
    double m_snapDistance;
    bool m_ringJumpRelated;
    gd::unordered_set<int> m_ringRelatedSet;
    GameObject* m_objectSnappedTo;
    CheckpointObject* m_pendingCheckpoint;
    int m_onFlyCheckpointTries;
    GJRobotSprite* m_robotSprite;
    GJSpiderSprite* m_spiderSprite;
    bool m_maybeSpriteRelated;
    cocos2d::CCParticleSystemQuad* m_playerGroundParticles;
    cocos2d::CCParticleSystemQuad* m_trailingParticles;
    cocos2d::CCParticleSystemQuad* m_shipClickParticles;
    cocos2d::CCParticleSystemQuad* m_vehicleGroundParticles;
    cocos2d::CCParticleSystemQuad* m_ufoClickParticles;
    cocos2d::CCParticleSystemQuad* m_robotBurstParticles;
    cocos2d::CCParticleSystemQuad* m_dashParticles;
    cocos2d::CCParticleSystemQuad* m_swingBurstParticles1;
    cocos2d::CCParticleSystemQuad* m_swingBurstParticles2;
    bool m_useLandParticles0;
    cocos2d::CCParticleSystemQuad* m_landParticles0;
    cocos2d::CCParticleSystemQuad* m_landParticles1;
    float m_landParticlesAngle;
    float m_landParticleRelatedY;
    int m_playerStreak;
    float m_streakStrokeWidth;
    bool m_disableStreakTint;
    bool m_alwaysShowStreak;
    ShipStreak m_shipStreakType;
    double m_slopeRotation;
    double m_currentSlopeYVelocity;
    double m_unk3d0;
    double m_blackOrbRelated;
    bool m_unk3e0;
    bool m_unk3e1;
    bool m_isAccelerating;
    bool m_isCurrentSlopeTop;
    double m_collidedTopMinY;
    double m_collidedBottomMaxY;
    double m_collidedLeftMaxX;
    double m_collidedRightMinX;
    bool m_fadeOutStreak;
    bool m_canPlaceCheckpoint;
    cocos2d::ccColor3B m_originalMainColor;
    cocos2d::ccColor3B m_originalSecondColor;
    bool m_hasCustomGlowColor;
    cocos2d::ccColor3B m_glowColor;
    bool m_maybeIsColliding;
    bool m_jumpBuffered;
    bool m_stateRingJump;
    bool m_wasJumpBuffered;
    bool m_wasRobotJump;
    unsigned char m_stateJumpBuffered;
    bool m_stateRingJump2;
    bool m_touchedRing;
    bool m_touchedCustomRing;
    bool m_touchedGravityPortal;
    bool m_maybeTouchedBreakableBlock;
    geode::SeedValueRSV m_jumpRelatedAC2;
    bool m_touchedPad;
    double m_yVelocity;
    double m_fallSpeed;
    bool m_isOnSlope;
    bool m_wasOnSlope;
    float m_slopeVelocity;
    bool m_maybeUpsideDownSlope;
    bool m_isShip;
    bool m_isBird;
    bool m_isBall;
    bool m_isDart;
    bool m_isRobot;
    bool m_isSpider;
    bool m_isUpsideDown;
    bool m_isDead;
    bool m_isOnGround;
    bool m_isGoingLeft;
    bool m_isSideways;
    bool m_isSwing;
    int m_reverseRelated;
    double m_maybeReverseSpeed;
    double m_maybeReverseAcceleration;
    float m_xVelocityRelated2;
    bool m_isDashing;
    int m_unk9e8;
    int m_groundObjectMaterial;
    float m_vehicleSize;
    float m_playerSpeed;
    cocos2d::CCPoint m_shipRotation;
    cocos2d::CCPoint m_lastPortalPos;
    float m_unkUnused3;
    bool m_isOnGround2;
    double m_lastLandTime;
    float m_platformerVelocityRelated;
    bool m_maybeIsBoosted;
    double m_scaleXRelatedTime;
    bool m_decreaseBoostSlide;
    bool m_unkA29;
    bool m_isLocked;
    bool m_controlsDisabled;
    cocos2d::CCPoint m_lastGroundedPos;
    cocos2d::CCArray* m_touchingRings;
    gd::unordered_set<int> m_touchedRings;
    GameObject* m_lastActivatedPortal;
    bool m_hasEverJumped;
    bool m_hasEverHitRing;
    cocos2d::ccColor3B m_playerColor1;
    cocos2d::ccColor3B m_playerColor2;
    cocos2d::CCPoint m_position;
    bool m_isSecondPlayer;
    bool m_unkA99;
    double m_totalTime;
    bool m_isBeingSpawnedByDualPortal;
    float m_audioScale;
    float m_unkAngle1;
    float m_yVelocityRelated3;
    bool m_defaultMiniIcon;
    bool m_swapColors;
    bool m_switchDashFireColor;
    int m_followRelated;
    gd::vector<float> m_playerFollowFloats;
    float m_unk838;
    int m_stateOnGround;
    unsigned char m_stateUnk;
    unsigned char m_stateNoStickX;
    unsigned char m_stateNoStickY;
    unsigned char m_stateUnk2;
    int m_stateBoostX;
    int m_stateBoostY;
    int m_maybeStateForce2;
    int m_stateScale;
    double m_platformerXVelocity;
    bool m_holdingRight;
    bool m_holdingLeft;
    bool m_leftPressedFirst;
    double m_scaleXRelated;
    bool m_maybeHasStopped;
    float m_xVelocityRelated;
    bool m_maybeGoingCorrectSlopeDirection;
    bool m_isSliding;
    double m_maybeSlopeForce;
    bool m_isOnIce;
    double m_physDeltaRelated;
    bool m_isOnGround4;
    int m_maybeSlidingTime;
    double m_maybeSlidingStartTime;
    double m_changedDirectionsTime;
    double m_slopeEndTime;
    bool m_isMoving;
    bool m_platformerMovingLeft;
    bool m_platformerMovingRight;
    bool m_isSlidingRight;
    double m_maybeChangedDirectionAngle;
    double m_unkUnused2;
    bool m_isPlatformer;
    int m_stateNoAutoJump;
    int m_stateDartSlide;
    int m_stateHitHead;
    int m_stateFlipGravity;
    float m_gravityMod;
    int m_stateForce;
    cocos2d::CCPoint m_stateForceVector;
    bool m_affectedByForces;
    gd::map<int, bool> m_jumpPadRelated;
    float m_somethingPlayerSpeedTime;
    float m_playerSpeedAC;
    bool m_fixRobotJump;
    gd::map<int, bool> m_holdingButtons;
    bool m_inputsLocked;
    gd::string m_currentRobotAnimation;
    bool m_gv0123;
    int m_iconRequestID;
    cocos2d::CCSpriteBatchNode* m_robotBatchNode;
    cocos2d::CCSpriteBatchNode* m_spiderBatchNode;
    cocos2d::CCArray* m_unk958;
    PlayerFireBoostSprite* m_robotFire;
    int m_unkUnused;
    GJBaseGameLayer* m_gameLayer;
    cocos2d::CCLayer* m_parentLayer;
    GJActionManager* m_actionManager;
    bool m_isOutOfBounds;
    float m_fallStartY;
    bool m_disablePlayerSqueeze;
    bool m_robotAnimation1Enabled;
    bool m_robotAnimation2Enabled;
    bool m_spiderAnimationEnabled;
    bool m_ignoreDamage;
    bool m_enable22Changes;
}

[[link(android), depends(DynamicBitset), depends(SavedActiveObjectState), depends(SavedObjectStateRef), depends(SavedSpecialObjectState)]]
class PlayLayer : GJBaseGameLayer, CCCircleWaveDelegate, CurrencyRewardDelegate, DialogDelegate {
    PlayLayer();
    ~PlayLayer() = win 0x3a5460;

    static PlayLayer* create(GJGameLevel* level, bool useReplay, bool dontCreateObjects) = win inline {
        auto ret = new PlayLayer();
        if (ret->init(level, useReplay, dontCreateObjects)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static PlayLayer* get() {
        return GameManager::get()->m_playLayer;
    }
    static cocos2d::CCScene* scene(GJGameLevel* level, bool useReplay, bool dontCreateObjects) = win 0x3a5700;

    virtual void onEnterTransitionDidFinish() = win 0x3bac30;
    virtual void onExit() = win 0x3bac60;
    virtual void postUpdate(float dt);
    virtual void checkForEnd() = win 0x3b4990;
    virtual void testTime() {}
    virtual void updateVerifyDamage();
    virtual void updateAttemptTime(float attemptTime) = win 0x3b4c00;
    virtual void updateVisibility(float dt) = win 0x3af050;
    virtual float opacityForObject(GameObject* object);
    virtual void updateColor(cocos2d::ccColor3B& color, float fadeTime, int colorID, bool blending, float opacity, cocos2d::ccHSVValue& copyHSV, int colorIDToCopy, bool copyOpacity, EffectGameObject* callerObject, int unk1, int unk2) = win 0x3b1c40;
    virtual void activateEndTrigger(int targetID, bool reverse, bool lockPlayerY) = win inline {}
    virtual void activatePlatformerEndTrigger(EndTriggerGameObject* object, gd::vector<int> const& remapKeys) = win 0x3abf80;
    virtual void toggleGlitter(bool visible) = win 0x3b3550;
    virtual void destroyPlayer(PlayerObject* player, GameObject* object) = win 0x3b3670;
    virtual void toggleGroundVisibility(bool visible) = win 0x3b33a0;
    virtual void toggleMGVisibility(bool visible) = win 0x3b3420;
    virtual void toggleHideAttempts(bool hide) = win 0x3b3460;
    virtual float timeForPos(cocos2d::CCPoint position, int order, int channel, bool songTriggers, int id) = win 0x3b3270;
    virtual cocos2d::CCPoint posForTime(float time) = win 0x3b3300;
    virtual void resetSPTriggered() = win 0x3b3360;
    virtual void updateTimeWarp(float timeWarp) = win 0x3ab650;
    virtual void playGravityEffect(bool flip) = win 0x3b1d00;
    virtual void manualUpdateObjectColors(GameObject* object) = win 0x3affa0;
    virtual void checkpointActivated(CheckpointGameObject* object) = win 0x3b4c40;
    virtual void flipArt(bool flip) = win 0x3b26e0;
    virtual void updateTimeLabel(int seconds, int centiseconds, bool decimals) = win 0x3b2210;
    virtual void checkSnapshot() = win inline {}
    virtual void toggleProgressbar() = win 0x3b2410;
    virtual void toggleInfoLabel();
    virtual void removeAllCheckpoints() = win 0x3b7ce0;
    virtual void toggleMusicInPractice() = win 0x3b25b0;
    virtual void currencyWillExit(CurrencyRewardLayer* layer);
    virtual void circleWaveWillBeRemoved(CCCircleWave* circleWave) = win 0x3b4590;
    virtual void dialogClosed(DialogLayer* layer);

    void addCircle(CCCircleWave* cw) = win inline {
        m_circleWaveArray->addObject(cw);
    }
    void addObject(GameObject* object) = win 0x3ada20;
    void addToGroupOld(GameObject* object) = win inline, ios inline {
        for (int i = 0; i < object->m_groupCount; i++) {
            auto id = object->getGroupID(i);
            auto group = this->getGroup(id);
            if (!group->containsObject(object)) group->addObject(object);
            if (object->m_objectType == GameObjectType::Decoration) {
                auto optimizedGroup = this->getOptimizedGroup(id);
                if (!optimizedGroup->containsObject(object)) optimizedGroup->addObject(object);
            }
            else {
                auto staticGroup = this->getStaticGroup(id);
                if (!staticGroup->containsObject(object)) staticGroup->addObject(object);
            }
        }
    }
    void applyCustomEnterEffect(GameObject* object, bool isRight) = win 0x3b0620;
    void applyEnterEffect(GameObject* object, int enterType, bool isRight) = win 0x3b1310;
    bool canPauseGame() = win inline {
        return !m_hasCompletedLevel && !m_levelEndAnimationStarted;
    }
    CheckpointObject* checkpointWithID(int id) = win inline, ios inline {
        for (int i = 0; i < m_checkpointArray->count(); i++) {
            auto checkpoint = static_cast<CheckpointObject*>(m_checkpointArray->objectAtIndex(i));
            if (checkpoint->m_uniqueID == id) return checkpoint;
        }
        return nullptr;
    }
    void colorObject(int id, cocos2d::ccColor3B color) = win inline, ios inline {}
    void commitJumps() = ios inline {
        GameStatsManager::sharedState()->incrementStat("1", m_uncommittedJumps);
        m_uncommittedJumps = 0;
    }
    void compareStateSnapshot() = win inline, ios inline {}
    CheckpointObject* createCheckpoint() = win 0x3b4c60;
    void createObjectsFromSetupFinished() = win 0x3ad580;
    void delayedFullReset() = win inline {
        if (m_isPlatformer) {
            m_started = false;
            m_platformerRestart = true;
        }
        this->runAction(cocos2d::CCSequence::create(
            cocos2d::CCDelayTime::create(.5f),
            cocos2d::CCCallFunc::create(this, callfunc_selector(PlayLayer::fullReset)),
            nullptr
        ));
    }
    void delayedResetLevel();
    void fullReset() = win 0x3b8890;
    float getCurrentPercent() = win 0x3b35f0;
    int getCurrentPercentInt() = win inline, ios inline { // i love this
        return static_cast<int>(this->getCurrentPercent());
    }
    cocos2d::CCPoint getEndPosition() = win inline {
        return !m_isPlatformer && m_endPortal && !m_platformerEndTrigger ? m_endPortal->getPosition() : m_endPosition;
    }
    CheckpointObject* getLastCheckpoint() = win inline {
        if (m_checkpointArray->count() != 0) {
            return static_cast<CheckpointObject*>(m_checkpointArray->lastObject());
        }
        return nullptr;
    }
    float getRelativeMod(cocos2d::CCPoint position, float right, float left, float offset) = win inline, ios inline {
        auto result = m_halfCameraWidth;
        auto xPos = position.x;
        if (xPos > result + m_gameState.m_cameraPosition2.x) {
            result = (result - (xPos - offset - m_gameState.m_cameraPosition2.x - result)) * right;
        }
        else {
            result = (result - (result + m_gameState.m_cameraPosition2.x - xPos - offset)) * left;
        }
        return std::clamp(result, 0.f, 1.f);
    }
    float getRelativeModNew(cocos2d::CCPoint position, float mod, float offset, bool unused, bool isRight) = win inline, ios inline {
        auto result = isRight ? (m_cameraWidth + m_gameState.m_cameraPosition2.x - position.x + offset) : (position.x - m_gameState.m_cameraPosition2.x - offset);
        return cocos2d::clampf(result / mod, 0.f, 1.f);
    }
    double getTempMilliTime() = win inline {
        __timeb64 current;
        _ftime64_s(&current);
        return ((current.time & 0xfffff) * 1000 + current.millitm) / 1000.0;
    }
    void gravityEffectFinished() = win 0x3b2050;
    void incrementJumps() = win inline {
        m_uncommittedJumps++;
        m_jumps++;
        m_level->m_jumps = m_level->m_jumps.value() + 1;
    }
    bool init(GJGameLevel* level, bool useReplay, bool dontCreateObjects);
    bool isGameplayActive() = win inline {
        return !m_hasCompletedLevel && m_started && !m_player1->m_isDead;
    }
    void levelComplete();
    void loadActiveSaveObjects(gd::vector<SavedActiveObjectState>& activeObjects, gd::vector<SavedSpecialObjectState>& specialObjects) = win inline {
        for (auto& state : activeObjects) {
            auto object = static_cast<EnhancedGameObject*>(state.m_gameObject);
            object->m_activatedByPlayer1 = state.m_activatedByPlayer1;
            object->m_activatedByPlayer2 = state.m_activatedByPlayer2;
        }
        for (auto& state : specialObjects) {
            auto object = state.m_gameObject;
            if (object->m_classType == GameObjectClassType::Animated) {
                static_cast<AnimatedGameObject*>(object)->playAnimation(state.m_animationID);
            }
            else if (object->m_objectID == 1615) {
                static_cast<LabelGameObject*>(object)->m_updateLabel = true;
            }
        }
    }
    void loadDefaultColors() = win 0x3b1900;
    void loadDynamicSaveObjects(gd::vector<SavedObjectStateRef>& dynamicObjects) = win inline {
        for (auto& state : dynamicObjects) {
            auto object = state.m_gameObject;
            object->m_positionX = state.m_positionX;
            object->m_positionY = state.m_positionY;
            object->m_rotationXOffset = state.m_rotationXOffset;
            object->m_rotationYOffset = state.m_rotationYOffset;
            object->addToCustomScaleX(state.m_addToCustomScaleX);
            object->addToCustomScaleY(state.m_addToCustomScaleY);
            object->setRRotation(0.f);
            object->setRScale(1.f);
            object->m_unk4C4 = -1;
            object->m_unk4CC = -1;
            object->setPosition(object->getRealPosition());
            object->setLastPosition(object->getRealPosition());
            object->setObjectRectDirty(true);
            object->m_isDirty = true;
            object->setOrientedRectDirty(true);
            this->updateObjectSection(object);
        }
    }
    void loadFromCheckpoint(CheckpointObject* object);
    CheckpointObject* loadLastCheckpoint() = win inline {
        if (m_checkpointArray->count() != 0) {
            auto checkpoint = static_cast<CheckpointObject*>(m_checkpointArray->lastObject());
            this->loadFromCheckpoint(checkpoint);
            return checkpoint;
        }
        return nullptr;
    }
    CheckpointObject* markCheckpoint() = win 0x3b7210;
    void onQuit() = win 0x3ba850;
    void optimizeColorGroups();
    void optimizeOpacityGroups() = win 0x3aeb10;
    void pauseGame(bool unfocused) = win 0x3b9d80;
    void playEndAnimationToPos(cocos2d::CCPoint position);
    void playPlatformerEndAnimationToPos(cocos2d::CCPoint position, bool instant) = win 0x3ac090;
    void playReplay(gd::string inputs) = win inline, ios inline {
        m_useReplay = true;
        this->setupReplay(inputs);
        this->resetLevel();
    }
    void prepareCreateObjectsFromSetup(gd::string& levelString) = win 0x3acaf0;
    void prepareMusic(bool dontWait) = win 0x3ba580;
    void processCreateObjectsFromSetup() = win 0x3acda0;
    void processLoadedMoveActions() = win 0x3aee80;
    void queueCheckpoint() = win inline {
        m_tryPlaceCheckpoint = true;
    }
    void removeAllObjects() = win 0x3baa50;
    void removeCheckpoint(bool first) = win 0x3b7ba0;
    void removeFromGroupOld(GameObject* object) = win inline, ios inline {
        for (int i = 0; i < object->m_groupCount; i++) {
            this->getGroup(object->getGroupID(i))->removeObject(object);
        }
    }
    void resetLevel();
    void resetLevelFromStart();
    void resume() = win 0x3ba2e0;
    void resumeAndRestart(bool fromStart);
    void saveActiveSaveObjects(gd::vector<SavedActiveObjectState>& activeObjects, gd::vector<SavedSpecialObjectState>& specialObjects) = win 0x3b8690;
    void saveDynamicSaveObjects(gd::vector<SavedObjectStateRef>& dynamicObjects) = win 0x3b8380;
    void scanActiveSaveObjects() = win inline {
        CCObject* obj;
        CCARRAY_FOREACH(m_objects, obj) {
            auto object = static_cast<GameObject*>(obj);
            if (object->canAllowMultiActivate()) {
                if (!object->canMultiActivate(m_isPlatformer)) {
                    m_activeSaveObjects1.push_back(object);
                }
            }
            else if (object->m_classType == GameObjectClassType::Animated) {
                if (static_cast<AnimatedGameObject*>(object)->m_notGrounded) m_activeSaveObjects2.push_back(object);
            }
        }
    }
    void scanDynamicSaveObjects() = win 0x3b7d30;
    void screenFlipObject(GameObject* object) = win 0x3b0400 {
        auto factor = m_gameState.m_levelFlipping;
        if (m_cameraFlip == -1.f) factor = 1.f - factor;
        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        auto objectPos = object->getPosition();
        auto xDiff = objectPos.x - m_gameState.m_cameraPosition.x;
        object->setPosition(objectPos + cocos2d::CCPoint { (winSize.width / m_gameState.m_cameraZoom - (xDiff + xDiff)) * factor, 0.f });
        auto angle = std::abs(object->getRotation());
        auto rotated = angle == 90.f || angle == 270.f;
        auto flip = m_cameraFlip;
        auto flipping = m_gameState.m_levelFlipping;
        if ((flip != 1.f && flipping > .5f) || (flip == 1.f && flipping < .5f)) {
            if (!m_gameState.m_unkBool11) return;
            auto sign = flip == 1.f ? 1 : -1;
            if (rotated) object->setFlipY(object->m_startFlipY * sign != 0);
            else object->setFlipX(object->m_startFlipX * sign != 0);
            if ((int)angle % 90 != 0) object->setRotation(object->m_startRotationX * sign);
        }
        else {
            if (rotated) object->setFlipY(!object->m_startFlipY);
            else object->setFlipX(!object->m_startFlipX);
            if ((int)angle % 90 != 0) object->setRotation(-object->m_startRotationX);
        }
    }
    void setDamageVerifiedIdx(int idx) {
        m_damageVerifiedIndex = idx;
    }
    void setupHasCompleted() = win 0x3a6380;
    bool shouldBlend(int colorID) = win inline {
        return m_effectManager->shouldBlend(colorID);
    }
    void showCompleteEffect() = win 0x3a8be0;
    void showCompleteText() = win 0x3a85b0;
    void showEndLayer() = win 0x3ac3b0;
    void showHint() = win 0x3b4410;
    void showNewBest(bool newReward, int orbs, int diamonds, bool demonKey, bool noRetry, bool noTitle) = win 0x3a9200;
    void showRetryLayer() = win 0x3ac5b0;
    void showTwoPlayerGuide() = win 0x3ac750;
    void spawnCircle() = win 0x3abbb0;
    void spawnFirework() = win 0x3abca0;
    void startGame() = win 0x3a76d0;
    void startGameDelayed();
    void startMusic() = win 0x3ba700;
    void startRecording() = win inline, ios inline {
        m_recordingStopped = false;
    }
    void startRecordingDelayed() = win inline, ios inline {
        auto action = cocos2d::CCSequence::create(
            cocos2d::CCDelayTime::create(2.f),
            cocos2d::CCCallFunc::create(this, callfunc_selector(PlayLayer::startRecording)),
            nullptr
        );
        action->setTag(31);
        this->runAction(action);
    }
    void stopRecording() = win inline {
        this->stopActionByTag(31);
    }
    void storeCheckpoint(CheckpointObject* checkpoint) = win 0x3b7140;
    void takeStateSnapshot() = win inline, ios inline {}
    void toggleBGEffectVisibility(bool enabled) = win inline {
        m_bgEffectDisabled = !enabled;
        if (!enabled) m_glitterParticles->stopSystem();
        else if (m_glitterEnabled) m_glitterParticles->resumeSystem();
    }
    void toggleDebugDraw(bool enabled) = win inline {
        m_isDebugDrawEnabled = enabled;
        m_debugDrawNode->clear();
        m_debugDrawNode->setVisible(m_isDebugDrawEnabled && m_isPracticeMode);
    }
    void toggleGhostEffect(int type) = win inline {
        m_player1->toggleGhostEffect((GhostType)type);
        if (m_gameState.m_isDualMode) m_player2->toggleGhostEffect((GhostType)type);
    }
    void toggleIgnoreDamage(bool value) = win inline {
        this->m_ignoreDamage = value;
        if (value) this->m_isIgnoreDamageEnabled = true;
        this->m_player1->m_maybeCanRunIntoBlocks = value;
        this->m_player2->m_maybeCanRunIntoBlocks = value;
        this->updateTestModeLabel();
    }
    void togglePracticeMode(bool practiceMode) = win 0x3b9af0;
    void tryStartRecord() = win inline, ios inline {
        this->stopActionByTag(31);
        this->startRecording();
    }
    void updateAttempts() = win 0x3b9840;
    void updateEffectPositions() = win inline {
        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        m_glitterParticles->setPosition(winSize * .5f / m_gameState.m_cameraZoom + m_gameState.m_cameraPosition);
        for (int i = 0; i < m_circleWaveArray->count(); i++) {
            auto wave = static_cast<CCCircleWave*>(m_circleWaveArray->objectAtIndex(i));
            if (wave->m_target) wave->setPosition(wave->m_target->getPosition());
        }
    }
    void updateInfoLabel() = win 0x3b2710;
    void updateInvisibleBlock(GameObject* object, float rightFadeBound, float leftFadeBound, float rightFadeWidth, float leftFadeWidth, cocos2d::ccColor3B const& lbgColor) = win 0x3b0060 {
        auto realPosition = object->getRealPosition();
        if (realPosition.x > m_cameraUnzoomedX) realPosition.x -= object->m_fadeMargin;
        else realPosition.x += object->m_fadeMargin;
        auto relativeMod = this->getRelativeMod(realPosition, .02f, 1.f / 70.f, .0f) * 255.f;
        auto cameraX = m_gameState.m_cameraPosition2.x;
        float factor;
        if (realPosition.x > cameraX + rightFadeBound) {
            factor = realPosition.x - cameraX - rightFadeBound;
        }
        else {
            factor = factor + leftFadeBound - realPosition.x;
            rightFadeWidth = leftFadeWidth;
        }
        rightFadeWidth = std::max(rightFadeWidth, 1.f);
        factor = std::clamp(factor / rightFadeWidth, 0.f, 1.f);
        object->setOpacity(std::min(relativeMod, (factor * .95f + .05f) * 255.f));
        object->setGlowOpacity(std::min(relativeMod, (factor * .85f + .15f) * 255.f));
        auto opacity = object->getOpacity() / 255.f;
        if (opacity > 0.8f) {
            object->setGlowColor(GJEffectManager::getMixedColor(m_lightBGColor, lbgColor, (1.f - (opacity - .8f) / .2f) * .3f + .7f));
        }
        else {
            object->setGlowColor(m_lightBGColor);
        }
    }
    void updateProgressbar() = win 0x3b2070;
    void updateScreenRotation(int rotation, bool add, bool convert, float duration, int easingType, float easingRate, int uniqueID, int controlID) = win inline, ios inline {
        float angle = add ? m_gameState.m_targetCameraAngle + rotation : rotation;
        if (convert) convertToClosestDirection(angle, 180.f);
        if (angle != m_gameState.m_targetCameraAngle) m_calculateTargetHeightOffset = true;
        GJBaseGameLayer::updateScreenRotation(angle, add, convert, duration, easingType, easingRate, uniqueID, controlID);
    }
    void updateTestModeLabel() = win 0x3a7640;
    void updateTimeWarp(EffectGameObject* object, float timeWarp) = win inline, ios inline {
        this->updateTimeWarp(timeWarp);
    }

    int m_unk36c8;
    bool m_unk36cc;
    bool m_unk36cd;
    bool m_unk36ce;
    bool m_unk36cf;
    geode::SeedValueRSV m_damageVerifiedIndex;
    bool m_damageVerified;
    gd::vector<gd::string> m_objectStrings;
    cocos2d::CCArray* m_coinArray;
    bool m_passedIntegrity;
    int m_objectsCreated;
    gd::vector<GameObject*> m_dynamicSaveObjects;
    gd::vector<GameObject*> m_activeSaveObjects1;
    gd::vector<GameObject*> m_activeSaveObjects2;
    gd::vector<SavedObjectStateRef> m_dynamicSaveObjects2;
    int m_unk3768;
    bool m_platformerRestart;
    bool m_unk376d;
    bool m_isIgnoreDamageEnabled;
    cocos2d::CCLabelBMFont* m_statusLabel;
    float m_unk3778;
    int m_unk377c;
    float m_unk3780;
    float m_unk3784;
    int m_unk3788;
    int m_unk378c;
    bool m_endChecked;
    float m_endXPosition;
    CheckpointObject* m_currentCheckpoint;
    cocos2d::CCArray* m_checkpointArray;
    cocos2d::CCArray* m_speedObjects;
    bool m_unk37b0;
    bool m_unk37b1;
    cocos2d::CCPoint m_enterEffectPosition;
    cocos2d::CCArray* m_unk37c0;
    bool m_isSilent;
    int m_unk37cc;
    cocos2d::CCArray* m_circleWaveArray;
    cocos2d::CCArray* m_collectibles;
    bool m_unk37e0;
    int m_pulseRodIndex;
    float m_maxObjectX;
    cocos2d::CCLabelBMFont* m_attemptLabel;
    cocos2d::CCLabelBMFont* m_percentageLabel;
    bool m_decimalPercentage;
    bool m_hintShown;
    cocos2d::CCSprite* m_progressBar;
    cocos2d::CCSprite* m_progressFill;
    float m_progressWidth;
    float m_progressHeight;
    int m_totalGravityEffects;
    int m_activeGravityEffects;
    int m_gravityEffectIndex;
    cocos2d::CCArray* m_gravityEffects;
    bool m_doNot;
    float m_unk383c;
    bool m_skipAudioStep;
    gd::unordered_set<int> m_blendingColors;
    int m_jumps;
    bool m_hasJumped;
    int m_uncommittedJumps;
    bool m_showLeaderboardPercentage;
    bool m_hasCompletedLevel;
    bool m_inResetDelay;
    int m_lastAttemptPercent;
    bool m_endLayerStars;
    int m_orbs;
    int m_diamonds;
    bool m_secretKey;
    bool m_recordingStopped;
    double m_unk38b0;
    double m_unk38b8;
    double m_unk38c0;
    bool m_unk38c8;
    float m_unk38cc;
    int m_unk38d0;
    double m_attemptTime;
    double m_bestAttemptTime;
    double m_pauseTime;
    double m_currentTime;
    double m_pauseDelta;
    float m_unk3900;
    bool m_glitterEnabled;
    bool m_bgEffectDisabled;
    bool m_unk3906;
    bool m_isPaused;
    bool m_disableGravityEffect;
    cocos2d::CCLabelBMFont* m_infoLabel;
    cocos2d::CCPoint m_unk3918;
    cocos2d::CCPoint m_unk3920;
    cocos2d::CCDictionary* m_colorKeyDict;
    gd::vector<cocos2d::ccColor3B> m_keyColors;
    gd::vector<float> m_keyOpacities;
    DynamicBitset m_keyPulses;
    int m_nextColorKey;
    bool m_tryPlaceCheckpoint;
    CheckpointGameObject* m_activatedCheckpoint;
    bool m_musicPrepared;
    cocos2d::CCPoint m_endPosition;
    EndTriggerGameObject* m_platformerEndTrigger;
}

[[link(android)]]
class PointNode : cocos2d::CCObject {
    // virtual ~PointNode();
    PointNode() {}

    static PointNode* create(cocos2d::CCPoint point) = win inline {
        auto ret = new PointNode();
        if (ret->init(point)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init(cocos2d::CCPoint point) = win inline, ios inline {
        m_point = point;

        return true;
    }

    cocos2d::CCPoint m_point;
}

[[link(android)]]
class PriceLabel : cocos2d::CCNode {
    // virtual ~PriceLabel();

    static PriceLabel* create(int price);

    bool init(int price);
    void setColor(cocos2d::ccColor3B color);
    void setOpacity(float opacity);
    void setPrice(int price);

    cocos2d::CCLabelBMFont* m_priceLabel;
    cocos2d::CCSprite* m_coinSprite;
}

[[link(android)]]
class ProfilePage : FLAlertLayer, FLAlertLayerProtocol, LevelCommentDelegate, CommentUploadDelegate, UserInfoDelegate, UploadActionDelegate, UploadPopupDelegate, LeaderboardManagerDelegate {
    // virtual ~ProfilePage();
    // ProfilePage() = ios 0x1a9c90;

    static ProfilePage* create(int accountID, bool ownProfile) = win 0x3be300;

    virtual void registerWithTouchDispatcher() = win 0x42660;
    virtual void keyBackClicked();
    virtual void show();
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x3c4790;
    virtual void updateUserScoreFinished();
    virtual void updateUserScoreFailed() = win 0x3c5000;
    virtual void getUserInfoFinished(GJUserScore* score) = win 0x3c5b80, ios 0x1234567, imac 0x1234567, m1 0x1234567;
    virtual void getUserInfoFailed(int id) = win 0x3c5c70;
    virtual void userInfoChanged(GJUserScore* score) = win 0x3c5cc0;
    virtual void loadCommentsFinished(cocos2d::CCArray* comments, char const* key) = win 0x3c62c0;
    virtual void loadCommentsFailed(char const* key) = win 0x3c6340;
    virtual void setupPageInfo(gd::string info, char const* key) = win 0x3c63a0;
    virtual void commentUploadFinished(int parentID);
    virtual void commentUploadFailed(int parentID, CommentError errorType) = win 0x3c65f0;
    virtual void commentDeleteFailed(int id, int parentID) = win 0x3c6710;
    virtual void onClosePopup(UploadActionPopup* popup) = win 0x3c4a80;
    virtual void uploadActionFinished(int id, int response) = win 0x3c4ad0;
    virtual void uploadActionFailed(int id, int response) = win 0x3c4c90;

    void blockUser() = win inline {
        if (GameLevelManager::sharedState()->blockUser(m_score->m_accountID)) {
            m_popupDelegate = UploadActionPopup::create(this, "Blocking user...");
            m_popupDelegate->show();
        }
    }
    bool init(int accountID, bool ownProfile) = win 0x3be4e0;
    bool isCorrect(char const* key);
    bool isOnWatchlist(int id) = win inline, ios inline { return false; }
    void loadPage(int page) = win 0x3c5e70;
    void loadPageFromUserInfo(GJUserScore* score);
    void onBlockUser(cocos2d::CCObject* sender);
    void onClose(cocos2d::CCObject* sender) = win 0x3c4d40;
    void onComment(cocos2d::CCObject* sender) = win 0x3c39c0;
    void onCommentHistory(cocos2d::CCObject* sender) = win 0x3c3930;
    void onCopyName(cocos2d::CCObject* sender) = win 0x3c2f50;
    void onFollow(cocos2d::CCObject* sender) = win 0x3c41c0;
    void onFriend(cocos2d::CCObject* sender) = win 0x3c3b80;
    void onFriends(cocos2d::CCObject* sender);
    void onInfo(cocos2d::CCObject* sender);
    void onMessages(cocos2d::CCObject* sender);
    void onMyLevels(cocos2d::CCObject* sender) = win 0x3c3620;
    void onMyLists(cocos2d::CCObject* sender) = win 0x3c37d0;
    void onNextPage(cocos2d::CCObject* sender);
    void onPrevPage(cocos2d::CCObject* sender);
    void onRequests(cocos2d::CCObject* sender);
    void onSendMessage(cocos2d::CCObject* sender);
    void onSettings(cocos2d::CCObject* sender);
    void onStatInfo(cocos2d::CCObject* sender) = win 0x3c2d80;
    void onTwitch(cocos2d::CCObject* sender);
    void onTwitter(cocos2d::CCObject* sender);
    void onUpdate(cocos2d::CCObject* sender) = win 0x3bf490;
    void onYouTube(cocos2d::CCObject* sender);
    void setupComments() = win inline {
        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        auto leftSprite = cocos2d::CCSprite::createWithSpriteFrameName("GJ_arrow_01_001.png");
        leftSprite->setScale(.8f);
        m_leftArrow = CCMenuItemSpriteExtra::create(leftSprite, this, menu_selector(ProfilePage::onPrevPage));
        m_buttonMenu->addChild(m_leftArrow);
        m_leftArrow->setPosition(m_buttonMenu->convertToNodeSpace(winSize / 2.f + cocos2d::CCPoint { -195.f, -53.f }));
        m_leftArrow->setSizeMult(2.f);
        auto rightSprite = cocos2d::CCSprite::createWithSpriteFrameName("GJ_arrow_01_001.png");
        rightSprite->setFlipX(true);
        rightSprite->setScale(.8f);
        m_rightArrow = CCMenuItemSpriteExtra::create(rightSprite, this, menu_selector(ProfilePage::onNextPage));
        m_buttonMenu->addChild(m_rightArrow);
        m_rightArrow->setPosition(m_buttonMenu->convertToNodeSpace(winSize / 2.f + cocos2d::CCPoint { 195.f, -53.f }));
        m_rightArrow->setSizeMult(2.f);
        m_leftArrow->setVisible(false);
        m_rightArrow->setVisible(false);
    }
    void setupCommentsBrowser(cocos2d::CCArray* comments) = win 0x3c6160;
    void showNoAccountError() = win 0x3c4dd0;
    void toggleMainPageVisibility(bool visible) = win inline, ios inline {
        CCObject* obj;
        CCARRAY_FOREACH(m_arrayWithUsernameLabel, obj) {
            static_cast<cocos2d::CCNode*>(obj)->setVisible(visible);
        }
        CCARRAY_FOREACH(m_buttons, obj) {
            static_cast<cocos2d::CCNode*>(obj)->setVisible(visible);
        }
        if (m_list) m_list->setVisible(visible);
        if (visible) this->updatePageArrows();
        m_rightArrow->setVisible(false);
        m_leftArrow->setVisible(false);
    }
    void toggleShip(cocos2d::CCObject* sender) = win 0x3c2cd0;
    void updateLevelsLabel() = win inline, ios inline {}
    void updatePageArrows() = win 0x3c6510, ios inline {
        m_leftArrow->setVisible(m_pageStartIdx != 0);
        m_rightArrow->setVisible(m_itemCount > m_pageEndIdx + m_pageStartIdx);
    }

    GJUserScore* m_score;
    int m_accountID;
    bool m_ownProfile;
    gd::string m_profileKey;
    cocos2d::CCLabelBMFont* m_somethingWentWrong;
    cocos2d::CCLabelBMFont* m_usernameLabel;
    GJCommentListLayer* m_list;
    CCMenuItemSpriteExtra* m_rightArrow;
    CCMenuItemSpriteExtra* m_leftArrow;
    CCMenuItemSpriteExtra* m_followBtn;
    bool m_unk;
    cocos2d::CCArray* m_buttons;
    cocos2d::CCArray* m_arrayWithUsernameLabel;
    int m_itemCount;
    int m_pageStartIdx;
    int m_pageEndIdx;
    int m_page;
    LoadingCircle* m_circle;
    UploadActionPopup* m_popupDelegate;
    CCMenuItemSpriteExtra* m_refreshBtn;
    int m_unk2;
}

[[link(android)]]
class PromoInterstitial : FLAlertLayer {
    // virtual ~PromoInterstitial();

    static PromoInterstitial* create(bool fullVersion);

    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event);
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event);
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event);
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event);
    virtual void keyBackClicked();
    virtual void show();

    bool init(bool fullVersion);
    void onClick(cocos2d::CCObject* sender);
    void onClose(cocos2d::CCObject* sender);
    void setup();

    bool m_fullVersion;
    cocos2d::CCMenu* m_closeMenu;
    bool m_promoTouched;
    gd::string m_marketLink;
    bool m_showAdBanner;
}

[[link(android)]]
class PulseEffectAction {
    bool isFinished() = win inline, ios inline {
        return m_fadeInTime + m_holdTime + m_fadeOutTime <= m_deltaTime + m_startTime;
    }
    void step(float delta) = win inline {
        if (m_disabled) return;
        m_deltaTime += delta;
        m_currentValue = this->valueForDelta(m_deltaTime + m_startTime, m_fadeInTime, m_holdTime, m_fadeOutTime);
    }
    float valueForDelta(float currentTime, float fadeInTime, float holdTime, float fadeOutTime) = win inline, ios inline {
        if (currentTime < fadeInTime) return currentTime / fadeInTime;
        if (currentTime > fadeInTime + holdTime) {
            if (fadeOutTime > 0.f) return 1.f - (currentTime - fadeInTime - holdTime) / fadeOutTime;
            return 0.f;
        }
        return 1.f;
    }

    bool m_disabled;
    float m_fadeInTime;
    float m_holdTime;
    float m_fadeOutTime;
    float m_deltaTime;
    int m_targetGroupID;
    float m_currentValue;
    cocos2d::ccColor3B m_color;
    PulseEffectType m_pulseEffectType;
    cocos2d::ccHSVValue m_hsv;
    int m_colorIndex;
    bool m_mainOnly;
    bool m_detailOnly;
    bool m_isDynamicHsv;
    int m_triggerUniqueID;
    int m_controlID;
    float m_startTime;
}

[[link(android)]]
class PurchaseItemPopup : FLAlertLayer {
    // virtual ~PurchaseItemPopup();
    // PurchaseItemPopup();

    static PurchaseItemPopup* create(GJStoreItem* item);

    virtual void keyBackClicked() = win 0x846c0;

    bool init(GJStoreItem* item) = win 0x2aeae0;
    void onClose(cocos2d::CCObject* sender) = win 0x84690;
    void onPurchase(cocos2d::CCObject* sender) = win 0x2af990;

    GJStoreItem* m_storeItem;
    GJPurchaseDelegate* m_delegate;
}

[[link(android)]]
class RandTriggerGameObject : ChanceTriggerGameObject {
    // virtual ~RandTriggerGameObject();
    RandTriggerGameObject() {}

    static RandTriggerGameObject* create() = win inline {
        auto ret = new RandTriggerGameObject();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init();
    virtual void triggerObject(GJBaseGameLayer* layer, int uniqueID, gd::vector<int> const* remapKeys) = win 0x4b3e70;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4b4040;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x4b4240;

    int getRandomGroupID() = win inline {
        int num = this->getTotalChance() * GameToolbox::fast_rand_0_1();
        auto chance = 0;
        for (auto& obj : m_chanceObjects) {
            chance += obj.m_chance;
            if (num <= chance) return obj.m_groupID;
        }
        return 0;
    }
    int getTotalChance() = win inline {
        auto total = 0;
        for (auto& obj : m_chanceObjects) {
            total += obj.m_chance;
        }
        return total;
    }
}

[[link(android)]]
class RateDemonLayer : FLAlertLayer, UploadPopupDelegate, UploadActionDelegate {
    RateDemonLayer() {
        m_uploadFinished = false;
        m_submitButton = nullptr;
        m_demons = nullptr;
        m_unkPtr = nullptr;
        m_levelID = 0;
        m_demonRate = 0;
        m_moderator = false;
        m_popup = nullptr;
        m_delegate = nullptr;
    }
    ~RateDemonLayer() = win inline {
        auto glm = GameLevelManager::sharedState();
        if (glm->m_uploadActionDelegate == this) glm->m_uploadActionDelegate = nullptr;
        CC_SAFE_RELEASE(m_demons);
    }

    static RateDemonLayer* create(int levelID) = win inline {
        auto ret = new RateDemonLayer();
        if (ret->init(levelID)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyBackClicked();
    virtual void uploadActionFinished(int id, int response) = win 0x3c90d0;
    virtual void uploadActionFailed(int id, int response) = win 0x3c9160;
    virtual void onClosePopup(UploadActionPopup* popup);

    bool init(int levelID);
    void onClose(cocos2d::CCObject* sender);
    void onRate(cocos2d::CCObject* sender) = win 0x3c8f30;
    void selectRating(cocos2d::CCObject* sender) = win 0x3c8db0;

    bool m_uploadFinished;
    CCMenuItemSpriteExtra* m_submitButton;
    cocos2d::CCArray* m_demons;
    void* m_unkPtr;
    int m_levelID;
    int m_demonRate;
    bool m_moderator;
    UploadActionPopup* m_popup;
    RateLevelDelegate* m_delegate;
}

[[link(android)]]
class RateLevelDelegate {
    virtual void rateLevelClosed() {}
}

[[link(android)]]
class RateLevelLayer : FLAlertLayer {
    RateLevelLayer() {
        m_submitButton = nullptr;
        m_difficulties = nullptr;
        m_levelID = 0;
        m_levelRate = 0;
        m_delegate = nullptr;
    }
    ~RateLevelLayer() = win inline {
        CC_SAFE_RELEASE(m_difficulties);
    }

    static RateLevelLayer* create(int levelID) = win inline {
        auto ret = new RateLevelLayer();
        if (ret->init(levelID)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyBackClicked();

    bool init(int levelID);
    void onClose(cocos2d::CCObject* sender);
    void onRate(cocos2d::CCObject* sender) = win 0x3c9a70;
    void selectRating(cocos2d::CCObject* sender) = win 0x3c9920;

    CCMenuItemSpriteExtra* m_submitButton;
    cocos2d::CCArray* m_difficulties;
    int m_levelID;
    int m_levelRate;
    RateLevelDelegate* m_delegate;
}

[[link(android)]]
class RateStarsLayer : FLAlertLayer, UploadPopupDelegate, UploadActionDelegate {
    // virtual ~RateStarsLayer();

    static RateStarsLayer* create(int levelID, bool platformer, bool moderator) = win 0x3c9c90;

    virtual void keyBackClicked();
    virtual void uploadActionFinished(int id, int response) = win 0x3ca980;
    virtual void uploadActionFailed(int id, int response) = win 0x3caa00;
    virtual void onClosePopup(UploadActionPopup* popup);

    CCMenuItemSpriteExtra* getStarsButton(int stars, cocos2d::SEL_MenuHandler selector, cocos2d::CCMenu* menu, float scale) = ios inline {
        auto button = CCMenuItemSpriteExtra::create(
            ButtonSprite::create(cocos2d::CCString::createWithFormat("%i", stars)->getCString(), 20, 0, .5f, true, "bigFont.fnt", "GJ_button_01.png", 30.f),
            this, selector
        );
        button->setScale(scale);
        button->m_baseScale = scale;
        if (menu) menu->addChild(button);
        return button;
    }
    bool init(int levelID, bool platformer, bool moderator);
    void onClose(cocos2d::CCObject* sender);
    void onFeature(cocos2d::CCObject* sender) = win 0x3ca570;
    void onRate(cocos2d::CCObject* sender) = win 0x3ca790;
    void onToggleCoins(cocos2d::CCObject* sender) = win inline, ios inline {
        m_coinsToggled = !m_coinsToggled;
        m_coinSprite->setColor(m_coinsToggled ? cocos2d::ccColor3B { 255, 255, 255 } : cocos2d::ccColor3B { 50, 50, 50 });
    }
    void selectRating(cocos2d::CCObject* sender) = win 0x2f6660;

    bool m_uploadFinished;
    bool m_moderator;
    CCMenuItemSpriteExtra* m_submitButton;
    cocos2d::CCArray* m_buttons;
    int m_levelID;
    int m_starsRate;
    bool m_coinsToggled;
    cocos2d::CCSprite* m_coinSprite;
    UploadActionPopup* m_popup;
    GJDifficultySprite* m_difficultySprite;
    int m_featureState;
    RateLevelDelegate* m_delegate;
}

[[link(android)]]
class RetryLevelLayer : GJDropDownLayer, RewardedVideoDelegate {
    RetryLevelLayer() {
        m_mainMenu = nullptr;
        m_exitingMenu = false;
        m_unk1e9 = false;
    }
    ~RetryLevelLayer() = win inline {
        auto gm = GameManager::sharedState();
        if (gm->m_rewardedVideoDelegate == this) gm->m_rewardedVideoDelegate = nullptr;
    }

    static RetryLevelLayer* create() = win inline {
        auto ret = new RetryLevelLayer();
        if (ret->init(" ", 230.f, true)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyBackClicked() = win 0x3cbc40;
    virtual void keyDown(cocos2d::enumKeyCodes key);
    virtual void customSetup() = win 0x3cacf0;
    virtual void showLayer(bool instant) = win 0x3cb890;
    virtual void enterAnimFinished() = win 0x3cb9b0;
    virtual void rewardedVideoFinished();
    virtual bool shouldOffsetRewardCurrency() { return true; }
    virtual void keyUp(cocos2d::enumKeyCodes key) = win inline {}

    const char* getEndText() = win inline, ios inline {
        auto index = rand() % 5;
        switch (index) {
            case 2: return "Good Job!";
            case 3: return "Well Done!";
            case 4: return "Impressive!";
            default: return "Awesome!";
        }
    }
    void onEveryplay(cocos2d::CCObject* sender) = win inline, ios inline {}
    void onMenu(cocos2d::CCObject* sender) = win 0x3cbb20;
    void onReplay(cocos2d::CCObject* sender);
    void onRewardedVideo(cocos2d::CCObject* sender);
    void setupLastProgress() = win 0x3cb450;

    cocos2d::CCMenu* m_mainMenu;
    bool m_exitingMenu;
    bool m_unk1e9;
}

[[link(android)]]
class RewardedVideoDelegate {
    virtual void rewardedVideoFinished() {}
    virtual bool shouldOffsetRewardCurrency() { return false; }
}

[[link(android)]]
class RewardsPage : FLAlertLayer, FLAlertLayerProtocol, GJRewardDelegate {
    RewardsPage() {
        m_leftLabel = nullptr;
        m_rightLabel = nullptr;
        m_leftChest = nullptr;
        m_rightChest = nullptr;
        m_leftOpen = false;
        m_rightOpen = false;
        m_openLayer = nullptr;
    }
    ~RewardsPage() = win inline {
        auto glm = GameLevelManager::sharedState();
        if (glm->m_GJRewardDelegate == this) glm->m_GJRewardDelegate = nullptr;
    }

    static RewardsPage* create() = win inline {
        auto ret = new RewardsPage();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static char const* getRewardFrame(int type, int state) = win inline, ios inline {
        return cocos2d::CCString::createWithFormat("chest_%02d_%02d_001.png", type, state)->getCString();
    }

    virtual bool init() = win 0x3cc120;
    virtual void registerWithTouchDispatcher() = win 0x42660;
    virtual void keyBackClicked() = win 0x846c0;
    virtual void show();
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win inline {}
    virtual void rewardsStatusFinished(int type) = win 0x3cd120;
    virtual void rewardsStatusFailed();

    void onClose(cocos2d::CCObject* sender) = win 0x84690;
    void onFreeStuff(cocos2d::CCObject* sender);
    void onReward(cocos2d::CCObject* sender) = win 0x3ccfe0;
    void tryGetRewards();
    void unlockLayerClosed(RewardUnlockLayer* layer) = win inline, ios inline {
        if (m_openLayer == layer) m_openLayer = nullptr;
    }
    callback void updateTimers(float dt) = win 0x3cd470;

    cocos2d::CCLabelBMFont* m_leftLabel;
    cocos2d::CCLabelBMFont* m_rightLabel;
    CCMenuItemSpriteExtra* m_leftChest;
    CCMenuItemSpriteExtra* m_rightChest;
    bool m_leftOpen;
    bool m_rightOpen;
    RewardUnlockLayer* m_openLayer;
}

[[link(android)]]
class RewardUnlockLayer : FLAlertLayer, CurrencyRewardDelegate {
    // virtual ~RewardUnlockLayer();

    static RewardUnlockLayer* create(int type, RewardsPage* page) = win 0x3cd950;

    virtual void keyBackClicked() = win inline {}
    virtual void currencyWillExit(CurrencyRewardLayer* layer) = win 0x3d1210;

    void connectionTimeout() = win 0x3ce850;
    bool init(int type, RewardsPage* page) = win 0x3cda80;
    void labelEnterFinishedO(cocos2d::CCObject* object) = win inline {}
    void onClose(cocos2d::CCObject* sender) = win 0x3d1220;
    void playDropSound() = win 0x3ce8b0;
    void playLabelEffect(int count, int type, cocos2d::CCSprite* sprite, cocos2d::CCPoint position, float delay) = win 0x3d0180;
    void playRewardEffect() = win 0x3cea70;
    bool readyToCollect(GJRewardItem* item) = win inline, ios inline {
        return item ? m_chestType == (int)item->m_rewardType : false;
    }
    void showCloseButton() = win 0x3d0110;
    bool showCollectReward(GJRewardItem* item) = win 0x3ce790;
    void step2() = win 0x3ce950;
    void step3() = win 0x3cea50;

    cocos2d::CCArray* m_backgroundObjects;
    RewardsPage* m_rewardsPage;
    GJChestSprite* m_chestSprite;
    int m_chestType;
    bool m_rewardCollected;
    bool m_animationPlayed;
    GJRewardItem* m_rewardItem;
    cocos2d::CCLabelBMFont* m_wrongLabel;
    CCMenuItemSpriteExtra* m_closeBtn;
    CCMenuItemSpriteExtra* m_rewardBtn;
    float m_unkFloat;
}

[[link(android)]]
class RingObject : EffectGameObject {
    // virtual ~RingObject();
    RingObject() {
        m_claimTouch = false;
        m_isSpawnOnly = false;
    }

    static RingObject* create(char const* frame) = win 0x4a18e0;

    virtual void setScale(float scale) = win 0x4a1c60;
    virtual void setRotation(float rotation);
    virtual void resetObject();
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists);
    virtual gd::string getSaveString(GJBaseGameLayer* layer);
    virtual void setRScale(float scale) = win 0x4a1c90;
    virtual void triggerActivated(float xPosition);
    virtual bool shouldDrawEditorHitbox() = win 0x4a1d10;
    virtual void powerOnObject(int state) = win 0x4a19a0;

    bool init(char const* frame) = win inline, ios inline {
        if (!EffectGameObject::init(frame)) return false;
        m_customGlowColor = true;
        m_isTouchTriggered = true;
        return true;
    }
    void spawnCircle();

    bool m_claimTouch;
    // property 504
    bool m_isSpawnOnly;
}

[[link(android)]]
class RotateGameplayGameObject : EffectGameObject {
    // virtual ~RotateGameplayGameObject();
    RotateGameplayGameObject() {
        m_moveDirection = 0;
        m_groundDirection = 0;
        m_editVelocity = false;
        m_overrideVelocity = false;
        m_velocityModX = 1.f;
        m_velocityModY = 1.f;
        m_changeChannel = false;
        m_channelOnly = false;
        m_targetChannelID = 0;
        m_instantOffset = false;
        m_dontSlide = false;
    }

    static RotateGameplayGameObject* create() = win inline {
        auto ret = new RotateGameplayGameObject();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init();
    virtual void updateStartValues();
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4c4210;
    virtual gd::string getSaveString(GJBaseGameLayer* layer);

    void updateGameplayRotation() = win inline {
        this->determineSlopeDirection();
        switch (m_slopeDirection) {
            case 1:
                m_moveDirection = 1;
                m_groundDirection = 4;
                break;
            case 2:
                m_moveDirection = 2;
                m_groundDirection = 3;
                break;
            case 3:
                m_moveDirection = 1;
                m_groundDirection = 3;
                break;
            case 4:
                m_moveDirection = 3;
                m_groundDirection = 2;
                break;
            case 5:
                m_moveDirection = 4;
                m_groundDirection = 1;
                break;
            case 6:
                m_moveDirection = 3;
                m_groundDirection = 1;
                break;
            case 7:
                m_moveDirection = 4;
                m_groundDirection = 2;
                break;
            default:
                m_moveDirection = 2;
                m_groundDirection = 4;
                break;
        }
    }

    // property 166
    int m_moveDirection;
    // property 167
    int m_groundDirection;
    // property 169
    bool m_editVelocity;
    // property 584
    bool m_overrideVelocity;
    // property 582
    float m_velocityModX;
    // property 583
    float m_velocityModY;
    // property 171
    bool m_changeChannel;
    // property 172
    bool m_channelOnly;
    // property 173
    int m_targetChannelID;
    // property 368
    bool m_instantOffset;
    // property 585
    bool m_dontSlide;
}

[[link(android)]]
class ScrollingLayer : cocos2d::CCLayerColor {
    // virtual ~ScrollingLayer();
    ScrollingLayer() {
        m_scrollFactor = 0.f;
        m_touchID = -1;
        m_contentLayer = nullptr;
        m_parentLayer = nullptr;
    }

    static ScrollingLayer* create(cocos2d::CCSize size, cocos2d::CCPoint position, float factor) = win inline {
        auto ret = new ScrollingLayer();
        if (ret->init(size, position, factor)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void draw() = win 0x70f30;
    virtual void visit() = win 0x70ff0;
    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x71040;
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x71130;
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event);
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event);

    cocos2d::CCRect getViewRect() = win 0x70e40;
    bool init(cocos2d::CCSize size, cocos2d::CCPoint position, float factor) = win inline {
        if (!cocos2d::CCLayerColor::initWithColor({ 0, 0, 0, 0 })) return false;
        m_scrollFactor = factor;
        this->addChild(cocos2d::CCLayerColor::create({ 0, 0, 0, 50 }), -2);
        m_contentLayer = cocos2d::CCLayer::create();
        this->addChild(m_contentLayer, -1);
        m_size = size;
        return true;
    }
    void setStartOffset(cocos2d::CCPoint offset) = win inline {
        m_startOffset = offset;
        m_contentLayer->setPosition(offset);
    }

    cocos2d::CCPoint m_position;
    cocos2d::CCSize m_size;
    cocos2d::CCPoint m_touchStartPosition;
    cocos2d::CCPoint m_touchPosition;
    cocos2d::CCPoint m_startOffset;
    float m_scrollFactor;
    int m_touchID;
    cocos2d::CCLayer* m_contentLayer;
    cocos2d::CCLayer* m_parentLayer;
}

[[link(android)]]
class SearchButton : cocos2d::CCSprite {
    // virtual ~SearchButton();

    static SearchButton* create(char const* background, char const* label, float scale, char const* icon) = win 0x312600;

    bool init(char const* background, char const* label, float scale, char const* icon) = win 0x3126d0;

    cocos2d::CCLabelBMFont* m_label;
    cocos2d::CCSprite* m_icon;
}

[[link(android)]]
class SearchSFXPopup : SetTextPopup {
    // virtual ~SearchSFXPopup();
    SearchSFXPopup() {}

    static SearchSFXPopup* create(gd::string query) = win inline {
        auto ret = new SearchSFXPopup();
        if (ret->init(query)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init(gd::string query) = win 0x4809b0;
    void onSearchFolders(cocos2d::CCObject* sender);
}

[[link(android)]]
class SecretGame01Layer : cocos2d::CCLayer {
    // virtual ~SecretGame01Layer() = m1 0x3dc158, imac 0x46cd20;

    static SecretGame01Layer* create();

    virtual void update(float dt);
    virtual bool init();

    void didSelectCorrectObject(CCMenuItemSpriteExtra* button);
    void gameStep01();
    void gameStep02();
    int getCountForDifficulty(int difficulty);
    gd::string getFrameForDifficulty(int difficulty);
    int getRowsForDifficulty(int difficulty);
    int getTimeForDifficulty(int difficulty);
    void onSelectButton(cocos2d::CCObject* sender);
    void resetGame();
    void resetGameTimer();
    void scaleOutGame(bool won);
    void showGameOver();
    void showGameWon();

    cocos2d::CCArray* m_gameObjects;
    cocos2d::CCArray* m_requiredObjects;
    cocos2d::CCMenu* m_mainMenu;
    int m_selectedObject;
    int m_gameDifficulty;
    bool m_gameActive;
    float m_timeElapsed;
    float m_gameTime;
    cocos2d::CCSprite* m_timeBarSprite;
}

[[link(android)]]
class SecretLayer : cocos2d::CCLayer, TextInputDelegate, FLAlertLayerProtocol {
    SecretLayer() {
        m_basicMessageIndex = -1;
        m_selectedThread = 0;
        m_threadMessageIndex = 0;
        m_basicMessageCount = 0;
        m_doomedIndex = 0;
        m_searchInput = nullptr;
        m_messageLabel = nullptr;
        m_messageThreads = nullptr;
        m_threadTag = -1;
    }
    ~SecretLayer() = win inline {
        CC_SAFE_RELEASE(m_messageThreads);
    }

    static SecretLayer* create() = win inline {
        auto ret = new SecretLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static cocos2d::CCScene* scene() = win inline {
        auto scene = cocos2d::CCScene::create();
        AppDelegate::get()->m_runningScene = scene;
        auto layer = SecretLayer::create();
        scene->addChild(layer);
        return scene;
    }

    virtual bool init() = win 0x3dc700;
    virtual void keyBackClicked();
    virtual void textInputOpened(CCTextInputNode* node);
    virtual void textInputClosed(CCTextInputNode* node);
    virtual void textChanged(CCTextInputNode* node);
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win inline {}

    gd::string getBasicMessage();
    gd::string getMessage() = win 0x3dfa50;
    gd::string getThreadMessage() = win 0x3dfc40;
    cocos2d::CCNode* nodeWithTag(int tag) = win inline, ios inline {
        auto node = cocos2d::CCNode::create();
        node->setTag(tag);
        return node;
    }
    void onBack(cocos2d::CCObject* sender) = win 0x3e1b10;
    void onSubmit(cocos2d::CCObject* sender) = win 0x3dda40;
    void playCoinEffect();
    void selectAThread() = win inline {
        auto keys = m_messageThreads->allKeys();
        if (m_threadTag < 0) m_threadTag = (float)(keys->count() - 1) * (float)rand() / (float)RAND_MAX;
        else m_threadTag++;
        if (keys->count() <= m_threadTag) m_threadTag = 0;
        if (m_messageThreads->count() != 0) {
            auto key = static_cast<cocos2d::CCInteger*>(keys->objectAtIndex(m_threadTag));
            m_selectedThread = m_messageThreads->objectForKey(key->getValue())->getTag();
        }
    }
    void updateMessageLabel(gd::string text);
    void updateSearchLabel(char const* text);

    int m_basicMessageIndex;
    int m_selectedThread;
    int m_threadMessageIndex;
    int m_basicMessageCount;
    int m_doomedIndex;
    CCTextInputNode* m_searchInput;
    cocos2d::CCLabelBMFont* m_messageLabel;
    CCMenuItemSpriteExtra* m_submitButton;
    cocos2d::CCDictionary* m_messageThreads;
    int m_threadTag;
}

[[link(android)]]
class SecretLayer2 : cocos2d::CCLayer, TextInputDelegate, FLAlertLayerProtocol, DialogDelegate {
    SecretLayer2() {
        m_threadTag = -1;
        m_basicMessageIndex = -1;
        m_selectedThread = 0;
        m_threadMessageIndex = 0;
        m_basicMessageCount = 0;
        m_errorMessageIndex = -1;
        m_searchInput = nullptr;
        m_messageLabel = nullptr;
        m_messageThreads = nullptr;
        m_exiting = false;
        m_doorDialogIndex = -1;
        m_secretLevelButton = nullptr;
        m_secretLevelLabels = nullptr;
        m_secretDoorButton = nullptr;
    }
    ~SecretLayer2() = win inline {
        CC_SAFE_RELEASE(m_messageThreads);
        CC_SAFE_RELEASE(m_secretLevelLabels);
    }

    static SecretLayer2* create() = win inline {
        auto ret = new SecretLayer2();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static cocos2d::CCScene* scene() = win 0x1f8b20;

    virtual bool init() = win 0x3e1f70;
    virtual void onExit() = win 0x3e95a0;
    virtual void keyBackClicked();
    virtual void textInputOpened(CCTextInputNode* node);
    virtual void textInputClosed(CCTextInputNode* node);
    virtual void textChanged(CCTextInputNode* node);
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win inline {}
    virtual void dialogClosed(DialogLayer* layer);

    gd::string getBasicMessage() = win 0x3e7880;
    gd::string getErrorMessage() = win 0x3e83e0;
    gd::string getMessage();
    gd::string getThreadMessage() = win 0x3e7190;
    cocos2d::CCNode* nodeWithTag(int tag) = win inline, ios inline {
        auto node = cocos2d::CCNode::create();
        node->setTag(tag);
        return node;
    }
    void onBack(cocos2d::CCObject* sender);
    void onDoor(cocos2d::CCObject* sender) = win 0x3e45a0;
    void onSecretLevel(cocos2d::CCObject* sender) = win 0x3e42f0;
    void onSubmit(cocos2d::CCObject* sender) = win 0x3e4f00;
    void playCoinEffect();
    void selectAThread() = win inline {
        auto keys = m_messageThreads->allKeys();
        if (m_threadTag < 0) m_threadTag = (float)(keys->count() - 1) * (float)rand() / (float)RAND_MAX;
        else m_threadTag++;
        if (keys->count() <= m_threadTag) m_threadTag = 0;
        if (m_messageThreads->count() != 0) {
            auto key = static_cast<cocos2d::CCInteger*>(keys->objectAtIndex(m_threadTag));
            m_selectedThread = m_messageThreads->objectForKey(key->getValue())->getTag();
        }
    }
    void showCompletedLevel() = win 0x3e35a0;
    void showSecretLevel() = win 0x3e3430;
    void updateMessageLabel(gd::string text);
    void updateSearchLabel(char const* text);

    int m_threadTag;
    int m_basicMessageIndex;
    int m_selectedThread;
    int m_threadMessageIndex;
    int m_basicMessageCount;
    int m_errorMessageIndex;
    CCTextInputNode* m_searchInput;
    cocos2d::CCLabelBMFont* m_messageLabel;
    CCMenuItemSpriteExtra* m_submitButton;
    cocos2d::CCDictionary* m_messageThreads;
    bool m_exiting;
    int m_doorDialogIndex;
    CCMenuItemSpriteExtra* m_secretLevelButton;
    cocos2d::CCArray* m_secretLevelLabels;
    CCMenuItemSpriteExtra* m_secretDoorButton;
}

[[link(android)]]
class SecretLayer3 : cocos2d::CCLayer, DialogDelegate {
    SecretLayer3() {
        m_lockInput = false;
        m_locksArray = nullptr;
        m_demonEyes = nullptr;
        m_demonBody = nullptr;
        m_secretChest = nullptr;
    }
    ~SecretLayer3() = win inline {
        CC_SAFE_RELEASE(m_locksArray);
    }

    static SecretLayer3* create() = win inline {
        auto ret = new SecretLayer3();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static cocos2d::CCScene* scene() = win inline {
        auto scene = cocos2d::CCScene::create();
        AppDelegate::get()->m_runningScene = scene;
        auto layer = SecretLayer3::create();
        scene->addChild(layer);
        return scene;
    }

    virtual bool init() = win 0x3e9b20;
    virtual void onExit();
    virtual void keyBackClicked();
    virtual void dialogClosed(DialogLayer* layer) = win 0x3eee20;

    void animateEyes() = win 0x3eb480;
    void firstInteractionStep1() = win inline {
        m_lockInput = true;
        m_demonEyes->stopAllActions();
        m_demonEyes->setScale(1.f);
        m_demonEyes->setOpacity(0);
        m_demonEyes->setVisible(true);
        m_demonEyes->runAction(cocos2d::CCFadeIn::create(1.f));
        this->runAction(cocos2d::CCSequence::create(
            cocos2d::CCDelayTime::create(2.f),
            cocos2d::CCCallFunc::create(this, callfunc_selector(SecretLayer3::firstInteractionStep2)),
            nullptr
        ));
    }
    void firstInteractionStep2() = win 0x3eb5a0;
    void firstInteractionStep3() = win inline {
        for (int i = 0; i < m_locksArray->count(); i++) {
            auto lock = static_cast<cocos2d::CCMenuItemSprite*>(m_locksArray->objectAtIndex(i));
            lock->setEnabled(true);
            lock->setVisible(true);
            auto lockSprite = static_cast<cocos2d::CCNodeRGBA*>(lock->getNormalImage());
            lockSprite->setScale(2.f);
            lockSprite->setOpacity(0);
            lockSprite->runAction(cocos2d::CCSequence::create(
                cocos2d::CCDelayTime::create((i + 1) * .1f),
                cocos2d::CCSpawn::createWithTwoActions(
                    cocos2d::CCEaseBounceOut::create(cocos2d::CCScaleTo::create(.5f, 1.f)),
                    cocos2d::CCFadeIn::create(.15f)
                ),
                nullptr
            ));
        }
        this->runAction(cocos2d::CCSequence::create(
            cocos2d::CCDelayTime::create(2.f),
            cocos2d::CCCallFunc::create(this, callfunc_selector(SecretLayer3::firstInteractionStep4)),
            nullptr
        ));
    }
    void firstInteractionStep4();
    void onBack(cocos2d::CCObject* sender) = win 0x3ef2b0;
    void onChest01(cocos2d::CCObject* sender);
    void onChest02(cocos2d::CCObject* sender);
    void onClick(cocos2d::CCObject* sender) = win 0x3ec090;
    void revealStep1() = win 0x3ed8b0;
    void revealStep2();
    void revealStep3() = win inline {
        m_demonBody->setOpacity(0);
        m_demonBody->setVisible(true);
        m_demonBody->runAction(cocos2d::CCEaseInOut::create(cocos2d::CCFadeIn::create(3.f), 1.5f));
        this->runAction(cocos2d::CCSequence::create(
            cocos2d::CCDelayTime::create(4.f),
            cocos2d::CCCallFunc::create(this, callfunc_selector(SecretLayer3::revealStep4)),
            nullptr
        ));
    }
    void revealStep4() = win 0x3edf30;
    void revealStep5() = win 0x3ee780;
    void showUnlockDialog() = win 0x3ed3a0;

    DungeonBarsSprite* m_dungeonBars;
    bool m_lockInput;
    cocos2d::CCArray* m_locksArray;
    cocos2d::CCSprite* m_demonEyes;
    cocos2d::CCSprite* m_demonBody;
    CCMenuItemSpriteExtra* m_secretChest;
}

[[link(android)]]
class SecretLayer4 : cocos2d::CCLayer, TextInputDelegate, FLAlertLayerProtocol, DialogDelegate {
    SecretLayer4() {
        m_threadTag = -1;
        m_basicMessageIndex = -1;
        m_selectedThread = 0;
        m_threadMessageIndex = 0;
        m_basicMessageCount = 0;
        m_errorMessageIndex = -1;
        m_searchInput = nullptr;
        m_messageLabel = nullptr;
        m_messageThreads = nullptr;
        m_exiting = false;
    }
    ~SecretLayer4() = win inline {
        CC_SAFE_RELEASE(m_messageThreads);
    }

    static SecretLayer4* create() = win inline {
        auto ret = new SecretLayer4();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static cocos2d::CCScene* scene() = win inline {
        auto scene = cocos2d::CCScene::create();
        AppDelegate::get()->m_runningScene = scene;
        auto layer = SecretLayer4::create();
        scene->addChild(layer);
        return scene;
    }

    virtual bool init() = win 0x3ef7b0;
    virtual void onExit() = win 0x3e95a0;
    virtual void keyBackClicked();
    virtual void textInputOpened(CCTextInputNode* node);
    virtual void textInputClosed(CCTextInputNode* node);
    virtual void textChanged(CCTextInputNode* node);
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win inline {}
    virtual void dialogClosed(DialogLayer* layer) = win inline {}

    gd::string getBasicMessage();
    gd::string getErrorMessage() = win 0x3e83e0;
    gd::string getMessage();
    gd::string getThreadMessage() = win 0x3f20d0;
    cocos2d::CCNode* nodeWithTag(int tag) = win inline, ios inline {
        auto node = cocos2d::CCNode::create();
        node->setTag(tag);
        return node;
    }
    void onBack(cocos2d::CCObject* sender);
    void onChest01(cocos2d::CCObject* sender) = win 0x3f0870;
    void onSubmit(cocos2d::CCObject* sender) = win 0x3f09e0;
    void playCoinEffect();
    void selectAThread() = win inline {
        auto keys = m_messageThreads->allKeys();
        if (m_threadTag < 0) m_threadTag = (float)(keys->count() - 1) * (float)rand() / (float)RAND_MAX;
        else m_threadTag++;
        if (keys->count() <= m_threadTag) m_threadTag = 0;
        if (m_messageThreads->count() != 0) {
            auto key = static_cast<cocos2d::CCInteger*>(keys->objectAtIndex(m_threadTag));
            m_selectedThread = m_messageThreads->objectForKey(key->getValue())->getTag();
        }
    }
    void showDialog(int index);
    void showFirstDialog() = win 0x3f24f0;
    void updateMessageLabel(gd::string text);
    void updateSearchLabel(char const* text);

    int m_threadTag;
    int m_basicMessageIndex;
    int m_selectedThread;
    int m_threadMessageIndex;
    int m_basicMessageCount;
    int m_errorMessageIndex;
    CCTextInputNode* m_searchInput;
    cocos2d::CCLabelBMFont* m_messageLabel;
    CCMenuItemSpriteExtra* m_submitButton;
    cocos2d::CCDictionary* m_messageThreads;
    bool m_exiting;
}

[[link(android)]]
class SecretLayer5 : cocos2d::CCLayer, TextInputDelegate, FLAlertLayerProtocol, DialogDelegate, GJOnlineRewardDelegate {
    SecretLayer5() {
        m_threadTag = -1;
        m_basicMessageIndex = -1;
        m_selectedThread = 0;
        m_threadMessageIndex = 0;
        m_basicMessageCount = 0;
        m_errorMessageIndex = -1;
        m_textInput = nullptr;
        m_messageLabel = nullptr;
        m_exiting = false;
        m_torchFires = nullptr;
        m_loading = false;
        m_rewardStatus = 0;
        m_uiLocked = false;
        m_chatIndex = -1;
    }
    ~SecretLayer5() = win inline {
        CC_SAFE_RELEASE(m_torchFires);
        auto glm = GameLevelManager::sharedState();
        if (glm->m_GJOnlineRewardDelegate == this) glm->m_GJOnlineRewardDelegate = nullptr;
    }

    static SecretLayer5* create() = win inline {
        auto ret = new SecretLayer5();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static cocos2d::CCScene* scene() = win inline {
        auto scene = cocos2d::CCScene::create();
        AppDelegate::get()->m_runningScene = scene;
        auto layer = SecretLayer5::create();
        scene->addChild(layer);
        return scene;
    }

    virtual bool init() = win 0x3f3cc0;
    virtual void onExit() = win 0x3e95a0;
    virtual void updateTweenActionInt(float value, int tag) = win 0x3f53d0;
    virtual void keyBackClicked();
    virtual void textInputOpened(CCTextInputNode* node);
    virtual void textInputClosed(CCTextInputNode* node);
    virtual void textChanged(CCTextInputNode* node);
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win inline {}
    virtual void dialogClosed(DialogLayer* layer) = win inline {}
    virtual void onlineRewardStatusFinished(gd::string key) = win 0x3f66b0;
    virtual void onlineRewardStatusFailed() = win 0x3f6820;

    void animateHead() = win 0x3f5060;
    void claimOnlineReward() = win 0x3f6490;
    void fadeInMessage() = win inline {
        auto labels = m_messageArea->getChildren()->data;
        CCObject* obj;
        CCARRAYDATA_FOREACH(labels, obj) {
            auto characters = static_cast<cocos2d::CCLabelBMFont*>(obj)->getChildren()->data;
            CCObject* charObj;
            CCARRAYDATA_FOREACH(characters, charObj) {
                static_cast<cocos2d::CCSprite*>(charObj)->setColor({ (uint8_t)(((float)rand() / (float)RAND_MAX) * 25.f + 150.f), 0, 255 });
            }
        }
        auto duration = m_messageArea->fadeInCharacters(.6f, .06f, false, TextFadeInStyle::Scale);
        this->runAction(cocos2d::CCSequence::create(
            cocos2d::CCDelayTime::create(duration + .6f),
            cocos2d::CCCallFunc::create(this, callfunc_selector(SecretLayer5::fadeOutMessage)),
            nullptr
        ));
    }
    void fadeInSubmitMessage() = win 0x3f4e60;
    void fadeOutMessage() = win 0x3f5030;
    void finishLoadingState() = win 0x3f5420;
    gd::string getMessage() = win inline, ios inline {
        return " ";
    }
    void handleSecretResponse() = win 0x3f5440;
    void hideTextInput() = win inline {
        m_textInput->setTouchEnabled(false);
        m_textInput->onClickTrackNode(false);
        m_textInput->setVisible(false);
        m_messageArea->stopAllActions();
        m_messageArea->runAction(cocos2d::CCFadeTo::create(.5f, 0));
    }
    void incrementChatIdx() = win inline {
        m_chatIndex++;
        if (m_chatIndex > m_soundEffects.size() - 1) {
            auto effectID = m_soundEffects[m_chatIndex - 1];
            std::mt19937 rng(rand());
            std::shuffle(m_soundEffects.begin(), m_soundEffects.end(), rng);
            m_chatIndex = m_soundEffects[0] == effectID ? 1 : 0;
        }
    }
    cocos2d::CCNode* nodeWithTag(int tag) = win inline, ios inline {
        auto ret = cocos2d::CCNode::create();
        ret->setTag(tag);
        return ret;
    }
    void onBack(cocos2d::CCObject* sender) = win 0x3f7c10;
    void onSubmit(cocos2d::CCObject* sender) = win 0x3f68c0;
    void playWinSFX() = win 0x3f6400;
    void showDialog(int index);
    void showFailAnimation() = win 0x3f54a0;
    void showFirstDialog() = win 0x3f74f0;
    void showSuccessAnimation() = win 0x3f5a60;
    void showTextInput() = win 0x3f6860;
    void unlockUI() = win 0x3f66a0;
    void updateMessageLabel(gd::string text) = win inline {
        m_messageLabel->setString(text.c_str());
        m_messageLabel->limitLabelWidth(320.f, .6f, 0.f);
    }
    void updateSearchLabel(char const* text);

    int m_threadTag;
    int m_basicMessageIndex;
    int m_selectedThread;
    int m_threadMessageIndex;
    int m_basicMessageCount;
    int m_errorMessageIndex;
    CCTextInputNode* m_textInput;
    cocos2d::CCLabelBMFont* m_messageLabel;
    CCMenuItemSpriteExtra* m_wraithButton;
    bool m_exiting;
    void* m_unk1f0;
    cocos2d::CCArray* m_torchFires;
    bool m_loading;
    int m_rewardStatus; // 0 invalid, 1 valid, 2 claimed
    gd::string m_chestID;
    bool m_uiLocked;
    CCSpriteWithHue* m_wraithSprite;
    CCSpriteGrayscale* m_wraithGraySprite;
    cocos2d::CCSprite* m_eyesSprite;
    cocos2d::CCSprite* m_background;
    cocos2d::CCSprite* m_lockSprite;
    gd::vector<int> m_soundEffects;
    int m_chatIndex;
    cocos2d::extension::CCScale9Sprite* m_inputBackground;
    LoadingCircleSprite* m_circleSprite;
    TextArea* m_messageArea;
}

[[link(android)]]
class SecretLayer6 : cocos2d::CCLayer {
    // virtual ~SecretLayer6() = m1 0x3db294, imac 0x64bc50;

    static SecretLayer6* create();
    static cocos2d::CCScene* scene();

    virtual bool init();
    virtual void keyBackClicked();

    void onBack(cocos2d::CCObject* sender);
    void startGame01();

    SecretGame01Layer* m_gameLayer;
}

[[link(android)]]
class SecretNumberLayer : cocos2d::CCLayer {
    // virtual ~SecretNumberLayer();

    static SecretNumberLayer* create() = win 0x3e95f0;

    virtual bool init();

    void playNumberEffect(int secretNumber) = win 0x3e96b0;
}

[[link(android)]]
class SecretRewardsLayer : cocos2d::CCLayer, DialogDelegate, BoomScrollLayerDelegate {
    SecretRewardsLayer() {
        m_mainLayer = nullptr;
        m_secondaryLayer = nullptr;
        m_chestCounter = nullptr;
        m_chestCounters = nullptr;
        m_backSprite = nullptr;
        m_unkSize4_2 = 0;
        m_secondaryScrollLayer = nullptr;
        m_scratchDialogIndex = 0;
        m_potborDialogIndex = 0;
        m_diamondDialogIndex = 0;
        m_mechanicDialogIndex = 0;
        m_inMainLayer = false;
        m_rewardType = GJRewardType::Unknown;
        m_lockedDialogIndex = 0;
    }
    ~SecretRewardsLayer() = win inline {
        CC_SAFE_RELEASE(m_chestCounters);
    }

    static SecretRewardsLayer* create(bool fromShop) = win inline {
        auto ret = new SecretRewardsLayer();
        if (ret->init(fromShop)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static cocos2d::CCScene* scene(bool fromShop) = win 0x3d21a0;

    virtual void onExit();
    virtual void keyBackClicked();
    virtual void dialogClosed(DialogLayer* layer) = win 0x3d6570;
    virtual void scrollLayerMoved(cocos2d::CCPoint position) = win 0x3d4a10;

    void createSecondaryLayer(int chestType) = win 0x3d4f70;
    void fadeInMusic() = win inline {
        FMODAudioEngine::sharedEngine()->fadeMusic(1.f, 0, 1.f, .2f);
        this->runAction(cocos2d::CCSequence::create(
            cocos2d::CCDelayTime::create(3.2f),
            cocos2d::CCCallFunc::create(this, callfunc_selector(SecretRewardsLayer::fadeInOutMusic)),
            nullptr
        ));
    }
    void fadeInOutMusic() = win 0x3d76c0;
    cocos2d::CCArray* generateChestItems(int chestType) = win 0x3d53c0;
    cocos2d::ccColor3B getPageColor(int page) = win inline, ios inline {
        if (page == 1) return cocos2d::ccc3(50, 50, 50);
        else if (page == 2) return cocos2d::ccc3(70, 0, 120);
        else return cocos2d::ccc3(70, 0, 75);
    }
    void goToPage(int page) = win inline {
        if (m_inMainLayer) m_mainScrollLayer->moveToPage(page);
        else m_secondaryScrollLayer->moveToPage(page);
    }
    bool init(bool fromShop) = win 0x3d2300;
    void moveToMainLayer(cocos2d::CCObject* sender) = win inline {
        if (m_inMainLayer) return;
        m_inMainLayer = true;
        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        m_mainLayer->runAction(cocos2d::CCEaseInOut::create(cocos2d::CCMoveTo::create(.4f, { 0.f, 0.f }), 2.f));
        if (m_secondaryLayer) {
            m_secondaryScrollLayer->setTouchEnabled(false);
            m_secondaryScrollLayer = nullptr;
            m_chestCounter = nullptr;
            m_secondaryLayer->runAction(cocos2d::CCSequence::create(
                cocos2d::CCEaseInOut::create(cocos2d::CCMoveTo::create(.4f, { 0.f, winSize.height + 50.f }), 2.f),
                cocos2d::CCCallFunc::create(m_secondaryLayer, callfunc_selector(cocos2d::CCNode::removeMeAndCleanup)),
                nullptr
            ));
            m_secondaryLayer = nullptr;
        }
        this->updateBackButton();
    }
    void moveToSecondaryLayer(int page) = win inline {
        if (!m_inMainLayer) return;
        m_inMainLayer = false;
        m_rewardType = (GJRewardType)page;
        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        m_mainScrollLayer->setTouchEnabled(false);
        m_mainLayer->runAction(cocos2d::CCEaseBounceOut::create(cocos2d::CCMoveTo::create(.5f, { 0.f, -winSize.height - 100.f })));
        this->createSecondaryLayer(page);
        m_secondaryLayer->setPosition({ 0.f, winSize.height });
        m_secondaryLayer->runAction(cocos2d::CCEaseBounceOut::create(cocos2d::CCMoveTo::create(.5f, { 0.f, 0.f })));
        this->updateBackButton();
    }
    void onBack(cocos2d::CCObject* sender) = win 0x3d78b0;
    void onChestType(cocos2d::CCObject* sender) = win 0x3d4ce0;
    void onGoldChest(cocos2d::CCObject* sender) = win 0x3d7020;
    void onSelectItem(cocos2d::CCObject* sender) = win 0x3d5dd0;
    void onShop(cocos2d::CCObject* sender) = win 0x3d6360;
    void onSpecialItem(cocos2d::CCObject* sender) = win 0x3d6760;
    void onSwitchPage(cocos2d::CCObject* sender) = win 0x3d4950;
    void showDialog01() = win 0x3d7ae0;
    void showDialog03();
    void showDialogDiamond();
    void showDialogMechanic() = win 0x3da6f0;
    void showLockedChest();
    void showShop(int shop) = win inline {
        if (cocos2d::CCDirector::sharedDirector()->replaceScene(cocos2d::CCTransitionMoveInT::create(0.5f, GJShopLayer::scene((ShopType)shop)))) this->setKeypadEnabled(false);
    }
    void switchToOpenedState(CCMenuItemSpriteExtra* button) = win 0x3d6b80;
    void updateBackButton() = win 0x3d4e30;
    void updateUnlockedGoldLabel() = win 0x3d7730;
    void updateUnlockedLabel() = win 0x3d6c60;

    cocos2d::CCLayer* m_mainLayer;
    cocos2d::CCLayer* m_secondaryLayer;
    cocos2d::CCLabelBMFont* m_chestLabel;
    cocos2d::CCLabelBMFont* m_chestCounter;
    cocos2d::CCSprite* m_goldPriceSprite;
    cocos2d::CCDictionary* m_chestCounters;
    cocos2d::CCLabelBMFont* m_keysLabel;
    cocos2d::CCLabelBMFont* m_goldKeysLabel;
    cocos2d::CCSprite* m_keySprite;
    cocos2d::CCSprite* m_goldKeySprite;
    void* m_unknown;
    CCMenuItemSpriteExtra* m_leftButton;
    CCMenuItemSpriteExtra* m_rightButton;
    cocos2d::CCSprite* m_backSprite;
    int m_unkSize4_1;
    int m_unkSize4_2;
    BoomScrollLayer* m_mainScrollLayer;
    BoomScrollLayer* m_secondaryScrollLayer;
    cocos2d::CCSprite* m_backgroundSprite;
    int m_scratchDialogIndex;
    int m_potborDialogIndex;
    int m_diamondDialogIndex;
    int m_mechanicDialogIndex;
    bool m_inMainLayer;
    GJRewardType m_rewardType;
    int m_lockedDialogIndex;
}

[[link(android)]]
class SelectArtDelegate {
    virtual void selectArtClosed(SelectArtLayer* layer) {}
}

[[link(android)]]
class SelectArtLayer : FLAlertLayer {
    // virtual ~SelectArtLayer();

    static SelectArtLayer* create(SelectArtType type, int index) = win 0x321f10;

    virtual void keyBackClicked();

    bool init(SelectArtType type, int index) = win 0x322020;
    void onClose(cocos2d::CCObject* sender);
    void onSelectCustom(cocos2d::CCObject* sender) = win 0x322d30;
    void selectArt(cocos2d::CCObject* sender) = win 0x322c70;
    void updateSelectedCustom(int idx) = win inline {
        if (m_lineSprites) {
            m_line = idx;
            this->onSelectCustom(nullptr);
        }
    }

    cocos2d::CCArray* m_artSprites;
    cocos2d::CCArray* m_lineSprites;
    int m_art;
    int m_line;
    SelectArtType m_type;
    SelectArtDelegate* m_delegate;
}

[[link(android)]]
class SelectEventLayer : SetupTriggerPopup {
    SelectEventLayer() {
        m_eventLinkPopup = nullptr;
        m_eventsChanged = false;
        m_unk3b4 = 0;
        m_toggleCount = 0;
        m_maxPage = 0;
    }
    ~SelectEventLayer() = win inline {
        CCNode::removeAllChildrenWithCleanup(true);
    }

    static SelectEventLayer* create(SetupEventLinkPopup* popup, gd::set<int>& eventIDs) = win inline {
        auto ret = new SelectEventLayer();
        if (ret->init(popup, eventIDs)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyBackClicked();
    virtual void onClose(cocos2d::CCObject* sender) = win 0x467330;
    virtual void onCustomToggleTriggerValue(cocos2d::CCObject* sender) = win 0x4671e0;

    void addToggle(int id, gd::string info) = win 0x4673f0;
    bool init(SetupEventLinkPopup* popup, gd::set<int>& eventIDs) = win 0x466370;
    cocos2d::CCPoint nextPosition() = win inline {
        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        auto count = (m_toggleCount - 1) % 12;
        cocos2d::CCPoint pos = winSize * .5f + cocos2d::CCPoint { count < 6 ? -140.f : 40.f, 90.f };
        pos.y -= (count % 6) * 34;
        return pos;
    }
    void onInfo(cocos2d::CCObject* sender) = win 0x467830;

    SetupEventLinkPopup* m_eventLinkPopup;
    bool m_eventsChanged;
    int m_unk3b4;
    int m_toggleCount;
    int m_maxPage;
    gd::map<int, gd::string> m_eventInfos;
    gd::set<int> m_eventIDs;
}

[[link(android)]]
class SelectFontLayer : FLAlertLayer {
    SelectFontLayer() {
        m_font = -1;
        m_editorLayer = nullptr;
        m_fontLabel = nullptr;
    }
    ~SelectFontLayer() = win inline {
        CCNode::removeAllChildrenWithCleanup(true);
    }

    static SelectFontLayer* create(LevelEditorLayer* editorLayer) = win inline {
        auto ret = new SelectFontLayer();
        if (ret->init(editorLayer)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyBackClicked() = win 0x846c0;

    bool init(LevelEditorLayer* layer) = win 0x28e370;
    void onChangeFont(cocos2d::CCObject* sender) = win 0x28eb90;
    void onClose(cocos2d::CCObject* sender) = win 0x84690;
    void updateFontLabel() = win 0x28e990;

    int m_font;
    LevelEditorLayer* m_editorLayer;
    cocos2d::CCLabelBMFont* m_fontLabel;
}

[[link(android)]]
class SelectListIconDelegate {
    virtual void iconSelectClosed(SelectListIconLayer* layer) {}
}

[[link(android)]]
class SelectListIconLayer : FLAlertLayer {
    SelectListIconLayer() {
        m_difficulties = nullptr;
        m_currentDifficulty = 0;
        m_delegate = nullptr;
    }
    ~SelectListIconLayer() = win inline {
        CC_SAFE_RELEASE(m_difficulties);
    }

    static SelectListIconLayer* create(int difficulty) = win inline {
        auto ret = new SelectListIconLayer();
        if (ret->init(difficulty)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyBackClicked();

    bool init(int difficulty) = win 0x308f60;
    void onClose(cocos2d::CCObject* sender);
    void onSelect(cocos2d::CCObject* sender) = win 0x309750;

    cocos2d::CCArray* m_difficulties;
    int m_currentDifficulty;
    SelectListIconDelegate* m_delegate;
}

[[link(android)]]
class SelectPremadeDelegate {
    virtual void selectPremadeClosed(SelectPremadeLayer* layer, int type) {}
}

[[link(android)]]
class SelectPremadeLayer : FLAlertLayer {
    // virtual ~SelectPremadeLayer();
    SelectPremadeLayer() {}

    static SelectPremadeLayer* create() = win inline {
        auto ret = new SelectPremadeLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x406840;
    virtual void keyBackClicked() = win 0x846c0;

    void onClose(cocos2d::CCObject* sender) = win 0x84690;
    void onSelectPremade(cocos2d::CCObject* sender) = win 0x406e50;

    SelectPremadeDelegate* m_delegate;
}

[[link(android)]]
class SelectSettingDelegate {
    virtual void selectSettingClosed(SelectSettingLayer* layer) {}
}

[[link(android)]]
class SelectSettingLayer : FLAlertLayer {
    // virtual ~SelectSettingLayer();

    static SelectSettingLayer* create(SelectSettingType type, int value) = win 0x322e90;
    static gd::string frameForItem(SelectSettingType type, int index) = win 0x3236f0;
    static gd::string frameForValue(SelectSettingType type, int value) = win inline {
        return frameForItem(type, valueToIdx(type, value));
    }
    static int idxToValue(SelectSettingType type, int idx) = win inline, ios inline {
        if (type != SelectSettingType::StartingSpeed) return idx;

        switch (idx) {
            case 0: return 1;
            case 1: return 0;
            case 2: case 3: case 4: return idx;
            default: return 0;
        }
    }
    static int valueToIdx(SelectSettingType type, int value) = win inline, ios inline {
        if (type != SelectSettingType::StartingSpeed) return value;

        switch (value) {
            case 0: return 1;
            case 1: return 0;
            case 2: case 3: case 4: return value;
            default: return 1;
        }
    }

    virtual void keyBackClicked();

    gd::string getSelectedFrame() = win inline {
        return frameForValue(m_type, m_settingID);
    }
    int getSelectedValue() = win inline {
        return idxToValue(m_type, m_settingID);
    }
    bool init(SelectSettingType type, int value) = win 0x322fa0;
    void onClose(cocos2d::CCObject* sender);
    void onSelect(cocos2d::CCObject* sender) = win 0x323b90;

    cocos2d::CCArray* m_settingSprites;
    int m_settingID;
    SelectSettingType m_type;
    SelectSettingDelegate* m_delegate;
}

[[link(android)]]
class SelectSFXSortDelegate {
    virtual void sortSelectClosed(SelectSFXSortLayer* layer) {}
}

[[link(android)]]
class SelectSFXSortLayer : FLAlertLayer {
    // virtual ~SelectSFXSortLayer();
    SelectSFXSortLayer() {
        m_sortType = AudioSortType::NameAscending;
        m_delegate = nullptr;
    }

    static SelectSFXSortLayer* create(AudioSortType sortType) = win inline {
        auto ret = new SelectSFXSortLayer();
        if (ret->init(sortType)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyBackClicked() = win 0x846c0;

    bool init(AudioSortType sortType) = win 0x480cc0;
    void onClose(cocos2d::CCObject* sender) = win 0x84690;
    void onSelect(cocos2d::CCObject* sender) = win 0x481340;

    AudioSortType m_sortType;
    SelectSFXSortDelegate* m_delegate;
}

[[link(android)]]
class SequenceTriggerGameObject : ChanceTriggerGameObject {
    // virtual ~SequenceTriggerGameObject();
    SequenceTriggerGameObject() {
        m_sequenceMode = 0;
        m_minInt = 0.f;
        m_resetMode = 0;
        m_reset = 0.f;
        m_sequenceTotalCount = 0;
        m_uniqueRemap = false;
    }

    static SequenceTriggerGameObject* create() = win inline {
        auto ret = new SequenceTriggerGameObject();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init();
    virtual void resetObject();
    virtual void triggerObject(GJBaseGameLayer* layer, int uniqueID, gd::vector<int> const* remapKeys) = win 0x4b4500;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4b4920;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x4b4c50;

    void addCount(int index, int count) = win inline {
        if (index < 0 || index >= m_chanceObjects.size()) return;
        auto& object = m_chanceObjects[index];
        object.m_chance = std::max(object.m_chance + count, 1);
        m_sequenceTotalCount = -1;
    }
    void addTarget(int groupID, int count) = win inline {
        count = std::max(count, 1);
        m_chanceObjects.emplace_back(groupID, count);
        m_sequenceTotalCount = -1;
    }
    void deleteTarget(int index) = win inline {
        if (index < 0 || index >= m_chanceObjects.size()) return;
        m_chanceObjects.erase(m_chanceObjects.begin() + index);
        m_sequenceTotalCount = -1;
    }
    bool reorderTarget(int index, bool left) = win inline {
        int size = m_chanceObjects.size();
        if (index >= size) return false;
        if (left) {
            if (index == 0) return false;
            std::swap(m_chanceObjects[index], m_chanceObjects[index - 1]);
            return true;
        }
        else {
            if (index == size - 1) return false;
            std::swap(m_chanceObjects[index], m_chanceObjects[index + 1]);
            return true;
        }
    }
    void updateSequenceTotalCount() = win inline, ios inline {
        auto total = 0;
        for (auto& obj : m_chanceObjects) {
            total += obj.m_chance;
            m_sequenceTotalCount = total;
        }
    }

    SequenceTriggerState m_sequenceState;
    // property 437
    float m_minInt;
    // property 436
    int m_sequenceMode;
    // property 439
    int m_resetMode;
    // property 438
    float m_reset;
    int m_sequenceTotalCount;
    // property 505
    bool m_uniqueRemap;
}

[[link(android)]]
class SetColorIDPopup : SetIDPopup, GJSpecialColorSelectDelegate {
    // virtual ~SetColorIDPopup();
    SetColorIDPopup() {}

    static SetColorIDPopup* create(int id) = win inline {
        auto ret = new SetColorIDPopup();
        if (ret->init(id)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void colorSelectClosed(GJSpecialColorSelect* select, int id) = win 0x29c1b0;

    bool init(int id) = win 0x29bf60;
    void onSelectSpecialColor(cocos2d::CCObject* sender);
}

[[link(android)]]
class SetFolderPopup : SetIDPopup, SetTextPopupDelegate {
    // virtual ~SetFolderPopup();

    static SetFolderPopup* create(int value, bool isCreated, gd::string title) = win 0x29c350;

    virtual void valueChanged() = win 0x29c710;
    virtual void setTextPopupClosed(SetTextPopup* popup, gd::string text) = win 0x29ca50;

    bool init(int value, bool isCreated, gd::string title) = win 0x29c490;
    void onSetFolderName(cocos2d::CCObject* sender) = win 0x29c850;

    bool m_isCreated;
    cocos2d::CCLabelBMFont* m_titleLabel;
}

[[link(android)]]
class SetGroupIDLayer : FLAlertLayer, TextInputDelegate {
    SetGroupIDLayer() {
        m_targetObject = nullptr;
        m_targetObjects = nullptr;
        m_editorLayerInput = nullptr;
        m_editorLayer2Input = nullptr;
        m_zOrderInput = nullptr;
        m_groupIDInput = nullptr;
        m_orderInput = nullptr;
        m_channelInput = nullptr;
        m_showChannelOrder = false;
        m_channelValue = 0;
        m_channelUpdated = false;
        m_groupIDValue = 0;
        m_editorLayerValue = 0;
        m_editorLayer2Value = 0;
        m_zOrderValue = -1000;
        m_zLayerValue = ZLayer::Default;
        m_orderValue = 0;
        m_channelOrderEdited = false;
        m_editorLayerEdited = false;
        m_removeGroupsLock = false;
        m_addedGroup = false;
        m_reverseChanged = false;
        m_unk2ff = false;
        m_unk300 = false;
        m_nextFreeID = 0;
        m_parentGroups = nullptr;
    }
    ~SetGroupIDLayer() = win inline {
        CC_SAFE_RELEASE(m_targetObjects);
        CC_SAFE_RELEASE(m_zLayerButtons);
        CC_SAFE_RELEASE(m_groupIDObjects);
        CC_SAFE_RELEASE(m_parentGroups);
    }

    static SetGroupIDLayer* create(GameObject* object, cocos2d::CCArray* objects) = win inline {
        auto ret = new SetGroupIDLayer();
        if (ret->init(object, objects)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyBackClicked();
    virtual void textInputClosed(CCTextInputNode* node);
    virtual void textChanged(CCTextInputNode* node);

    void addGroupID(int id) = win inline {
        m_addedGroup = true;
        if (m_targetObject) {
            if (m_targetObject->addToGroup(id) == 1) {
                GameManager::sharedState()->m_levelEditorLayer->addToGroup(m_targetObject, id, false);
            }
        }
        else {
            for (int i = 0; i < m_targetObjects->count(); i++) {
                auto obj = static_cast<GameObject*>(m_targetObjects->objectAtIndex(i));
                if (obj->addToGroup(id) == 1) {
                    GameManager::sharedState()->m_levelEditorLayer->addToGroup(obj, id, false);
                }
            }
        }
    }
    void callRemoveFromGroup(float dt) = win 0x3fc470;
    CCTextInputNode* createTextInput(cocos2d::CCPoint position, int tag, int length, gd::string placeholder, float width, int arrow) = win 0x3fa8f0;
    void determineStartValues() = win 0x3faf90;
    bool init(GameObject* obj, cocos2d::CCArray* objs);
    void onAddGroup(cocos2d::CCObject* sender) = win 0x3fc720;
    void onAddGroupParent(cocos2d::CCObject* sender) = win 0x3fc890;
    void onAnim(cocos2d::CCObject* sender);
    void onArrow(int tag, int increment) = win 0x3fae20;
    void onArrowLeft(cocos2d::CCObject* sender) = win 0x3fadc0;
    void onArrowRight(cocos2d::CCObject* sender) = win 0x3fadf0;
    void onClose(cocos2d::CCObject* sender) = win 0x3fd7f0;
    void onCopy(cocos2d::CCObject* sender);
    void onExtra(cocos2d::CCObject* sender) = win 0x3fb510;
    void onExtra2(cocos2d::CCObject* sender) = win 0x3fb690;
    void onNextFreeEditorLayer1(cocos2d::CCObject* sender);
    void onNextFreeEditorLayer2(cocos2d::CCObject* sender);
    void onNextFreeOrderChannel(cocos2d::CCObject* sender);
    void onNextGroupID1(cocos2d::CCObject* sender);
    void onPaste(cocos2d::CCObject* sender) = win 0x3fb370;
    void onRemoveFromGroup(cocos2d::CCObject* sender);
    void onSmoothEase(cocos2d::CCObject* sender) = win inline, ios inline {
        if (auto teleportObject = static_cast<TeleportPortalObject*>(m_targetObject)) {
            teleportObject->m_teleportEase = !teleportObject->m_teleportEase;
        }
    }
    void onToggleGuide(cocos2d::CCObject* sender);
    void onToggleSelectedOrder(cocos2d::CCObject* sender);
    void onZLayer(cocos2d::CCObject* sender) = win 0x3fc990;
    void onZLayerShift(cocos2d::CCObject* sender) = win 0x3fca50;
    void removeGroupID(int id) = win inline {
        m_addedGroup = true;
        if (m_targetObject) {
            m_targetObject->removeFromGroup(id);
            GameManager::sharedState()->m_levelEditorLayer->removeFromGroup(m_targetObject, id);
        }
        else {
            for (int i = 0; i < m_targetObjects->count(); i++) {
                auto obj = static_cast<GameObject*>(m_targetObjects->objectAtIndex(i));
                obj->removeFromGroup(id);
                GameManager::sharedState()->m_levelEditorLayer->removeFromGroup(obj, id);
            }
        }
        this->updateGroupIDButtons();
    }
    void updateEditorLabel();
    void updateEditorLabel2();
    void updateEditorLayerID();
    void updateEditorLayerID2();
    void updateEditorOrder();
    void updateEditorOrderLabel();
    void updateGroupIDButtons() = win 0x3fbdb0;
    void updateGroupIDLabel();
    void updateOrderChannel();
    void updateOrderChannelLabel();
    void updateZLayerButtons() = win 0x3fd5c0;
    void updateZOrder() = win 0x3fd0f0;
    void updateZOrderLabel() = win 0x3fd2a0;

    GameObject* m_targetObject;
    cocos2d::CCArray* m_targetObjects;
    cocos2d::CCArray* m_zLayerButtons;
    cocos2d::CCArray* m_groupIDObjects;
    CCTextInputNode* m_editorLayerInput;
    CCTextInputNode* m_editorLayer2Input;
    CCTextInputNode* m_zOrderInput;
    CCTextInputNode* m_groupIDInput;
    CCTextInputNode* m_orderInput;
    CCTextInputNode* m_channelInput;
    bool m_showChannelOrder;
    int m_channelValue;
    bool m_channelUpdated;
    int m_groupIDValue;
    int m_editorLayerValue;
    int m_editorLayer2Value;
    int m_zOrderValue;
    ZLayer m_zLayerValue;
    int m_orderValue;
    bool m_channelOrderEdited;
    bool m_editorLayerEdited;
    bool m_removeGroupsLock;
    int m_groupToRemove;
    bool m_addedGroup;
    bool m_reverseChanged;
    bool m_hasTargetObjects;
    bool m_unk2ff;
    bool m_unk300;
    int m_nextFreeID;
    cocos2d::CCDictionary* m_parentGroups;
}

[[link(android)]]
class SetIDPopup : FLAlertLayer, TextInputDelegate {
    SetIDPopup() {
        m_inputNode = nullptr;
        m_value = 0;
        m_disableDelegate = false;
        m_cancelled = false;
        m_minimum = 0;
        m_maximum = 1000;
        m_default = 0;
        m_delegate = nullptr;
    }
    ~SetIDPopup() = win 0x29afd0;

    static SetIDPopup* create(int current, int begin, int end, gd::string title, gd::string button, bool resetButton, int defaultValue, float offset, bool numberInput, bool arrows) = win 0x29b070;

    virtual void keyBackClicked();
    virtual void show();
    virtual void textInputClosed(CCTextInputNode* node);
    virtual void textChanged(CCTextInputNode* node) = win 0x29bbd0;
    virtual void valueChanged() = win inline {}

    bool init(int current, int begin, int end, gd::string title, gd::string button, bool resetButton, int defaultValue, float offset, bool numberInput, bool arrows) = win 0x29b1a0;
    void onCancel(cocos2d::CCObject* sender) = win 0x29be10;
    void onClose(cocos2d::CCObject* sender) = win 0x29beb0;
    void onItemIDArrow(cocos2d::CCObject* sender) = win 0x29bb60;
    void onResetValue(cocos2d::CCObject* sender) = win 0x29bbb0;
    void updateTextInputLabel() = win 0x29bcd0;

    CCTextInputNode* m_inputNode;
    int m_value;
    bool m_disableDelegate;
    bool m_cancelled;
    int m_minimum;
    int m_maximum;
    int m_default;
    SetIDPopupDelegate* m_delegate;
}

[[link(android)]]
class SetIDPopupDelegate {
    virtual void setIDPopupClosed(SetIDPopup* popup, int value) {}
}

[[link(android)]]
class SetItemIDLayer : SetupTriggerPopup {
    // virtual ~SetItemIDLayer();
    SetItemIDLayer() {}

    static SetItemIDLayer* create(EffectGameObject* object, cocos2d::CCArray* objects) = win inline {
        auto ret = new SetItemIDLayer();
        if (ret->init(object, objects)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void onClose(cocos2d::CCObject* sender) = win 0x4017e0;
    virtual void valueDidChange(int tag, float value) = win 0x4016f0;
    virtual void onCustomToggleTriggerValue(cocos2d::CCObject* sender) = win 0x401550;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x400df0;
    void updateEditorLabel() = win inline {
        auto objects = this->getObjects();
        for (int i = 0; i < objects->count(); i++) {
            static_cast<LabelGameObject*>(objects->objectAtIndex(i))->updatePreviewLabel();
        }
    }
}

[[link(android)]]
class SetLevelOrderPopup : SetIDPopup {
    // virtual ~SetLevelOrderPopup();
    SetLevelOrderPopup() {
        m_levelID = 0;
    }

    static SetLevelOrderPopup* create(int levelID, int order, int amount) = win inline {
        auto ret = new SetLevelOrderPopup();
        if (ret->init(levelID, order, amount)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init(int levelID, int order, int amount) = win 0x308c50;
    void onOrderButton(cocos2d::CCObject* sender) = win 0x308f20;

    int m_levelID;
}

[[link(android)]]
class SetTargetIDLayer : SetupTriggerPopup {
    // virtual ~SetTargetIDLayer();

    static SetTargetIDLayer* create(EffectGameObject* object, cocos2d::CCArray* objects, gd::string title, gd::string label, int minimum, int maximum, int objectID) = win 0x98480;

    virtual void determineStartValues();
    virtual void valueDidChange(int tag, float value) = win 0x401f90;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects, gd::string title, gd::string label, int minimum, int maximum, int objectID) = win 0x401af0;

    int m_objectID;
    int m_minimumID;
    int m_maximumID;
}

[[link(android)]]
class SetTextPopup : FLAlertLayer, TextInputDelegate {
    SetTextPopup() {
        m_input = nullptr;
        m_disableDelegate = false;
        m_cancelled = false;
        m_delegate = nullptr;
    }
    ~SetTextPopup() = win 0x29cbe0;

    static SetTextPopup* create(gd::string value, gd::string placeholder, int maxLength, gd::string title, gd::string okBtnText, bool showResetBtn, float offset) = win 0x29cc90;

    virtual void keyBackClicked();
    virtual void show() = win 0x8bb10;
    virtual void textInputClosed(CCTextInputNode* node);
    virtual void textChanged(CCTextInputNode* node) = win 0x29d740;

    bool init(gd::string value, gd::string placeholder, int maxLength, gd::string title, gd::string okBtnText, bool showResetBtn, float offset) = win 0x29ce00;
    void onCancel(cocos2d::CCObject* sender) = win 0x29d830;
    void onClose(cocos2d::CCObject* sender) = win 0x29d8c0;
    void onResetValue(cocos2d::CCObject* sender) = win 0x29d6e0;
    void updateTextInputLabel() = win inline {
        m_disableDelegate = true;
        m_input->setString(m_value);
        m_disableDelegate = false;
    }

    CCTextInputNode* m_input;
    bool m_disableDelegate;
    bool m_cancelled;
    gd::string m_value;
    SetTextPopupDelegate* m_delegate;
}

[[link(android)]]
class SetTextPopupDelegate {
    virtual void setTextPopupClosed(SetTextPopup* popup, gd::string text) {}
}

[[link(android)]]
class SetupAdvFollowEditPhysicsPopup : SetupTriggerPopup {
    // virtual ~SetupAdvFollowEditPhysicsPopup();

    static SetupAdvFollowEditPhysicsPopup* create(AdvancedFollowEditObject* object, cocos2d::CCArray* objects);

    virtual void valueDidChange(int tag, float value) = win 0x407d50;

    bool init(AdvancedFollowEditObject* object, cocos2d::CCArray* objects) = win 0x406fc0;
}

[[link(android)]]
class SetupAdvFollowPopup : SetupTriggerPopup, SelectPremadeDelegate {
    // virtual ~SetupAdvFollowPopup();

    static SetupAdvFollowPopup* create(AdvancedFollowTriggerObject* object, cocos2d::CCArray* objects);

    virtual void onClose(cocos2d::CCObject* sender);
    virtual void updateDefaultTriggerValues();
    virtual void valueDidChange(int tag, float value) = win 0x405350;
    virtual void onCustomToggleTriggerValue(cocos2d::CCObject* sender) = win 0x405690;
    virtual void selectPremadeClosed(SelectPremadeLayer* layer, int type) = win 0x405940;

    bool init(AdvancedFollowTriggerObject* object, cocos2d::CCArray* objects) = win 0x4021a0;
    void onMode(cocos2d::CCObject* sender);
    void onPremade(cocos2d::CCObject* sender) = win 0x405810;
    void updateMode(int mode) = win 0x405770;
}

[[link(android)]]
class SetupAdvFollowRetargetPopup : SetupTriggerPopup {
    // virtual ~SetupAdvFollowRetargetPopup();

    static SetupAdvFollowRetargetPopup* create(AdvancedFollowEditObject* object, cocos2d::CCArray* objects);

    virtual void updateDefaultTriggerValues();
    virtual void valueDidChange(int tag, float value) = win 0x408570;

    bool init(AdvancedFollowEditObject* object, cocos2d::CCArray* objects) = win 0x407f30;
}

[[link(android)]]
class SetupAnimationPopup : SetupTriggerPopup {
    // virtual ~SetupAnimationPopup();

    static SetupAnimationPopup* create(EffectGameObject* object, cocos2d::CCArray* objects);

    virtual void determineStartValues();
    virtual void onClose(cocos2d::CCObject* sender);
    virtual void textChanged(CCTextInputNode* node) = win 0x409970;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x4089f0;
    void onAnimationIDArrow(cocos2d::CCObject* sender) = win 0x4098e0;
    void onTargetIDArrow(cocos2d::CCObject* sender) = win 0x409920;
    void updateAnimationID() = win 0x409cf0;
    void updateAnimationTextInputLabel();
    void updateTargetID();
    void updateTextInputLabel();

    CCTextInputNode* m_targetIDInput;
    CCTextInputNode* m_animationIDInput;
    int m_targetID;
    int m_animationID;
}

[[link(android)]]
class SetupAnimSettingsPopup : SetupTriggerPopup {
    // virtual ~SetupAnimSettingsPopup();

    static SetupAnimSettingsPopup* create(EffectGameObject* object, cocos2d::CCArray* objects);

    virtual void onClose(cocos2d::CCObject* sender) = win 0x40a7a0;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x409f20;
    void updateAnimSettings() = win inline {
        if (m_gameObject) m_gameObject->setupAnimationVariables();
        else {
            for (int i = 0; i < m_gameObjects->count(); i++) {
                static_cast<EnhancedGameObject*>(m_gameObjects->objectAtIndex(i))->setupAnimationVariables();
            }
        }
    }
}

[[link(android)]]
class SetupAreaAnimTriggerPopup : SetupAreaTintTriggerPopup {
    // virtual ~SetupAreaAnimTriggerPopup();
    SetupAreaAnimTriggerPopup() {}

    static SetupAreaAnimTriggerPopup* create(EnterEffectObject* object, cocos2d::CCArray* objects, int id) = win inline {
        auto ret = new SetupAreaAnimTriggerPopup();
        if (ret->init(object, objects, id)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void updateDefaultTriggerValues() = win 0x412450;
    virtual void valueDidChange(int tag, float value) = win 0x412620;

    void createValueControlAdvancedAnim(int property, gd::string label, cocos2d::CCPoint position, float scale, bool noSlider, InputValueType valueType, int length, bool arrows, float min, float max, int page, int group, GJInputStyle inputStyle) = win 0x412260;
    bool init(EnterEffectObject* object, cocos2d::CCArray* objects, int id) = win 0x410af0;
    void onDeactivateAnimValue(cocos2d::CCObject* sender) = win 0x4125b0;
    void updateTargetIDLabel() = win 0x412530;
}

[[link(android)]]
class SetupAreaFadeTriggerPopup : SetupAreaMoveTriggerPopup {
    // virtual ~SetupAreaFadeTriggerPopup();
    SetupAreaFadeTriggerPopup() {}

    static SetupAreaFadeTriggerPopup* create(EnterEffectObject* object, cocos2d::CCArray* objects) = win inline {
        auto ret = new SetupAreaFadeTriggerPopup();
        if (ret->init(object, objects)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init(EnterEffectObject* object, cocos2d::CCArray* objects) = win 0x40ed80;
}

[[link(android)]]
class SetupAreaMoveTriggerPopup : SetupTriggerPopup {
    SetupAreaMoveTriggerPopup() {
        m_modeButtons = nullptr;
        m_targetButtons = nullptr;
    }
    ~SetupAreaMoveTriggerPopup();

    static SetupAreaMoveTriggerPopup* create(EnterEffectObject* object, cocos2d::CCArray* objects) = win inline {
        auto ret = new SetupAreaMoveTriggerPopup();
        if (ret->init(object, objects)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void updateInputValue(int tag, float& value) = win 0x40dd40;
    virtual void updateDefaultTriggerValues();
    virtual void updateInputNode(int tag, float value) = win 0x40dd10;
    virtual void valueDidChange(int tag, float value) = win 0x40db90;
    virtual float triggerValueFromSliderValue(int tag, float value);
    virtual float triggerSliderValueFromValue(int tag, float value) = win 0x40dce0;

    void addAreaDefaultControls(int objectID) = win 0x40c000;
    void getModeValues(int mode, int& direction, bool& inbound, bool& twoDirections) = win inline, ios inline {
        if (mode > 1 && mode < 6) direction = 1;
        else if (mode < 2) direction = 0;
        else direction = 2;
        inbound = (mode == 1 || mode == 3 || mode == 5 || mode == 7 || mode == 8);
        twoDirections = (mode == 2 || mode == 3 || mode == 6 || mode == 7);
    }
    bool init(EnterEffectObject* object, cocos2d::CCArray* objects);
    void onMode(cocos2d::CCObject* sender) = win 0x40da30;
    void onNextFreeEffectID(cocos2d::CCObject* sender);
    void onSpecialTarget(cocos2d::CCObject* sender) = win 0x40d730;
    void updateEnterTargetIDState() = win 0x40d7d0;

    cocos2d::CCArray* m_modeButtons;
    cocos2d::CCArray* m_targetButtons;
}

[[link(android)]]
class SetupAreaRotateTriggerPopup : SetupAreaMoveTriggerPopup {
    // virtual ~SetupAreaRotateTriggerPopup();
    SetupAreaRotateTriggerPopup() {}

    static SetupAreaRotateTriggerPopup* create(EnterEffectObject* object, cocos2d::CCArray* objects) = win inline {
        auto ret = new SetupAreaRotateTriggerPopup();
        if (ret->init(object, objects)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init(EnterEffectObject* object, cocos2d::CCArray* objects) = win 0x40e630;
}

[[link(android)]]
class SetupAreaTintTriggerPopup : SetupAreaMoveTriggerPopup, HSVWidgetDelegate {
    // virtual ~SetupAreaTintTriggerPopup();
    SetupAreaTintTriggerPopup() = win 0x40aba0 {
        m_hsvButton = nullptr;
        m_hsvChanged = false;
    }

    static SetupAreaTintTriggerPopup* create(EnterEffectObject* object, cocos2d::CCArray* objects) = win inline {
        auto ret = new SetupAreaTintTriggerPopup();
        if (ret->init(object, objects)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void determineStartValues() = win 0x410190;
    virtual void onClose(cocos2d::CCObject* sender) = win 0x4104a0;
    virtual void valueDidChange(int tag, float value) = win 0x40ffd0;
    virtual void hsvPopupClosed(HSVWidgetPopup* popup, cocos2d::ccHSVValue value) = win 0x4103b0;

    bool init(EnterEffectObject* object, cocos2d::CCArray* objects) = win 0x40f590;
    void onHSV(cocos2d::CCObject* sender);
    void updateHSVButton();

    CCMenuItemSpriteExtra* m_hsvButton;
    cocos2d::ccHSVValue m_hsvValue;
    bool m_hsvChanged;
}

[[link(android)]]
class SetupAreaTransformTriggerPopup : SetupAreaMoveTriggerPopup {
    // virtual ~SetupAreaTransformTriggerPopup();
    SetupAreaTransformTriggerPopup() {}

    static SetupAreaTransformTriggerPopup* create(EnterEffectObject* object, cocos2d::CCArray* objects) = win inline {
        auto ret = new SetupAreaTransformTriggerPopup();
        if (ret->init(object, objects)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init(EnterEffectObject* object, cocos2d::CCArray* objects) = win 0x40dd70;
}

[[link(android)]]
class SetupAreaTriggerPopup : SetupAreaMoveTriggerPopup {
    // virtual ~SetupAreaTriggerPopup();
    SetupAreaTriggerPopup() {}

    static SetupAreaTriggerPopup* create(EnterEffectObject* object, cocos2d::CCArray* objects) = win inline {
        auto ret = new SetupAreaTriggerPopup();
        if (ret->init(object, objects)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init(EnterEffectObject* object, cocos2d::CCArray* objects) = win 0x410550;
}

[[link(android)]]
class SetupArtSwitchPopup : SetupTriggerPopup, SelectArtDelegate {
    // virtual ~SetupArtSwitchPopup();

    static SetupArtSwitchPopup* create(ArtTriggerGameObject* object, cocos2d::CCArray* objects, int id) = win 0x471410;

    virtual void selectArtClosed(SelectArtLayer* layer) = win 0x4720d0;

    bool init(ArtTriggerGameObject* object, cocos2d::CCArray* objects, int id) = win 0x4716d0;
    void onArt(cocos2d::CCObject* sender) = win 0x472080;

    SelectArtType m_artType;
    cocos2d::CCSprite* m_artSprite;
}

[[link(android)]]
class SetupAudioLineGuidePopup : SetupTriggerPopup, SelectSettingDelegate {
    // virtual ~SetupAudioLineGuidePopup();
    SetupAudioLineGuidePopup() {
        m_speedSprite = nullptr;
    }

    static SetupAudioLineGuidePopup* create(AudioLineGuideGameObject* object, cocos2d::CCArray* objects) = win inline {
        auto ret = new SetupAudioLineGuidePopup();
        if (ret->init(object, objects)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void selectSettingClosed(SelectSettingLayer* layer) = win 0x4703a0;

    bool init(AudioLineGuideGameObject* object, cocos2d::CCArray* objects) = win 0x46fc40;
    void onSpeed(cocos2d::CCObject* sender) = win 0x470350;

    cocos2d::CCSprite* m_speedSprite;
}

[[link(android)]]
class SetupAudioTriggerPopup : SetupTriggerPopup {
    // virtual ~SetupAudioTriggerPopup();

    virtual void valueDidChange(int tag, float value) = win 0x446330;

    void addProxVolControls(int page) = win 0x445350;
    void addTimeControls(int page, float yOffset) = win 0x444f90;
    void onProxMode(cocos2d::CCObject* sender) = win 0x4461e0;
    void updateSpecialGroup() = win 0x4462b0;

    cocos2d::CCArray* m_proximityButtons;
}

[[link(android)]]
class SetupBGSpeedTrigger : SetupTriggerPopup {
    // virtual ~SetupBGSpeedTrigger();

    static SetupBGSpeedTrigger* create(EffectGameObject* object, cocos2d::CCArray* objects, int id) = win 0x428640;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects, int id) = win 0x428760;
}

[[link(android)]]
class SetupCameraEdgePopup : SetupTriggerPopup {
    // virtual ~SetupCameraEdgePopup();

    static SetupCameraEdgePopup* create(CameraTriggerGameObject* object, cocos2d::CCArray* objects);

    virtual void determineStartValues();
    virtual void onClose(cocos2d::CCObject* sender) = win 0x413b50;
    virtual void textChanged(CCTextInputNode* node);

    bool init(CameraTriggerGameObject* object, cocos2d::CCArray* objects) = win 0x412920;
    void onCameraEdge(cocos2d::CCObject* sender) = win 0x413760;
    void onTargetIDArrow(cocos2d::CCObject* sender);
    void onUnlockEdge(cocos2d::CCObject* sender) = win 0x413890;
    void updateTargetID();
    void updateTextInputLabel();

    CCTextInputNode* m_targetIDInput;
    int m_targetID;
    int m_edgeDirection;
    cocos2d::CCArray* m_directionToggles;
}

[[link(android)]]
class SetupCameraGuidePopup : SetupTriggerPopup {
    // virtual ~SetupCameraGuidePopup();

    static SetupCameraGuidePopup* create(CameraTriggerGameObject* object, cocos2d::CCArray* objects);

    bool init(CameraTriggerGameObject* object, cocos2d::CCArray* objects);
}

[[link(android)]]
class SetupCameraModePopup : SetupTriggerPopup {
    // virtual ~SetupCameraModePopup();

    static SetupCameraModePopup* create(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x413cb0;

    virtual void determineStartValues() = win 0x414880;
    virtual void onClose(cocos2d::CCObject* sender);

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x413dd0;
    void onEditCameraSettings(cocos2d::CCObject* sender) = win 0x414af0;
    void onUnboundMode(cocos2d::CCObject* sender) = win 0x414a40;
    void sliderChanged(cocos2d::CCObject* sender);
    void updateCameraEasing() = win 0x414d80;
    void updateCameraEasingLabel() = win 0x414d20;
    void updateCameraPadding();
    void updateCameraPaddingLabel();
    void updateItemVisibility() = win 0x414ba0;

    cocos2d::CCArray* m_freeModeObjects;
    cocos2d::CCArray* m_cameraSettingsObjects;
    Slider* m_cameraEasingSlider;
    cocos2d::CCLabelBMFont* m_cameraEasingLabel;
    int m_cameraEasing;
    Slider* m_cameraPaddingSlider;
    cocos2d::CCLabelBMFont* m_cameraPaddingLabel;
    float m_cameraPadding;
    bool m_freeMode;
    bool m_cameraSettingsEnabled;
    bool m_cameraModeObjects;
}

[[link(android)]]
class SetupCameraOffsetTrigger : SetupTriggerPopup {
    // virtual ~SetupCameraOffsetTrigger();

    static SetupCameraOffsetTrigger* create(CameraTriggerGameObject* object, cocos2d::CCArray* objects) = win 0x414fe0;

    virtual void determineStartValues() = win 0x416340;
    virtual void onClose(cocos2d::CCObject* sender);
    virtual void textChanged(CCTextInputNode* node) = win 0x417050;
    virtual void valuePopupClosed(ConfigureValuePopup* popup, float value) = win 0x416750;

    bool init(CameraTriggerGameObject* object, cocos2d::CCArray* objects) = win 0x415100;
    void onEasing(cocos2d::CCObject* sender) = win 0x416b10;
    void onEasingRate(cocos2d::CCObject* sender);
    void onTargetMode(cocos2d::CCObject* sender) = win 0x416f70;
    int posFromSliderValue(float value) = win inline, ios inline {
        return (int)((value - .5f) * 200.f) * 3.f;
    }
    void sliderChanged(cocos2d::CCObject* sender) = win 0x271b30;
    float sliderValueFromPos(int pos) = win inline, ios inline {
        return std::clamp((int)((float)pos / 3.f) / 200.f + .5f, 0.f, 1.f);
    }
    void sliderXChanged(cocos2d::CCObject* sender);
    void sliderYChanged(cocos2d::CCObject* sender);
    void toggleEasingRateVisibility();
    void updateDuration();
    void updateDurLabel(bool decimals) = win inline {
        m_disableTextDelegate = true;
        auto moveTime = m_moveTime;
        if (moveTime == -99999.f) {
            m_moveTimeInput->setString("Mixed");
        }
        else if (decimals || moveTime - (int)moveTime != 0.f) {
            m_moveTimeInput->setString(cocos2d::CCString::createWithFormat("%.02f", moveTime)->getCString());
        }
        else {
            m_moveTimeInput->setString(cocos2d::CCString::createWithFormat("%i", (int)moveTime)->getCString());
        }
        m_disableTextDelegate = false;
    }
    void updateEasingLabel();
    void updateEasingRateLabel();
    void updateMoveCommandEasing() = win inline {
        if (m_gameObject) m_gameObject->m_easingType = m_cameraEasingType;
        else {
            for (int i = 0; i < m_gameObjects->count(); i++) {
                static_cast<EffectGameObject*>(m_gameObjects->objectAtIndex(i))->m_easingType = m_cameraEasingType;
            }
        }
    }
    void updateMoveCommandEasingRate() = win inline {
        if (m_gameObject) m_gameObject->m_easingRate = m_cameraEasingRate;
        else {
            for (int i = 0; i < m_gameObjects->count(); i++) {
                static_cast<EffectGameObject*>(m_gameObjects->objectAtIndex(i))->m_easingRate = m_cameraEasingRate;
            }
        }
    }
    void updateMoveCommandPosX() = win 0x417400;
    void updateMoveCommandPosY();
    void updateValueXLabel();
    void updateValueYLabel();

    CCTextInputNode* m_moveTimeInput;
    Slider* m_moveTimeSlider;
    float m_moveTime;
    cocos2d::CCLabelBMFont* m_cameraEasingLabel;
    EasingType m_cameraEasingType;
    float m_cameraEasingRate;
    CCMenuItemSpriteExtra* m_cameraEasingRateButton;
    cocos2d::CCLabelBMFont* m_cameraEasingRateLabel;
    CCTextInputNode* m_offsetXInput;
    CCTextInputNode* m_offsetYInput;
    Slider* m_offsetXSlider;
    Slider* m_offsetYSlider;
    int m_offsetX;
    int m_offsetY;
    int m_targetMode;
    CCMenuItemToggler* m_xOnlyToggler;
    CCMenuItemToggler* m_yOnlyToggler;
}

[[link(android)]]
class SetupCameraRotatePopup : SetupTriggerPopup {
    // virtual ~SetupCameraRotatePopup();

    static SetupCameraRotatePopup* create(EffectGameObject* object, cocos2d::CCArray* objects);

    virtual void determineStartValues();
    virtual void onClose(cocos2d::CCObject* sender);
    virtual void textChanged(CCTextInputNode* node);
    virtual void valuePopupClosed(ConfigureValuePopup* popup, float value);

    bool init(EffectGameObject* object, cocos2d::CCArray* objects);
    void onEasing(cocos2d::CCObject* sender);
    void onEasingRate(cocos2d::CCObject* sender);
    void sliderChanged(cocos2d::CCObject* sender);
    void sliderDegreesChanged(cocos2d::CCObject* sender);
    void toggleEasingRateVisibility();
    void updateCommandDegrees();
    void updateDegreesLabel();
    void updateDuration();
    void updateDurLabel(bool decimals);
    void updateEasingLabel();
    void updateEasingRateLabel();
    void updateMoveCommandEasing();
    void updateMoveCommandEasingRate();

    CCTextInputNode* m_moveTimeInput;
    Slider* m_moveTimeSlider;
    float m_moveTime;
    cocos2d::CCLabelBMFont* m_cameraEasingLabel;
    EasingType m_cameraEasingType;
    float m_cameraEasingRate;
    CCMenuItemSpriteExtra* m_cameraEasingRateButton;
    cocos2d::CCLabelBMFont* m_cameraEasingRateLabel;
    CCTextInputNode* m_degreesInput;
    Slider* m_degreesSlider;
    float m_degrees;
}

[[link(android)]]
class SetupCameraRotatePopup2 : SetupTriggerPopup {
    // virtual ~SetupCameraRotatePopup2();

    static SetupCameraRotatePopup2* create(EffectGameObject* object, cocos2d::CCArray* objects);

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x417790;
}

[[link(android)]]
class SetupCheckpointPopup : SetupTriggerPopup {
    // virtual ~SetupCheckpointPopup();
    SetupCheckpointPopup() {}

    static SetupCheckpointPopup* create(CheckpointGameObject* object, cocos2d::CCArray* objects) = win inline {
        auto ret = new SetupCheckpointPopup();
        if (ret->init(object, objects)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init(CheckpointGameObject* object, cocos2d::CCArray* objects) = win 0x468c20;
}

[[link(android)]]
class SetupCoinLayer : SetupTriggerPopup {
    // virtual ~SetupCoinLayer();
    SetupCoinLayer() {}

    static SetupCoinLayer* create(EffectGameObject* object, cocos2d::CCArray* objects) = win inline {
        auto ret = new SetupCoinLayer();
        if (ret->init(object, objects)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x46f200;
}

[[link(android)]]
class SetupCollisionStateTriggerPopup : SetupInstantCollisionTriggerPopup {
    // virtual ~SetupCollisionStateTriggerPopup();
    SetupCollisionStateTriggerPopup() {}

    static SetupCollisionStateTriggerPopup* create(EffectGameObject* object, cocos2d::CCArray* objects) = win inline {
        auto ret = new SetupCollisionStateTriggerPopup();
        if (ret->init(object, objects)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x41a650;
}

[[link(android)]]
class SetupCollisionTriggerPopup : SetupTriggerPopup {
    // virtual ~SetupCollisionTriggerPopup();

    static SetupCollisionTriggerPopup* create(EffectGameObject* object, cocos2d::CCArray* objects);

    virtual void determineStartValues();
    virtual void onClose(cocos2d::CCObject* sender);
    virtual void textChanged(CCTextInputNode* node) = win 0x419420;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x417fc0;
    void onActivateOnExit(cocos2d::CCObject* sender);
    void onEnableGroup(cocos2d::CCObject* sender);
    void onItemID2Arrow(cocos2d::CCObject* sender) = win 0x419350;
    void onItemIDArrow(cocos2d::CCObject* sender) = win 0x419390;
    void onTargetIDArrow(cocos2d::CCObject* sender) = win 0x4193d0;
    void onTargetP1(cocos2d::CCObject* sender) = win 0x419050;
    void onTargetP2(cocos2d::CCObject* sender) = win 0x419110;
    void onTargetPP(cocos2d::CCObject* sender) = win 0x4191d0;
    void updateItemID();
    void updateItemID2();
    void updateItemID2InputLabel() = win 0x419770;
    void updateItemIDInputLabel() = win 0x4196a0;
    void updateTargetID();
    void updateTargetIDInputLabel();

    CCTextInputNode* m_blockAInput;
    CCTextInputNode* m_blockBInput;
    CCTextInputNode* m_targetIDInput;
    int m_blockAID;
    int m_blockBID;
    int m_targetID;
    bool m_activateGroup;
    bool m_triggerOnExit;
    bool m_targetP1;
    bool m_targetP2;
    bool m_targetPP;
}

[[link(android)]]
class SetupCountTriggerPopup : SetupTriggerPopup {
    // virtual ~SetupCountTriggerPopup();

    static SetupCountTriggerPopup* create(EffectGameObject* object, cocos2d::CCArray* objects);

    virtual void determineStartValues();
    virtual void onClose(cocos2d::CCObject* sender);
    virtual void textChanged(CCTextInputNode* node);

    bool init(EffectGameObject* object, cocos2d::CCArray* objects);
    void onEnableGroup(cocos2d::CCObject* sender);
    void onItemIDArrow(cocos2d::CCObject* sender) = win 0x41bf20;
    void onMultiActivate(cocos2d::CCObject* sender);
    void onTargetCountArrow(cocos2d::CCObject* sender) = win 0x41bee0;
    void onTargetIDArrow(cocos2d::CCObject* sender) = win 0x41bf70;
    void updateCountTextInputLabel();
    void updateItemID();
    void updateItemIDInputLabel();
    void updateTargetCount();
    void updateTargetID() = win 0x41c330;
    void updateTargetIDInputLabel();

    CCTextInputNode* m_itemIDInput;
    CCTextInputNode* m_targetIDInput;
    CCTextInputNode* m_targetCountInput;
    int m_itemID;
    int m_targetID;
    int m_targetCount;
    bool m_activateGroup;
    bool m_multiActivate;
}

[[link(android)]]
class SetupDashRingPopup : SetupTriggerPopup {
    // virtual ~SetupDashRingPopup();
    SetupDashRingPopup() {}

    static SetupDashRingPopup* create(DashRingObject* object, cocos2d::CCArray* objects) = win inline {
        auto ret = new SetupDashRingPopup();
        if (ret->init(object, objects)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init(DashRingObject* object, cocos2d::CCArray* objects);
}

[[link(android)]]
class SetupEndPopup : SetupTriggerPopup {
    // virtual ~SetupEndPopup();

    static SetupEndPopup* create(EffectGameObject* object, cocos2d::CCArray* objects);

    virtual void determineStartValues();
    virtual void onClose(cocos2d::CCObject* sender) = win 0x413b50;
    virtual void textInputClosed(CCTextInputNode* node);
    virtual void textChanged(CCTextInputNode* node);

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x41c850;
    void onLockY(cocos2d::CCObject* sender);
    void onMultiActivate(cocos2d::CCObject* sender) = win 0x41d320;
    void onReversed(cocos2d::CCObject* sender);
    void onTargetIDArrow(cocos2d::CCObject* sender);
    void updateTargetID();
    void updateTextInputLabel();

    CCTextInputNode* m_groupIDInput;
    bool m_reversed;
    bool m_lockY;
    int m_groupID;
    bool m_multiActivate;
}

[[link(android)]]
class SetupEnterEffectPopup : SetupTriggerPopup, HSVWidgetDelegate {
    // virtual ~SetupEnterEffectPopup();
    SetupEnterEffectPopup() {
        m_objectID = 0;
        m_enterOnlyToggler = nullptr;
        m_exitOnlyToggler = nullptr;
        m_enterType = 0;
        m_hsvButton = nullptr;
        m_hsvChanged = false;
    }

    static SetupEnterEffectPopup* create(EnterEffectObject* object, cocos2d::CCArray* objects, int id) = win inline {
        auto ret = new SetupEnterEffectPopup();
        if (ret->init(object, objects, id)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void determineStartValues() = win 0x41fee0;
    virtual void onClose(cocos2d::CCObject* sender) = win 0x420500;
    virtual void updateInputValue(int tag, float& value) = win 0x40dd40;
    virtual void updateInputNode(int tag, float value) = win 0x40dd10;
    virtual void valueDidChange(int tag, float value) = win 0x4200b0;
    virtual float triggerValueFromSliderValue(int tag, float value);
    virtual float triggerSliderValueFromValue(int tag, float value) = win 0x40dce0;
    virtual void hsvPopupClosed(HSVWidgetPopup* popup, cocos2d::ccHSVValue value) = win 0x420410;

    bool init(EnterEffectObject* object, cocos2d::CCArray* objects, int id) = win 0x41ded0;
    void onEnterType(cocos2d::CCObject* sender);
    void onHSV(cocos2d::CCObject* sender);
    void onNextFreeEnterChannel(cocos2d::CCObject* sender);
    void onNextFreeEnterEffectID(cocos2d::CCObject* sender);
    void updateHSVButton();

    int m_objectID;
    CCMenuItemToggler* m_enterOnlyToggler;
    CCMenuItemToggler* m_exitOnlyToggler;
    int m_enterType;
    CCMenuItemSpriteExtra* m_hsvButton;
    cocos2d::ccHSVValue m_hsvValue;
    bool m_hsvChanged;
}

[[link(android)]]
class SetupEnterTriggerPopup : SetupTriggerPopup {
    // virtual ~SetupEnterTriggerPopup();
    SetupEnterTriggerPopup() {
        m_enterOnlyToggler = nullptr;
        m_exitOnlyToggler = nullptr;
        m_enterType = 0;
    }

    static SetupEnterTriggerPopup* create(EnterEffectObject* object, cocos2d::CCArray* objects) = win inline {
        auto ret = new SetupEnterTriggerPopup();
        if (ret->init(object, objects)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void determineStartValues();

    bool init(EnterEffectObject* object, cocos2d::CCArray* objects) = win 0x28f0c0;
    void onEnterType(cocos2d::CCObject* sender);

    CCMenuItemToggler* m_enterOnlyToggler;
    CCMenuItemToggler* m_exitOnlyToggler;
    int m_enterType;
}

[[link(android)]]
class SetupEventLinkPopup : SetupTriggerPopup {
    // virtual ~SetupEventLinkPopup();

    static SetupEventLinkPopup* create(EventLinkTrigger* object, cocos2d::CCArray* objects);

    bool init(EventLinkTrigger* object, cocos2d::CCArray* objects) = win 0x465be0;
    void onSelectEvent(cocos2d::CCObject* sender) = win 0x466150;
    void updateEventIDs(gd::set<int>& eventIDs) = win inline {
        auto objects = m_gameObject ? cocos2d::CCArray::createWithObject(m_gameObject) : m_gameObjects;
        CCObject* obj;
        CCARRAY_FOREACH(objects, obj) {
            static_cast<EventLinkTrigger*>(obj)->m_eventIDs = eventIDs;
        }
    }
}

[[link(android)]]
class SetupForceBlockPopup : SetupTriggerPopup {
    // virtual ~SetupForceBlockPopup();

    static SetupForceBlockPopup* create(ForceBlockGameObject* object, cocos2d::CCArray* objects);

    virtual void valueDidChange(int tag, float value) = win 0x4713a0;

    bool init(ForceBlockGameObject* object, cocos2d::CCArray* objects);
}

[[link(android)]]
class SetupGameplayOffsetPopup : SetupTriggerPopup {
    // virtual ~SetupGameplayOffsetPopup();
    SetupGameplayOffsetPopup() {}

    static SetupGameplayOffsetPopup* create(EffectGameObject* object, cocos2d::CCArray* objects) = win inline {
        auto ret = new SetupGameplayOffsetPopup();
        if (ret->init(object, objects)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void updateInputValue(int tag, float& value) = win 0x4425d0;
    virtual void updateInputNode(int tag, float value);
    virtual float triggerValueFromSliderValue(int tag, float value);
    virtual float triggerSliderValueFromValue(int tag, float value);
    virtual void onCustomToggleTriggerValue(cocos2d::CCObject* sender) = win 0x4424b0;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x441cd0;
    void onDefaultValues(cocos2d::CCObject* sender) = win 0x442400;
}

[[link(android)]]
class SetupGradientPopup : SetupTriggerPopup {
    SetupGradientPopup() {
        m_blendingMode = 0;
        m_layerButtons = nullptr;
        m_blendingLayer = 0;
        m_gradientLabels = nullptr;
    }
    ~SetupGradientPopup() = win inline {
        CC_SAFE_RELEASE(m_layerButtons);
    }

    static SetupGradientPopup* create(GradientTriggerObject* object, cocos2d::CCArray* objects) = win inline {
        auto ret = new SetupGradientPopup();
        if (ret->init(object, objects)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void determineStartValues() = win 0x421810;
    virtual void onPlusButton(cocos2d::CCObject* sender);
    virtual void updateToggleItem(int value, bool toggled) = win 0x4219e0;
    virtual void valueDidChange(int tag, float value) = win 0x421df0;

    bool init(GradientTriggerObject* object, cocos2d::CCArray* objects) = win 0x4206b0;
    void onBlending(cocos2d::CCObject* sender) = win 0x421ca0;
    void onZLayer(cocos2d::CCObject* sender) = win 0x421b80;
    void sliderChanged(cocos2d::CCObject* sender) = win inline, ios inline {}
    void updateBlending() = win inline {
        if (m_gameObject) static_cast<GradientTriggerObject*>(m_gameObject)->m_blendingMode = m_blendingMode;
        else {
            for (int i = 0; i < m_gameObjects->count(); i++) {
                static_cast<GradientTriggerObject*>(m_gameObjects->objectAtIndex(i))->m_blendingMode = m_blendingMode;
            }
        }
    }
    void updateBlendingLabel() = win 0x421d60;
    void updateGradientLabels(bool vertex) = win 0x421a70;
    void updateZLayerButtons() = win 0x421c10;

    cocos2d::CCLabelBMFont* m_blendingLabel;
    int m_blendingMode;
    cocos2d::CCArray* m_layerButtons;
    int m_blendingLayer;
    cocos2d::CCArray* m_gradientLabels;
}

[[link(android)]]
class SetupGravityModPopup : FLAlertLayer, TextInputDelegate {
    // virtual ~SetupGravityModPopup();

    static SetupGravityModPopup* create(EffectGameObject* object, cocos2d::CCArray* objects, bool gravityTrigger);

    virtual void keyBackClicked();
    virtual void show();
    virtual void textInputClosed(CCTextInputNode* node);
    virtual void textChanged(CCTextInputNode* node);

    void determineStartValues();
    bool init(EffectGameObject* object, cocos2d::CCArray* objects, bool gravityTrigger);
    void onClose(cocos2d::CCObject* sender);
    void onItemIDArrow(cocos2d::CCObject* sender);
    void sliderChanged(cocos2d::CCObject* sender);
    void updateItemID();
    void updateTextInputLabel();
    void updateValue();
    void updateValueLabel();

    EffectGameObject* m_gameObject;
    cocos2d::CCArray* m_gameObjects;
    cocos2d::CCLabelBMFont* m_gravityModLabel;
    Slider* m_gravityModSlider;
    float m_gravityMod;
    bool m_gravityTrigger;
    float m_minValue;
    float m_maxValue;
    CCTextInputNode* m_itemIDInput;
    int m_itemID;
    bool m_disableDelegate;
}

[[link(android)]]
class SetupGravityTriggerPopup : SetupTriggerPopup {
    // virtual ~SetupGravityTriggerPopup();

    static SetupGravityTriggerPopup* create(EffectGameObject* object, cocos2d::CCArray* objects);

    virtual void valueDidChange(int tag, float value) = win 0x429360;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x428ee0;
}

[[link(android)]]
class SetupInstantCollisionTriggerPopup : SetupTriggerPopup {
    // virtual ~SetupInstantCollisionTriggerPopup();
    SetupInstantCollisionTriggerPopup() {}

    static SetupInstantCollisionTriggerPopup* create(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x419b40;

    virtual void updateDefaultTriggerValues();
    virtual void valueDidChange(int tag, float value) = win 0x41a2f0;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x419bd0;
    void updateSpecialNodes() = win 0x41a310;
}

[[link(android)]]
class SetupInstantCountPopup : SetupTriggerPopup {
    // virtual ~SetupInstantCountPopup();

    static SetupInstantCountPopup* create(CountTriggerGameObject* object, cocos2d::CCArray* objects) = win 0x421f00;

    virtual void determineStartValues();
    virtual void onClose(cocos2d::CCObject* sender);
    virtual void textChanged(CCTextInputNode* node);

    bool init(CountTriggerGameObject* object, cocos2d::CCArray* objects) = win 0x422040;
    void onCountType(cocos2d::CCObject* sender) = win 0x423470;
    void onEnableGroup(cocos2d::CCObject* sender);
    void onTargetCountArrow(cocos2d::CCObject* sender) = win 0x41bee0;
    void onTargetID2Arrow(cocos2d::CCObject* sender) = win 0x4230e0;
    void onTargetIDArrow(cocos2d::CCObject* sender) = win 0x41bf20;
    void updateCountTextInputLabel();
    void updateItemID();
    void updateItemIDInputLabel();
    void updateTargetCount();
    void updateTargetID();
    void updateTargetIDInputLabel();

    CCTextInputNode* m_itemIDInput;
    CCTextInputNode* m_targetIDInput;
    CCTextInputNode* m_targetCountInput;
    int m_itemID;
    int m_targetID;
    int m_targetCount;
    bool m_activateGroup;
    int m_mode;
    CCMenuItemToggler* m_equalsToggler;
    CCMenuItemToggler* m_largerToggler;
    CCMenuItemToggler* m_smallerToggler;
}

[[link(android)]]
class SetupInteractObjectPopup : SetupTriggerPopup {
    // virtual ~SetupInteractObjectPopup();

    static SetupInteractObjectPopup* create(EffectGameObject* object, cocos2d::CCArray* objects);

    virtual void onClose(cocos2d::CCObject* sender);
    virtual void onPlusButton(cocos2d::CCObject* sender);
    virtual void valueDidChange(int tag, float value) = win 0x424110;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x423730;
    void updateItems() = win 0x424090;
}

[[link(android)]]
class SetupItemCompareTriggerPopup : SetupTriggerPopup {
    // virtual ~SetupItemCompareTriggerPopup();

    static SetupItemCompareTriggerPopup* create(ItemTriggerGameObject* object, cocos2d::CCArray* objects);

    virtual void valueDidChange(int tag, float value) = win 0x46f1e0;
    virtual void onCustomToggleTriggerValue(cocos2d::CCObject* sender) = win 0x46e6d0;

    bool init(ItemTriggerGameObject* object, cocos2d::CCArray* objects) = win 0x46d030;
    void onOpButton(cocos2d::CCObject* sender) = win 0x46e300;
    void updateFormulaLabel() = win 0x46e8d0;
    void updateOpButton(CCMenuItemSpriteExtra* button, int key, int objectID) = win 0x46e3e0;

    cocos2d::CCLabelBMFont* m_formulaLabel;
}

[[link(android)]]
class SetupItemEditTriggerPopup : SetupTriggerPopup {
    // virtual ~SetupItemEditTriggerPopup();

    static SetupItemEditTriggerPopup* create(ItemTriggerGameObject* object, cocos2d::CCArray* objects);

    virtual void valueDidChange(int tag, float value) = win 0x46cee0;
    virtual void onCustomToggleTriggerValue(cocos2d::CCObject* sender) = win 0x46cc40;

    bool init(ItemTriggerGameObject* object, cocos2d::CCArray* objects) = win 0x46a7f0;
    void onOpButton(cocos2d::CCObject* sender) = win 0x46b9e0;
    void updateFormulaLabel() = win 0x46c0b0;
    void updateOpButton(CCMenuItemSpriteExtra* button, int key, int objectID) = win 0x46be50;

    cocos2d::CCLabelBMFont* m_formulaLabel;
}

[[link(android)]]
class SetupKeyframeAnimPopup : SetupTriggerPopup {
    // virtual ~SetupKeyframeAnimPopup();

    static SetupKeyframeAnimPopup* create(EffectGameObject* object, cocos2d::CCArray* objects);

    bool init(EffectGameObject* object, cocos2d::CCArray* objects);
}

[[link(android)]]
class SetupKeyframePopup : SetupTriggerPopup {
    // virtual ~SetupKeyframePopup();

    static SetupKeyframePopup* create(KeyframeGameObject* object, cocos2d::CCArray* objects, LevelEditorLayer* layer) = win 0x424eb0;

    virtual void onClose(cocos2d::CCObject* sender) = win 0x426b90;
    virtual void onCustomButton(cocos2d::CCObject* sender) = win 0x4263a0;
    virtual void valueDidChange(int tag, float value) = win 0x4262c0;
    virtual void onCustomToggleTriggerValue(cocos2d::CCObject* sender) = win 0x4262e0;

    bool init(KeyframeGameObject* object, cocos2d::CCArray* objects, LevelEditorLayer* layer) = win 0x424ff0;
    void onTimeMode(cocos2d::CCObject* sender) = win 0x426aa0;
    void refreshPreviewArt() = win 0x426800;
    void updateTimeModeButtons() = win 0x426b00;

    cocos2d::CCArray* m_timeModeToggles;
    LevelEditorLayer* m_editorLayer;
    bool m_groupIDChanged;
}

[[link(android)]]
class SetupMGTrigger : SetupTriggerPopup {
    // virtual ~SetupMGTrigger();

    static SetupMGTrigger* create(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x426df0;

    virtual void determineStartValues() = win 0x427ee0;
    virtual void onClose(cocos2d::CCObject* sender);
    virtual void textChanged(CCTextInputNode* node) = win 0x428240;
    virtual void valuePopupClosed(ConfigureValuePopup* popup, float value) = win 0x416750;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x426f10;
    void onEasing(cocos2d::CCObject* sender) = win 0x416b10;
    void onEasingRate(cocos2d::CCObject* sender);
    int posFromSliderValue(float value) = win inline, ios inline {
        return (int)((value - .5f) * 200.f) * 3.f;
    }
    void sliderChanged(cocos2d::CCObject* sender) = win 0x271b30;
    float sliderValueFromPos(int pos) = win inline, ios inline {
        return std::clamp((int)((float)pos / 3.f) / 200.f + .5f, 0.f, 1.f);
    }
    void sliderYChanged(cocos2d::CCObject* sender);
    void toggleEasingRateVisibility();
    void updateDuration();
    void updateDurLabel(bool decimals);
    void updateEasingLabel();
    void updateEasingRateLabel();
    void updateMoveCommandEasing() = win inline {
        if (m_gameObject) m_gameObject->m_easingType = m_mgEasingType;
        else {
            for (int i = 0; i < m_gameObjects->count(); i++) {
                static_cast<EffectGameObject*>(m_gameObjects->objectAtIndex(i))->m_easingType = m_mgEasingType;
            }
        }
    }
    void updateMoveCommandEasingRate() = win inline {
        if (m_gameObject) m_gameObject->m_easingRate = m_mgEasingRate;
        else {
            for (int i = 0; i < m_gameObjects->count(); i++) {
                static_cast<EffectGameObject*>(m_gameObjects->objectAtIndex(i))->m_easingRate = m_mgEasingRate;
            }
        }
    }
    void updateMoveCommandPosY();
    void updateValueYLabel();

    CCTextInputNode* m_moveTimeInput;
    Slider* m_moveTimeSlider;
    float m_moveTime;
    cocos2d::CCLabelBMFont* m_mgEasingLabel;
    EasingType m_mgEasingType;
    float m_mgEasingRate;
    CCMenuItemSpriteExtra* m_mgEasingRateButton;
    cocos2d::CCLabelBMFont* m_mgEasingRateLabel;
    CCTextInputNode* m_offsetYInput;
    Slider* m_offsetYSlider;
    int m_offsetY;
}

[[link(android)]]
class SetupMoveCommandPopup : SetupTriggerPopup {
    // virtual ~SetupMoveCommandPopup();

    static SetupMoveCommandPopup* create(EffectGameObject* object, cocos2d::CCArray* objects);

    virtual void updateInputValue(int tag, float& value) = win 0x281c60;
    virtual void updateInputNode(int tag, float value) = win 0x281c30;
    virtual void valueDidChange(int tag, float value) = win 0x281c90;
    virtual float triggerValueFromSliderValue(int tag, float value) = win 0x281b70;
    virtual float triggerSliderValueFromValue(int tag, float value) = win 0x281bc0;
    virtual void onCustomToggleTriggerValue(cocos2d::CCObject* sender) = win 0x282300;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x2807a0;
    void updateControlVisibility() = win 0x282140;

    bool m_smallStep;
}

[[link(android)]]
class SetupObjectControlPopup : SetupTriggerPopup {
    // virtual ~SetupObjectControlPopup();

    static SetupObjectControlPopup* create(ObjectControlGameObject* object, cocos2d::CCArray* objects);

    bool init(ObjectControlGameObject* object, cocos2d::CCArray* objects) = win 0x472bd0;
}

[[link(android)]]
class SetupObjectOptions2Popup : SetupTriggerPopup {
    // virtual ~SetupObjectOptions2Popup();
    SetupObjectOptions2Popup() {}

    static SetupObjectOptions2Popup* create(GameObject* object, cocos2d::CCArray* objects) = win inline {
        auto ret = new SetupObjectOptions2Popup();
        if (ret->init(object, objects)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void onPlusButton(cocos2d::CCObject* sender);

    bool init(GameObject* object, cocos2d::CCArray* objects);
}

[[link(android)]]
class SetupObjectOptionsPopup : FLAlertLayer, TextInputDelegate {
    SetupObjectOptionsPopup() {
        m_gameObject = nullptr;
        m_gameObjects = nullptr;
        m_iceBlock = false;
        m_dontFade = false;
        m_dontEnter = false;
        m_noEffects = false;
        m_noParticle = false;
        m_noTouch = false;
        m_passable = false;
        m_hide = false;
        m_nonStickX = false;
        m_nonStickY = false;
        m_extraSticky = false;
        m_dontBoostY = false;
        m_scaleStick = false;
        m_highDetail = false;
        m_groupParent = false;
        m_areaParent = false;
        m_gripSlope = false;
        m_noGlow = false;
        m_reverse = false;
        m_extendedCollision = false;
        m_unk2a6 = false;
        m_groupIDLayer = nullptr;
        m_effectObject = false;
        m_singlePlayerTouch = false;
    }
    ~SetupObjectOptionsPopup() = win inline {
        CC_SAFE_RELEASE(m_gameObject);
        CC_SAFE_RELEASE(m_gameObjects);
    }

    static SetupObjectOptionsPopup* create(GameObject* object, cocos2d::CCArray* objects, SetGroupIDLayer* layer) = win inline {
        auto ret = new SetupObjectOptionsPopup();
        if (ret->init(object, objects, layer)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyBackClicked();
    virtual void show() = win 0x8bb10;
    virtual void determineStartValues() = win 0x3ff5a0;
    virtual void onClose(cocos2d::CCObject* sender) = win 0x84690;

    bool init(GameObject* object, cocos2d::CCArray* objects, SetGroupIDLayer* layer) = win 0x3fdbc0;
    void onAlwaysHide(cocos2d::CCObject* sender);
    void onApplyScaleStick(cocos2d::CCObject* sender);
    void onCenterEffect(cocos2d::CCObject* sender);
    void onDisableGlow(cocos2d::CCObject* sender);
    void onDisableObject(cocos2d::CCObject* sender) = win 0x3ffb00;
    void onDontBoost(cocos2d::CCObject* sender);
    void onDontBoostX(cocos2d::CCObject* sender);
    void onDontEnter(cocos2d::CCObject* sender);
    void onDontFade(cocos2d::CCObject* sender);
    void onExtendedCollision(cocos2d::CCObject* sender) = win 0x400400;
    void onExtraSticky(cocos2d::CCObject* sender);
    void onGripSlope(cocos2d::CCObject* sender);
    void onHideEffects(cocos2d::CCObject* sender);
    void onHighDetail(cocos2d::CCObject* sender);
    void onIceBlock(cocos2d::CCObject* sender);
    void onNoAudioScale(cocos2d::CCObject* sender);
    void onNonStickX(cocos2d::CCObject* sender);
    void onNonStickY(cocos2d::CCObject* sender);
    void onNoParticle(cocos2d::CCObject* sender);
    void onPassable(cocos2d::CCObject* sender);
    void onReverse(cocos2d::CCObject* sender) = win 0x400530;
    void onSinglePlayerTouch(cocos2d::CCObject* sender);
    void onToggleAreaParent(cocos2d::CCObject* sender);
    void onToggleGroupParent(cocos2d::CCObject* sender);

    GameObject* m_gameObject;
    cocos2d::CCArray* m_gameObjects;
    bool m_iceBlock;
    bool m_dontFade;
    bool m_dontEnter;
    bool m_noEffects;
    bool m_noParticle;
    bool m_noTouch;
    bool m_passable;
    bool m_hide;
    bool m_nonStickX;
    bool m_nonStickY;
    bool m_extraSticky;
    bool m_dontBoostY;
    bool m_dontBoostX;
    bool m_noAudioScale;
    bool m_scaleStick;
    bool m_highDetail;
    bool m_groupParent;
    bool m_areaParent;
    bool m_gripSlope;
    bool m_noGlow;
    bool m_reverse;
    bool m_extendedCollision;
    bool m_unk2a6;
    SetGroupIDLayer* m_groupIDLayer;
    bool m_effectObject;
    bool m_singlePlayerTouch;
    bool m_centerEffect;
}

[[link(android)]]
class SetupObjectTogglePopup : SetupTriggerPopup {
    // virtual ~SetupObjectTogglePopup();

    static SetupObjectTogglePopup* create(EffectGameObject* object, cocos2d::CCArray* objects, bool platformer) = win 0x429580;

    virtual void onClose(cocos2d::CCObject* sender);
    virtual void valueDidChange(int tag, float value) = win 0x429ff0;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects, bool platformer) = win 0x4296a0;
}

[[link(android)]]
class SetupOpacityPopup : SetupTriggerPopup {
    // virtual ~SetupOpacityPopup();

    static SetupOpacityPopup* create(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x42a140;

    virtual void determineStartValues();
    virtual void onClose(cocos2d::CCObject* sender);
    virtual void textInputClosed(CCTextInputNode* node);
    virtual void textChanged(CCTextInputNode* node) = win 0x42b460;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x42a270;
    void onTargetIDArrow(cocos2d::CCObject* sender) = win 0x42b200;
    void sliderChanged(cocos2d::CCObject* sender);
    void updateDuration();
    void updateDurLabel(bool decimals);
    void updateOpacity() = win inline {
        if (m_gameObject) m_gameObject->m_opacity = m_opacity;
        else {
            for (int i = 0; i < m_gameObjects->count(); i++) {
                static_cast<EffectGameObject*>(m_gameObjects->objectAtIndex(i))->m_opacity = m_opacity;
            }
        }
    }
    void updateOpacityLabel();
    void updateTargetID();
    void updateTextInputLabel();

    CCTextInputNode* m_groupIDInput;
    CCTextInputNode* m_fadeTimeInput;
    cocos2d::CCLabelBMFont* m_opacityLabel;
    Slider* m_fadeTimeSlider;
    Slider* m_opacitySlider;
    float m_opacity;
    float m_fadeTime;
    int m_groupID;
}

[[link(android)]]
class SetupOptionsTriggerPopup : SetupTriggerPopup {
    // virtual ~SetupOptionsTriggerPopup();
    SetupOptionsTriggerPopup() {
        m_togglePage = 0;
    }

    static SetupOptionsTriggerPopup* create(GameOptionsTrigger* object, cocos2d::CCArray* objects) = win inline {
        auto ret = new SetupOptionsTriggerPopup();
        if (ret->init(object, objects)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void onCustomToggleTriggerValue(cocos2d::CCObject* sender) = win 0x4365d0;

    void addOption(int property, gd::string label) = win 0x436370;
    bool init(GameOptionsTrigger* object, cocos2d::CCArray* objects) = win 0x435b70;

    cocos2d::CCPoint m_togglePosition;
    int m_togglePage;
}

[[link(android)]]
class SetupPersistentItemTriggerPopup : SetupTriggerPopup {
    // virtual ~SetupPersistentItemTriggerPopup();

    static SetupPersistentItemTriggerPopup* create(ItemTriggerGameObject* object, cocos2d::CCArray* objects);

    bool init(ItemTriggerGameObject* object, cocos2d::CCArray* objects) = win 0x46f6a0;
}

[[link(android)]]
class SetupPickupTriggerPopup : SetupTriggerPopup {
    // virtual ~SetupPickupTriggerPopup();

    static SetupPickupTriggerPopup* create(EffectGameObject* object, cocos2d::CCArray* objects);

    virtual void onPlusButton(cocos2d::CCObject* sender);
    virtual void onCustomToggleTriggerValue(cocos2d::CCObject* sender) = win 0x436ff0;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x4367b0;
    void updateState() = win 0x436f80, ios inline {
        auto pickupTriggerMode = this->getValue(88);
        this->toggleGroup(1, pickupTriggerMode == 0.0f);
        this->toggleGroup(2, pickupTriggerMode != 0.0f);
    }
}

[[link(android)]]
class SetupPlatformerEndPopup : SetupTriggerPopup {
    // virtual ~SetupPlatformerEndPopup();

    static SetupPlatformerEndPopup* create(EndTriggerGameObject* object, cocos2d::CCArray* objects);

    bool init(EndTriggerGameObject* object, cocos2d::CCArray* objects) = win 0x41d810;
}

[[link(android)]]
class SetupPlayerControlPopup : SetupTriggerPopup {
    // virtual ~SetupPlayerControlPopup();

    static SetupPlayerControlPopup* create(PlayerControlGameObject* object, cocos2d::CCArray* objects);

    bool init(PlayerControlGameObject* object, cocos2d::CCArray* objects) = win 0x467a30;
}

[[link(android)]]
class SetupPortalPopup : FLAlertLayer, TextInputDelegate {
    // virtual ~SetupPortalPopup();

    static SetupPortalPopup* create(EffectGameObject* object, cocos2d::CCArray* objects);

    virtual void keyBackClicked();

    void determineStartValues();
    bool init(EffectGameObject* object, cocos2d::CCArray* objects);
    void onClose(cocos2d::CCObject* sender);
    void onEditCameraSettings(cocos2d::CCObject* sender);
    void onUnboundMode(cocos2d::CCObject* sender);
    void sliderChanged(cocos2d::CCObject* sender);
    void updateCameraEasing();
    void updateCameraEasingLabel();
    void updateCameraPadding();
    void updateCameraPaddingLabel();
    void updateItemVisibility();

    EffectGameObject* m_gameObject;
    cocos2d::CCArray* m_gameObjects;
    cocos2d::CCArray* m_freeModeObjects;
    cocos2d::CCArray* m_cameraSettingsObjects;
    Slider* m_cameraEasingSlider;
    cocos2d::CCLabelBMFont* m_cameraEasingLabel;
    int m_cameraEasing;
    Slider* m_cameraPaddingSlider;
    cocos2d::CCLabelBMFont* m_cameraPaddingLabel;
    float m_cameraPadding;
    bool m_freeMode;
    bool m_cameraSettingsEnabled;
    bool m_disableDelegate;
}

[[link(android)]]
class SetupPulsePopup : SetupTriggerPopup, cocos2d::extension::ColorPickerDelegate, GJSpecialColorSelectDelegate {
    // virtual ~SetupPulsePopup();

    static SetupPulsePopup* create(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x4371b0;

    virtual void show();
    virtual void determineStartValues() = win 0x43ae50;
    virtual void onClose(cocos2d::CCObject* sender) = win 0x43bc10;
    virtual void textChanged(CCTextInputNode* node) = win 0x43c0b0;
    virtual void colorValueChanged(cocos2d::ccColor3B color) = win 0x43bdf0;
    virtual void textInputOpened(CCTextInputNode* node) = win inline {}
    virtual void colorSelectClosed(GJSpecialColorSelect* select, int id) = win 0x43b680;

    cocos2d::ccColor3B getColorValue() = win inline, ios inline {
        return m_colorPicker->getColorValue();
    }
    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x3a7730;
    void onCopy(cocos2d::CCObject* sender) = win 0x90e40;
    void onExclusive(cocos2d::CCObject* sender);
    void onGroupMainOnly(cocos2d::CCObject* sender) = win 0x43b370;
    void onGroupSecondaryOnly(cocos2d::CCObject* sender) = win 0x43b460;
    void onHSVLegacyMode(cocos2d::CCObject* sender);
    void onPaste(cocos2d::CCObject* sender) = win 0x90ec0;
    void onSelectPulseMode(cocos2d::CCObject* sender) = win 0x43aa00;
    void onSelectSpecialColor(cocos2d::CCObject* sender);
    void onSelectSpecialTargetID(cocos2d::CCObject* sender);
    void onSelectTargetMode(cocos2d::CCObject* sender) = win 0x43ac30;
    void onUpdateCopyColor(cocos2d::CCObject* sender) = win 0x43c040;
    void onUpdateCustomColor(cocos2d::CCObject* sender) = win 0x43bfb0;
    void selectColor(cocos2d::ccColor3B color) = win inline, ios inline {
        m_colorPicker->setColorValue(color);
    }
    void sliderChanged(cocos2d::CCObject* sender) = win 0x43b820;
    void updateColorLabels();
    void updateColorValue() = win inline {
        if (m_colorInitializing) return;
        if (m_gameObject) {
            m_gameObject->m_triggerTargetColor = m_currentColor;
        }
        else if (m_gameObjects) {
            for (int i = 0; i < m_gameObjects->count(); i++) {
                static_cast<EffectGameObject*>(m_gameObjects->objectAtIndex(i))->m_triggerTargetColor = m_currentColor;
            }
        }
    }
    void updateCopyColor();
    void updateCopyColorTextInputLabel();
    void updateFadeInLabel(bool decimals);
    void updateFadeInTime();
    void updateFadeOutLabel(bool decimals);
    void updateFadeOutTime();
    void updateGroupMainOnly();
    void updateGroupSecondaryOnly();
    void updateHoldLabel(bool decimals);
    void updateHoldTime();
    void updateHSVValue() = win inline {
        if (m_gameObject) {
            m_gameObject->m_hsvValue = m_hsv;
        }
        else if (m_gameObjects) {
            for (int i = 0; i < m_gameObjects->count(); i++) {
                static_cast<EffectGameObject*>(m_gameObjects->objectAtIndex(i))->m_hsvValue = m_hsv;
            }
        }
    }
    void updatePulseMode() = win inline {
        if (m_gameObject) {
            m_gameObject->m_pulseMode = m_pulseMode;
        }
        else if (m_gameObjects) {
            for (int i = 0; i < m_gameObjects->count(); i++) {
                static_cast<EffectGameObject*>(m_gameObjects->objectAtIndex(i))->m_pulseMode = m_pulseMode;
            }
        }
    }
    void updatePulseTargetType() = win inline {
        if (m_gameObject) {
            m_gameObject->m_pulseTargetType = m_pulseTargetType;
        }
        else if (m_gameObjects) {
            for (int i = 0; i < m_gameObjects->count(); i++) {
                static_cast<EffectGameObject*>(m_gameObjects->objectAtIndex(i))->m_pulseTargetType = m_pulseTargetType;
            }
        }
    }
    void updateTargetID() = win 0x43ca30;
    void updateTextInputLabel() = win 0x43cb80;

    cocos2d::extension::CCControlColourPicker* m_colorPicker;
    bool m_unk3c0;
    cocos2d::CCArray* m_colorObjects;
    cocos2d::CCArray* m_hsvObjects;
    Slider* m_fadeInSlider;
    Slider* m_holdSlider;
    Slider* m_fadeOutSlider;
    CCMenuItemSpriteExtra* m_channelButton;
    CCMenuItemSpriteExtra* m_groupButton;
    cocos2d::CCLabelBMFont* m_idLabel;
    cocos2d::ccColor3B m_originalColor;
    cocos2d::CCSprite* m_currentColorSprite;
    cocos2d::CCSprite* m_originalColorSprite;
    cocos2d::ccColor3B m_currentColor;
    CCMenuItemSpriteExtra* m_colorButton;
    CCMenuItemSpriteExtra* m_hsvButton;
    ConfigureHSVWidget* m_hsvWidget;
    CCMenuItemSpriteExtra* m_specialColorButton;
    CCTextInputNode* m_fadeInInput;
    CCTextInputNode* m_holdInput;
    CCTextInputNode* m_fadeOutInput;
    CCTextInputNode* m_idInput;
    CCTextInputNode* m_colorIDInput;
    CCMenuItemToggler* m_mainOnlyToggler;
    CCMenuItemToggler* m_secondaryOnlyToggler;
    CCMenuItemToggler* m_staticHSVToggler;
    cocos2d::CCLabelBMFont* m_mainOnlyLabel;
    cocos2d::CCLabelBMFont* m_secondaryOnlyLabel;
    cocos2d::CCLabelBMFont* m_staticHSVLabel;
    bool m_groupMainOnly;
    bool m_groupSecondaryOnly;
    bool m_staticHSV;
    int m_targetGroupID;
    int m_copyColorID;
    bool m_colorInitializing;
    float m_fadeInTime;
    float m_holdTime;
    float m_fadeOutTime;
    int m_pulseMode;
    int m_pulseTargetType;
    bool m_modesInitializing;
    bool m_pulseExclusive;
    cocos2d::ccHSVValue m_hsv;
    CCTextInputNode* m_rInput;
    CCTextInputNode* m_gInput;
    CCTextInputNode* m_bInput;
    CCTextInputNode* m_hexInput;
}

[[link(android)]]
class SetupRandAdvTriggerPopup : SetupTriggerPopup {
    // virtual ~SetupRandAdvTriggerPopup();

    static SetupRandAdvTriggerPopup* create(RandTriggerGameObject* object, cocos2d::CCArray* objects);

    virtual void onClose(cocos2d::CCObject* sender) = win 0x43da70;
    virtual void textChanged(CCTextInputNode* node) = win inline {}

    void addChance(int id, int chance) = win inline {
        m_performedAction = true;
        if (m_gameObject) {
            this->addChanceToObject(static_cast<RandTriggerGameObject*>(m_gameObject), id, chance);
        }
        else if (m_gameObjects) {
            for (int i = 0; i < m_gameObjects->count(); i++) {
                this->addChanceToObject(static_cast<RandTriggerGameObject*>(m_gameObjects->objectAtIndex(i)), id, chance);
            }
        }
        this->updateGroupIDButtons();
    }
    void addChanceToObject(RandTriggerGameObject* object, int id, int chance) = win inline {
        for (auto& object : object->m_chanceObjects) {
            if (object.m_groupID == id) {
                object.m_chance += chance;
                return;
            }
        }
        object->m_chanceObjects.emplace_back(id, chance);
    }
    void callRemoveFromGroup(float dt) = win 0x43e4b0;
    bool init(RandTriggerGameObject* object, cocos2d::CCArray* objects) = win 0x43cff0;
    void onAddChance(cocos2d::CCObject* sender) = win 0x43e6f0;
    void onRemoveFromGroup(cocos2d::CCObject* sender);
    void removeGroupID(int id) = win inline {
        m_performedAction = true;
        if (m_gameObject) {
            this->removeGroupIDFromObject(static_cast<RandTriggerGameObject*>(m_gameObject), id);
        }
        else if (m_gameObjects) {
            for (int i = 0; i < m_gameObjects->count(); i++) {
                this->removeGroupIDFromObject(static_cast<RandTriggerGameObject*>(m_gameObjects->objectAtIndex(i)), id);
            }
        }
        this->updateGroupIDButtons();
    }
    void removeGroupIDFromObject(RandTriggerGameObject* object, int id) = win inline {
        for (int i = 0; i < object->m_chanceObjects.size(); i++) {
            if (object->m_chanceObjects[i].m_groupID == id) {
                object->m_chanceObjects.erase(object->m_chanceObjects.begin() + i);
                return;
            }
        }
    }
    void updateGroupIDButtons() = win 0x43db30;

    bool m_performedAction;
    cocos2d::CCArray* m_groupButtons;
    CCTextInputNode* m_groupIDInput;
    CCTextInputNode* m_chanceInput;
    int m_groupToRemove;
    bool m_removingGroup;
}

[[link(android)]]
class SetupRandTriggerPopup : SetupTriggerPopup {
    // virtual ~SetupRandTriggerPopup();

    static SetupRandTriggerPopup* create(EffectGameObject* object, cocos2d::CCArray* objects);

    virtual void determineStartValues();
    virtual void onClose(cocos2d::CCObject* sender);
    virtual void textChanged(CCTextInputNode* node) = win 0x440840;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x3bfb20;
    void onTargetID2Arrow(cocos2d::CCObject* sender) = win 0x4407f0;
    void onTargetIDArrow(cocos2d::CCObject* sender) = win 0x4407a0;
    void sliderChanged(cocos2d::CCObject* sender);
    void updateChance();
    void updateChanceLabel(bool decimals);
    void updateTargetID();
    void updateTargetID2();
    void updateTextInputLabel();
    void updateTextInputLabel2();

    CCTextInputNode* m_chanceInput;
    Slider* m_chanceSlider;
    float m_chancePercent;
    CCTextInputNode* m_groupID1Input;
    CCTextInputNode* m_groupID2Input;
    int m_groupID1;
    int m_groupID2;
}

[[link(android)]]
class SetupResetTriggerPopup : SetupTriggerPopup {
    // virtual ~SetupResetTriggerPopup();

    static SetupResetTriggerPopup* create(EffectGameObject* object, cocos2d::CCArray* objects);

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x46a3e0;
}

[[link(android)]]
class SetupReverbPopup : SetupTriggerPopup {
    // virtual ~SetupReverbPopup();
    SetupReverbPopup() {}

    static SetupReverbPopup* create(SFXTriggerGameObject* object, cocos2d::CCArray* objects) = win inline {
        auto ret = new SetupReverbPopup();
        if (ret->init(object, objects)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void onClose(cocos2d::CCObject* sender) = win 0x446d40;

    bool init(SFXTriggerGameObject* object, cocos2d::CCArray* objects) = win 0x4464b0;
    void onPlay(cocos2d::CCObject* sender) = win 0x446a70;
    void onReverb(cocos2d::CCObject* sender) = win 0x446b60;
    void updateReverbLabel() = win 0x446bf0;

    cocos2d::CCLabelBMFont* m_reverbLabel;
}

[[link(android)]]
class SetupRotateCommandPopup : SetupTriggerPopup {
    // virtual ~SetupRotateCommandPopup();

    static SetupRotateCommandPopup* create(EffectGameObject* object, cocos2d::CCArray* objects);

    virtual void updateInputNode(int tag, float value);
    virtual void valueDidChange(int tag, float value) = win 0x2a8dd0;
    virtual float triggerValueFromSliderValue(int tag, float value) = win 0x2a8d80;
    virtual float triggerSliderValueFromValue(int tag, float value);
    virtual void onCustomToggleTriggerValue(cocos2d::CCObject* sender) = win 0xc3e50;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x2a7bf0;
    void onInfiniteDuration(cocos2d::CCObject* sender) = win 0x2a9130;
    void updateControlVisibility() = win 0x2a9050;
}

[[link(android)]]
class SetupRotateGameplayPopup : SetupTriggerPopup {
    // virtual ~SetupRotateGameplayPopup();
    SetupRotateGameplayPopup() {}

    static SetupRotateGameplayPopup* create(RotateGameplayGameObject* object, cocos2d::CCArray* objects) = win inline {
        auto ret = new SetupRotateGameplayPopup();
        if (ret->init(object, objects)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void onPlusButton(cocos2d::CCObject* sender);
    virtual void valueDidChange(int tag, float value) = win 0x441c60;

    bool init(RotateGameplayGameObject* object, cocos2d::CCArray* objects) = win 0x4411e0;
}

[[link(android)]]
class SetupRotatePopup : SetupTriggerPopup {
    // virtual ~SetupRotatePopup();

    static SetupRotatePopup* create(EnhancedGameObject* object, cocos2d::CCArray* objects);

    virtual void onClose(cocos2d::CCObject* sender) = win 0x442c70;
    virtual void onCustomToggleTriggerValue(cocos2d::CCObject* sender) = win 0x442d10;

    bool init(EnhancedGameObject* object, cocos2d::CCArray* objects) = win 0x442710;
}

[[link(android)]]
class SetupSequenceTriggerPopup : SetupTriggerPopup {
    // virtual ~SetupSequenceTriggerPopup();

    static SetupSequenceTriggerPopup* create(SequenceTriggerGameObject* object) = win 0x442fa0;

    virtual void onCustomToggleTriggerValue(cocos2d::CCObject* sender) = win 0x4442e0;

    bool init(SequenceTriggerGameObject* object) = win 0x4430d0;
    void onAddChance(cocos2d::CCObject* sender) = win 0x444930;
    void onChangeOrder(cocos2d::CCObject* sender) = win 0x444a70;
    void onDeleteSelected(cocos2d::CCObject* sender) = win 0x444b50;
    void onSelect(cocos2d::CCObject* sender) = win 0x4448b0;
    void updateGroupIDButtons() = win 0x4443d0;

    CCMenuItemSpriteExtra* m_selectedButton;
    bool m_unk3b0;
    bool m_unk3b1;
    cocos2d::CCArray* m_groupButtons;
    int m_unk3c0;
    bool m_unk3c4;
}

[[link(android)]]
class SetupSFXEditPopup : SetupAudioTriggerPopup {
    // virtual ~SetupSFXEditPopup();

    static SetupSFXEditPopup* create(SFXTriggerGameObject* object, cocos2d::CCArray* objects, bool songTrigger) = win 0x4490a0;

    bool init(SFXTriggerGameObject* object, cocos2d::CCArray* objects, bool songTrigger) = win 0x4491c0;
}

[[link(android)]]
class SetupSFXPopup : SetupAudioTriggerPopup, CustomSFXDelegate, SFXBrowserDelegate {
    // virtual ~SetupSFXPopup();

    static SetupSFXPopup* create(SFXTriggerGameObject* object, cocos2d::CCArray* objects) = win 0x446db0;

    virtual void pageChanged();
    virtual void onClose(cocos2d::CCObject* sender) = win 0x4481d0;
    virtual void onPlusButton(cocos2d::CCObject* sender);
    virtual void valueDidChange(int tag, float value) = win 0x448980;
    virtual void sfxObjectSelected(SFXInfoObject* object) = win inline {}
    virtual int getActiveSFXID();
    virtual bool overridePlaySFX(SFXInfoObject* object) = win 0x4488d0;
    virtual void sfxBrowserClosed(SFXBrowser* browser) = win 0x449080;

    void createSFXWidget() = win 0x448590;
    bool init(SFXTriggerGameObject* object, cocos2d::CCArray* objects) = win 0x446f00;
    void onBrowseSFX(cocos2d::CCObject* sender) = win 0x448ea0;
    void updateLength() = win 0x448510;

    int m_sfxID;
    CustomSFXWidget* m_sfxWidget;
    int m_sfxLength;
}

[[link(android)]]
class SetupShaderEffectPopup : SetupTriggerPopup {
    SetupShaderEffectPopup() {
        m_zLayerSprites = nullptr;
        m_zLayerMin = 0;
        m_zLayerMax = 0;
        m_changeMin = false;
        m_objectID = 0;
    }
    ~SetupShaderEffectPopup() = win inline {
        CC_SAFE_RELEASE(m_zLayerSprites);
    }

    static SetupShaderEffectPopup* create(EffectGameObject* object, cocos2d::CCArray* objects, int id) = win inline {
        auto ret = new SetupShaderEffectPopup();
        if (ret->init(object, objects, id)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void toggleGroup(int group, bool visible) = win 0x454680;
    virtual void onClose(cocos2d::CCObject* sender);
    virtual void updateDefaultTriggerValues();
    virtual void valueDidChange(int tag, float value) = win 0x454250;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects, int id) = win 0x449f50;
    void onResetColors(cocos2d::CCObject* sender) = win 0x453bb0;
    void onZLayer(cocos2d::CCObject* sender) = win 0x44ad30;
    void setupBulge() = win 0x450e30;
    void setupChromatic() = win 0x44da60;
    void setupChromaticGlitch() = win 0x44dfe0;
    void setupColorChange() = win 0x4534e0;
    void setupGlitch() = win 0x44d3e0;
    void setupGrayscale() = win 0x4522f0;
    void setupHueShift() = win 0x453190;
    void setupInvertColor() = win 0x452b20;
    void setupLensCircle() = win 0x44ef30;
    void setupMotionBlur() = win 0x4502c0;
    void setupPinch() = win 0x451700;
    void setupPixelate() = win 0x44e890;
    void setupRadialBlur() = win 0x44f880;
    void setupSepia() = win 0x4527f0;
    void setupShaderTrigger() = win 0x44a330;
    void setupShockLine() = win 0x44c1e0;
    void setupShockWave() = win 0x44aed0;
    void setupSplitScreen() = win 0x453d70;
    void updateZLayerButtons() = win 0x44ae20;
    gd::string zLayerToString(int zLayer) = win 0x44aa50;

    cocos2d::CCArray* m_zLayerSprites;
    int m_zLayerMin;
    int m_zLayerMax;
    bool m_changeMin;
    int m_objectID;
}

[[link(android)]]
class SetupShakePopup : SetupTriggerPopup {
    // virtual ~SetupShakePopup();

    static SetupShakePopup* create(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x454880;

    virtual void determineStartValues() = win 0x455700;
    virtual void onClose(cocos2d::CCObject* sender) = win 0x456150;
    virtual void textChanged(CCTextInputNode* node) = win 0x455d90;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x3f8270;
    void sliderChanged(cocos2d::CCObject* sender);
    void updateDuration();
    void updateDurLabel(bool decimals);
    void updateInterval();
    void updateIntervalLabel(bool decimals);
    void updateShake();
    void updateShakeLabel(bool decimals);

    CCTextInputNode* m_durationInput;
    Slider* m_durationSlider;
    float m_duration;
    CCTextInputNode* m_strengthInput;
    Slider* m_strengthSlider;
    float m_strength;
    CCTextInputNode* m_intervalInput;
    Slider* m_intervalSlider;
    float m_interval;
}

[[link(android)]]
class SetupSmartBlockLayer : FLAlertLayer, TextInputDelegate, SelectArtDelegate {
    // virtual ~SetupSmartBlockLayer();

    static SetupSmartBlockLayer* create(SmartGameObject* object, cocos2d::CCArray* objects) = win 0x456560;

    virtual void keyBackClicked() = win 0x458700;
    virtual void show() = win 0x8bb10;
    virtual void selectArtClosed(SelectArtLayer* layer) = win 0x4586c0;

    void determineStartValues() = win inline {
        if (auto smartTemplate = GameLevelManager::sharedState()->m_smartTemplate) {
            m_allowRotation = smartTemplate->m_allowRotation;
            m_allowFlipX = smartTemplate->m_allowFlipX;
            m_allowFlipY = smartTemplate->m_allowFlipY;
            m_ignoreCorners = smartTemplate->m_ignoreCorners;
        }
        auto gameManager = GameManager::sharedState();
        m_useNearby = gameManager->getGameVariable("0131");
        m_dontDelete = gameManager->getGameVariable("0132");
        if (m_gameObject) {
            m_referenceOnly = m_gameObject->m_referenceOnly;
        }
        else {
            m_referenceOnly = true;
            for (int i = 0; i < m_gameObjects->count(); i++) {
                auto obj = static_cast<SmartGameObject*>(m_gameObjects->objectAtIndex(i));
                if (!obj->m_referenceOnly) m_referenceOnly = false;
            }
        }
    }
    bool init(SmartGameObject* object, cocos2d::CCArray* objects) = win 0x4566a0;
    void onAllowFlipping(cocos2d::CCObject* sender) = win 0x457780;
    void onAllowRotation(cocos2d::CCObject* sender);
    void onClose(cocos2d::CCObject* sender) = win 0x458060;
    void onCreate(cocos2d::CCObject* sender) = win 0x458120;
    void onCreateAll(cocos2d::CCObject* sender) = win 0x457db0;
    void onCreateTemplate(cocos2d::CCObject* sender) = win 0x458550;
    void onDontDelete(cocos2d::CCObject* sender);
    void onIgnoreCorners(cocos2d::CCObject* sender);
    void onNearbyReference(cocos2d::CCObject* sender);
    void onPasteTemplate(cocos2d::CCObject* sender) = win 0x4579b0;
    void onReferenceOnly(cocos2d::CCObject* sender);
    void onSelectPremade(cocos2d::CCObject* sender) = win 0x458650;
    void onSelectTemplate(cocos2d::CCObject* sender) = win 0x4586d0;

    bool m_referenceOnly;
    bool m_allowRotation;
    bool m_allowFlipX;
    bool m_allowFlipY;
    bool m_useNearby;
    bool m_dontDelete;
    bool m_ignoreCorners;
    int m_specialTemplate;
    SmartGameObject* m_gameObject;
    cocos2d::CCArray* m_gameObjects;
}

[[link(android)]]
class SetupSmartTemplateLayer : FLAlertLayer, TextInputDelegate, FLAlertLayerProtocol {
    // virtual ~SetupSmartTemplateLayer();

    static SetupSmartTemplateLayer* create(GJSmartTemplate* smartTemplate) = win 0x458710;

    virtual void keyBackClicked() = win 0x459970;
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x4593d0;
    virtual void textInputOpened(CCTextInputNode* node) = win 0x459710;
    virtual void textInputClosed(CCTextInputNode* node) = win 0x4594b0;
    virtual void textChanged(CCTextInputNode* node) = win 0xc3e50;

    bool init(GJSmartTemplate* smartTemplate) = win 0x458820;
    void onBack(cocos2d::CCObject* sender) = win 0x459870;
    void onClick(cocos2d::CCObject* sender) = win 0x459210;
    void onClose(cocos2d::CCObject* sender) = win 0x4598a0;

    GJSmartTemplate* m_smartTemplate;
    CCTextInputNode* m_nameInput;
    cocos2d::CCNode* m_unk298;
}

[[link(android)]]
class SetupSongTriggerPopup : SetupAudioTriggerPopup, MusicDownloadDelegate, SongPlaybackDelegate {
    // virtual ~SetupSongTriggerPopup();

    static SetupSongTriggerPopup* create(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x45c4a0;

    virtual void pageChanged();
    virtual void onClose(cocos2d::CCObject* sender) = win 0x45d9c0;
    virtual void valueDidChange(int tag, float value) = win 0x45d7f0;
    virtual void onPlayback(SongInfoObject* object) = win 0x45d2c0;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x45c5e0;
    void onResetSongTime(cocos2d::CCObject* sender) = win inline, ios inline {
        this->updateValue(408, 0.f);
    }
    void onSavePlaybackPos(cocos2d::CCObject* sender) = win 0x45d660;
    void updateApplyPrepare(bool hideAll) = win inline {
        if (hideAll) this->hideAll();
        else this->goToPage(0, false);
        this->toggleGroup(2, true);
    }
    void updateLength() = win 0x45d230;
    void updateSongTimeSlider() = win inline {
        if (m_selectNode->m_selectedSongID <= 0) return;
        auto engine = FMODAudioEngine::sharedEngine();
        engine->loadMusic(MusicDownloadManager::sharedState()->pathForSong(m_selectNode->m_selectedSongID));
        auto musicLength = engine->getMusicLengthMS(0);
        if (musicLength != 0) {
            this->setMaxSliderValue(musicLength, 408);
            this->setMaxSliderValue(musicLength, 410);
            this->updateSlider(408);
            this->updateSlider(410);
        }
    }

    SongSelectNode* m_selectNode;
}

[[link(android)]]
class SetupSpawnParticlePopup : SetupTriggerPopup {
    // virtual ~SetupSpawnParticlePopup();

    static SetupSpawnParticlePopup* create(EffectGameObject* object, cocos2d::CCArray* objects);

    bool init(EffectGameObject* object, cocos2d::CCArray* objects);
}

[[link(android)]]
class SetupSpawnPopup : SetupTriggerPopup {
    // virtual ~SetupSpawnPopup();

    static SetupSpawnPopup* create(EffectGameObject* object, cocos2d::CCArray* objects);

    virtual void onClose(cocos2d::CCObject* sender);

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x45dd50;
    void onAddRemap(cocos2d::CCObject* sender);
    void onDeleteRemap(cocos2d::CCObject* sender) = win 0x45ec80;
    void onSelectRemap(cocos2d::CCObject* sender) = win 0x45f6e0;
    void queueUpdateButtons() = win 0x45f7b0;
    void updateRemapButtons(float dt) = win 0x45eec0;

    bool m_isBusy;
    cocos2d::CCArray* m_remapButtons;
    gd::vector<int> m_remapGroups;
    int m_remapOriginalID;
    int m_remapNewID;
}

[[link(android)]]
class SetupStaticCameraPopup : SetupTriggerPopup {
    // virtual ~SetupStaticCameraPopup();

    static SetupStaticCameraPopup* create(CameraTriggerGameObject* object, cocos2d::CCArray* objects);

    virtual void valueDidChange(int tag, float value) = win 0x460330;
    virtual void onCustomToggleTriggerValue(cocos2d::CCObject* sender) = win 0x4424b0;

    bool init(CameraTriggerGameObject* object, cocos2d::CCArray* objects) = win 0x45f930;
    void updateState() = win 0x460350;
}

[[link(android)]]
class SetupStopTriggerPopup : SetupTriggerPopup {
    // virtual ~SetupStopTriggerPopup();

    static SetupStopTriggerPopup* create(EffectGameObject* object, cocos2d::CCArray* objects);

    virtual void onClose(cocos2d::CCObject* sender) = win 0x472a20;
    virtual void onCustomToggleTriggerValue(cocos2d::CCObject* sender) = win 0x472970;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x472290;
}

[[link(android)]]
class SetupTeleportPopup : SetupTriggerPopup {
    // virtual ~SetupTeleportPopup();

    static SetupTeleportPopup* create(TeleportPortalObject* object, cocos2d::CCArray* objects, int id, bool platformer) = win 0x4604c0;

    virtual void determineStartValues();
    virtual void updateDefaultTriggerValues();
    virtual void valueDidChange(int tag, float value) = win 0x461790;

    bool init(TeleportPortalObject* object, cocos2d::CCArray* objects, int id, bool platformer) = win 0x2f70e0;
    void onTeleportGravity(cocos2d::CCObject* sender) = win 0x461890;
    void updateTeleportGravityState(int state) = win 0x461920;

    cocos2d::CCArray* m_teleportGravityToggles;
}

[[link(android)]]
class SetupTimerControlTriggerPopup : SetupTriggerPopup {
    // virtual ~SetupTimerControlTriggerPopup();

    static SetupTimerControlTriggerPopup* create(TimerTriggerGameObject* object, cocos2d::CCArray* objects);

    virtual void onCustomToggleTriggerValue(cocos2d::CCObject* sender) = win 0x462e80;

    bool init(TimerTriggerGameObject* object, cocos2d::CCArray* objects) = win 0x462aa0;
}

[[link(android)]]
class SetupTimerEventTriggerPopup : SetupTriggerPopup {
    // virtual ~SetupTimerEventTriggerPopup();

    static SetupTimerEventTriggerPopup* create(TimerTriggerGameObject* object, cocos2d::CCArray* objects);

    bool init(TimerTriggerGameObject* object, cocos2d::CCArray* objects) = win 0x462440;
}

[[link(android)]]
class SetupTimerTriggerPopup : SetupTriggerPopup {
    // virtual ~SetupTimerTriggerPopup();

    static SetupTimerTriggerPopup* create(TimerTriggerGameObject* object, cocos2d::CCArray* objects);

    bool init(TimerTriggerGameObject* object, cocos2d::CCArray* objects) = win 0x461ac0;
}

[[link(android)]]
class SetupTimeWarpPopup : SetupTriggerPopup {
    // virtual ~SetupTimeWarpPopup();

    static SetupTimeWarpPopup* create(EffectGameObject* object, cocos2d::CCArray* objects);

    virtual void determineStartValues() = win 0x463560;
    virtual void onClose(cocos2d::CCObject* sender);

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x4630f0;
    void sliderChanged(cocos2d::CCObject* sender) = win 0x463670;
    void updateTimeWarp() = win inline {
        if (m_gameObject) m_gameObject->m_timeWarpTimeMod = m_timeWarpMod;
        else if (m_gameObjects) {
            for (int i = 0; i < m_gameObjects->count(); i++) {
                static_cast<EffectGameObject*>(m_gameObjects->objectAtIndex(i))->m_timeWarpTimeMod = m_timeWarpMod;
            }
        }
    }
    void updateTimeWarpLabel();

    cocos2d::CCLabelBMFont* m_timeWarpLabel;
    Slider* m_timeWarpSlider;
    float m_timeWarpMod;
}

[[link(android)]]
class SetupTouchTogglePopup : SetupTriggerPopup {
    // virtual ~SetupTouchTogglePopup();

    static SetupTouchTogglePopup* create(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x463880;

    virtual void determineStartValues();
    virtual void onClose(cocos2d::CCObject* sender) = win 0x464b20;
    virtual void textChanged(CCTextInputNode* node) = win 0x464a00;

    bool init(EffectGameObject* object, cocos2d::CCArray* objects) = win 0x4639c0;
    void onControlMode(cocos2d::CCObject* sender) = win 0x464940;
    void onDualTouchMode(cocos2d::CCObject* sender);
    void onHoldMode(cocos2d::CCObject* sender);
    void onTargetIDArrow(cocos2d::CCObject* sender);
    void onTouchMode(cocos2d::CCObject* sender) = win 0x464870;
    void updateTargetID();
    void updateTextInputLabel();

    CCTextInputNode* m_groupIDInput;
    int m_groupID;
    bool m_holdMode;
    int m_toggleMode;
    int m_playerMode;
    CCMenuItemToggler* m_toggleOnToggler;
    CCMenuItemToggler* m_toggleOffToggler;
    bool m_dualMode;
    CCMenuItemToggler* m_p1OnlyToggler;
    CCMenuItemToggler* m_p2OnlyToggler;
}

[[link(android)]]
class SetupTransformPopup : SetupTriggerPopup {
    // virtual ~SetupTransformPopup();

    static SetupTransformPopup* create(TransformTriggerGameObject* object, cocos2d::CCArray* objects);

    bool init(TransformTriggerGameObject* object, cocos2d::CCArray* objects) = win 0x464cd0;
}

[[link(android)]]
class SetupTriggerPopup : FLAlertLayer, TextInputDelegate, ConfigureValuePopupDelegate, SliderDelegate {
    SetupTriggerPopup() {
        m_gameObject = nullptr;
        m_gameObjects = nullptr;
        m_touchTriggered = false;
        m_spawnTriggered = false;
        m_touchToggle = nullptr;
        m_spawnToggle = nullptr;
        m_multiTriggerContainer = nullptr;
        m_multiTriggered = false;
        m_width = 0.f;
        m_height = 0.f;
        m_disableTextDelegate = false;
        m_valueToggles = nullptr;
        m_inputNodes = nullptr;
        m_valueControls = nullptr;
        m_customValueToggles = nullptr;
        m_disableButtons = nullptr;
        m_easingLabel = nullptr;
        m_easingRateLabel = nullptr;
        m_easingRateButton = nullptr;
        m_easingType = EasingType::None;
        m_easingRate = 0.f;
        m_inputLabels = nullptr;
        m_triggerValues = nullptr;
        m_minSliderValues = nullptr;
        m_maxSliderValues = nullptr;
        m_disableSliderDelegate = false;
        m_effectObjects = false;
        m_pageContainers = nullptr;
        m_page = 0;
        m_easingControlScale = 1.f;
        m_groupContainers = nullptr;
        m_customEasingTags = nullptr;
        m_customEasingLabels = nullptr;
        m_customEasingButtons = nullptr;
        m_customEasingScales = nullptr;
        m_disabledEasingButtons = nullptr;
        m_prevButton = nullptr;
        m_nextButton = nullptr;
        m_hideAll = false;
    }
    ~SetupTriggerPopup() = win 0x473710;

    static SetupTriggerPopup* create(float width, float height) = win inline, ios inline {
        return SetupTriggerPopup::create(nullptr, nullptr, width, height, 1);
    }
    static SetupTriggerPopup* create(EffectGameObject* trigger, cocos2d::CCArray* triggers, float width, float height, int background) = win inline, ios inline {
        auto ret = new SetupTriggerPopup();
        if (ret->init(trigger, triggers, width, height, background)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event);
    virtual void keyBackClicked();
    virtual void show() = win 0x8bb10;
    virtual void pageChanged() {}
    virtual void toggleGroup(int group, bool visible) = win 0x474340;
    virtual void determineStartValues() = win 0x475090;
    virtual void onClose(cocos2d::CCObject* sender) = win 0x4756d0;
    virtual void textInputClosed(CCTextInputNode* node);
    virtual void textChanged(CCTextInputNode* node) = win 0x475510;
    virtual void textInputShouldOffset(CCTextInputNode* node, float yOffset) = win 0x7b620;
    virtual void textInputReturn(CCTextInputNode* node) = win 0x7b680;
    virtual void updateInputValue(int tag, float& value) {}
    virtual void sliderBegan(Slider* slider) = win 0x475810;
    virtual void sliderEnded(Slider* slider) = win 0x4758e0;
    virtual void onPlusButton(cocos2d::CCObject* sender) {}
    virtual void onCustomButton(cocos2d::CCObject* sender) {}
    virtual void updateDefaultTriggerValues() = win 0x4774c0;
    virtual void updateInputNode(int tag, float value) = win 0x4779b0;
    virtual void updateToggleItem(int value, bool toggled) = win 0x477d50;
    virtual void valueDidChange(int tag, float value) {}
    virtual float getValue(int tag) = win 0x477dc0;
    virtual float triggerValueFromSliderValue(int tag, float value) = win 0x47bdb0;
    virtual float triggerSliderValueFromValue(int tag, float value) = win 0x47be40;
    virtual void onCustomToggleTriggerValue(cocos2d::CCObject* sender) {}
    virtual void valuePopupClosed(ConfigureValuePopup* popup, float value) = win 0x47cd60;

    void addCloseButton(gd::string text) = win 0x4745c0;
    void addHelpButton(gd::string title, gd::string desc, float scale) = win 0x4746d0;
    void addInfoLabel(gd::string text, float scale, cocos2d::CCPoint position, int page, int group) = win 0x476ec0;
    void addObjectsToGroup(cocos2d::CCArray* objects, int group) = win inline {
        this->getGroupContainer(group)->addObjectsFromArray(objects);
    }
    void addObjectsToPage(cocos2d::CCArray* objects, int page) = win inline {
        this->getPageContainer(page)->addObjectsFromArray(objects);
    }
    void addObjectToGroup(cocos2d::CCObject* object, int group) = win inline {
        this->getGroupContainer(group)->addObject(object);
    }
    void addObjectToPage(cocos2d::CCObject* object, int page) = win 0x474430;
    void addTitle(gd::string title) = win 0x4744c0;
    void closeInputNodes() = win inline, ios inline {
        cocos2d::CCDictElement* element;
        cocos2d::CCDictElement* temp;
        HASH_ITER(hh, m_inputNodes->m_pElements, element, temp) {
            auto inputNode = static_cast<CCTextInputNode*>(element->getObject());
            inputNode->m_delegate = nullptr;
            inputNode->onClickTrackNode(false);
        }
    }
    void createCustomButton(int tag, gd::string text, gd::string frame, cocos2d::CCPoint position, float buttonScale, float labelScale, bool vertical, int page, int group) = win 0x477140;
    void createCustomEasingControls(gd::string text, cocos2d::CCPoint position, float scale, int typeProperty, int rateProperty, int page, int group) = win 0x47ce20;
    cocos2d::CCArray* createCustomToggleValueControl(int property, bool toggled, bool notClickable, gd::string text, cocos2d::CCPoint position, bool vertical, int page, int group) = win 0x476c40;
    void createEasingControls(cocos2d::CCPoint position, float scale, int page, int group) = win 0x47bef0;
    void createMultiTriggerItems(cocos2d::CCPoint touchPos, cocos2d::CCPoint spawnPos, cocos2d::CCPoint multiPos) = win 0x474d80;
    void createMultiTriggerItemsCorner() = win 0x474a70;
    void createMultiTriggerItemsDefault() = win 0x474960;
    void createMultiTriggerItemsDefaultHorizontal() = win 0x474c70;
    void createMultiTriggerItemsDefaultVertical() = win 0x474b70;
    void createPageButtons(float offset, int arrow) = win 0x473cb0;
    CCMenuItemSpriteExtra* createPlusButton(int tag, cocos2d::CCPoint position, float scale, gd::string frame, int page, int group) = win 0x476fa0;
    CCMenuItemToggler* createToggleButton(gd::string text, cocos2d::SEL_MenuHandler selector, bool toggled, cocos2d::CCPoint position) = win 0x474830;
    cocos2d::CCArray* createToggleValueControl(int property, gd::string label, cocos2d::CCPoint position, bool vertical, int page, int group, float scale) = win 0x476930;
    cocos2d::CCArray* createToggleValueControlAdvanced(int property, gd::string label, cocos2d::CCPoint position, bool vertical, int page, int group, float buttonScale, float labelScale, float labelWidth, cocos2d::CCPoint offset) = win inline {
        auto pageContainer = this->getPageContainer(page);
        auto groupContainer = this->getGroupContainer(group);
        auto nodes = cocos2d::CCArray::create();
        auto toggle = GameToolbox::createToggleButton(
            label, menu_selector(SetupTriggerPopup::onToggleTriggerValue), false, m_buttonMenu, position,
            this, m_mainLayer, buttonScale, labelScale, labelWidth, offset, "bigFont.fnt", vertical, 0, nodes
        );
        toggle->setTag(property);
        toggle->m_notClickable = true;
        m_valueToggles->setObject(toggle, property);
        pageContainer->addObjectsFromArray(nodes);
        if (group > 0) groupContainer->addObjectsFromArray(nodes);
        return nodes;
    }
    void createValueControl(int property, gd::string label, cocos2d::CCPoint position, float scale, float sliderMin, float sliderMax) = win 0x475b70;
    cocos2d::CCArray* createValueControlAdvanced(int property, gd::string label, cocos2d::CCPoint position, float scale, bool noSlider, InputValueType valueType, int length, bool arrows, float sliderMin, float sliderMax, int page, int group, GJInputStyle inputStyle, int decimalPlaces, bool allowDisable) = win 0x475c60;
    void createValueControlWArrows(int property, gd::string label, cocos2d::CCPoint position, float scale) = win inline, ios inline {
        this->createValueControlAdvanced(property, label, position, scale, true, InputValueType::Int, 6, true, 0.f, 0.f, 0, 0, GJInputStyle::GoldLabel, 2, false);
    }
    cocos2d::CCArray* getGroupContainer(int group);
    float getMaxSliderValue(int property) = win inline, ios inline {
        if (auto value = static_cast<cocos2d::CCFloat*>(m_maxSliderValues->objectForKey(property))) {
            return value->getValue();
        }
        return 1.f;
    }
    float getMinSliderValue(int property) = win inline, ios inline {
        if (auto value = static_cast<cocos2d::CCFloat*>(m_minSliderValues->objectForKey(property))) {
            return value->getValue();
        }
        return 0.f;
    }
    cocos2d::CCArray* getObjects() = win inline {
        if (m_gameObject) {
            auto arr = cocos2d::CCArray::create();
            arr->addObject(m_gameObject);
            return arr;
        }
        return m_gameObjects;
    }
    cocos2d::CCArray* getPageContainer(int page);
    float getTriggerValue(int property, GameObject* object) = win 0x47a240;
    float getTruncatedValue(float value, int decimals) = win 0x4778a0, ios inline {
        if (decimals < 1) return value;
        auto exponent = decimals > 1 ? powf(10.f, decimals) : 10.f;
        return roundf(value * exponent) / exponent;
    }
    float getTruncatedValueByTag(int tag, float value) = win inline {
        if (auto inputNode = static_cast<CCTextInputNode*>(m_inputNodes->objectForKey(tag))) {
            return this->getTruncatedValue(value, inputNode->m_decimalPlaces);
        }
        return value;
    }
    void goToPage(int page, bool hideAll) = win 0x474040;
    void hideAll() = win inline {
        this->goToPage(0, true);
    }
    bool init(EffectGameObject* trigger, cocos2d::CCArray* triggers, float width, float height, int background) = win 0x473930;
    void onCustomEaseArrow(int property, bool up) = win 0x47d700;
    void onCustomEaseArrowDown(cocos2d::CCObject* sender) = win 0x47d6d0;
    void onCustomEaseArrowUp(cocos2d::CCObject* sender) = win 0x47d6a0;
    void onCustomEaseRate(cocos2d::CCObject* sender);
    void onDisableValue(cocos2d::CCObject* sender) = win 0x476820;
    void onEase(cocos2d::CCObject* sender) = win 0x47cc10;
    void onEaseRate(cocos2d::CCObject* sender);
    void onMultiTrigger(cocos2d::CCObject* sender);
    void onPage(cocos2d::CCObject* sender) = win 0x473f60;
    void onSpawnedByTrigger(cocos2d::CCObject* sender) = win 0x475300;
    void onToggleTriggerValue(cocos2d::CCObject* sender) = win 0x477810;
    void onTouchTriggered(cocos2d::CCObject* sender) = win 0x475210;
    void postSetup() = win inline {
        this->updateDefaultTriggerValues();
        m_disableTextDelegate = false;
    }
    void preSetup() = win inline {
        m_disableTextDelegate = true;
        this->determineStartValues();
    }
    void refreshGroupVisibility() = win inline {
        for (int i = 0; i < m_groupContainers->count(); i++) {
            auto groupContainer = static_cast<cocos2d::CCArray*>(m_groupContainers->objectAtIndex(i));
            auto tag = groupContainer->getTag();
            for (int j = 0; j < groupContainer->count(); j++) {
                auto node = static_cast<cocos2d::CCNode*>(groupContainer->objectAtIndex(j));
                if (node->isVisible() && tag == 0) node->setVisible(false);
            }
        }
    }
    void removeObjectFromGroup(cocos2d::CCObject* object, int group) = win inline, ios inline {
        this->getGroupContainer(group)->removeObject(object);
    }
    void removeObjectFromPage(cocos2d::CCObject* object, int page) = win inline {
        this->getPageContainer(page)->removeObject(object);
    }
    void resetDisabledValues() = win inline {
        cocos2d::CCDictElement* element;
        cocos2d::CCDictElement* temp;
        HASH_ITER(hh, m_inputNodes->m_pElements, element, temp) {
            auto property = element->getObject()->getTag();
            if (this->getValue(property) == -909190.f) this->updateValue(property, 0.f);
        }
    }
    void setMaxSliderValue(float value, int property) = win inline {
        m_maxSliderValues->setObject(cocos2d::CCFloat::create(value), property);
    }
    void setMinSliderValue(float value, int property) = win inline, ios inline {
        m_minSliderValues->setObject(cocos2d::CCFloat::create(value), property);
    }
    bool shouldLimitValue(int property) = win inline, ios inline {
        return m_shouldLimitValues[property];
    }
    void toggleBG(bool visible) = win inline {
        if (auto background = m_mainLayer->getChildByTag(1)) background->setVisible(visible);
    }
    void toggleCustomEaseRateVisibility(int property, int tag) = win 0x47da80;
    void toggleDisableButtons(bool visible) = win 0x476850;
    void toggleEaseRateVisibility();
    void toggleLimitValue(int property, bool limit) = win inline {
        m_shouldLimitValues[property] = limit;
    }
    void togglePageArrows(bool visible) = win inline {
        if (m_prevButton) {
            m_prevButton->setVisible(visible);
            m_prevButton->setEnabled(visible);
            m_nextButton->setVisible(visible);
            m_nextButton->setEnabled(visible);
        }
    }
    void triggerArrowChanged(int property, bool isRight) = win 0x475ad0;
    void triggerArrowLeft(cocos2d::CCObject* sender) = win 0x475a70;
    void triggerArrowRight(cocos2d::CCObject* sender) = win 0x475aa0;
    void triggerSliderChanged(cocos2d::CCObject* sender) = win 0x4759b0;
    void updateCustomEaseLabel(int property, int easingType) = win 0x47d7a0;
    void updateCustomEaseRateLabel(int property, float easingRate) = win 0x47d970;
    void updateCustomToggleTrigger(int tag, bool toggled) = win inline {
        if (auto toggle = static_cast<CCMenuItemToggler*>(m_customValueToggles->objectForKey(tag))) {
            toggle->toggle(toggled);
        }
    }
    void updateEaseLabel();
    void updateEaseRateLabel();
    void updateEditorLabel();
    void updateInputNodeLabel(int property, gd::string text) = win 0x47bd30;
    void updateLabel(int property, gd::string text) = win inline, ios inline {
        if (auto label = static_cast<cocos2d::CCLabelBMFont*>(m_inputLabels->objectForKey(property))) {
            label->setString(text.c_str());
        }
    }
    void updateMultiTriggerBtn() = win 0x4753f0;
    void updateSlider(int property) = win 0x477ce0;
    void updateSlider(int property, float value) = win inline {
        if (auto slider = static_cast<Slider*>(m_valueControls->objectForKey(property))) slider->setValue(value);
    }
    void updateSpawnedByTrigger() = win 0x475350;
    void updateTouchTriggered() = win 0x475260;
    void updateValue(int property, float value) = win 0x47bca0;
    void updateValueControls(int property, float value) = win 0x477910;
    void valueChanged(int property, float value) = win 0x45eb40;

    EffectGameObject* m_gameObject;
    cocos2d::CCArray* m_gameObjects;
    bool m_touchTriggered;
    bool m_spawnTriggered;
    CCMenuItemToggler* m_touchToggle;
    CCMenuItemToggler* m_spawnToggle;
    cocos2d::CCArray* m_multiTriggerContainer;
    bool m_multiTriggered;
    float m_width;
    float m_height;
    bool m_disableTextDelegate;
    cocos2d::CCDictionary* m_valueToggles;
    cocos2d::CCDictionary* m_inputNodes;
    cocos2d::CCDictionary* m_valueControls;
    cocos2d::CCDictionary* m_customValueToggles;
    cocos2d::CCDictionary* m_disableButtons;
    cocos2d::CCLabelBMFont* m_easingLabel;
    cocos2d::CCLabelBMFont* m_easingRateLabel;
    CCMenuItemSpriteExtra* m_easingRateButton;
    EasingType m_easingType;
    float m_easingRate;
    cocos2d::CCDictionary* m_inputLabels;
    cocos2d::CCDictionary* m_triggerValues;
    cocos2d::CCDictionary* m_minSliderValues;
    cocos2d::CCDictionary* m_maxSliderValues;
    gd::map<int, bool> m_shouldLimitValues;
    bool m_disableSliderDelegate;
    bool m_effectObjects;
    cocos2d::CCArray* m_pageContainers;
    int m_page;
    float m_easingControlScale;
    cocos2d::CCArray* m_groupContainers;
    cocos2d::CCDictionary* m_customEasingTags;
    cocos2d::CCDictionary* m_customEasingLabels;
    cocos2d::CCDictionary* m_customEasingButtons;
    cocos2d::CCDictionary* m_customEasingScales;
    cocos2d::CCDictionary* m_disabledEasingButtons;
    CCMenuItemSpriteExtra* m_prevButton;
    CCMenuItemSpriteExtra* m_nextButton;
    bool m_hideAll;
}

[[link(android)]]
class SetupZoomTriggerPopup : SetupTriggerPopup {
    // virtual ~SetupZoomTriggerPopup();

    static SetupZoomTriggerPopup* create(EffectGameObject* object, cocos2d::CCArray* objects);

    virtual void determineStartValues();
    virtual void onClose(cocos2d::CCObject* sender);

    bool init(EffectGameObject* object, cocos2d::CCArray* objects);
}

[[link(android)]]
class SFXBrowser : FLAlertLayer, MusicDownloadDelegate, TableViewCellDelegate, SetTextPopupDelegate, SelectSFXSortDelegate {
    SFXBrowser() {
        m_searchResult = nullptr;
        m_sfxObjects = nullptr;
        m_listLayer = nullptr;
        m_nameLabel = nullptr;
        m_pathLabel = nullptr;
        m_infoLabel = nullptr;
        m_pageLabel = nullptr;
        m_searchLabel = nullptr;
        m_prevButton = nullptr;
        m_refreshButton = nullptr;
        m_clearSearchButton = nullptr;
        m_circleSprite = nullptr;
        m_libraryVersion = 0;
        m_cellAmount = 0;
        m_gettingURL = false;
        m_selectedCell = false;
        m_snapToSelected = false;
        m_compactMode = false;
        m_sortType = AudioSortType::NameAscending;
        m_delegate = nullptr;
        m_autoUpdating = false;
    }
    ~SFXBrowser() = win inline {
        MusicDownloadManager::sharedState()->removeMusicDownloadDelegate(this);
        CC_SAFE_RELEASE(m_sfxObjects);
        CC_SAFE_RELEASE(m_searchResult);
    }

    static SFXBrowser* create(int id) = win inline {
        auto ret = new SFXBrowser();
        if (ret->init(id)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void registerWithTouchDispatcher() = win 0x42660;
    virtual void keyBackClicked();
    virtual void musicActionFinished(GJMusicAction action);
    virtual void musicActionFailed(GJMusicAction action) = win 0x47f570;
    virtual void sortSelectClosed(SelectSFXSortLayer* layer) = win 0x480090;
    virtual void setTextPopupClosed(SetTextPopup* popup, gd::string text);
    virtual bool cellPerformedAction(TableViewCell* cell, int listType, CellAction action, cocos2d::CCNode* parent) = win 0x480410;
    virtual int getSelectedCellIdx();
    virtual bool shouldSnapToSelected();

    bool init(int id) = win 0x47e320;
    void onClearSearch(cocos2d::CCObject* sender);
    void onClose(cocos2d::CCObject* sender);
    void onCredits(cocos2d::CCObject* sender);
    void onExitFolder(cocos2d::CCObject* sender) = win 0x4807d0;
    void onPage(cocos2d::CCObject* sender) = win 0x480530;
    void onSearch(cocos2d::CCObject* sender) = win 0x480200;
    void onSorting(cocos2d::CCObject* sender) = win 0x47ff50;
    void onToggleCompactMode(cocos2d::CCObject* sender) = win 0x4800f0;
    void onUpdateLibrary(cocos2d::CCObject* sender);
    void setupList(SFXSearchResult* result) = win 0x47f6b0;
    void setupSFXBrowser();
    void trySetupSFXBrowser();
    void updatePageLabel() = win 0x480600;

    SFXSearchResult* m_searchResult;
    cocos2d::CCArray* m_sfxObjects;
    GJCommentListLayer* m_listLayer;
    cocos2d::CCLabelBMFont* m_nameLabel;
    cocos2d::CCLabelBMFont* m_pathLabel;
    cocos2d::CCLabelBMFont* m_infoLabel;
    cocos2d::CCLabelBMFont* m_pageLabel;
    cocos2d::CCLabelBMFont* m_searchLabel;
    CCMenuItemSpriteExtra* m_prevButton;
    CCMenuItemSpriteExtra* m_nextButton;
    CCMenuItemSpriteExtra* m_backButton;
    CCMenuItemSpriteExtra* m_refreshButton;
    CCMenuItemSpriteExtra* m_clearSearchButton;
    LoadingCircleSprite* m_circleSprite;
    int m_sfxID;
    int m_libraryVersion;
    int m_cellAmount;
    bool m_gettingURL;
    bool m_selectedCell;
    bool m_snapToSelected;
    bool m_compactMode;
    AudioSortType m_sortType;
    SFXBrowserDelegate* m_delegate;
    bool m_autoUpdating;
}

[[link(android)]]
class SFXBrowserDelegate {
    virtual void sfxBrowserClosed(SFXBrowser* browser) {}
}

[[link(android)]]
class SFXFolderObject : SFXInfoObject {
    SFXFolderObject() {
        m_sfxObjects = nullptr;
    }
    ~SFXFolderObject() = win inline {
        CC_SAFE_RELEASE(m_sfxObjects);
    }

    static SFXFolderObject* create(int id, gd::string name, int folderID) = win inline {
        auto ret = new SFXFolderObject();
        if (ret->init(id, name, folderID)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init(int id, gd::string name, int folderID) = win inline {
        if (!SFXInfoObject::init(id, name, folderID, 0, 0)) return false;
        m_sfxObjects = cocos2d::CCArray::create();
        m_sfxObjects->retain();
        return true;
    }

    cocos2d::CCArray* m_sfxObjects;
}

[[link(android)]]
class SFXInfoObject : cocos2d::CCObject {
    // virtual ~SFXInfoObject();
    SFXInfoObject() {
        m_sfxID = 0;
        m_folderID = 0;
        m_size = 0;
        m_duration = 0;
        m_folder = false;
        m_unk049 = false;
    }

    static SFXInfoObject* create(int id, gd::string name, int folderID, int size, int duration) = win inline {
        auto ret = new SFXInfoObject();
        if (ret->init(id, name, folderID, size, duration)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    gd::string getLowerCaseName() = win inline {
        gd::string name = m_name;
        for (int i = 0; i < name.size(); i++) {
            name[i] = tolower(name[i]);
        }
        return name;
    }
    bool init(int id, gd::string name, int folderID, int size, int duration) = win inline, ios inline {
        m_sfxID = id;
        m_name = name;
        m_folderID = folderID;
        m_size = size;
        m_duration = duration;
        m_folder = false;
        return true;
    }

    int m_sfxID;
    int m_folderID;
    int m_size;
    int m_duration;
    bool m_folder;
    bool m_unk049;
    gd::string m_name;
}

[[link(android)]]
class SFXSearchResult : MusicSearchResult {
    // virtual ~SFXSearchResult();

    static SFXSearchResult* create(int folderID) = win 0x3479f0;

    virtual void updateObjects(AudioSortType type) = win 0x347a70;

    SFXFolderObject* getActiveFolder() = win inline {
        return m_folderObject;
    }
    int getSelectedPage(int id, int count) = win 0x347fd0;
    bool init(int folderID) = win inline, ios inline {
        if (!MusicSearchResult::init(GJSongType::Music)) return false;
        m_folderID = folderID;
        m_audioType = 1;
        return true;
    }
    void setActiveFolder(SFXFolderObject* folder) = win inline {
        if (folder != m_folderObject) {
            CC_SAFE_RELEASE(m_folderObject);
            CC_SAFE_RETAIN(folder);
            m_folderObject = folder;
        }
        else if (!folder) {
            CC_SAFE_RELEASE_NULL(m_folderObject);
        }
    }

    int m_folderID;
    SFXFolderObject* m_folderObject;
}

[[link(android)]]
class SFXTriggerGameObject : EffectGameObject {
    // virtual ~SFXTriggerGameObject();
    SFXTriggerGameObject() = win 0x495fa0 {
        m_soundID = 0;
        m_pitch = 0.f;
        m_speed = 0;
        m_pitchIndex = 0;
        m_fadeIn = 0;
        m_end = 0;
        m_fadeOut = 0;
        m_reverb = false;
        m_fastFourierTransform = false;
        m_loop = false;
        m_stopLoop = false;
        m_dontReset = false;
        m_unique = false;
        m_override = false;
        m_sfxUniqueID = 0;
        m_minDistNear = 0;
        m_minDistMedium = 0;
        m_minDistFar = 0;
        m_proximityMode = 0;
        m_cameraDistance = false;
        m_preload = false;
        m_ignoreVolumeTest = false;
        m_minInterval = 0.f;
        m_sfxGroup = 0;
        m_stop = false;
        m_changeSpeed = false;
        m_changeVolume = false;
        m_groupID = 0;
        m_unk788 = 0;
        m_reverbPreset = FMODReverbPreset::Generic;
        m_reverbEnabled = false;
        m_soundDuration = 0.f;
        m_applyDisabled = false;
        m_speedVariance = 0;
        m_pitchVariance = 0;
        m_volumeVariance = 0.f;
        m_pitchSteps = false;
        m_volume = 1.f;
        m_start = 0;
        m_volumeNear = 1.f;
        m_volumeMedium = .5f;
        m_volumeFar = 0.f;
    }

    static SFXTriggerGameObject* create(char const* frame) = win inline {
        auto ret = new SFXTriggerGameObject();
        if (ret->init(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4b77b0;
    virtual gd::string getSaveString(GJBaseGameLayer* layer);

    int getSFXRefID() = win inline {
        return m_sfxUniqueID > 0 ? m_sfxUniqueID : m_uniqueID;
    }
    int getUniqueSFXID() = win inline {
        return m_unique ? this->getSFXRefID() : 0;
    }
    bool init(char const* frame) = win inline, ios inline {
        return EffectGameObject::init(frame);
    }

    gd::string m_soundPath;
    // property 392
    int m_soundID;
    float m_pitch;
    // property 404
    int m_speed;
    // property 405
    int m_pitchIndex;
    // property 406
    float m_volume;
    // property 408
    int m_start;
    // property 409
    int m_fadeIn;
    // property 410
    int m_end;
    // property 411
    int m_fadeOut;
    // property 407
    bool m_reverb;
    // property 412
    bool m_fastFourierTransform;
    // property 413
    bool m_loop;
    // property 414
    bool m_stopLoop;
    // property 595
    bool m_dontReset;
    // property 415
    bool m_unique;
    // property 420
    bool m_override;
    // property 416
    int m_sfxUniqueID;
    // property 421
    float m_volumeNear;
    // property 422
    float m_volumeMedium;
    // property 423
    float m_volumeFar;
    // property 424
    int m_minDistNear;
    // property 425
    int m_minDistMedium;
    // property 426
    int m_minDistFar;
    // property 458
    int m_proximityMode;
    // property 428
    bool m_cameraDistance;
    // property 433
    bool m_preload;
    // property 489
    bool m_ignoreVolumeTest;
    // property 434
    float m_minInterval;
    // property 455
    int m_sfxGroup;
    // property 417
    bool m_stop;
    // property 418
    bool m_changeSpeed;
    // property 419
    bool m_changeVolume;
    // property 457
    int m_groupID;
    int m_unk788;
    // property 502
    FMODReverbPreset m_reverbPreset;
    // property 503
    bool m_reverbEnabled;
    // property 490
    float m_soundDuration;
    bool m_applyDisabled;
    // property 596
    int m_speedVariance;
    // property 597
    int m_pitchVariance;
    // property 598
    float m_volumeVariance;
    // property 599
    bool m_pitchSteps;
}

[[link(android)]]
class ShaderGameObject : EffectGameObject {
    // virtual ~ShaderGameObject();
    ShaderGameObject() {
        m_speed = 1.f;
        m_strength = 1.f;
        m_outer = 1.f;
        m_timeOff = 0.f;
        m_waveWidth = 1.f;
        m_targetX = 1.f;
        m_targetY = 1.f;
        m_fadeIn = 1.f;
        m_fadeOut = 1.f;
        m_screenOffsetX = 0.f;
        m_screenOffsetY = 0.f;
        m_invert = false;
        m_inner = 0.f;
        m_maxSize = 0.f;
        m_flip = false;
        m_rotate = false;
        m_dual = false;
        m_useX = false;
        m_useY = false;
        m_snapGrid = false;
        m_hardEdges = false;
        m_disableAll = false;
        m_zLayerMin = 0;
        m_zLayerMax = 0;
        m_animate = false;
        m_relative = false;
        m_editorDisabled = false;
    }

    static ShaderGameObject* create(char const* frame) = win inline {
        auto ret = new ShaderGameObject();
        if (ret->init(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void customSetup();
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x49aa50;
    virtual gd::string getSaveString(GJBaseGameLayer* layer);

    bool init(char const* frame) = win inline, ios inline {
        return EffectGameObject::init(frame);
    }

    // property 175
    float m_speed;
    // property 176
    float m_strength;
    // property 191
    float m_outer;
    // property 177
    float m_timeOff;
    // property 179
    float m_waveWidth;
    // property 180
    float m_targetX;
    // property 189
    float m_targetY;
    // property 181
    float m_fadeIn;
    // property 182
    float m_fadeOut;
    // property 290
    float m_screenOffsetX;
    // property 291
    float m_screenOffsetY;
    // property 184
    bool m_invert;
    // property 183
    float m_inner;
    // property 512
    float m_maxSize;
    // property 185
    bool m_flip;
    // property 186
    bool m_rotate;
    // property 187
    bool m_dual;
    // property 188
    bool m_useX;
    // property 190
    bool m_useY;
    // property 194
    bool m_snapGrid;
    // property 515
    bool m_hardEdges;
    // property 192
    bool m_disableAll;
    // property 196
    int m_zLayerMin;
    // property 197
    int m_zLayerMax;
    // property 513
    bool m_animate;
    // property 514
    bool m_relative;
    // property 531
    bool m_editorDisabled;
}

[[link(android), depends(GJShaderState)]]
class ShaderLayer : cocos2d::CCLayer {
    ShaderLayer() {
        m_timesyncShaderActions = false;
        m_shader = nullptr;
        m_renderTexture = nullptr;
        m_sprite = nullptr;
        m_antiAlias = false;
        m_configuredAntiAlias = false;
        m_gameLayer = nullptr;
        m_savedCameraRotation = 0.f;
        m_shockWaveTimeMult = 1.f;
        m_scaleFactor = 1.f;
    }
    ~ShaderLayer() = win inline {
        CC_SAFE_RELEASE(m_renderTexture);
    }

    static ShaderLayer* create() = win inline {
        auto ret = new ShaderLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x481920;
    virtual void update(float dt) = win 0x4826d0;
    virtual void visit() = win 0x4886f0;

    cocos2d::CCPoint objectPosToShaderPos(cocos2d::CCPoint position) = win 0x482a00;
    void performCalculations() = win 0x487d40;
    void preBulgeShader() = win inline {
        if (m_state.m_bulgeValue <= 0.f) {
            if (this->getActionByTag(21)) {
                m_state.m_usesShaders = true;
            }
            m_sprite->getShaderProgram()->setUniformLocationWith1f(m_bulgeValueUniform, 0.f);
        }
    }
    void preChromaticGlitchShader() = win 0x4859b0;
    void preChromaticShader() = win inline {
        if (m_state.m_chromaticTargetX != 0.f || m_state.m_chromaticTargetY != 0.f || this->getActionByTag(1) || this->getActionByTag(2)) {
            m_state.m_usesShaders = true;
        }
        auto scale = m_state.m_chromaticRelative && m_gameLayer ? abs(m_gameLayer->m_objectLayer->getScale()) : 1.f;
        auto shaderProgram = m_sprite->getShaderProgram();
        shaderProgram->setUniformLocationWith1f(m_chromaticXOffUniform, (m_scaleFactor / 1.2018504f) * m_state.m_chromaticTargetX * m_state.m_textureScaleX * scale);
        shaderProgram->setUniformLocationWith1f(m_chromaticYOffUniform, (m_scaleFactor / 1.2018504f) * m_state.m_chromaticTargetY * m_state.m_textureScaleY * scale);
    }
    void preColorChangeShader() = win inline {
        auto shaderProgram = m_sprite->getShaderProgram();
        if (m_state.m_colorChangeCR != 1.f || m_state.m_colorChangeCG != 1.f || m_state.m_colorChangeCB != 1.f ||
            m_state.m_colorChangeBR != 0.f || m_state.m_colorChangeBG != 0.f || m_state.m_colorChangeBB != 0.f) {
            m_state.m_usesShaders = true;
            shaderProgram->setUniformLocationWith3f(m_colorChangeCUniform, std::max(m_state.m_colorChangeCR, .001f), m_state.m_colorChangeCG, m_state.m_colorChangeCB);
            shaderProgram->setUniformLocationWith3f(m_colorChangeBUniform, m_state.m_colorChangeBR, m_state.m_colorChangeBG, m_state.m_colorChangeBB);
        }
        else {
            shaderProgram->setUniformLocationWith3f(m_colorChangeCUniform, 0.f, 0.f, 0.f);
            if (this->getActionByTag(42) || this->getActionByTag(43) || this->getActionByTag(44) || this->getActionByTag(39) || this->getActionByTag(40) || this->getActionByTag(41)) {
                m_state.m_usesShaders = true;
            }
        }
    }
    void preCommonShader() = win inline {
        auto shaderProgram = m_sprite->getShaderProgram();
        shaderProgram->setUniformLocationWith3f(m_blurRefColorUniform, m_state.m_blurRefColor.r / 255.f, m_state.m_blurRefColor.g / 255.f, m_state.m_blurRefColor.b / 255.f);
        shaderProgram->setUniformLocationWith1f(m_blurUseRefUniform, m_state.m_minBlendingLayer > 1);
        shaderProgram->setUniformLocationWith1f(m_blurIntensityUniform, m_state.m_blurIntensity + 1.f);
        shaderProgram->setUniformLocationWith2f(m_textureScaleUniform, m_state.m_textureScaleX, m_state.m_textureScaleY);
        shaderProgram->setUniformLocationWith2f(m_textureScaleInvUniform, 1.f / m_state.m_textureScaleX, 1.f / m_state.m_textureScaleY);
        shaderProgram->setUniformLocationWith1f(m_blurOnlyEmptyUniform, m_state.m_minBlendingLayer > 1 && m_state.m_blurOnlyEmpty);
        shaderProgram->setUniformLocationWith1f(m_screenAspectINVUniform, m_screenSize.height / m_screenSize.width);
        shaderProgram->setUniformLocationWith1f(m_shaderPositionUniform, m_screenSize.width / m_screenSize.height);
    }
    void preGlitchShader() = win 0x485240;
    void preGrayscaleShader() = win inline {
        if (m_state.m_grayscaleValue > 0.f || this->getActionByTag(32)) {
            m_state.m_usesShaders = true;
        }
        auto shaderProgram = m_sprite->getShaderProgram();
        shaderProgram->setUniformLocationWith1f(m_grayscaleValueUniform, m_state.m_grayscaleValue);
        if (m_state.m_grayscaleValue > 0.f) {
            shaderProgram->setUniformLocationWith1f(m_grayscaleUseLumUniform, m_state.m_grayscaleUseLum);
            shaderProgram->setUniformLocationWith3f(m_grayscaleTintUniform, m_state.m_grayscaleTint.r / 255.f, m_state.m_grayscaleTint.g / 255.f, m_state.m_grayscaleTint.b / 255.f);
        }
    }
    void preHueShiftShader() = win inline {
        if (m_state.m_hueShiftDegrees != 0.f || this->getActionByTag(38)) {
            m_state.m_usesShaders = true;
        }
        auto radians = m_state.m_hueShiftDegrees * (M_PI / 180.f);
        auto shaderProgram = m_sprite->getShaderProgram();
        shaderProgram->setUniformLocationWith1f(m_hueShiftCosAUniform, cosf(radians));
        shaderProgram->setUniformLocationWith1f(m_hueShiftSinAUniform, sinf(radians));
    }
    void preInvertColorShader() = win inline {
        if (m_state.m_invertColorEditRGB > 0.f || this->getActionByTag(34)) {
            m_state.m_usesShaders = true;
        }
        auto shaderProgram = m_sprite->getShaderProgram();
        auto edit = m_state.m_invertColorEditRGB;
        auto r = edit * m_state.m_invertColorR;
        auto g = edit * m_state.m_invertColorG;
        auto b = edit * m_state.m_invertColorB;
        if (m_state.m_invertColorClampRGB) {
            r = std::min(r, 1.f);
            g = std::min(g, 1.f);
            b = std::min(b, 1.f);
        }
        shaderProgram->setUniformLocationWith4f(m_invertColorValueUniform, r, g, b, edit);
    }
    void preLensCircleShader() = win 0x4864f0;
    void preMotionBlurShader() = win 0x4869c0;
    cocos2d::CCPoint prepareTargetContainer() = win 0x485ee0;
    void prePinchShader() = win inline {
        if (m_state.m_pinchTargetX != 0.0 || m_state.m_pinchTargetY != 0.0 || this->getActionByTag(25) || this->getActionByTag(26)) {
            m_state.m_usesShaders = true;
        }
    }
    void prePixelateShader() = win 0x485d30;
    void preRadialBlurShader() = win inline {
        if (m_state.m_radialBlurSize != 0.f || this->getActionByTag(16)) {
            m_state.m_usesShaders = true;
        }
        auto shaderProgram = m_sprite->getShaderProgram();
        shaderProgram->setUniformLocationWith1f(m_radialBlurValueUniform, m_state.m_radialBlurSize / 45.f);
        if (m_state.m_radialBlurSize != 0.f) {
            shaderProgram->setUniformLocationWith1f(m_blurFadeUniform, std::clamp(m_state.m_radialBlurFade * .2f, .0f, .2f));
        }
    }
    void preSepiaShader() = win inline {
        if (m_state.m_sepiaValue > 0.f || this->getActionByTag(33)) {
            m_state.m_usesShaders = true;
        }
        m_sprite->getShaderProgram()->setUniformLocationWith1f(m_sepiaValueUniform, m_state.m_sepiaValue);
    }
    void preShockLineShader() = win 0x484d30;
    void preShockWaveShader() = win 0x4841e0;
    void preSplitScreenShader() = win 0x487a20;
    bool resetAllShaders() = win 0x489260;
    void resetTargetContainer() = win inline {
        if (m_gameLayer) {
            auto parent = m_state.m_minBlendingLayer < 2 ? m_gameLayer->m_objectParent : m_gameLayer->m_inShaderParent;
            parent->setPosition(m_savedCameraPosition);
            parent->setScale(1.f);
            parent->setRotation(m_savedCameraRotation);
            this->setRotation(0.f);
        }
    }
    void setupBulgeShader() = win inline {
        auto program = m_sprite->getShaderProgram()->getProgram();
        m_bulgeValueUniform = glGetUniformLocation(program, "_bulgeValue");
        m_bulgeValue2Uniform = glGetUniformLocation(program, "_bulgeValue2");
        m_bulgeOriginUniform = glGetUniformLocation(program, "_bulgeOrigin");
        m_bulgeRadiusUniform = glGetUniformLocation(program, "_bulgeRadius");
    }
    void setupChromaticGlitchUniforms() = win inline {
        auto program = m_sprite->getShaderProgram()->getProgram();
        m_cGRGBOffsetUniform = glGetUniformLocation(program, "_cGRGBOffset");
        m_cGYOffsetUniform = glGetUniformLocation(program, "_cGYOffset");
        m_cGTimeUniform = glGetUniformLocation(program, "_cGTime");
        m_cGStrengthUniform = glGetUniformLocation(program, "_cGStrength");
        m_cGHeightUniform = glGetUniformLocation(program, "_cGHeight");
        m_cGLineThickUniform = glGetUniformLocation(program, "_cGLineThick");
        m_cGLineStrengthUniform = glGetUniformLocation(program, "_cGLineStrength");
    }
    void setupChromaticUniforms() = win inline {
        auto program = m_sprite->getShaderProgram()->getProgram();
        m_chromaticXOffUniform = glGetUniformLocation(program, "_chromaticXOff");
        m_chromaticYOffUniform = glGetUniformLocation(program, "_chromaticYOff");
    }
    void setupColorChangeShader() = win inline {
        auto program = m_sprite->getShaderProgram()->getProgram();
        m_colorChangeCUniform = glGetUniformLocation(program, "_colorChangeC");
        m_colorChangeBUniform = glGetUniformLocation(program, "_colorChangeB");
    }
    void setupCommonUniforms();
    void setupGlitchUniforms() = win inline {
        auto program = m_sprite->getShaderProgram()->getProgram();
        m_glitchBotUniform = glGetUniformLocation(program, "_glitchBot");
        m_glitchTopUniform = glGetUniformLocation(program, "_glitchTop");
        m_glitchXOffsetUniform = glGetUniformLocation(program, "_glitchXOffset");
        m_glitchColOffsetUniform = glGetUniformLocation(program, "_glitchColOffset");
        m_glitchRndUniform = glGetUniformLocation(program, "_glitchRnd");
    }
    void setupGrayscaleShader() = win inline {
        auto program = m_sprite->getShaderProgram()->getProgram();
        m_grayscaleValueUniform = glGetUniformLocation(program, "_grayscaleValue");
        m_grayscaleTintUniform = glGetUniformLocation(program, "_grayscaleTint");
        m_grayscaleUseLumUniform = glGetUniformLocation(program, "_grayscaleUseLum");
    }
    void setupHueShiftShader() = win inline {
        auto program = m_sprite->getShaderProgram()->getProgram();
        m_hueShiftCosAUniform = glGetUniformLocation(program, "_hueShiftCosA");
        m_hueShiftSinAUniform = glGetUniformLocation(program, "_hueShiftSinA");
    }
    void setupInvertColorShader() = win inline, ios inline {
        m_invertColorValueUniform = glGetUniformLocation(m_sprite->getShaderProgram()->getProgram(), "_invertColorValue");
    }
    void setupLensCircleShader() = win inline {
        auto program = m_sprite->getShaderProgram()->getProgram();
        m_lensCircleOriginUniform = glGetUniformLocation(program, "_lensCircleOrigin");
        m_lensCircleStartUniform = glGetUniformLocation(program, "_lensCircleStart");
        m_lensCircleEndUniform = glGetUniformLocation(program, "_lensCircleEnd");
        m_lensCircleStrengthUniform = glGetUniformLocation(program, "_lensCircleStrength");
        m_lensCircleTintUniform = glGetUniformLocation(program, "_lensCircleTint");
        m_lensCircleAdditiveUniform = glGetUniformLocation(program, "_lensCircleAdditive");
    }
    void setupMotionBlurShader() = win inline {
        auto program = m_sprite->getShaderProgram()->getProgram();
        m_motionBlurValueUniform = glGetUniformLocation(program, "_motionBlurValue");
        m_motionBlurMultUniform = glGetUniformLocation(program, "_motionBlurMult");
        m_motionBlurDualUniform = glGetUniformLocation(program, "_motionBlurDual");
    }
    void setupPinchShader() = win inline {
        auto program = m_sprite->getShaderProgram()->getProgram();
        m_pinchValueUniform = glGetUniformLocation(program, "_pinchValue");
        m_pinchCenterPosUniform = glGetUniformLocation(program, "_pinchCenterPos");
        m_pinchCalcUniform = glGetUniformLocation(program, "_pinchCalc1");
        m_pinchRadiusUniform = glGetUniformLocation(program, "_pinchRadius");
    }
    void setupRadialBlurShader() = win inline {
        auto program = m_sprite->getShaderProgram()->getProgram();
        m_radialBlurCenterUniform = glGetUniformLocation(program, "_radialBlurCenter");
        m_radialBlurValueUniform = glGetUniformLocation(program, "_radialBlurValue");
    }
    void setupSepiaShader() = win inline, ios inline {
        m_sepiaValueUniform = glGetUniformLocation(m_sprite->getShaderProgram()->getProgram(), "_sepiaValue");
    }
    void setupShader(bool reset) = win 0x481a30;
    void setupShockLineUniforms();
    void setupShockWaveUniforms();
    void setupSplitScreenShader();
    void toggleAntiAlias(bool antiAlias) = win 0x482660;
    void triggerBulge(float fadeTime, float bulge, float screenOffsetX, float screenOffsetY, float radius, int targetID, int easingType, float easingRate, bool relative) = win 0x486cd0;
    void triggerChromaticGlitch(bool enable, float duration, float speed, float strength, float rgbOffset, float lineThickness, float lineStrength, float segmentHeight, int easingType, float easingRate, bool relative, bool relativePos) = win 0x485690;
    void triggerChromaticX(float fadeTime, float targetX, int easingType, float easingRate, bool relative) = win inline {
        this->tweenValueAuto(targetX, 1, fadeTime, easingType, easingRate);
        m_state.m_chromaticRelative = relative;
    }
    void triggerChromaticY(float fadeTime, float targetY, int easingType, float easingRate, bool relative) = win inline {
        this->tweenValueAuto(targetY, 2, fadeTime, easingType, easingRate);
        m_state.m_chromaticRelative = relative;
    }
    void triggerColorChange(float fadeTime, float cr, float cg, float cb, float br, float bg, float bb, int easingType, float easingRate) = win 0x4875a0;
    void triggerGlitch(float fadeTime, float strength, float speed, float sliceHeight, float maxSliceXOff, float maxColXOff, float maxColYOff, bool relative) = win inline {
        this->tweenValueAuto(strength, 49, fadeTime, 0, 0.f);
        m_state.m_glitchSpeed = speed;
        m_state.m_glitchSliceHeight = sliceHeight;
        m_state.m_glitchMaxSliceXOff = maxSliceXOff;
        m_state.m_glitchMaxColXOff = maxColXOff;
        m_state.m_glitchMaxColYOff = maxColYOff;
        m_state.m_glitchRelative = relative;
    }
    void triggerGrayscale(float fadeTime, float target, bool useLuminance, int tintChannel, int easingType, float easingRate) = win inline {
        if (tintChannel > -1) m_state.m_grayscaleTintChannel = tintChannel;
        m_state.m_grayscaleUseLum = useLuminance;
        this->tweenValueAuto(target, 32, fadeTime, easingType, easingRate);
    }
    void triggerHueShift(float fadeTime, float degrees, int easingType, float easingRate) = win inline {
        this->tweenValueAuto(degrees, 38, fadeTime, easingType, easingRate);
    }
    void triggerInvertColor(float fadeTime, float target, float r, float g, float b, bool editRGB, bool tweenRGB, bool clampRGB, int easingType, float easingRate) = win 0x487320;
    void triggerLensCircle(float fadeTime, float size, float fade, float strength, int targetID, int tintChannel, float screenOffsetX, float screenOffsetY, int easingType, float easingRate, bool relative) = win 0x486250;
    void triggerMotionBlurX(float fadeTime, float targetX, float intensity, float fade, int targetID, float followEase, bool dualDir, int refChannel, int easingType, float easingRate, bool relative, bool emptyOnly) = win inline {
        m_state.m_blurRefChannel = refChannel;
        this->tweenValueAuto(fade, 48, fadeTime, 0, 0.f);
        this->tweenValueAuto(intensity, 47, fadeTime, 0, 0.f);
        this->tweenValueAuto(targetX, 19, fadeTime, easingType, easingRate);
        m_state.m_blurOnlyEmpty = emptyOnly;
        m_state.m_motionBlurFollowEaseX = followEase;
        m_state.m_motionBlurTargetIDX = targetID;
        m_state.m_motionBlurDual = dualDir;
        m_state.m_motionBlurRelative = relative;
    }
    void triggerMotionBlurY(float fadeTime, float targetY, float intensity, float fade, int targetID, float followEase, bool dualDir, int refChannel, int easingType, float easingRate, bool relative, bool emptyOnly) = win inline {
        m_state.m_blurRefChannel = refChannel;
        this->tweenValueAuto(fade, 48, fadeTime, 0, 0.f);
        this->tweenValueAuto(intensity, 47, fadeTime, 0, 0.f);
        this->tweenValueAuto(targetY, 20, fadeTime, easingType, easingRate);
        m_state.m_blurOnlyEmpty = emptyOnly;
        m_state.m_motionBlurFollowEaseY = followEase;
        m_state.m_motionBlurTargetIDY = targetID;
        m_state.m_motionBlurDual = dualDir;
        m_state.m_motionBlurRelative = relative;
    }
    void triggerPinchX(float fadeTime, float targetX, float screenOffsetX, float radius, float modifier, bool target, int targetID, int easingType, float easingRate, bool relative) = win 0x486ee0;
    void triggerPinchY(float fadeTime, float targetY, float screenOffsetY, float radius, float modifier, bool target, int targetID, int easingType, float easingRate, bool relative) = win 0x487100;
    void triggerPixelateX(float fadeTime, float targetX, bool snapGrid, bool hardEdges, int easingType, float easingRate, bool relative) = win inline {
        m_state.m_pixelateSnapGrid = snapGrid;
        if (m_state.m_pixelateTargetX < 1.f) m_state.m_pixelateTargetX = 1.f;
        this->tweenValueAuto(targetX, 9, fadeTime, easingType, easingRate);
        m_state.m_pixelateRelative = relative;
        m_state.m_pixelateHardEdges = hardEdges;
    }
    void triggerPixelateY(float fadeTime, float targetY, bool snapGrid, bool hardEdges, int easingType, float easingRate, bool relative) = win inline {
        m_state.m_pixelateSnapGrid = snapGrid;
        if (m_state.m_pixelateTargetY < 1.f) m_state.m_pixelateTargetY = 1.f;
        this->tweenValueAuto(targetY, 10, fadeTime, easingType, easingRate);
        m_state.m_pixelateRelative = relative;
        m_state.m_pixelateHardEdges = hardEdges;
    }
    void triggerRadialBlur(float fadeTime, float size, float intensity, float fade, int refChannel, float screenOffsetX, float screenOffsetY, bool target, int targetID, int easingType, float easingRate, bool emptyOnly) = win 0x486720;
    void triggerSepia(float fadeTime, float target, int easingType, float easingRate) = win inline {
        this->tweenValueAuto(target, 33, fadeTime, easingType, easingRate);
    }
    void triggerShockLine(float speed, float thickness, bool rotate, bool flip, bool dual, bool invert, float strength, float waveWidth, float fadeIn, float fadeOut, float timeOffset, float screenOffset, int targetID, bool target, bool follow, bool relative, float maxSize, bool animate, float fadeTime, int easingType, float easingRate) = win 0x484680;
    void triggerShockWave(float speed, float thickness, float strength, float waveWidth, float fadeIn, float fadeOut, float timeOffset, bool invert, float inner, float screenOffsetX, float screenOffsetY, int targetID, bool target, bool follow, bool relative, float outer, float maxSize, bool animate, float fadeTime, int easingType, float easingRate) = win 0x483a20;
    void triggerSplitScreenCols(float fadeTime, float targetX, int easingType, float easingRate) = win inline {
        this->tweenValueAuto(targetX, 46, fadeTime, easingType, easingRate);
    }
    void triggerSplitScreenRows(float fadeTime, float targetY, int easingType, float easingRate) = win inline {
        this->tweenValueAuto(targetY, 45, fadeTime, easingType, easingRate);
    }
    void tweenValue(float fromValue, float toValue, int action, float duration, int easingType, float easingRate) = win 0x4890d0, ios inline {
        m_state.tweenValue(fromValue, toValue, action, duration, easingType, easingRate);
    }
    void tweenValueAuto(float value, int action, float duration, int easingType, float easingRate) = win 0x4889d0;
    void updateEffectOffsets(cocos2d::CCPoint center) = win 0x482bc0;
    void updateMotionBlurSpeedX(float x, float dt) = win inline {
        auto divisor = m_state.m_motionBlurFollowEaseX;
        if (divisor > 1.f) {
            if (dt > 0.f) divisor /= dt;
            m_state.m_motionBlurSpeedX += (x - m_state.m_motionBlurSpeedX) / divisor;
        }
        else m_state.m_motionBlurSpeedX = x;
    }
    void updateMotionBlurSpeedY(float y, float dt) = win inline {
        auto divisor = m_state.m_motionBlurFollowEaseY;
        if (divisor > 1.f) {
            if (dt > 0.f) divisor /= dt;
            m_state.m_motionBlurSpeedY += (y - m_state.m_motionBlurSpeedY) / divisor;
        }
        else m_state.m_motionBlurSpeedY = y;
    }
    void updateShockLineCenter(cocos2d::CCPoint center) = win inline {
        if (m_state.m_shockLineCenterDirty) {
            if (!m_state.m_shockLineCenterMoving) m_state.m_shockLineCenterDirty = false;
            m_state.m_shockLineCenter = center;
        }
    }
    void updateShockWaveCenter(cocos2d::CCPoint center) = win inline {
        if (m_state.m_shockWaveCenterDirty) {
            if (!m_state.m_shockWaveCenterMoving) m_state.m_shockWaveCenterDirty = false;
            m_state.m_shockWaveCenter = center;
        }
    }
    bool updateZLayer(int minLayer, int maxLayer, bool noParticles) = win 0x4891e0;

    GJShaderState m_state;
    bool m_timesyncShaderActions;
    cocos2d::CCGLProgram* m_shader;
    cocos2d::CCRenderTexture* m_renderTexture;
    cocos2d::CCSprite* m_sprite;
    bool m_antiAlias;
    bool m_configuredAntiAlias;
    void* m_unk3d4;
    GJBaseGameLayer* m_gameLayer;
    cocos2d::CCPoint m_savedCameraPosition;
    float m_savedCameraRotation;
    float m_shockWaveTimeMult;
    float m_scaleFactor;
    float m_aspectRatio;
    cocos2d::CCSize m_screenSize;
    cocos2d::CCSize m_textureContentSize;
    cocos2d::CCSize m_targetTextureSize;
    // how much bigger is the texture compared to visibleSize
    cocos2d::CCSize m_targetTextureSizeExtra;
    int m_textureScaleUniform;
    int m_textureScaleInvUniform;
    int m_screenAspectUniform;
    int m_screenAspectINVUniform;
    int m_shaderPositionUniform;
    int m_blurRefColorUniform;
    int m_blurUseRefUniform;
    int m_blurIntensityUniform;
    int m_blurOnlyEmptyUniform;
    int m_shockWaveTimeUniform;
    int m_shockWaveTime1Uniform;
    int m_shockWaveTime2Uniform;
    int m_shockWaveTime3Uniform;
    int m_shockWaveTime4Uniform;
    int m_shockWaveStrengthUniform;
    int m_shockWaveWavesUniform;
    int m_shockWaveCenterUniform;
    int m_shockWaveInvertUniform;
    int m_shockWaveMinSizeUniform;
    int m_shockWaveMaxSizeUniform;
    int m_shockWaveMaxDistValUniform;
    float m_shockWaveTime1;
    float m_shockWaveTime2;
    float m_shockWaveTime3;
    float m_shockWaveTime4;
    float m_shockWaveMaxDistVal;
    float m_shockWaveMinSize;
    float m_shockWaveMaxSize;
    bool m_shockWaveUnk46c;
    int m_shockLineTimeUniform;
    int m_shockLineTime1Uniform;
    int m_shockLineTime2Uniform;
    int m_shockLineTime3Uniform;
    int m_shockLineTime4Uniform;
    int m_shockLineAxisUniform;
    int m_shockLineDirectionUniform;
    int m_shockLineDualUniform;
    int m_shockLineWavesUniform;
    int m_shockLineStrengthUniform;
    int m_shockLineCenterUniform;
    int m_shockLineMaxDistValUniform;
    float m_shockLineTime1;
    float m_shockLineTime2;
    float m_shockLineTime3;
    float m_shockLineTime4;
    float m_shockLineMaxDistVal;
    int m_unk4b4;
    int m_unk4b8;
    int m_unk4bc;
    int m_glitchBotUniform;
    int m_glitchTopUniform;
    int m_glitchXOffsetUniform;
    int m_glitchColOffsetUniform;
    int m_glitchRndUniform;
    int m_chromaticXOffUniform;
    int m_chromaticYOffUniform;
    int m_cGRGBOffsetUniform;
    int m_cGYOffsetUniform;
    int m_cGTimeUniform;
    int m_cGStrengthUniform;
    int m_cGHeightUniform;
    int m_cGLineThickUniform;
    int m_cGLineStrengthUniform;
    int m_lensCircleOriginUniform;
    int m_lensCircleStartUniform;
    int m_lensCircleEndUniform;
    int m_lensCircleStrengthUniform;
    int m_lensCircleTintUniform;
    int m_lensCircleAdditiveUniform;
    int m_radialBlurCenterUniform;
    int m_radialBlurValueUniform;
    int m_blurFadeUniform;
    int m_motionBlurValueUniform;
    int m_motionBlurMultUniform;
    int m_motionBlurDualUniform;
    int m_bulgeValueUniform;
    int m_bulgeValue2Uniform;
    int m_bulgeOriginUniform;
    int m_bulgeRadiusUniform;
    int m_pinchValueUniform;
    int m_pinchCenterPosUniform;
    int m_pinchCalcUniform;
    int m_pinchRadiusUniform;
    int m_grayscaleValueUniform;
    int m_grayscaleTintUniform;
    int m_grayscaleUseLumUniform;
    int m_sepiaValueUniform;
    int m_invertColorValueUniform;
    int m_hueShiftCosAUniform;
    int m_hueShiftSinAUniform;
    int m_colorChangeCUniform;
    int m_colorChangeBUniform;
    int m_rowmodUniform;
    int m_colmodUniform;
    int m_rowmodCalcUniform;
    int m_colmodCalcUniform;
    int m_splitXStartUniform;
    int m_splitXRangeUniform;
    int m_splitXRangeMultUniform;
    int m_splitYStartUniform;
    int m_splitYRangeUniform;
    int m_splitYRangeMultUniform;
}

[[link(android)]]
class ShardsPage : FLAlertLayer {
    ShardsPage() {
        m_pages = nullptr;
        m_prevButton = nullptr;
        m_nextButton = nullptr;
        m_tierSprite = nullptr;
        m_page = -1;
    }
    ~ShardsPage() = win inline {
        CC_SAFE_RELEASE(m_pages);
    }

    static ShardsPage* create() = win inline {
        auto ret = new ShardsPage();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x489790;
    virtual void registerWithTouchDispatcher() = win 0x42660;
    virtual void keyBackClicked() = win 0x846c0;
    virtual void show();

    void FLAlert_Clicked(FLAlertLayer* alert, bool btn2) = win inline, ios inline {}
    void goToPage(int page) = win inline {
        if (page < 4 && page != m_page) {
            m_page = page;
            for (int i = 0; i < m_pages->count(); i++) {
                auto arr = static_cast<cocos2d::CCArray*>(m_pages->objectForKey(i));
                CCObject* obj;
                CCARRAY_FOREACH(arr, obj) {
                    static_cast<cocos2d::CCNode*>(obj)->setVisible(i == page);
                }
            }
            m_prevButton->setVisible(m_page > 0);
            m_nextButton->setVisible(m_page < 3);
            m_tierSprite->setDisplayFrame(cocos2d::CCSpriteFrameCache::sharedSpriteFrameCache()->spriteFrameByName(page > 1 ? "tier2Icon_001.png" : "tier1Icon_001.png"));
        }
    }
    void onClose(cocos2d::CCObject* sender) = win 0x84690;
    void onIconInfo(cocos2d::CCObject* sender) = win 0x48c780;
    void onSwitchPage(cocos2d::CCObject* sender);

    cocos2d::CCDictionary* m_pages;
    CCMenuItemSpriteExtra* m_prevButton;
    CCMenuItemSpriteExtra* m_nextButton;
    cocos2d::CCSprite* m_tierSprite;
    int m_page;
}

[[link(android)]]
class ShareCommentDelegate {
    virtual void shareCommentClosed(gd::string text, ShareCommentLayer* layer) {}
}

[[link(android)]]
class ShareCommentLayer : FLAlertLayer, TextInputDelegate, UploadActionDelegate, UploadPopupDelegate {
    // virtual ~ShareCommentLayer();

    static ShareCommentLayer* create(gd::string title, int charLimit, CommentType type, int ID, gd::string desc) = win 0x48caa0;

    virtual void registerWithTouchDispatcher() = win 0x42660;
    virtual void keyBackClicked() = win 0x48e2e0;
    virtual void textInputOpened(CCTextInputNode* node) = win inline {}
    virtual void textInputClosed(CCTextInputNode* node) = win 0x48e330;
    virtual void textChanged(CCTextInputNode* node) = win 0x48e470;
    virtual void uploadActionFinished(int id, int response) = win 0x48e6c0;
    virtual void uploadActionFailed(int id, int response) = win 0x48e750;
    virtual void onClosePopup(UploadActionPopup* popup) = win 0x48e800;

    bool init(gd::string title, int charLimit, CommentType type, int ID, gd::string desc) = win 0x48ccb0;
    void onClear(cocos2d::CCObject* sender) = win 0x2c3790;
    void onClose(cocos2d::CCObject* sender) = win 0x48e2a0;
    void onPercent(cocos2d::CCObject* sender) = win 0x48de00;
    void onShare(cocos2d::CCObject* sender) = win 0x48df00;
    void updateCharCountLabel() = win inline {
        if (m_charLimit * .9f <= m_descText.size()) {
            m_charCountLabel->setColor({ 255, 0, 0 });
            m_charCountLabel->setOpacity(255);
        } else if (m_charLimit * .7f <= m_descText.size()) {
            m_charCountLabel->setColor({ 0, 0, 0 });
            m_charCountLabel->setOpacity(255);
        } else {
            m_charCountLabel->setColor({ 0, 0, 0 });
            m_charCountLabel->setOpacity(125);
        }
        m_charCountLabel->setString(cocos2d::CCString::createWithFormat("%i", m_charLimit - m_descText.size())->getCString());
    }
    void updateDescText(gd::string desc) = win 0x48e590, ios inline {
        m_descText = desc;
        this->updateCharCountLabel();
    }
    void updatePercentLabel() = win 0x48de20;

    int m_charLimit;
    int m_itemID;
    CommentType m_commentType;
    CCTextInputNode* m_commentInput;
    gd::string m_descText;
    gd::string m_placeholderText;
    cocos2d::CCLabelBMFont* m_charCountLabel;
    cocos2d::CCLabelBMFont* m_percentLabel;
    UploadActionPopup* m_uploadPopup;
    bool m_uploadSuccess;
    bool m_percentEnabled;
    int m_percent;
    ShareCommentDelegate* m_delegate;
}

[[link(android)]]
class ShareLevelLayer : FLAlertLayer {
    ShareLevelLayer() {
        m_level = nullptr;
        m_starsRequested = 0;
        m_starButtons = nullptr;
    }
    ~ShareLevelLayer() = win inline {
        CC_SAFE_RELEASE(m_level);
        CC_SAFE_RELEASE(m_starButtons);
    }

    static ShareLevelLayer* create(GJGameLevel* level) = win inline {
        auto ret = new ShareLevelLayer();
        if (ret->init(level)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyBackClicked() = win 0x846c0;

    CCMenuItemSpriteExtra* getStarsButton(int btnID, cocos2d::SEL_MenuHandler selector, cocos2d::CCMenu* menu, float scale) = win inline {
        auto btnSpr = ButtonSprite::create(cocos2d::CCString::createWithFormat("%i", btnID)->getCString(), 20, 0, .5f, true, "bigFont.fnt", "GJ_button_01.png", 30.f);
        auto btn = CCMenuItemSpriteExtra::create(btnSpr, this, selector);
        btn->setScale(scale);
        btn->m_baseScale = scale;
        if (menu) menu->addChild(btn);
        return btn;
    }
    bool init(GJGameLevel* level) = win 0x48eb50;
    void onClose(cocos2d::CCObject* sender) = win 0x84690;
    void onSettings(cocos2d::CCObject* sender);
    void onShare(cocos2d::CCObject* sender) = win 0x48ff00;
    void selectRating(cocos2d::CCObject* sender) = win 0x48fc20;
    void setupStars() = win 0x48f810;

    GJGameLevel* m_level;
    int m_starsRequested;
    cocos2d::CCArray* m_starButtons;
    cocos2d::CCSprite* m_difficultySprite;
}

[[link(android)]]
class ShareLevelSettingsLayer : FLAlertLayer, NumberInputDelegate {
    // virtual ~ShareLevelSettingsLayer();
    ShareLevelSettingsLayer() {}

    static ShareLevelSettingsLayer* create(GJGameLevel* level) = win inline {
        auto ret = new ShareLevelSettingsLayer();
        if (ret->init(level)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyBackClicked();

    bool init(GJGameLevel* level) = win 0x490d70;
    void onClose(cocos2d::CCObject* sender) = win 0x491ab0;
    void onUnlisted(cocos2d::CCObject* sender) = win 0x491790;
    void onUnlistedFriendsOnly(cocos2d::CCObject* sender);
    void updateSettingsState();

    cocos2d::CCLabelBMFont* m_passwordLabel;
    GJGameLevel* m_level;
    CCMenuItemToggler* m_friendsOnlyToggler;
    cocos2d::CCLabelBMFont* m_friendsOnlyLabel;
}

[[link(android)]]
class ShareListLayer : FLAlertLayer {
    ShareListLayer() {
        m_list = nullptr;
        m_friendsOnlyToggler = nullptr;
        m_friendsOnlyLabel = nullptr;
    }
    ~ShareListLayer() = win inline {
        CC_SAFE_RELEASE(m_list);
    }

    static ShareListLayer* create(GJLevelList* list) = win inline {
        auto ret = new ShareListLayer();
        if (ret->init(list)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyBackClicked() = win 0x846c0;

    bool init(GJLevelList* list) = win 0x3098a0;
    void onClose(cocos2d::CCObject* sender) = win 0x84690;
    void onInfo(cocos2d::CCObject* sender) = win 0x30aa40;
    void onShare(cocos2d::CCObject* sender) = win 0x30ad00;
    void onUnlisted(cocos2d::CCObject* sender) = win 0x30abb0;
    void updateUnlistedF();

    GJLevelList* m_list;
    CCMenuItemToggler* m_friendsOnlyToggler;
    cocos2d::CCLabelBMFont* m_friendsOnlyLabel;
}

[[link(android)]]
class SimpleObject : cocos2d::CCObject {
    // virtual ~SimpleObject();
    SimpleObject() {}

    static SimpleObject* create() = win inline, ios inline {
        auto ret = new SimpleObject();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init() = win inline, ios inline {
        return true;
    }

    cocos2d::ccColor3B m_color;
}

[[link(android)]]
class SimplePlayer : cocos2d::CCSprite {
    SimplePlayer() {
        m_firstLayer = nullptr;
        m_secondLayer = nullptr;
        m_birdDome = nullptr;
        m_outlineSprite = nullptr;
        m_detailSprite = nullptr;
        m_robotSprite = nullptr;
        m_spiderSprite = nullptr;
        m_unknown = 0;
        m_hasGlowOutline = false;
        m_iconRequestID = 0;
        m_hasCustomGlowColor = false;
        m_iconLoaded = false;
    }
    ~SimplePlayer() = win 0x278ff0;

    static SimplePlayer* create(int id) = win 0x2791b0;

    virtual void setOpacity(unsigned char opacity) = win 0x27a600;
    virtual void setColor(cocos2d::ccColor3B const& color) = win 0x279a10;

    void asyncLoadIcon(int id, IconType type);
    void createRobotSprite(int frame) = win inline {
        if (m_robotSprite) return;
        auto robotSprite = GJRobotSprite::create(frame);
        m_robotSprite = robotSprite;
        addChild(robotSprite);
        m_robotSprite->setVisible(false);
    }
    void createSpiderSprite(int frame) = win 0x279980;
    void disableCustomGlowColor() = win inline {
        m_hasCustomGlowColor = false;
    }
    void disableGlowOutline() {
        disableCustomGlowColor();
        m_hasGlowOutline = false;
        updateColors();
    }
    void enableCustomGlowColor(cocos2d::ccColor3B const& color) = win inline {
        m_hasCustomGlowColor = true;
        m_glowColor = color;
    }
    void hideAll() = win inline, ios inline {
        m_firstLayer->setVisible(false);
        m_secondLayer->setVisible(false);
        if (m_birdDome) m_birdDome->setVisible(false);
        if (m_outlineSprite) m_outlineSprite->setVisible(false);
        if (m_detailSprite) m_detailSprite->setVisible(false);
        if (m_robotSprite) m_robotSprite->setVisible(false);
        if (m_spiderSprite) m_spiderSprite->setVisible(false);
    }
    void hideSecondary() = win inline {
        m_secondLayer->setVisible(false);
        m_birdDome->setVisible(false);
        m_detailSprite->setVisible(false);
        m_outlineSprite->setVisible(false);
        if (m_robotSprite) {
            m_robotSprite->hideSecondary();
            m_robotSprite->hideGlow();
        }
        if (m_spiderSprite) {
            m_spiderSprite->hideSecondary();
            m_spiderSprite->hideGlow();
        }
    }
    void iconFinishedLoading(int id, IconType type);
    bool init(int id) = win 0x2792a0;
    void setColors(cocos2d::ccColor3B const& color1, cocos2d::ccColor3B const& color2) = win inline, ios inline {
        m_firstLayer->setColor(color1);
        m_secondLayer->setColor(color2);
        updateColors();
    }
    void setFrames(char const* firstFrame, char const* secondFrame, char const* ufoFrame, char const* glowFrame, char const* extraFrame) = win 0x27a3d0;
    void setGlowOutline(cocos2d::ccColor3B color) {
        enableCustomGlowColor(color);
        m_hasGlowOutline = true;
        updateColors();
    }
    void setSecondColor(cocos2d::ccColor3B const& color) = win inline {
        m_secondLayer->setColor(color);
        updateColors();
    }
    void updateColors() = win 0x279ae0;
    void updatePlayerFrame(int id, IconType type) = win 0x279ea0;

    cocos2d::CCSprite* m_firstLayer;
    cocos2d::CCSprite* m_secondLayer;
    cocos2d::CCSprite* m_birdDome;
    cocos2d::CCSprite* m_outlineSprite;
    cocos2d::CCSprite* m_detailSprite;
    GJRobotSprite* m_robotSprite;
    GJSpiderSprite* m_spiderSprite;
    int m_unknown;
    bool m_hasGlowOutline;
    int m_iconRequestID;
    bool m_hasCustomGlowColor;
    cocos2d::ccColor3B m_glowColor;
    bool m_iconLoaded;
}

[[link(android)]]
class SlideInLayer : cocos2d::CCLayerColor {
    // virtual ~SlideInLayer();

    static SlideInLayer* create();

    virtual bool init();
    virtual void draw();
    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event);
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event);
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event);
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event);
    virtual void registerWithTouchDispatcher();
    virtual void keyBackClicked();
    virtual void customSetup();
    virtual void enterLayer();
    virtual void exitLayer(cocos2d::CCObject* sender);
    virtual void showLayer(bool instant);
    virtual void hideLayer(bool instant);
    virtual void layerVisible();
    virtual void layerHidden();
    virtual void enterAnimFinished();
    virtual void disableUI();
    virtual void enableUI();

    cocos2d::CCLayer* m_mainLayer;
    cocos2d::CCMenu* m_buttonMenu;
    cocos2d::CCSprite* m_exitSprite;
    CCMenuItemSpriteExtra* m_exitButton;
    cocos2d::CCPoint m_endPosition;
    cocos2d::CCPoint m_startPosition;
    void* m_delegate;
    bool m_closeOnHide;
}

[[link(android), depends(SliderTouchLogic)]]
class Slider : cocos2d::CCLayer {
    // virtual ~Slider();

    static Slider* create(cocos2d::CCNode* target, cocos2d::SEL_MenuHandler handler) = win inline {
        return Slider::create(target, handler, 1.f);
    }
    static Slider* create(cocos2d::CCNode* target, cocos2d::SEL_MenuHandler handler, float scale) = win inline {
        return Slider::create(target, handler, "sliderBar.png", "slidergroove.png", "sliderthumb.png", "sliderthumbsel.png", scale);
    }
    static Slider* create(cocos2d::CCNode* target, cocos2d::SEL_MenuHandler handler, char const* bar, char const* groove, char const* thumb, char const* thumbSel, float scale) = win 0x71770;

    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event);
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event);
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event);

    void disableSlider() = win inline {
        if (!m_enabled) return;
        m_enabled = false;
        m_touchLogic->setTouchEnabled(false);
        m_sliderBar->setColor({ 150, 150, 150 });
        m_groove->setColor({ 150, 150, 150 });
        if (auto normalImage = static_cast<cocos2d::CCSprite*>(m_touchLogic->m_thumb->getNormalImage())) {
            normalImage->setColor({ 150, 150, 150 });
        }
    }
    void disableTouch() = win inline {
        m_touchLogic->setTouchEnabled(false);
    }
    void enableSlider() = win inline {
        if (m_enabled) return;
        m_enabled = true;
        m_touchLogic->setTouchEnabled(true);
        m_sliderBar->setColor({ 255, 255, 255 });
        m_groove->setColor({ 255, 255, 255 });
        if (auto normalImage = static_cast<cocos2d::CCSprite*>(m_touchLogic->m_thumb->getNormalImage())) {
            normalImage->setColor({ 255, 255, 255 });
        }
    }
    bool getLiveDragging() = win inline {
        return m_touchLogic->m_activateThumb;
    }
    SliderThumb* getThumb() = win inline {
        return m_touchLogic->m_thumb;
    }
    float getValue() = win inline {
        return this->getThumb()->getValue();
    }
    void hideGroove(bool visibility) = win inline {
        m_groove->setVisible(!visibility);
    }
    bool init(cocos2d::CCNode* target, cocos2d::SEL_MenuHandler handler, char const* bar, char const* groove, char const* thumb, char const* thumbSel, float scale) = win 0x718a0;
    void setBarVisibility(bool visibility) = win inline {
        m_sliderBar->setVisible(visibility);
    }
    void setLiveDragging(bool activateThumb) = win inline, ios inline {
        m_touchLogic->m_activateThumb = activateThumb;
    }
    void setMaxOffset(float offset) = win 0x71e60;
    void setRotated(bool rotated) = win 0x71dc0;
    void setValue(float val) = win 0x71c50;
    void sliderBegan() = win inline, ios inline {
        if (m_delegate) m_delegate->sliderBegan(this);
    }
    void sliderEnded() = win inline, ios inline {
        if (m_delegate) m_delegate->sliderEnded(this);
    }
    void updateBar() = win 0x71ce0;

    SliderTouchLogic* m_touchLogic;
    cocos2d::CCSprite* m_sliderBar;
    cocos2d::CCSprite* m_groove;
    float m_width;
    float m_height;
    SliderDelegate* m_delegate;
    bool m_enabled;
}

[[link(android)]]
class SliderDelegate {
    virtual void sliderBegan(Slider* slider) {}
    virtual void sliderEnded(Slider* slider) {}
}

[[link(android)]]
class SliderThumb : cocos2d::CCMenuItemImage {
    // virtual ~SliderThumb();
    SliderThumb() {
        m_length = 0.f;
        m_vertical = false;
    }

    static SliderThumb* create(cocos2d::CCNode* target, cocos2d::SEL_MenuHandler selector, char const* normalFrame, char const* selectedFrame) = win inline {
        auto ret = new SliderThumb();
        if (ret->init(target, selector, normalFrame, selectedFrame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    float getValue() = win 0x71300;
    bool init(cocos2d::CCNode* target, cocos2d::SEL_MenuHandler selector, char const* normalFrame, char const* selectedFrame) = win inline, ios inline {
        m_length = 200.f;
        return cocos2d::CCMenuItemImage::initWithNormalImage(normalFrame, selectedFrame, nullptr, target, selector);
    }
    void setMaxOffset(float offset) = win inline {
        float value = getValue();
        m_length = offset;
        this->setPosition({0, 0});
        setValue(value);
    }
    void setRotated(bool rotated) = win inline {
        float value = getValue();
        m_vertical = rotated;
        this->setPosition({0, 0});
        setValue(value);
    }
    void setValue(float value) = win 0x71390;

    float m_length;
    bool m_vertical;
}

[[link(android), depends(SliderThumb)]]
class SliderTouchLogic : cocos2d::CCMenu {
    // virtual ~SliderTouchLogic();
    SliderTouchLogic() {}

    static SliderTouchLogic* create(cocos2d::CCNode* target, cocos2d::SEL_MenuHandler selector, char const* thumb, char const* thumbSel, float scale) = win inline {
        auto ret = new SliderTouchLogic();
        if (ret->init(target, selector, thumb, thumbSel, scale)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x71500;
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x715f0;
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x715b0;
    virtual void registerWithTouchDispatcher() = win 0x71720;

    bool init(cocos2d::CCNode* target, cocos2d::SEL_MenuHandler selector, char const* thumb, char const* thumbSel, float scale) = win inline {
        if (!cocos2d::CCMenu::init()) return false;
        m_rotated = false;
        m_length = scale * 200.f;
        this->setPosition({ 0.f, 0.f });
        m_thumb = SliderThumb::create(target, selector, thumb, thumbSel);
        this->addChild(m_thumb);
        m_thumb->setScale(scale);
        m_activateThumb = false;
        return true;
    }
    void setMaxOffset(float offset) = win inline, ios inline {
        float newOffset = m_thumb->getScale() * offset;
        m_length = newOffset;
        m_thumb->setMaxOffset(newOffset);
    }
    void setRotated(bool rotated) = win inline, ios inline {
        m_rotated = rotated;
        m_thumb->setRotated(rotated);
    }

    float m_unknownUnused;
    float m_length;
    SliderThumb* m_thumb;
    Slider* m_slider;
    bool m_activateThumb;
    cocos2d::CCPoint m_position;
    bool m_rotated;
}

[[link(android)]]
class SmartGameObject : GameObject {
    // virtual ~SmartGameObject();
    SmartGameObject() {
        m_referenceOnly = false;
    }

    static SmartGameObject* create(char const* frame) = win inline {
        auto ret = new SmartGameObject();
        if (ret->init(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x49f740;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x49f5d0;

    bool init(char const* frame) = win inline {
        if (!GameObject::init(frame)) return false;
        m_baseFrame = frame;
        m_classType = GameObjectClassType::Smart;
        m_bUnkBool2 = false;
        return true;
    }
    void updateSmartFrame() = win 0x49f3e0;

    // property 157
    bool m_referenceOnly;
    gd::string m_baseFrame;
    gd::string m_smartFrame;
}

[[link(android)]]
class SmartTemplateCell : TableViewCell {
    // virtual ~SmartTemplateCell();
    SmartTemplateCell(char const* identifier, float width, float height) = win inline, ios inline : TableViewCell(identifier, width, height) {
        this->init();
    }

    virtual bool init();
    virtual void draw() = win 0xade40;

    void loadFromObject(GJSmartTemplate* smartTemplate) = win 0xbe600;
    void onClick(cocos2d::CCObject* sender) = win 0xbeae0;
    void updateBGColor(int index);

    GJSmartTemplate* m_smartTemplate;
}

[[link(android)]]
class SongCell : TableViewCell {
    // virtual ~SongCell();
    SongCell(char const* identifier, float width, float height) = win inline, ios inline : TableViewCell(identifier, width, height) {
        this->init();
    }

    virtual bool init();
    virtual void draw() = win 0xade40;

    void loadFromObject(SongObject* object) = win 0xb4130;
    void onClick(cocos2d::CCObject* sender) = win 0xb4540;
    void updateBGColor(int index) = win inline {
        m_backgroundLayer->setColor(index % 2 == 0 ? cocos2d::ccColor3B { 161, 88, 44 } : cocos2d::ccColor3B { 194, 114, 62 });
        m_backgroundLayer->setOpacity(255);
    }

    SongObject* m_songObject;
}

[[link(android)]]
class SongInfoLayer : FLAlertLayer {
    // virtual ~SongInfoLayer();

    static SongInfoLayer* create(int artistID) = win 0x492090;
    static SongInfoLayer* create(gd::string songName, gd::string artistName, gd::string songURL, gd::string newgroundsURL, gd::string youtubeURL, gd::string facebookURL, int songID, gd::string songTags, int nongType) = win 0x4922a0;

    virtual void keyBackClicked() = win 0x846c0;

    bool init(gd::string songName, gd::string artistName, gd::string songURL, gd::string newgroundsURL, gd::string youtubeURL, gd::string facebookURL, int songID, gd::string songTags, int nongType);
    void onBPM(cocos2d::CCObject* sender);
    void onClose(cocos2d::CCObject* sender) = win 0x84690;
    void onDownload(cocos2d::CCObject* sender);
    void onFB(cocos2d::CCObject* sender);
    void onMenuMusic(cocos2d::CCObject* sender);
    void onNG(cocos2d::CCObject* sender);
    void onPracticeMusic(cocos2d::CCObject* sender);
    void onYT(cocos2d::CCObject* sender);
    void showCustomMusicUnlockInfo() = win 0x4938e0;

    gd::string m_downloadLink;
    gd::string m_newgroundsLink;
    gd::string m_youtubeLink;
    gd::string m_facebookLink;
    int m_songID;
    int m_musicCustomizerMessageIndex;
}

[[link(android)]]
class SongInfoObject : cocos2d::CCNode {
    // virtual ~SongInfoObject();

    static SongInfoObject* create(cocos2d::CCDictionary* dict);
    static SongInfoObject* create(int songID);
    static SongInfoObject* create(int songID, gd::string songName, gd::string artistName, int artistID, float filesize, gd::string youtubeVideo, gd::string youtubeChannel, gd::string url, int nongType, gd::string extraArtistIDs, bool isNew, int libraryOrder, int priority);
    static SongInfoObject* createWithCoder(DS_Dictionary* dict);

    virtual void encodeWithCoder(DS_Dictionary* dict);
    virtual bool canEncode() = win inline { return true; }

    void addTags(gd::string tags) = win 0x3469a0;
    bool containsTag(int tag) = win inline, ios inline {
        return m_tags.find(tag) != m_tags.end();
    }
    gd::string getArtistNames(int unused);
    gd::string getTagsString(bool shortTags) = win 0x346b90;
    bool init(int songID, gd::string songName, gd::string artistName, int artistID, float filesize, gd::string youtubeVideo, gd::string youtubeChannel, gd::string url, int nongType, gd::string extraArtistIDs, bool isNew, int libraryOrder, int priority);
    void updateArtists(gd::string artists) = win inline {
        m_extraArtists = artists;
        m_artistIDs.clear();
        if (m_extraArtists.empty()) return;
        std::vector<std::string> splitArtists;
        auto start = 0;
        auto index = artists.find_first_of(".");
        auto size = artists.size();
        while (index != std::string::npos) {
            auto str = artists.substr(start, index - start);
            if (!str.empty() || start != size) {
                splitArtists.push_back(str);
            }
            start = index + 1;
            index = artists.find_first_of(".", start);
        }
        for (auto& artistID : splitArtists) {
            m_artistIDs.insert(atoi(artistID.c_str()));
        }
    }

    int m_songID;
    gd::string m_songName;
    gd::string m_artistName;
    gd::string m_youtubeVideo;
    gd::string m_youtubeChannel;
    gd::string m_songUrl;
    int m_artistID;
    float m_fileSize;
    int m_nongType;
    gd::string m_extraArtists;
    bool m_isUnknownSong; //isUnloaded
    bool m_autoDownload; //isVerified
    bool m_isBlocked;
    int m_priority;
    int m_unkInt;
    int m_BPM;
    bool m_isNew;
    int m_libraryOrder;
    int m_songOrder;
    gd::string m_extraArtistNames;
    gd::unordered_set<int> m_artistIDs;
    gd::set<int> m_tags;
    gd::string m_longTagsString;
    gd::string m_shortTagsString;
}

[[link(android)]]
class SongObject : cocos2d::CCObject {
    // virtual ~SongObject();
    SongObject() {
        m_audioID = 0;
    }

    static SongObject* create(int audioID) = win inline {
        auto ret = new SongObject();
        if(ret->init(audioID)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init(int audioID) = win inline, ios inline {
        m_audioID = audioID;
        return true;
    }

    int m_audioID;
}

[[link(android)]]
class SongOptionsLayer : FLAlertLayer {
    // virtual ~SongOptionsLayer();
    SongOptionsLayer() {
        m_delegate = nullptr;
    }

    static SongOptionsLayer* create(CustomSongDelegate* delegate) = win inline {
        auto ret = new SongOptionsLayer();
        if (ret->init(delegate)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyBackClicked();

    bool init(CustomSongDelegate* delegate) = win 0xc45c0;
    void onClose(cocos2d::CCObject* sender) = win 0xc54f0;
    void onFadeIn(cocos2d::CCObject* sender);
    void onFadeOut(cocos2d::CCObject* sender);
    void onInfo(cocos2d::CCObject* sender) = win 0xc5390;
    void onPlayback(cocos2d::CCObject* sender) = win 0xc50d0;
    void onSongPersistent(cocos2d::CCObject* sender);
    void updatePlaybackBtn() = win inline {
        auto playbackSprite = static_cast<cocos2d::CCSprite*>(m_playbackButton->getNormalImage());
        if (FMODAudioEngine::sharedEngine()->isMusicPlaying(0)) {
            playbackSprite->setDisplayFrame(cocos2d::CCSpriteFrameCache::sharedSpriteFrameCache()->spriteFrameByName("GJ_stopMusicBtn_001.png"));
        } else {
            playbackSprite->setDisplayFrame(cocos2d::CCSpriteFrameCache::sharedSpriteFrameCache()->spriteFrameByName("GJ_playMusicBtn_001.png"));
        }
    }

    CustomSongDelegate* m_delegate;
    CCTextInputNode* m_offsetInput;
    CCMenuItemSpriteExtra* m_playbackButton;
}

[[link(android)]]
class SongPlaybackDelegate {
    virtual void onPlayback(SongInfoObject* object) {}
}

[[link(android)]]
class SongSelectNode : cocos2d::CCNode, FLAlertLayerProtocol, CustomSongLayerDelegate, CustomSongDelegate {
    // virtual ~SongSelectNode();

    static SongSelectNode* create(int id, bool customSong, LevelSettingsObject* settings, SongSelectType selectType, cocos2d::CCPoint position, cocos2d::CCNode* parent, cocos2d::CCMenu* menu, bool noLabel) = win 0xc6cc0;

    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0xc7d20;
    virtual void customSongLayerClosed() = win 0xc7db0;
    virtual void songIDChanged(int id) = win 0xc7de0;
    virtual int getActiveSongID();
    virtual gd::string getSongFileName() = win 0xc7e00;
    virtual LevelSettingsObject* getLevelSettings() = win 0xc7ec0;

    void audioNext(cocos2d::CCObject* sender) = win 0xc77f0;
    void audioPrevious(cocos2d::CCObject* sender) = win 0xc7830;
    bool init(int id, bool customSong, LevelSettingsObject* settings, SongSelectType selectType, cocos2d::CCPoint position, cocos2d::CCNode* parent, cocos2d::CCMenu* menu, bool noLabel) = win 0xc6df0;
    void onOpenCustomSong(cocos2d::CCObject* sender);
    void onSongMode(cocos2d::CCObject* sender);
    void onSongMode(int songMode) = win 0xc7890;
    void selectSong(int id) = win inline, ios inline {
        auto songID = id;
        if (songID > 21) songID = 21;
        m_songChanged = true;
        if (songID < 0) songID = 0;
        m_selectedSongID = songID;
        this->updateAudioLabel();
    }
    void showCustomSongSelect() = win 0xc7bc0, ios inline {
        auto layer = CustomSongLayer::create(this);
        layer->m_delegate = this;
        layer->show();
    }
    void updateAudioLabel() = win 0xc7700;
    void updateWidgetVisibility() = win 0xc7ab0;

    int m_selectedSongID;
    bool m_isCustomSong;
    bool m_songChanged;
    cocos2d::CCLabelBMFont* m_audioLabel;
    cocos2d::CCArray* m_selectSongObjects;
    cocos2d::CCArray* m_normalSongObjects;
    cocos2d::CCArray* m_changeSongObjects;
    CCMenuItemSpriteExtra* m_normalButton;
    CCMenuItemSpriteExtra* m_customButton;
    CCMenuItemSpriteExtra* m_selectButton;
    CCMenuItemSpriteExtra* m_changeButton;
    CustomSongWidget* m_songWidget;
    LevelSettingsObject* m_settingsObject;
}

[[link(android)]]
class SongsLayer : GJDropDownLayer {
    // virtual ~SongsLayer();

    static SongsLayer* create();

    virtual void customSetup() = win 0x4943c0;
}

[[link(android)]]
class SongTriggerGameObject : SFXTriggerGameObject {
    // virtual ~SongTriggerGameObject();
    SongTriggerGameObject() {
        m_unk7a9 = false;
        m_prep = false;
        m_loadPrep = false;
        m_songChannel = 0;
    }

    static SongTriggerGameObject* create(char const* frame) = win inline {
        auto ret = new SongTriggerGameObject();
        if (ret->init(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4b83e0;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x4b8180;

    bool init(char const* frame) = win inline, ios inline {
        return SFXTriggerGameObject::init(frame);
    }

    bool m_unk7a9;
    // property 399
    bool m_prep;
    // property 400
    bool m_loadPrep;
    // property 432
    int m_songChannel;
}

[[link(android)]]
class SpawnParticleGameObject : EffectGameObject {
    // virtual ~SpawnParticleGameObject();
    SpawnParticleGameObject() {
        m_matchRotation = false;
        m_rotation = 0.f;
        m_rotationVariance = 0.f;
        m_scale = 1.f;
        m_scaleVariance = 0.f;
    }

    static SpawnParticleGameObject* create() = win inline {
        auto ret = new SpawnParticleGameObject();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init();
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4c3890;
    virtual gd::string getSaveString(GJBaseGameLayer* layer);

    // property 547, property 548
    cocos2d::CCPoint m_offset;
    // property 549, property 550
    cocos2d::CCPoint m_offsetVariance;
    // property 551
    bool m_matchRotation;
    // property 552
    float m_rotation;
    // property 553
    float m_rotationVariance;
    // property 554
    float m_scale;
    // property 555
    float m_scaleVariance;
}

[[link(android)]]
class SpawnTriggerAction {
    SpawnTriggerAction() {}
    SpawnTriggerAction(GameObject* object, float delay, gd::vector<int> const& remapKeys, int uniqueID, int controlID) {
        m_finished = false;
        m_disabled = false;
        m_duration = delay;
        m_deltaTime = 0.0;
        m_targetGroupID = 0;
        m_triggerUniqueID = uniqueID;
        m_controlID = controlID;
        m_spawnOrdered = false;
        m_gameObject = object;
        m_remapKeys = remapKeys;
    }
    SpawnTriggerAction(int targetID, float delay, bool spawnOrdered, gd::vector<int> const& remapKeys, int uniqueID, int controlID) {
        m_finished = false;
        m_disabled = false;
        m_duration = delay;
        m_deltaTime = 0.0;
        m_targetGroupID = targetID;
        m_triggerUniqueID = uniqueID;
        m_controlID = controlID;
        m_spawnOrdered = spawnOrdered;
        m_gameObject = nullptr;
        m_remapKeys = remapKeys;
    }

    bool isFinished() = win inline, ios inline {
        return m_finished;
    }
    void step(float dt) = win inline, ios inline {
        if (m_finished || m_disabled) return;
        m_deltaTime += dt;
        m_finished = m_deltaTime >= m_duration;
    }

    bool m_finished;
    bool m_disabled;
    double m_duration;
    double m_deltaTime;
    int m_targetGroupID;
    int m_triggerUniqueID;
    int m_controlID;
    bool m_spawnOrdered;
    GameObject* m_gameObject;
    gd::vector<int> m_remapKeys;
}

[[link(android), depends(ChanceObject)]]
class SpawnTriggerGameObject : EffectGameObject {
    // virtual ~SpawnTriggerGameObject();
    SpawnTriggerGameObject() {
        m_remapKey = 0;
        m_currentDelay = 0.0;
        m_spawnDelay = 0.f;
        m_delayRange = 0.f;
        m_resetRemap = false;
    }

    static SpawnTriggerGameObject* create() = win inline {
        auto ret = new SpawnTriggerGameObject();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init();
    virtual void triggerObject(GJBaseGameLayer* layer, int uniqueID, gd::vector<int> const* remapKeys) = win 0x4b8e80;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4b91f0;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x4b9530;

    void addRemap(int oldID, int newID) = win inline {
        for (auto& obj : m_remapObjects) {
            if (obj.m_groupID == oldID && obj.m_chance == newID) return;
        }
        m_remapObjects.emplace_back(oldID, newID);
    }
    void changeRemap(int oldID, int newID, bool reverse) = win 0x4b8fa0;
    void removeRemap(int oldID, int newID) = win inline {
        for (int i = 0; i < m_remapObjects.size(); i++) {
            auto& obj = m_remapObjects[i];
            if (obj.m_groupID == oldID && obj.m_chance == newID) {
                m_remapObjects.erase(m_remapObjects.begin() + i);
                return;
            }
        }
    }
    void updateRemapKeys(gd::vector<int> const& remapKeys) = win 0x4b8d80;

    // property 442
    gd::vector<ChanceObject> m_remapObjects;
    int m_remapKey;
    gd::vector<int> m_remapKeys;
    double m_currentDelay;
    // property 63
    float m_spawnDelay;
    // property 556
    float m_delayRange;
    // property 581
    bool m_resetRemap;
}

[[link(android)]]
class SpecialAnimGameObject : EnhancedGameObject {
    // virtual ~SpecialAnimGameObject();
    SpecialAnimGameObject() {
        m_skipMainColorUpdate = false;
        m_skipSecondaryColorUpdate = false;
    }

    static SpecialAnimGameObject* create(char const* frame) = win inline {
        auto ret = new SpecialAnimGameObject();
        if (ret->init(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void resetObject();
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists);
    virtual gd::string getSaveString(GJBaseGameLayer* layer);
    virtual void updateMainColor(cocos2d::ccColor3B const& color);
    virtual void updateSecondaryColor(cocos2d::ccColor3B const& color);
    virtual void updateSyncedAnimation(float totalTime, int frameIndex) = win 0x1a9980;

    bool init(char const* frame) = win inline, ios inline {
        if (!EnhancedGameObject::init(frame)) return false;
        m_bUnkBool2 = false;
        return true;
    }

    bool m_skipMainColorUpdate;
    bool m_skipSecondaryColorUpdate;
}

[[link(android)]]
class SpriteAnimationManager : cocos2d::CCNode {
    SpriteAnimationManager() {
        m_sprite = nullptr;
        m_priorityDict = nullptr;
        m_typeDict = nullptr;
        m_soundDict = nullptr;
        m_frameDict = nullptr;
    }
    ~SpriteAnimationManager() = win inline {
        CC_SAFE_RELEASE(m_frameDict);
        CC_SAFE_RELEASE(m_priorityDict);
        CC_SAFE_RELEASE(m_typeDict);
        CC_SAFE_RELEASE(m_soundDict);
        CC_SAFE_RELEASE(m_animateDict);
    }

    static void createAnimations(gd::string definition) = win 0x72ff0;
    static SpriteAnimationManager* createWithOwner(CCAnimatedSprite* sprite, gd::string definition) = win inline {
        auto ret = new SpriteAnimationManager();
        if (ret->initWithOwner(sprite, definition)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    void animationFinished() = win 0x74640;
    void callAnimationFinished() = win 0x74690;
    void doCleanup() = win inline {
        m_frameDict->removeAllObjects();
        this->release();
    }
    void executeAnimation(gd::string animation) = win 0x73f80;
    void finishAnimation(gd::string animation) = win inline, ios inline {
        if (m_queuedAnimation == animation) m_queuedAnimation = "not_used";
        if (m_currentAnimation == animation) this->runQueuedAnimation();
    }
    spriteMode getAnimType(gd::string animation) = win inline {
        return (spriteMode)m_typeDict->valueForKey(animation)->intValue();
    }
    int getPrio(gd::string animation) = win 0x74770;
    bool initWithOwner(CCAnimatedSprite* sprite, gd::string definition) = win 0x723b0;
    void loadAnimations(gd::string definition) = win 0x72620;
    void offsetCurrentAnimation(float dt) = win inline {
        if (auto action = static_cast<cocos2d::CCActionInterval*>(m_sprite->m_sprite->getActionByTag(1))) {
            if (action->getM_bFirstTick()) action->step(0.f);
            action->step(dt);
        }
    }
    void overridePrio() = win 0x74470;
    void playSound(gd::string sound) = win inline, ios inline {}
    void playSoundForAnimation(gd::string animation) = win inline {
        if (auto sound = static_cast<cocos2d::CCString*>(m_soundDict->objectForKey(animation))) {
            auto delay = static_cast<cocos2d::CCString*>(m_soundDict->objectForKey(cocos2d::CCString::createWithFormat("%s%s", animation.c_str(), "delay")->getCString()))->floatValue();
            if (delay == 0.f) this->playSound(sound->getCString());
        }
    }
    void queueAnimation(gd::string animation) = win 0x74560;
    void resetAnimState() = win inline, ios inline {
        m_queuedAnimation = "not_used";
        m_nextAnimation = "not_used";
    }
    void runAnimation(gd::string animation) = win 0x73e20;
    void runQueuedAnimation() = win inline, ios inline {
        if (m_queuedAnimation != "not_used") {
            this->executeAnimation(m_queuedAnimation);
            m_queuedAnimation = "not_used";
        }
    }
    void stopAnimations() = win inline {
        this->overridePrio();
        if (m_sprite->m_paSprite) m_sprite->m_paSprite->stopAllActions();
        if (m_sprite->m_fbfSprite) m_sprite->m_fbfSprite->stopAllActions();
    }
    void storeAnimation(cocos2d::CCAnimate* action, cocos2d::CCAnimate* frames, gd::string name, int priority, spriteMode type, cocos2d::CCSpriteFrame* first) = win 0x73bb0;
    void storeSoundForAnimation(cocos2d::CCString* sound, gd::string animation, float delay) = win inline {
        m_soundDict->setObject(sound, animation);
        m_soundDict->setObject(cocos2d::CCString::createWithFormat("%f", delay), animation);
    }
    void switchToFirstFrameOfAnimation(gd::string animation) = win inline, ios inline {
        if (m_frameDict->objectForKey(animation)->getObjType() == (cocos2d::CCObjectType)0) {
            m_sprite->switchToMode(this->getAnimType(animation));
            auto frame = static_cast<cocos2d::CCSpriteFrame*>(m_frameDict->objectForKey(cocos2d::CCString::createWithFormat("%s_first", animation.c_str())->getCString()));
            auto type = (int)frame->getObjType();
            if (type == 1 || type == 2) m_sprite->m_sprite->setDisplayFrame(frame);
        }
    }
    void updateAnimationSpeed(float speed) = win inline {
        cocos2d::CCDictElement* element;
        cocos2d::CCDictElement* temp;
        if (m_animateDict) HASH_ITER(hh, m_animateDict->m_pElements, element, temp) {
            if (element->getObject()->getObjType() == (cocos2d::CCObjectType)0) {
                static_cast<cocos2d::CCAnimate*>(element->getObject())->setSpeedMod(speed);
            }
        }
    }

    CCAnimatedSprite* m_sprite;
    cocos2d::CCDictionary* m_priorityDict;
    cocos2d::CCDictionary* m_typeDict;
    cocos2d::CCDictionary* m_soundDict;
    gd::string m_queuedAnimation;
    float m_speed;
    cocos2d::CCDictionary* m_animateDict;
    cocos2d::CCDictionary* m_frameDict;
    gd::string m_currentAnimation;
    gd::string m_nextAnimation;
}

[[link(android)]]
class SpriteDescription : cocos2d::CCObject {
    SpriteDescription() {
        m_rotation = 0;
        m_zValue = 0;
        m_tag = 0;
        m_usesCustomTag = false;
        m_texture = nullptr;
    }
    ~SpriteDescription() = win inline {
        CC_SAFE_RELEASE(m_texture);
    }

    static SpriteDescription* createDescription(DS_Dictionary* dict) = win inline {
        auto ret = new SpriteDescription();
        if (ret->initDescription(dict)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static SpriteDescription* createDescription(cocos2d::CCDictionary* dict) = win inline {
        auto ret = new SpriteDescription();
        if (ret->initDescription(dict)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool initDescription(DS_Dictionary* dict) = win 0x41d80;
    bool initDescription(cocos2d::CCDictionary* dict) = win inline {
        m_position = cocos2d::CCPointFromString(dict->valueForKey("position")->getCString());
        m_scale = cocos2d::CCPointFromString(dict->valueForKey("scale")->getCString());
        m_flipped = cocos2d::CCPointFromString(dict->valueForKey("flipped")->getCString());
        m_rotation = dict->valueForKey("rotation")->floatValue();
        m_zValue = dict->valueForKey("zValue")->intValue();
        m_tag = dict->valueForKey("tag")->intValue();
        m_usesCustomTag = dict->valueForKey("usesCustomTag")->boolValue();
        if (m_usesCustomTag) {
            auto frameName = dict->valueForKey("texture")->getCString();
            m_texture = cocos2d::CCSpriteFrameCache::sharedSpriteFrameCache()->spriteFrameByName(frameName);
            m_texture->retain();
            m_texture->setFrameName(frameName);
        }
        return true;
    }

    cocos2d::CCPoint m_position;
    cocos2d::CCPoint m_scale;
    cocos2d::CCPoint m_flipped;
    float m_rotation;
    int m_zValue;
    int m_tag;
    bool m_usesCustomTag;
    cocos2d::CCSpriteFrame* m_texture;
}

[[link(android)]]
class SpritePartDelegate {
    virtual void displayFrameChanged(cocos2d::CCObject* sprite, gd::string frameName) {}
}

[[link(android)]]
class StarInfoPopup : FLAlertLayer {
    // virtual ~StarInfoPopup();

    static StarInfoPopup* create(int autos, int easies, int normals, int hards, int harders, int insanes, int dailies, int gauntlets, int maps, bool platformer) = win 0x3c7d00;
    static StarInfoPopup* createFromString(gd::string str);
    static StarInfoPopup* createFromStringMoons(gd::string str);

    virtual void keyBackClicked() = win 0x846c0;

    bool init(int autos, int easies, int normals, int hards, int harders, int insanes, int dailies, int gauntlets, int maps, bool platformer) = win 0x3c7e40;
    void onClose(cocos2d::CCObject* sender) = win 0x84690;
}

[[link(android)]]
class StartPosObject : EffectGameObject {
    StartPosObject() {
        m_startSettings = nullptr;
    }
    ~StartPosObject() = win inline {
        CC_SAFE_RELEASE(m_startSettings);
    }

    static StartPosObject* create() = win inline {
        auto ret = new StartPosObject();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x4b1c30;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists);
    virtual gd::string getSaveString(GJBaseGameLayer* layer);

    void loadSettingsFromString(gd::string objectString) = win 0x4b1cf0;
    void setSettings(LevelSettingsObject* settings) = win inline {
        if (settings == m_startSettings) return;
        CC_SAFE_RETAIN(settings);
        CC_SAFE_RELEASE(m_startSettings);
        m_startSettings = settings;
    }

    LevelSettingsObject* m_startSettings;
}

[[link(android)]]
class StatsCell : TableViewCell {
    // virtual ~StatsCell();
    StatsCell(char const* identifier, float width, float height) = win inline, ios inline : TableViewCell(identifier, width, height) {
        this->init();
    }

    virtual bool init() = win inline { return true; }
    virtual void draw() = win 0xade40;

    const char* getTitleFromKey(char const* key) = win 0xb3030;
    void loadFromObject(StatsObject* object) = win 0xb2dd0;
    void updateBGColor(int index) = win inline {
        m_backgroundLayer->setColor(index % 2 == 0 ? cocos2d::ccColor3B { 161, 88, 44 } : cocos2d::ccColor3B { 194, 114, 62 });
    }
}

[[link(android)]]
class StatsLayer : GJDropDownLayer {
    // virtual ~StatsLayer();
    StatsLayer() {}

    static StatsLayer* create() = win inline {
        auto ret = new StatsLayer();
        if(ret->init("Stats", 220.f, false)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void customSetup() = win 0x4c78e0;
}

[[link(android)]]
class StatsObject : cocos2d::CCObject {
    // virtual ~StatsObject();

    static StatsObject* create(char const* key, int value) = win 0xb2c70;

    bool init(char const* key, int value) = win inline {
        m_key = cocos2d::CCString::create(key)->getCString();
        m_value = value;
        return true;
    }

    const char* m_key;
    int m_value;
}

[[link(android)]]
class SupportLayer : GJDropDownLayer, FLAlertLayerProtocol, UploadActionDelegate, UploadPopupDelegate {
    SupportLayer() {
        m_uploadPopup = nullptr;
    }
    ~SupportLayer() = win inline {
        auto glm = GameLevelManager::sharedState();
        if (glm->m_uploadActionDelegate == this) glm->m_uploadActionDelegate = nullptr;
    }

    static SupportLayer* create() = win inline {
        auto ret = new SupportLayer();
        if (ret->init("Support", 220.f, false)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void customSetup() = win 0x4c81f0;
    virtual void uploadActionFinished(int id, int response);
    virtual void uploadActionFailed(int id, int response) = win 0x4c9960;
    virtual void onClosePopup(UploadActionPopup* popup);
    virtual void FLAlert_Clicked(FLAlertLayer* layer, bool btn2) = win 0x4ca5e0;

    CCMenuItemToggler* createToggleButton(gd::string text, cocos2d::SEL_MenuHandler selector, bool toggled, cocos2d::CCMenu* menu, cocos2d::CCPoint position, cocos2d::CCArray* nodes) = win 0x4c8db0;
    void exitLayer() = win inline, ios inline {
        GJDropDownLayer::exitLayer(nullptr);
    }
    void onCocos2d(cocos2d::CCObject* sender);
    void onEmail(cocos2d::CCObject* sender) = win 0x4c9c80;
    void onGetReward(cocos2d::CCObject* sender) = win 0x4c9600;
    void onLinks(cocos2d::CCObject* sender);
    void onLowDetail(cocos2d::CCObject* sender) = win 0x4c99f0;
    void onPrivacy(cocos2d::CCObject* sender);
    void onRequestAccess(cocos2d::CCObject* sender) = win 0x4c9510;
    void onRobTop(cocos2d::CCObject* sender);
    void onSFX(cocos2d::CCObject* sender);
    void onTOS(cocos2d::CCObject* sender);
    void sendSupportMail() = win inline {
        PlatformToolbox::sendMail("Geometry Dash Support", cocos2d::CCString::createWithFormat(
            "\n\nGame: %s"
            "\n\nUserID: %s"
            "\n\nAccount: %s"
            "\n\nPlatform: %i"
            "\n\nVersion: %i - %i",
            "Geometry Dash",
            GameManager::sharedState()->m_playerUDID.c_str(),
            GJAccountManager::sharedState()->m_username.c_str(),
            (int)AppDelegate::get()->m_ios,
            22,
            45
        )->getCString(), "support@robtopgames.com");
    }

    UploadActionPopup* m_uploadPopup;
}

[[link(android), depends(CCIndexPath)]]
class TableView : CCScrollLayerExt, CCScrollLayerExtDelegate {
    TableView(cocos2d::CCRect rect) = win inline : CCScrollLayerExt(rect) {
        m_tableDelegate = nullptr;
        m_dataSource = nullptr;
        m_cellDelegate = nullptr;
        m_unused2 = false;
        this->setTouchEnabled(true);
        this->setMouseEnabled(true);
        m_vScrollbarVisible = false;
        m_hScrollbarVisible = false;
        m_disableHorizontal = false;
        m_unused3 = nullptr;
        m_delegate = this;
        m_touchOutOfBoundary = false;
        m_cellRemovedArray = cocos2d::CCArray::create();
        m_cellRemovedArray->retain();
        m_cellArray = cocos2d::CCArray::create();
        m_cellArray->retain();
        m_indexPathArray = cocos2d::CCArray::create();
        m_indexPathArray->retain();
        m_touchLastY = 0.f;
        m_cancellingTouches = false;
        m_idk2 = false;
    }
    ~TableView() = win inline {
        CCNode::removeAllChildrenWithCleanup(true);
        m_cellRemovedArray->removeAllObjects();
        CC_SAFE_DELETE(m_cellRemovedArray);
        m_cellArray->removeAllObjects();
        CC_SAFE_DELETE(m_cellArray);
        m_indexPathArray->removeAllObjects();
        CC_SAFE_DELETE(m_indexPathArray);
    }

    static TableView* create(TableViewDelegate* tvd, TableViewDataSource* tvds, TableViewCellDelegate* tvcd, cocos2d::CCRect rect) = win inline {
        auto ret = new TableView(rect);
        ret->m_tableDelegate = tvd;
        ret->m_dataSource = tvds;
        ret->m_cellDelegate = tvcd;
        ret->setPosition({ 0.f, 0.f });
        ret->autorelease();
        return ret;
    }

    virtual void onEnter();
    virtual void onExit();
    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x752a0;
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x75530;
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event);
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x754b0;
    virtual void registerWithTouchDispatcher() = win 0x3e610;
    virtual void scrollWheel(float y, float x) = win 0x75ae0;
    virtual void scrllViewWillBeginDecelerating(CCScrollLayerExt* layer) = win inline {}
    virtual void scrollViewDidEndDecelerating(CCScrollLayerExt* layer) = win inline {}
    virtual void scrollViewTouchMoving(CCScrollLayerExt* layer) = win inline {}
    virtual void scrollViewDidEndMoving(CCScrollLayerExt* layer) = win inline {}

    void cancelAndStoleTouch(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win inline {
        auto touches = new cocos2d::CCSet();
        touches->addObject(touch);
        touches->autorelease();
        m_cancellingTouches = true;
        cocos2d::CCDirector::sharedDirector()->getTouchDispatcher()->touchesCancelled(touches, event);
        m_cancellingTouches = false;
        this->claimTouch(touch);
    }
    TableViewCell* cellForRowAtIndexPath(CCIndexPath& path) = win inline, ios inline {
        for (int i = 0; i < m_cellArray->count(); i++) {
            auto cell = static_cast<TableViewCell*>(m_cellArray->objectAtIndex(i));
            if (cell->m_indexPath.m_row == path.m_row && cell->m_indexPath.m_section == path.m_section) {
                return cell;
            }
        }
        return nullptr;
    }
    TableViewCell* cellForTouch(cocos2d::CCTouch* touch) = win inline {
        auto location = cocos2d::CCDirector::sharedDirector()->convertToGL(touch->getLocationInView());
        if (!m_cellArray || m_cellArray->count() == 0) return nullptr;
        for (int i = 0; i < m_cellArray->count(); i++) {
            auto cell = static_cast<TableViewCell*>(m_cellArray->objectAtIndex(i));
            auto cellBox = cocos2d::CCRect {
                cell->getPosition().x - cell->getAnchorPoint().x * cell->getContentSize().width,
                cell->getPosition().y - cell->getAnchorPoint().y * cell->getContentSize().height,
                cell->getContentSize().width,
                cell->getContentSize().height
            };
            cellBox.origin.x = 0.f;
            cellBox.origin.y = 0.f;
            if (cellBox.containsPoint(location)) return cell;
        }
        return nullptr;
    }
    int checkBoundaryOfCell(TableViewCell* cell) = win 0x75bc0;
    int checkBoundaryOfCell(cocos2d::CCPoint& position, float height) = win 0x75ce0;
    void checkBoundaryOfContent(float dt) = win 0x75de0;
    void checkFirstCell(TableViewCell* cell) = win 0x763a0;
    void checkLastCell(TableViewCell* cell) = win 0x76650;
    void claimTouch(cocos2d::CCTouch* touch) = win inline {
        auto handler = static_cast<cocos2d::CCTargetedTouchHandler*>(cocos2d::CCDirector::sharedDirector()->getTouchDispatcher()->findHandler(this));
        if (!handler->getClaimedTouches()->containsObject(touch)) {
            handler->getClaimedTouches()->addObject(touch);
        }
    }
    void deleteTableViewCell(TableViewCell* cell) = win 0x74aa0;
    bool dequeueReusableCellWithIdentifier(char const* identifier) = win inline {
        return false;
    }
    void initTableViewCells();
    bool isDuplicateIndexPath(CCIndexPath& path) = win 0x74a00;
    bool isDuplicateInVisibleCellArray(CCIndexPath* path) = win 0x74970;
    void reloadData() = win 0x74d50;
    bool removeIndexPathFromPathAddedArray(CCIndexPath& path) = win inline {
        if (!m_indexPathArray || m_indexPathArray->count() == 0) return false;
        for (int i = 0; i < m_indexPathArray->count(); i++) {
            auto indexPath = static_cast<CCIndexPath*>(m_indexPathArray->objectAtIndex(i));
            if (indexPath->m_row == path.m_row && indexPath->m_section == path.m_section) {
                m_indexPathArray->removeObject(indexPath);
                return true;
            }
        }
        return false;
    }
    void scrollToIndexPath(CCIndexPath& path) = win inline, ios inline {}
    void touchFinish(cocos2d::CCTouch* touch) = win 0x757f0;

    bool m_touchOutOfBoundary; //isScheduled
    cocos2d::CCTouch* m_touchStart; //beginTouch
    cocos2d::CCPoint m_touchStartPosition2; //beginLocation
    cocos2d::CCPoint m_lastCellPos;
    cocos2d::CCPoint m_touchPosition2; //checkLocation
    TableViewCell* m_touchedCell; //touchCell
    bool m_touchMoved;
    bool m_isTouch;
    cocos2d::CCArray* m_cellArray; //cellVisibleArray
    cocos2d::CCArray* m_cellRemovedArray;
    cocos2d::CCArray* m_indexPathArray;
    TableViewDelegate* m_tableDelegate;
    TableViewDataSource* m_dataSource;
    TableViewCellDelegate* m_cellDelegate;
    bool m_unused2;
    void* m_unused3;
    int m_unused4;
    float m_touchLastY;
    bool m_cancellingTouches;
    bool m_idk2;
}

[[link(android), depends(CCIndexPath)]]
class TableViewCell : cocos2d::CCLayer {
    TableViewCell(char const* identifier, float width, float height) = win 0x76b20;
    ~TableViewCell() = win 0x76d80;

    void updateVisibility() = win inline {
        if (!m_tableView) return;
        auto height = this->getContentSize().height;
        auto tableHeight = m_tableView->getContentSize().height;
        auto y = this->getPosition().y + this->getParent()->getPosition().y;
        this->setVisible(tableHeight >= y && y >= -height);
    }

    void* m_unknown;
    TableView* m_tableView;
    CCIndexPath m_indexPath;
    void* m_unknown2;
    gd::string m_cellIdentifier;
    float m_width;
    float m_height;
    cocos2d::CCLayerColor* m_backgroundLayer;
    cocos2d::CCLayer* m_mainLayer;
    BoomListType m_listType;
}

[[link(android)]]
class TableViewCellDelegate {
    virtual bool cellPerformedAction(TableViewCell* cell, int listType, CellAction action, cocos2d::CCNode* parent) { return false; }
    virtual int getSelectedCellIdx() { return 0; }
    virtual bool shouldSnapToSelected() { return true; }
    virtual int getCellDelegateType() { return 0; }
}

[[link(android)]]
class TableViewDataSource {
    virtual int numberOfRowsInSection(unsigned int section, TableView* tableView) { return 0; }
    virtual unsigned int numberOfSectionsInTableView(TableView* tableView) { return 0; }
    virtual void TableViewCommitCellEditingStyleForRowAtIndexPath(TableView* tableView, TableViewCellEditingStyle style, CCIndexPath& indexPath) {}
    virtual TableViewCell* cellForRowAtIndexPath(CCIndexPath& indexPath, TableView* tableView) { return nullptr; }
}

[[link(android)]]
class TableViewDelegate {
    virtual void willTweenToIndexPath(CCIndexPath& indexPath, TableViewCell* cell, TableView* tableView) {}
    virtual void didEndTweenToIndexPath(CCIndexPath& indexPath, TableView* tableView) {}
    virtual void TableViewWillDisplayCellForRowAtIndexPath(CCIndexPath& indexPath, TableViewCell* cell, TableView* tableView) {}
    virtual void TableViewDidDisplayCellForRowAtIndexPath(CCIndexPath& indexPath, TableViewCell* cell, TableView* tableView) {}
    virtual void TableViewWillReloadCellForRowAtIndexPath(CCIndexPath& indexPath, TableViewCell* cell, TableView* tableView) {}
    virtual float cellHeightForRowAtIndexPath(CCIndexPath& indexPath, TableView* tableView) { return 0; }
    virtual void didSelectRowAtIndexPath(CCIndexPath& indexPath, TableView* tableView) {}
}

[[link(android)]]
class TeleportPortalObject : RingObject {
    // virtual ~TeleportPortalObject();
    TeleportPortalObject() {
        m_orangePortal = nullptr;
        m_isYellowPortal = false;
        m_teleportYOffset = 0.f;
        m_teleportEase = false;
        m_staticForceEnabled = false;
        m_staticForce = 0.f;
        m_redirectForceEnabled = false;
        m_redirectForceMod = 1.f;
        m_redirectForceMin = 0.f;
        m_redirectForceMax = 0.f;
        m_saveOffset = false;
        m_ignoreX = false;
        m_ignoreY = false;
        m_gravityMode = 0;
        m_staticForceAdditive = false;
        m_instantCamera = false;
        m_snapGround = false;
        m_redirectDash = false;
    }

    static TeleportPortalObject* create(char const* frame, bool trigger) = win 0x4b1e50;

    virtual void setPosition(cocos2d::CCPoint const& position) = win 0x4b2030;
    virtual void setRotation(float rotation) = win 0x4b21b0;
    virtual void setStartPos(cocos2d::CCPoint position) = win 0x4b1f70;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists);
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x4b23a0;
    virtual int addToGroup(int id) = win 0x4b2260;
    virtual void removeFromGroup(int id) = win 0x4b2310;
    virtual void setRotation2(float rotation);
    virtual void addToGroup2(int id);
    virtual void removeFromGroup2(int id);

    float getTeleportXOff(cocos2d::CCNode* parent) = win 0x4b20d0;
    bool init(char const* frame, bool trigger) = win inline, ios inline {
        if (!EffectGameObject::init(frame)) return false;
        if (!trigger) m_isTouchTriggered = true;
        return true;
    }
    void setPositionOverride(cocos2d::CCPoint position) = win inline, ios inline {
        return GameObject::setPosition(position);
    }
    void setStartPosOverride(cocos2d::CCPoint position) = win inline, ios inline {
        return GameObject::setStartPos(position);
    }

    TeleportPortalObject* m_orangePortal;
    bool m_isYellowPortal;
    float m_teleportYOffset;
    // property 55
    bool m_teleportEase;
    // property 345
    bool m_staticForceEnabled;
    // property 346
    float m_staticForce;
    // property 347
    bool m_redirectForceEnabled;
    // property 350
    float m_redirectForceMod;
    // property 348
    float m_redirectForceMin;
    // property 349
    float m_redirectForceMax;
    // property 351
    bool m_saveOffset;
    // property 352
    bool m_ignoreX;
    // property 353
    bool m_ignoreY;
    // property 354
    int m_gravityMode;
    // property 443
    bool m_staticForceAdditive;
    // property 464
    bool m_instantCamera;
    // property 510
    bool m_snapGround;
    // property 591
    bool m_redirectDash;
    cocos2d::CCPoint m_teleportPosition;
}

[[link(android)]]
class TextAlertPopup : cocos2d::CCNode {
    // virtual ~TextAlertPopup();

    static TextAlertPopup* create(gd::string text, float delay, float scale, int opacity, gd::string font) = win 0x29d960;

    bool init(gd::string text, float delay, float scale, int opacity, gd::string font) = win 0x29da90;
    void setAlertPosition(cocos2d::CCPoint windowOffset, cocos2d::CCPoint pointOffset) = win inline {
        if (!m_label) return;

        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        this->setPosition({
            windowOffset.x * winSize.width + m_width / 2 + pointOffset.x,
            windowOffset.y * winSize.height + m_height / 2 + pointOffset.y
        });
    }
    void setLabelColor(cocos2d::ccColor3B color) = win inline {
        if (m_label) m_label->setColor(color);
    }

    float m_width;
    float m_height;
    cocos2d::CCLabelBMFont* m_label;
}

[[link(android)]]
class TextArea : cocos2d::CCSprite {
    // virtual ~TextArea();
    // TextArea();

    static TextArea* create(gd::string str, char const* font, float scale, float width, cocos2d::CCPoint anchor, float lineHeight, bool disableColor) = win 0x76ea0;

    virtual void update(float dt) = win 0x77700;
    virtual void draw() = win inline {}
    virtual void setOpacity(unsigned char opacity) = win 0x77610;

    void colorAllCharactersTo(cocos2d::ccColor3B color) = win 0x77650;
    void colorAllLabels(cocos2d::ccColor3B color) = win inline {
        auto lines = m_label->m_lines;
        for (int i = 0; i < lines->count(); i++) {
            static_cast<cocos2d::CCLabelBMFont*>(lines->objectAtIndex(i))->setColor(color);
        }
    }
    float fadeIn(float duration, bool unused) = win inline, ios inline {
        this->stopAllActions();
        this->stopAllCharacterActions();
        this->setOpacity(0);
        this->runAction(cocos2d::CCSequence::create(
            cocos2d::CCFadeIn::create(duration),
            cocos2d::CCDelayTime::create(duration),
            cocos2d::CCCallFunc::create(this, callfunc_selector(TextArea::finishFade)),
            nullptr
        ));
        return duration;
    }
    float fadeInCharacters(float duration, float charDuration, bool fadeOut, TextFadeInStyle style) = win 0x778e0;
    void fadeOut(float duration) = win inline, ios inline {
        this->stopAllActions();
        this->stopAllCharacterActions();
        this->runAction(cocos2d::CCActionTween::create(duration, "opacity", this->getOpacity(), 0.f));
    }
    void fadeOutAndRemove() = win inline, ios inline {
        this->fadeOut(.3f);
        this->runAction(cocos2d::CCSequence::create(
            cocos2d::CCDelayTime::create(.3f),
            cocos2d::CCCallFunc::create(this, callfunc_selector(cocos2d::CCNode::removeMeAndCleanup)),
            nullptr
        ));
    }
    void finishFade() = win 0x775f0;
    void hideAll() = win inline, ios inline {
        this->stopAllCharacterActions();
        this->setOpacity(0);
    }
    bool init(gd::string str, char const* font, float scale, float width, cocos2d::CCPoint anchor, float lineHeight, bool disableColor) = win inline {
        if (!cocos2d::CCSprite::init()) return false;
        m_width = width;
        m_anchorPoint = anchor;
        m_fontFile = font;
        m_scale = scale;
        m_height = lineHeight;
        m_disableColor = disableColor;
        this->setString(str);
        return true;
    }
    void setIgnoreColorCode(bool ignore) = win inline, ios inline {
        m_disableColor = ignore;
        if (m_label) m_label->m_disableColor = ignore;
    }
    void setString(gd::string text) = win 0x770e0;
    void showAll() = win inline {
        this->stopAllCharacterActions();
        this->setOpacity(255);
        m_allShown = true;
    }
    void stopAllCharacterActions() = win 0x77530;

    bool m_disableColor;
    MultilineBitmapFont* m_label;
    float m_width;
    float m_unknown;
    gd::string m_fontFile;
    float m_height;
    bool m_unkBool;
    cocos2d::CCPoint m_anchorPoint;
    bool m_allShown;
    float m_scale;
    int m_rectHeight;
    int m_rectWidth;
    float m_maxWidth;
    cocos2d::CCPoint m_unkPoint;
    TextAreaDelegate* m_delegate;
    cocos2d::CCDictionary* m_shakeCharacters;
    float m_shakeElapsed;
}

[[link(android)]]
class TextAreaDelegate {
    virtual void fadeInTextFinished(TextArea* textArea) {}
}

[[link(android)]]
class TextGameObject : GameObject {
    // virtual ~TextGameObject();
    TextGameObject() {
        m_kerning = 0;
    }

    static TextGameObject* create(cocos2d::CCTexture2D* texture) = win 0x1a74f0;

    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x1a7980;
    virtual gd::string getSaveString(GJBaseGameLayer* layer) = win 0x1a7b40;
    virtual void updateTextKerning(int kerning);
    virtual int getTextKerning();

    bool init(cocos2d::CCTexture2D* texture) = win inline, ios inline {
        return GameObject::initWithTexture(texture);
    }
    void updateTextObject(gd::string text, bool defaultFont) = win 0x1a75e0;

    // property 31
    gd::string m_text;
    // property 488
    int m_kerning;
}

[[link(android)]]
class TextInputDelegate {
    virtual void textChanged(CCTextInputNode* node) {}
    virtual void textInputOpened(CCTextInputNode* node) {}
    virtual void textInputClosed(CCTextInputNode* node) {}
    virtual void textInputShouldOffset(CCTextInputNode* node, float yOffset) {}
    virtual void textInputReturn(CCTextInputNode* node) {}
    virtual bool allowTextInput(CCTextInputNode* node) { return true; }
    virtual void enterPressed(CCTextInputNode* node) {}
}

[[link(android)]]
class TextStyleSection : cocos2d::CCObject {
    // virtual ~TextStyleSection();

    static TextStyleSection* create(int start, int end, TextStyleType type) = win 0x6d860;
    static TextStyleSection* createColoredSection(cocos2d::ccColor3B color, int start, int end) = win inline, ios inline {
        auto ret = TextStyleSection::create(start, end, TextStyleType::Colored);
        ret->m_color = color;
        return ret;
    }
    static TextStyleSection* createDelaySection(int start, float delay) = win inline, ios inline {
        auto ret = TextStyleSection::create(start, -1, TextStyleType::Delayed);
        ret->m_delay = delay;
        return ret;
    }
    static TextStyleSection* createInstantSection(int start, int end, float duration) = win inline, ios inline {
        auto ret = TextStyleSection::create(start, end, TextStyleType::Instant);
        ret->m_instantTime = duration;
        return ret;
    }
    static TextStyleSection* createShakeSection(int start, int end, int intensity, int perSecond) = win inline, ios inline {
        auto ret = TextStyleSection::create(start, end, TextStyleType::Shake);
        ret->m_shakeIntensity = intensity;
        ret->m_shakesPerSecond = perSecond;
        return ret;
    }

    bool init(int start, int end, TextStyleType type) = win inline, ios inline {
        m_styleType = type;
        m_startIndex = start;
        m_endIndex = end;
        return true;
    }

    TextStyleType m_styleType;
    int m_startIndex;
    int m_endIndex;
    cocos2d::ccColor3B m_color;
    float m_instantTime;
    float m_delay;
    int m_shakeIntensity;
    int m_shakesPerSecond;
}

[[link(android)]]
class TimerTriggerAction {
    TimerTriggerAction() {}
    TimerTriggerAction(int targetID, float targetTime, bool multiActivate, int itemID, gd::vector<int> const& remapKeys, int uniqueID, int controlID) {
        m_disabled = false;
        m_time = 0.f;
        m_targetTime = targetTime;
        m_targetGroupID = targetID;
        m_triggerUniqueID = uniqueID;
        m_controlID = controlID;
        m_itemID = itemID;
        m_multiActivate = multiActivate;
        m_remapKeys = remapKeys;
    }

    bool m_disabled;
    float m_time;
    float m_targetTime;
    int m_targetGroupID;
    int m_triggerUniqueID;
    int m_controlID;
    int m_itemID;
    bool m_multiActivate;
    gd::vector<int> m_remapKeys;
}

[[link(android)]]
class TimerTriggerGameObject : EffectGameObject {
    // virtual ~TimerTriggerGameObject();
    TimerTriggerGameObject() {
        m_startTime = 0.0;
        m_targetTime = 0.0;
        m_stopTimeEnabled = false;
        m_dontOverride = false;
        m_ignoreTimeWarp = false;
        m_timeMod = 1.f;
        m_startPaused = false;
        m_multiActivate = false;
        m_controlType = 0;
    }

    static TimerTriggerGameObject* create(char const* frame) = win inline {
        auto ret = new TimerTriggerGameObject();
        if (ret->init(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void triggerObject(GJBaseGameLayer* layer, int uniqueID, gd::vector<int> const* remapKeys) = win 0x4bee70;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4bf650;
    virtual gd::string getSaveString(GJBaseGameLayer* layer);

    bool init(char const* frame) = win inline, ios inline {
        return EffectGameObject::init(frame);
    }

    // property 467
    double m_startTime;
    // property 473
    double m_targetTime;
    // property 474
    bool m_stopTimeEnabled;
    // property 468
    bool m_dontOverride;
    // property 469
    bool m_ignoreTimeWarp;
    // property 470
    float m_timeMod;
    // property 471
    bool m_startPaused;
    // property 475
    bool m_multiActivate;
    // property 472
    int m_controlType;
}

[[link(android)]]
class ToggleTriggerAction {
    ToggleTriggerAction() {}
    ToggleTriggerAction(int targetID, bool activateGroup, gd::vector<int> const& remapKeys, int uniqueID, int controlID) {
        m_disabled = false;
        m_targetGroupID = targetID;
        m_activateGroup = activateGroup;
        m_triggerUniqueID = uniqueID;
        m_controlID = controlID;
        m_remapKeys = remapKeys;
    }

    bool m_disabled;
    int m_targetGroupID;
    bool m_activateGroup;
    int m_triggerUniqueID;
    int m_controlID;
    gd::vector<int> m_remapKeys;
}

[[link(android)]]
class TopArtistsLayer : FLAlertLayer, OnlineListDelegate {
    TopArtistsLayer() {
        m_topArtists = nullptr;
        m_listLayer = nullptr;
        m_loadingCircle = nullptr;
        m_page = 0;
    }
    ~TopArtistsLayer() = win inline {
        auto glm = GameLevelManager::sharedState();
        if (glm->m_onlineListDelegate == this) glm->m_onlineListDelegate = nullptr;
    }

    static TopArtistsLayer* create() = win inline {
        auto ret = new TopArtistsLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x4ca8a0;
    virtual void registerWithTouchDispatcher() = win 0x42660;
    virtual void keyBackClicked() = win 0x846c0;
    virtual void show();
    virtual void loadListFinished(cocos2d::CCArray* objects, char const* key) = win 0x4cb040;
    virtual void loadListFailed(char const* key) = win 0x4cb0a0;
    virtual void setupPageInfo(gd::string info, char const* key) = win 0x4cb200;

    bool isCorrect(char const* key) = win inline, ios inline {
        return true;
    }
    void loadPage(int page) = win 0x4cb3e0;
    void onClose(cocos2d::CCObject* sender) = win 0x84690;
    void onNextPage(cocos2d::CCObject* sender) = win 0x4cb850;
    void onPrevPage(cocos2d::CCObject* sender) = win 0x4cb860;
    void setupLeaderboard(cocos2d::CCArray* artists) = win 0x4cb0b0;
    void updateLevelsLabel() = win inline {
        auto end = m_pageEndIdx + m_pageStartIdx;
        auto count = m_itemCount;
        if (end > count) end = count;
        m_pageInfoLabel->setString(cocos2d::CCString::createWithFormat("%i to %i of %i", m_pageStartIdx + 1, end, count)->getCString());
        m_pageInfoLabel->limitLabelWidth(100.f, .5f, .0f);
    }

    cocos2d::CCArray* m_topArtists;
    GJCommentListLayer* m_listLayer;
    LoadingCircle* m_loadingCircle;
    CCMenuItemSpriteExtra* m_nextButton;
    CCMenuItemSpriteExtra* m_prevButton;
    void* m_unkPtr;
    cocos2d::CCLabelBMFont* m_pageInfoLabel;
    int m_itemCount;
    int m_pageStartIdx;
    int m_pageEndIdx;
    int m_unkSize4;
    int m_page;
}

[[link(android)]]
class TOSPopup : FLAlertLayer {
    // virtual ~TOSPopup();
    TOSPopup() {}

    static TOSPopup* create() = win inline {
        auto ret = new TOSPopup();
        if(ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x29ddf0;
    virtual void keyBackClicked() = win inline {}

    void onClose(cocos2d::CCObject* sender);
    void onPrivacy(cocos2d::CCObject* sender);
    void onTOS(cocos2d::CCObject* sender);
}

[[link(android)]]
class TouchToggleAction {
    TouchToggleAction() {}
    TouchToggleAction(int targetID, bool holdMode, TouchTriggerType touchType, TouchTriggerControl touchControl, bool dualMode, gd::vector<int> const& remapKeys, int uniqueID, int controlID) {
        m_disabled = false;
        m_targetGroupID = targetID;
        m_holdMode = holdMode;
        m_touchTriggerType = touchType;
        m_touchTriggerControl = touchControl;
        m_triggerUniqueID = uniqueID;
        m_controlID = controlID;
        m_dualMode = dualMode;
        m_remapKeys = remapKeys;
    }

    bool m_disabled;
    int m_targetGroupID;
    bool m_holdMode;
    TouchTriggerType m_touchTriggerType;
    TouchTriggerControl m_touchTriggerControl;
    int m_triggerUniqueID;
    int m_controlID;
    bool m_dualMode;
    gd::vector<int> m_remapKeys;
}

[[link(android)]]
class TransformTriggerGameObject : EffectGameObject {
    // virtual ~TransformTriggerGameObject();
    TransformTriggerGameObject() {
        m_objectScaleX = 1.f;
        m_objectScaleY = 1.f;
        m_property450 = 0.f;
        m_property451 = 0.f;
        m_onlyMove = false;
        m_divideX = false;
        m_divideY = false;
        m_relativeRotation = false;
        m_relativeScale = false;
    }

    static TransformTriggerGameObject* create(char const* frame) = win inline {
        auto ret = new TransformTriggerGameObject();
        if (ret->init(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void triggerObject(GJBaseGameLayer* layer, int uniqueID, gd::vector<int> const* remapKeys) = win 0x4bbe10;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists);
    virtual gd::string getSaveString(GJBaseGameLayer* layer);

    bool init(char const* frame) = win inline, ios inline {
        return EffectGameObject::init(frame);
    }

    // property 150
    float m_objectScaleX;
    // property 151
    float m_objectScaleY;
    // property 450
    float m_property450;
    // property 451
    float m_property451;
    // property 133
    bool m_onlyMove;
    // property 153
    bool m_divideX;
    // property 154
    bool m_divideY;
    // property 452
    bool m_relativeRotation;
    // property 577
    bool m_relativeScale;
}

[[link(android)]]
class TriggerControlGameObject : EffectGameObject {
    // virtual ~TriggerControlGameObject();
    TriggerControlGameObject() {
        m_customTriggerValue = GJActionCommand::Stop;
    }

    static TriggerControlGameObject* create(char const* frame) = win inline {
        auto ret = new TriggerControlGameObject();
        if (ret->init(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void triggerObject(GJBaseGameLayer* layer, int uniqueID, gd::vector<int> const* remapKeys) = win 0x4c2fb0;
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists) = win 0x4c2ec0;
    virtual gd::string getSaveString(GJBaseGameLayer* layer);

    bool init(char const* frame) = win inline {
        m_triggerControlFrame = frame;
        return EffectGameObject::init(frame);
    }
    void updateTriggerControlFrame() = win 0x4c2fe0;

    gd::string m_triggerControlFrame;
    // property 580 (The type of a stop trigger for example)
    GJActionCommand m_customTriggerValue;
}

[[link(android)]]
class TriggerEffectDelegate {
    virtual void toggleGroupTriggered(int group, bool activate, gd::vector<int> const& remapKeys, int triggerID, int controlID) {}
    virtual void spawnGroup(int group, bool ordered, double delay, gd::vector<int> const& remapKeys, int triggerID, int controlID) {}
    virtual void spawnObject(GameObject* object, double delay, gd::vector<int> const& remapKeys) {}
}

[[link(android)]]
class TutorialLayer : FLAlertLayer {
    // virtual ~TutorialLayer();

    static TutorialLayer* create() = win 0x4cb920;

    virtual bool init() = win 0x4cba30;
    virtual void keyBackClicked();

    void loadPage(int page) = win 0x4cbfa0;
    void onClose(cocos2d::CCObject* sender) = win 0x4cc5d0;
    void onNext(cocos2d::CCObject* sender) = win 0x4cbf80;
    void removeTutorialTexture() = win inline {
        if (m_page == 0) return;
        cocos2d::CCTextureCache::sharedTextureCache()->removeTextureForKey(cocos2d::CCString::createWithFormat("tutorial_%02d", m_page)->getCString());
    }

    cocos2d::CCLayer* m_tutorialLayer;
    int m_page;
    CCMenuItemSpriteExtra* m_nextButton;
    CCMenuItemSpriteExtra* m_exitButton;
}

[[link(android)]]
class TutorialPopup : FLAlertLayer {
    // virtual ~TutorialPopup();

    static TutorialPopup* create(gd::string frame);

    virtual void keyBackClicked();
    virtual void show();

    void animateMenu();
    void closeTutorial(cocos2d::CCObject* sender);
    bool init(gd::string frame);
    void registerForCallback(cocos2d::SEL_MenuHandler selector, cocos2d::CCNode* target);

    gd::string m_currentSprite;
    bool m_callbackRegistered;
    cocos2d::SEL_MenuHandler m_callbackSelector;
    cocos2d::CCNode* m_targetNode;
    CCMenuItemSpriteExtra* m_closeButton;
}

[[link(android)]]
class UIButtonConfig {
    void reset() = win 0x17aa30 {
        m_width = 280;
        m_height = 120;
        m_deadzone = 0.f;
        m_scale = 1.f;
        m_opacity = 255;
        m_radius = 10.f;
        m_modeB = false;
        m_position.x = 95.f;
        m_position.y = 36.f;
        m_oneButton = false;
        m_player2 = false;
        m_snap = false;
        m_split = false;
    }
    void resetOneBtn() = win 0x17aaa0 {
        this->reset();
        m_width = 200;
        m_height = 200;
        m_position.x = 95.f;
        m_position.y = 196.f;
        m_oneButton = true;
    }

    int m_width;
    int m_height;
    float m_deadzone;
    float m_scale;
    int m_opacity;
    float m_radius;
    bool m_modeB;
    bool m_snap;
    cocos2d::CCPoint m_position;
    bool m_oneButton;
    bool m_player2;
    bool m_split;
}

[[link(android)]]
class UILayer : cocos2d::CCLayerColor {
    UILayer() {
        m_pUnknown1 = nullptr;
        m_checkpointMenu = nullptr;
        m_pauseBtn = nullptr;
        m_bUnknown2 = false;
        m_bUnknown3 = false;
        m_p1Jumping = false;
        m_p2Jumping = false;
        m_checkpointBtnDown = false;
        m_p1TouchId = -1;
        m_p2TouchId = -1;
        m_clkTimer = 0.f;
        m_inPlatformer = false;
        m_gameLayer = nullptr;
        m_initialized = false;
        m_uiNodes = nullptr;
        m_dualMode = false;
        m_dpadType = false;
        m_editorMode = false;
        m_controllerButtons = nullptr;
    }
    ~UILayer() = win inline {
        CC_SAFE_RELEASE(m_uiNodes);
        CC_SAFE_RELEASE(m_controllerButtons);
    }

    static UILayer* create(GJBaseGameLayer* layer) = win inline {
        auto ret = new UILayer();
        if (ret->init(layer)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static UILayer* get() {
        if (auto gjbgl = GJBaseGameLayer::get()) return gjbgl->m_uiLayer;
        return nullptr;
    }

    virtual void draw() = win inline {}
    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event);
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x4ce040;
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event);
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event);
    virtual void registerWithTouchDispatcher() = win 0x9b7f0;
    virtual void keyBackClicked() = win 0x4cdad0;
    virtual void keyDown(cocos2d::enumKeyCodes key);
    virtual void keyUp(cocos2d::enumKeyCodes key);

    void disableMenu() = win inline {
        m_pauseBtn->setEnabled(false);
    }
    void doPause() = win inline {
        m_p1TouchId = -1;
        m_p2TouchId = -1;
        this->resetUINodeState();
        if (auto playLayer = GameManager::sharedState()->m_playLayer) {
            playLayer->pauseGame(false);
            playLayer->m_gameState.m_pauseCounter++;
        }
    }
    void editorPlaytest(bool visible) = win inline {
        this->resetAllButtons();
        this->toggleMenuVisibility(visible);
        this->setVisible(visible);
        cocos2d::CCEGLView::sharedOpenGLView()->toggleGameplayActive(false);
    }
    void enableEditorMode() = win inline {
        m_editorMode = true;
        m_pauseBtn->setVisible(false);
        this->disableMenu();
        this->editorPlaytest(false);
    }
    void enableMenu() = win inline {
        m_pauseBtn->setEnabled(true);
    }
    void handleKeypress(cocos2d::enumKeyCodes key, bool down);
    bool init(GJBaseGameLayer* layer) = win 0x4cc790;
    bool isJumpButtonPressed(bool player1) = win inline {
        return player1 ? (m_p2TouchId != -1 || m_p1Jumping) : (m_p1TouchId != -1 || m_p2Jumping);
    }
    void onCheck(cocos2d::CCObject* sender);
    void onDeleteCheck(cocos2d::CCObject* sender);
    void onPause(cocos2d::CCObject* sender);
    bool processUINodesTouch(GJUITouchEvent event, cocos2d::CCTouch* touch);
    bool processUINodeTouch(GJUITouchEvent event, int touchID, cocos2d::CCPoint position, GJUINode* node) = win 0x4ce210;
    void refreshDpad() = win inline {}
    void resetAllButtons() = win inline {
        m_p1Jumping = false;
        m_p2Jumping = false;
        m_checkpointBtnDown = false;
        m_p1TouchId = -1;
        m_p2TouchId = -1;
        this->resetUINodeState();
    }
    void resetUINodeState() = win 0x4cd350;
    void toggleCheckpointsMenu(bool visible) = win 0x4cdb10;
    void toggleMenuVisibility(bool visible) = win inline {
        this->resetUINodeState();
        if (GameManager::sharedState()->getGameVariable("0024")) {
            static_cast<cocos2d::CCNodeRGBA*>(m_pauseBtn->getNormalImage())->setOpacity(visible ? 75 : 0);
            this->updateUINodeVisibility(visible && m_inPlatformer);
        }
    }
    void togglePlatformerMode(bool platformer);
    void updateCheckState() = win 0x4cd0b0;
    void updateDualMode(bool dual) = win inline {
        if (m_dualMode == dual) return;
        m_dualMode = dual;
        this->togglePlatformerMode(m_inPlatformer);
    }
    void updateUINodeVisibility(bool visible);

    // This member is here because rob managed to inhert CCKeyboardDelegate twice
    // in this class, which ended up breaking addresser when trying to hook it.
    // so instead, we removed the second CCKeyboardDelegate from the base class list
    // and put this member here to take the place of its vtable
    void* m_stupidDelegate;
    void* m_pUnknown1;
    cocos2d::CCMenu* m_checkpointMenu;
    CCMenuItemSpriteExtra* m_pauseBtn;
    bool m_bUnknown2;
    bool m_bUnknown3;
    bool m_p1Jumping;
    bool m_p2Jumping;
    bool m_checkpointBtnDown;
    int m_p1TouchId;
    int m_p2TouchId;
    float m_clkTimer;
    bool m_inPlatformer;
    GJBaseGameLayer* m_gameLayer;
    bool m_initialized;
    cocos2d::CCArray* m_uiNodes;
    bool m_dualMode;
    bool m_dpadType;
    bool m_editorMode;
    cocos2d::CCArray* m_controllerButtons;
}

[[link(android)]]
class UIObjectSettingsPopup : SetupTriggerPopup {
    // virtual ~UIObjectSettingsPopup();

    static UIObjectSettingsPopup* create(UISettingsGameObject* object, cocos2d::CCArray* objects);

    virtual void onCustomToggleTriggerValue(cocos2d::CCObject* sender) = win 0x46a160;

    bool init(UISettingsGameObject* object, cocos2d::CCArray* objects) = win 0x469620;
}

[[link(android)]]
class UIOptionsLayer : SetupTriggerPopup {
    // virtual ~UIOptionsLayer();

    static UIOptionsLayer* create(bool dual) = win 0x2a0b00;

    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x2a3b60;
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x2a3cb0;
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x2a3de0;
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event);
    virtual void registerWithTouchDispatcher() = win 0x9b7f0;
    virtual void onClose(cocos2d::CCObject* sender) = win 0x2a2c40;
    virtual void valueDidChange(int tag, float value) = win 0x2a3040;
    virtual float getValue(int tag) = win 0x2a37c0;

    GJUINode* getNode(int type) = win inline, ios inline {
        switch (type) {
            case 0: return m_uiNode1;
            case 1: return m_uiNode2;
            case 2: return m_uiNode3;
            case 3: return m_uiNode4;
            default: return nullptr;
        }
    }
    bool init(bool dual) = win 0x2a0c40;
    void onReset(cocos2d::CCObject* sender) = win 0x2a2f30;
    void onSaveLoad(cocos2d::CCObject* sender) = win 0x2a2b10;
    void toggleUIGroup(int group) = win 0x2a2950;

    bool m_dual;
    GJUINode* m_uiNode1;
    GJUINode* m_uiNode2;
    GJUINode* m_uiNode3;
    GJUINode* m_uiNode4;
    cocos2d::CCLabelBMFont* m_nameLabel;
    int m_activeUIGroup;
}

[[link(android)]]
class UIPOptionsLayer : SetupTriggerPopup {
    // virtual ~UIPOptionsLayer();
    UIPOptionsLayer() {
        m_touchID = -1;
        m_practiceNode = nullptr;
    }

    static UIPOptionsLayer* create() = win inline {
        auto ret = new UIPOptionsLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init() = win 0x2a5690;
    virtual bool ccTouchBegan(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x2a6000;
    virtual void ccTouchMoved(cocos2d::CCTouch* touch, cocos2d::CCEvent* event) = win 0x2a6110;
    virtual void ccTouchEnded(cocos2d::CCTouch* touch, cocos2d::CCEvent* event);
    virtual void ccTouchCancelled(cocos2d::CCTouch* touch, cocos2d::CCEvent* event);
    virtual void registerWithTouchDispatcher() = win 0x9b7f0;
    virtual void onClose(cocos2d::CCObject* sender);
    virtual void valueDidChange(int tag, float value) = win 0x2a5ea0;
    virtual float getValue(int tag) = win 0x2a5fa0;

    cocos2d::CCRect getTouchRect() = win inline {
        return { m_practiceNode->getPosition() - cocos2d::CCPoint { 70.0f, 25.0f }, { 140.0f, 50.0f } };
    }
    void onReset(cocos2d::CCObject* sender) = win 0x2a5d80;

    int m_touchID;
    cocos2d::CCNode* m_practiceNode;
    cocos2d::CCPoint m_touchPosition;
    cocos2d::CCPoint m_touchDelta;
}

[[link(android)]]
class UISaveLoadLayer : SetupTriggerPopup {
    // virtual ~UISaveLoadLayer();
    UISaveLoadLayer() {
        m_optionsLayer = nullptr;
    }

    static UISaveLoadLayer* create(UIOptionsLayer* layer) = win inline {
        auto ret = new UISaveLoadLayer();
        if (ret->init(layer)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init(UIOptionsLayer* layer) = win 0x2a3e60;
    void onLoad(cocos2d::CCObject* sender);
    void onSave(cocos2d::CCObject* sender);

    UIOptionsLayer* m_optionsLayer;
}

[[link(android)]]
class UISettingsGameObject : EffectGameObject {
    // virtual ~UISettingsGameObject();
    UISettingsGameObject() {
        m_xRef = 0;
        m_yRef = 0;
        m_xRelative = false;
        m_yRelative = false;
    }

    static UISettingsGameObject* create() = win inline {
        auto ret = new UISettingsGameObject();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual bool init();
    virtual void customObjectSetup(gd::vector<gd::string>& values, gd::vector<void*>& exists);
    virtual gd::string getSaveString(GJBaseGameLayer* layer);

    // property 385
    int m_xRef;
    // property 386
    int m_yRef;
    // property 387
    bool m_xRelative;
    // property 388
    bool m_yRelative;
}

[[link(android), depends(GJTransformState)]]
class UndoObject : cocos2d::CCObject {
    UndoObject() {
        m_objectCopy = nullptr;
        m_command = (UndoCommand)0;
        m_objects = nullptr;
        m_redo = false;
        m_undoTransform = false;
    }
    ~UndoObject() = win inline {
        CC_SAFE_RELEASE(m_objectCopy);
        CC_SAFE_RELEASE(m_objects);
    }

    static UndoObject* create(GameObject* object, UndoCommand command) = win inline {
        auto ret = new UndoObject();
        if (ret->init(object, command)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static UndoObject* createWithArray(cocos2d::CCArray* array, UndoCommand command) = win inline {
        auto ret = new UndoObject();
        if (ret->init(array, command)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }
    static UndoObject* createWithTransformObjects(cocos2d::CCArray* objects, UndoCommand command) = win inline {
        auto ret = new UndoObject();
        if (ret->initWithTransformObjects(objects, command)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    bool init(GameObject* object, UndoCommand command) = win inline, ios inline {
        if (object) {
            m_objectCopy = GameObjectCopy::create(object);
            m_objectCopy->retain();
        }
        m_command = command;
        return true;
    }
    bool init(cocos2d::CCArray* array, UndoCommand command) = win inline {
        if (array) {
            m_objects = cocos2d::CCArray::create();
            m_objects->addObjectsFromArray(array);
            m_objects->retain();
        }
        m_command = command;
        return true;
    }
    bool initWithTransformObjects(cocos2d::CCArray* objects, UndoCommand command) = win inline {
        m_objects = cocos2d::CCArray::create();
        for (int i = 0; i < objects->count(); i++) {
            m_objects->addObject(GameObjectCopy::create(static_cast<GameObject*>(objects->objectAtIndex(i))));
        }
        m_objects->retain();
        m_command = command;
        return true;
    }
    void setObjects(cocos2d::CCArray* objects) = win inline {
        if (m_objects != objects) {
            CC_SAFE_RETAIN(objects);
            CC_SAFE_RELEASE(m_objects);
            m_objects = objects;
        }
    }

    GameObjectCopy* m_objectCopy;
    UndoCommand m_command;
    cocos2d::CCArray* m_objects;
    bool m_redo;
    bool m_undoTransform;
    GJTransformState m_transformState;
}

[[link(android)]]
class UpdateAccountSettingsPopup : FLAlertLayer, GJAccountSettingsDelegate {
    UpdateAccountSettingsPopup() {
        m_updateSuccess = false;
        m_textArea = nullptr;
        m_loadingCircle = nullptr;
        m_closeButton = nullptr;
    }
    ~UpdateAccountSettingsPopup() = win inline {
        auto gjam = GJAccountManager::sharedState();
        if (gjam->m_accountSettingsDelegate == this) gjam->m_accountSettingsDelegate = nullptr;
    }

    static UpdateAccountSettingsPopup* create(GJAccountSettingsLayer* settingsLayer, int messageStatus, int friendStatus, int commentStatus, gd::string youtubeURL, gd::string twitterURL, gd::string twitchURL) = win inline {
        auto ret = new UpdateAccountSettingsPopup();
        if (ret->init(settingsLayer, messageStatus, friendStatus, commentStatus, youtubeURL, twitterURL, twitchURL)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyBackClicked();
    virtual void updateSettingsFinished() = win 0x294d90;
    virtual void updateSettingsFailed() = win 0x294e90;

    bool init(GJAccountSettingsLayer* settingsLayer, int messageStatus, int friendStatus, int commentStatus, gd::string youtubeURL, gd::string twitterURL, gd::string twitchURL);
    void onClose(cocos2d::CCObject* sender);

    bool m_updateSuccess;
    GJAccountSettingsLayer* m_settingsLayer;
    TextArea* m_textArea;
    LoadingCircle* m_loadingCircle;
    CCMenuItemSpriteExtra* m_closeButton;
}

[[link(android)]]
class UploadActionDelegate {
    virtual void uploadActionFinished(int id, int response) {}
    virtual void uploadActionFailed(int id, int response) {}
}

[[link(android)]]
class UploadActionPopup : FLAlertLayer {
    // virtual ~UploadActionPopup();

    static UploadActionPopup* create(UploadPopupDelegate* delegate, gd::string str) = win 0x294fe0;

    virtual void keyBackClicked() = win 0x2957e0;

    void closePopup() = win inline {
        this->setKeypadEnabled(false);
        this->removeFromParentAndCleanup(true);
    }
    bool init(UploadPopupDelegate* delegate, gd::string str) = win 0x295120;
    void onClose(cocos2d::CCObject* sender) = win 0x295790;
    void showFailMessage(gd::string message) = win 0x295690;
    void showSuccessMessage(gd::string message) = win 0x295580;

    UploadPopupDelegate* m_delegate;
    TextArea* m_textArea;
    LoadingCircle* m_loadingCircle;
    CCMenuItemSpriteExtra* m_closeButton;
    bool m_succeeded;
}

[[link(android)]]
class UploadListPopup : FLAlertLayer, ListUploadDelegate {
    UploadListPopup() {
        m_levelList = nullptr;
        m_textArea = nullptr;
        m_loadingCircle = nullptr;
        m_backButton = nullptr;
    }
    ~UploadListPopup() = win inline {
        CC_SAFE_RELEASE(m_levelList);
        auto glm = GameLevelManager::sharedState();
        if (glm->m_listUploadDelegate == this) glm->m_listUploadDelegate = nullptr;
    }

    static UploadListPopup* create(GJLevelList* list) = win inline {
        auto ret = new UploadListPopup();
        if (ret->init(list)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyBackClicked() = win inline {}
    virtual void show() = win 0x30b9f0;
    virtual void listUploadFinished(GJLevelList* list);
    virtual void listUploadFailed(GJLevelList* list, int response) = win 0x30b660;

    bool init(GJLevelList* list) = win 0x30af50;
    void onBack(cocos2d::CCObject* sender) = win 0x30ba50;
    void onClose(cocos2d::CCObject* sender) = win 0x84690;
    void onReturnToList(cocos2d::CCObject* sender) = win 0x30b9a0;

    GJLevelList* m_levelList;
    TextArea* m_textArea;
    LoadingCircle* m_loadingCircle;
    CCMenuItemSpriteExtra* m_backButton;
}

[[link(android)]]
class UploadMessageDelegate {
    virtual void uploadMessageFinished(int accountID) {}
    virtual void uploadMessageFailed(int accountID) {}
}

[[link(android)]]
class UploadPopup : FLAlertLayer, LevelUploadDelegate {
    UploadPopup() {
        m_level = nullptr;
        m_textArea = nullptr;
        m_loadingCircle = nullptr;
        m_backButton = nullptr;
    }
    ~UploadPopup() = win inline {
        CC_SAFE_RELEASE(m_level);
        auto glm = GameLevelManager::sharedState();
        if (glm->m_levelUploadDelegate == this) glm->m_levelUploadDelegate = nullptr;
    }

    static UploadPopup* create(GJGameLevel* level) = win inline {
        auto ret = new UploadPopup();
        if (ret->init(level)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

    virtual void keyBackClicked() = win inline {}
    virtual void show() = win 0x30b9f0;
    virtual void levelUploadFinished(GJGameLevel* level);
    virtual void levelUploadFailed(GJGameLevel* level) = win 0x490a50;

    bool init(GJGameLevel* level) = win 0x4902b0;
    void onBack(cocos2d::CCObject* sender) = win 0x490d20;
    void onClose(cocos2d::CCObject* sender) = win 0x84690;
    void onReturnToLevel(cocos2d::CCObject* sender) = win 0x490c30;

    GJGameLevel* m_level;
    TextArea* m_textArea;
    LoadingCircle* m_loadingCircle;
    CCMenuItemSpriteExtra* m_backButton;
}

[[link(android)]]
class UploadPopupDelegate {
    virtual void onClosePopup(UploadActionPopup* popup) {}
}

[[link(android)]]
class URLCell : TableViewCell {
    // virtual ~URLCell();
    URLCell(char const* identifier, float width, float height) = win inline, ios inline : TableViewCell(identifier, width, height) {
        this->init();
    }

    virtual bool init();
    virtual void draw() = win 0xade40;

    void loadFromObject(CCURLObject* object) = win 0xc0270;
    void onURL(cocos2d::CCObject* sender) = win 0xc04a0;
    void updateBGColor(int index) = win inline {
        m_backgroundLayer->setColor(index % 2 == 0 ? cocos2d::ccColor3B { 161, 88, 44 } : cocos2d::ccColor3B { 194, 114, 62 });
        m_backgroundLayer->setOpacity(255);
    }

    CCURLObject* m_urlObject;
}

[[link(android)]]
class URLViewLayer : GJDropDownLayer {
    // virtual ~URLViewLayer();

    static URLViewLayer* create(gd::string title, cocos2d::CCArray* objects) = win 0x2a48d0;

    bool init(gd::string title, cocos2d::CCArray* objects) = win inline {
        if (!GJDropDownLayer::init(title.c_str())) return false;
        if (objects) {
            m_urlObjects = objects;
            objects->retain();
        }
        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        auto listView = CustomListView::create(m_urlObjects, nullptr, 220.f, 356.f, 0, BoomListType::URL, 0.f);
        listView->setTag(9);
        m_listLayer->addChild(listView, 6);
        return true;
    }

    cocos2d::CCArray* m_urlObjects;
}

[[link(android)]]
class UserInfoDelegate {
    virtual void getUserInfoFinished(GJUserScore* score) {}
    virtual void getUserInfoFailed(int id) {}
    virtual void userInfoChanged(GJUserScore* score) {}
}

[[link(android)]]
class UserListDelegate {
    virtual void getUserListFinished(cocos2d::CCArray* scores, UserListType type) {}
    virtual void getUserListFailed(UserListType type, GJErrorCode errorType) {}
    virtual void userListChanged(cocos2d::CCArray* scores, UserListType type) {}
    virtual void forceReloadList(UserListType type) {}
}

[[link(android)]]
class VideoOptionsLayer : FLAlertLayer {
    // virtual ~VideoOptionsLayer();

    static VideoOptionsLayer* create() = win 0x376770;

    virtual bool init() = win 0x376890;
    virtual void keyBackClicked();

    CCMenuItemToggler* createToggleButton(gd::string label, cocos2d::SEL_MenuHandler selector, bool toggled, cocos2d::CCMenu* menu, cocos2d::CCPoint position, float scale, float width, bool center, cocos2d::CCArray* nodes) = win 0x378710;
    void onAdvanced(cocos2d::CCObject* sender) = win 0x377bd0;
    void onApply(cocos2d::CCObject* sender) = win 0x3781c0;
    void onBorderless(cocos2d::CCObject* sender) = win 0x377d20;
    void onBorderlessFix(cocos2d::CCObject* sender);
    void onClose(cocos2d::CCObject* sender);
    void onFullscreen(cocos2d::CCObject* sender) = win 0x377d00;
    void onInfo(cocos2d::CCObject* sender) = win inline, ios inline {
        FLAlertLayer::create(
            nullptr,
            "Video Options",
            "No info yet",
            "OK",
            nullptr,
            360.f
        )->show();
    }
    void onResolutionNext(cocos2d::CCObject* sender);
    void onResolutionPrev(cocos2d::CCObject* sender);
    void onTextureQualityNext(cocos2d::CCObject* sender);
    void onTextureQualityPrev(cocos2d::CCObject* sender);
    void reloadMenu() = win inline, ios inline {
        cocos2d::CCDirector::sharedDirector()->replaceScene(MenuLayer::scene(true));
    }
    void toggleResolution() = win 0x377f60;
    void updateResolution(int resolution) = win 0x377e50;
    void updateTextureQuality(int quality) = win 0x377d80;

    CCMenuItemSpriteExtra* m_prevResolutionBtn;
    CCMenuItemSpriteExtra* m_nextResolutionBtn;
    cocos2d::CCLabelBMFont* m_windowedResolutionLabel;
    cocos2d::CCLabelBMFont* m_selectedResolutionLabel;
    cocos2d::CCLabelBMFont* m_qualityLabel;
    int m_textureQuality;
    cocos2d::CCArray* m_availableResolutions;
    CCMenuItemToggler* m_borderlessToggle;
    cocos2d::CCLabelBMFont* m_borderlessLabel;
    CCMenuItemToggler* m_fixToggle;
    cocos2d::CCLabelBMFont* m_fixLabel;
    bool m_fullscreen;
    bool m_borderless;
    bool m_fix;
    int m_currentResolution;
}

[[link(android)]]
class WorldLevelPage : FLAlertLayer {
    // virtual ~WorldLevelPage();

    static WorldLevelPage* create(GJGameLevel* level, GJWorldNode* node);

    virtual void keyBackClicked();
    virtual void show();

    bool init(GJGameLevel* level, GJWorldNode* node);
    void onClose(cocos2d::CCObject* sender);
    void onInfo(cocos2d::CCObject* sender);
    void onPlay(cocos2d::CCObject* sender);
    void onSong(cocos2d::CCObject* sender);

    GJWorldNode* m_worldNode;
    GJGameLevel* m_level;
}

[[link(android)]]
class WorldSelectLayer : cocos2d::CCLayer, BoomScrollLayerDelegate {
    // virtual ~WorldSelectLayer();

    static WorldSelectLayer* create(int page);
    static cocos2d::CCScene* scene(int page);

    virtual void onExit();
    virtual void keyBackClicked();
    virtual void scrollLayerWillScrollToPage(BoomScrollLayer* layer, int page);
    virtual void scrollLayerScrolledToPage(BoomScrollLayer* layer, int page);
    virtual void scrollLayerMoved(cocos2d::CCPoint position);

    void animateInActiveIsland();
    cocos2d::ccColor3B colorForPage(int page);
    cocos2d::ccColor3B getColorValue(int page1, int page2, float progress);
    void goToPage(int page, bool instant);
    bool init(int page);
    void onBack(cocos2d::CCObject* sender);
    void onFreeLevels(cocos2d::CCObject* sender);
    void onGarage(cocos2d::CCObject* sender);
    void onNext(cocos2d::CCObject* sender);
    void onPrev(cocos2d::CCObject* sender);
    void setupWorlds();
    void showCompleteDialog();
    void tryShowAd();
    void unblockButtons();
    void updateArrows();

    cocos2d::CCSprite* m_background;
    BoomScrollLayer* m_scrollLayer;
    CCMenuItemSpriteExtra* m_arrowLeft;
    CCMenuItemSpriteExtra* m_arrowRight;
    bool m_cleanupSprites;
    bool m_enteringLevel;
    GJWorldNode* m_worldNode;
    bool m_buttonsLocked;
}

